# Min Cost to Connect All Points 1584

You are given an array `points` representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`.

The cost of connecting two points `[xi, yi]` and `[xj, yj]` is the **manhattan distance** between them: `|xi - xj| + |yi - yj|`, where `|val|` denotes the absolute value of `val`.

Return *the minimum cost to make all points connected.* All points are connected if there is **exactly one** simple path between any two points.

**Example 1:**

```
Input: points = [[3,12],[-2,5],[-4,1]]
Output: 18
```

**Example 2:**

```
Input: points = [[0,0],[1,1],[1,0],[-1,1]]
Output: 4
```

**Example 3:**

```
Input: points = [[-1000000,-1000000],[1000000,1000000]]
Output: 4000000
```

**Example 4:**

```
Input: points = [[0,0]]
Output: 0
```

 

**Constraints:**

- `1 <= points.length <= 1000`
- `-106 <= xi, yi <= 106`
- All pairs `(xi, yi)` are distinct.

<br/>

## SOLUTION 1: Prim's MST (use PQ, dense graph will TLE)

ä½¿ç”¨PriorityQueueæ¥å®ç°Prim'sã€‚

**time: O(ElogV) = O(V^2^logV) = O(n^2^logn), where n = # of input points**

å› ä¸ºè¿™é“é¢˜æœ‰ **V** ä¸ªç‚¹ï¼Œin a dense graphï¼Œé‚£å°±å¯ä»¥æœ‰ **E = V^2^** æ¡è¾¹ã€‚è¿™æ ·åšçš„è¯å½“æ•°æ®ä¸€å¤§å¿…å®šä¼šTLE

```java
class Edge {
    int from, dest, cost;
    public Edge(int from, int dest, int cost) {
        this.from = from;
        this.dest = dest;
        this.cost = cost;
    }
}

class Solution {
    public int minCostConnectPoints(int[][] points) {
        int N = points.length;
        Map<Integer, List<Edge>> graph = new HashMap<>();
        for (int i = 0; i < points.length; i++) {
            graph.put(i, new ArrayList<>());
        }
        
        // 1. å»ºå›¾ï¼šåŒé‡å¾ªç¯æŠŠå…¨éƒ¨çš„point pairså»ºç«‹ point--edge--pointå…³ç³»
        for (int i = 0; i < points.length; i++) {
            for (int j = 0; j < points.length; j++) {
                if (j == i) continue;
                
                int x1 = points[i][0], y1 = points[i][1], x2 = points[j][0], y2 = points[j][1];
                int dist = Math.abs(x1 - x2) + Math.abs(y1 - y2);
                graph.get(i).add(new Edge(i, j, dist));
                graph.get(j).add(new Edge(j, i, dist));
            }
        }
        
        // 2.å¼€å§‹Prim's
        Set<Integer> visited = new HashSet<>();
        Queue<Edge> minHeap = new PriorityQueue<>((a, b) -> a.cost - b.cost);
        
        //éšä¾¿è¿›ä¸ªEdge æƒ³è±¡æˆä»è™šæ— å‡ºå‘æŒ‡å‘dest_id = 0çš„start Edge 
        //start_id = -1 , dest_id = 0, cost = 0
        Edge startEdge = new Edge(-1, 0, 0); 
        minHeap.offer(startEdge); 
        int totalCost = 0;
        while (!minHeap.isEmpty()) {
            Edge minEdge = minHeap.poll();
            if (!visited.contains(minEdge.dest)) {
                visited.add(minEdge.dest);
                totalCost += minEdge.cost;
                for (Edge neighbor: graph.get(minEdge.dest)) {
                    if (!visited.contains(neighbor.dest)) {
                        minHeap.offer(new Edge(neighbor.from, neighbor.dest, neighbor.cost));
                    }
                }
            }
        }
        
        return visited.size() == N ? totalCost : -1;
    }
}
```

<br/>

<br/>

## SOLUTION 2: Prim's MST (use adj-matrix, works best in dense graph)

SOLUTION1 é‡Œç”¨PriorityQueueæ¥å®ç°Prim'sçš„è¯ï¼Œä¼šTLEã€‚

è¿™é‡Œå¦‚æœæ¢æˆadjacency matrixæ¥æ‰¾åˆ°each round's minimum edge(cost) çš„è¯ï¼Œé‚£å¯ä»¥é™ä½æ—¶é—´

ç”¨PriorityQueueåšPrim'sçš„è¯ğŸ‘‡

```
while pq is not empty:     |V| rounds
	x = extracted min edge (add x to visited)
	for neighbor in neighbor_of(x):   Sum_x->V O(degree(x))*O(logV)
		decrease neighbor if it's shorter to join MST from x
```

PriorityQueueå¯¼è‡´ä¸Šé¢è¿™4è¡Œæ€»æ—¶é—´æ˜¯ **O(ElogV) = O(V^2^logV)** (in a dense graph)

é‚£ä¹ˆå¦‚æœä¸ç”¨PriorityQueueçš„è¯ï¼Œæœ€å¤–å±‚å¾ªç¯ä»»ç„¶èµ° **|V|** æ¬¡ï¼Œä½†æ˜¯å†…å±‚å¾ªç¯æ¯æ¬¡ä¹Ÿèµ° **O(V)** æ¬¡å°±å¥½ã€‚å†…å¾ªç¯çš„ä»»åŠ¡å°±æ˜¯

1. æ‰¾åˆ°å½“å‰æœª **visited[x]** è¿‡çš„ **x**  -> **O(V)**

2. å¯¹ **x** çš„neighborsåšdecrease -> **O(V)**

**time:** æ‰€ä»¥æ€»æ—¶é—´ä» **O(V^2^logV)** é™åˆ°äº† **O(V^2^)**

<br/>

* `matrix[i][j]` ï¼Œinstead of using PriorityQueue, ç”¨adjacency matrixæ¥ç›´æ¥ç´¢å¼• **i**  åˆ° **j** çš„manhattan distance

* `dist_to_MST[i]` è®°å½•çš„æ˜¯ **i** åŠ å…¥åˆ° MST çš„æœ€çŸ­çš„â€edge"

    åˆå§‹åŒ–çš„æ—¶å€™ `dist_to_MST[0] = 0` ï¼Œä»£è¡¨æˆ‘éšæœºé€‰äº†ä¸ªèµ·ç‚¹ index = 0 çš„pointï¼Œæ‰€ä»¥å®ƒåŠ å…¥åˆ° MST çš„æ‰€éœ€è¦çš„edge cost = 0

    åˆ«çš„ `dist_to_MST[*] = INF` ï¼Œä»£è¡¨åˆ«çš„ç‚¹éƒ½è¿˜è¿œç¦»åŠ å…¥MST

* æ‰€ä»¥æœ€å¼€å§‹çš„æ—¶å€™ï¼Œextracted minå°±ä¼šæ˜¯index=0çš„é‚£ä¸ªç‚¹åŠ å…¥MSTæ‰€éœ€è¦çš„edge cost (which is 0)ï¼Œç„¶åä»è¿™ä¸ªç‚¹å°±ä¼šå¼€å§‹ decrease å®ƒé‚»å±…æ‰€éœ€è¦åŠ å…¥MSTçš„temp edge costã€‚

    ç„¶åæ¥ä¸‹æ¥çš„ **|V|** roundså°±ä¸æ–­åœ°é‡å¤ï¼šextract min, extractåå°±ç›¸å½“äºå½“å‰pointå·²ç»ç¡®è®¤åŠ å…¥åˆ°MSTï¼Œç„¶åå†å¯¹å®ƒçš„neighborsæ›´æ–°ä¹‹åâ€œå¯èƒ½â€åŠ å…¥MSTæ‰€éœ€è¦çš„cost



```java
class Solution {
    public int minCostConnectPoints(int[][] points) {
        int n = points.length;
        // 1. æ„å›¾ï¼Œç”¨adj-matrixè®°å½•ç‚¹ä¸ç‚¹ä¹‹é—´çš„edge cost
        int[][] matrix = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);
            }
        }
        
        // 2. run Prim's MST
        boolean[] visited = new boolean[n];
        int[] dist_to_MST = new int[n];
        Arrays.fill(dist_to_MST, Integer.MAX_VALUE);
        dist_to_MST[0] = 0;
        int v = 0;
        while (v++ < n) {
            // to find the next point that has temporary min_edge_cost to join MST
            int closest = -1; 
            for (int i = 0; i < n; i++) {
                if (!visited[i] && (closest == -1 || dist_to_MST[i] < dist_to_MST[closest])) {
                    closest = i;
                }
            }
            
            visited[closest] = true;
            
            // decrease other points' possible distance to MST
            for (int pt = 0; pt < n; pt++) {
                if (!visited[pt]) {
                    dist_to_MST[pt] = Math.min(dist_to_MST[pt], matrix[closest][pt]);
                }
            }
        }
        
       	// now dist_to_MST[*] è®°å½•äº†å…¨éƒ¨ç‚¹åŠ å…¥MSTæ—¶ç”¨çš„è¾¹é•¿ï¼Œæ‰€ä»¥sum of theseå°±æ˜¯MSTè·¯å¾„
        return Arrays.stream(dist_to_MST).sum();
    }
}
```









