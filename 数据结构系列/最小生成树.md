# Min Cost to Connect All Points 1584

You are given an array `points` representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`.

The cost of connecting two points `[xi, yi]` and `[xj, yj]` is the **manhattan distance** between them: `|xi - xj| + |yi - yj|`, where `|val|` denotes the absolute value of `val`.

Return *the minimum cost to make all points connected.* All points are connected if there is **exactly one** simple path between any two points.

**Example 1:**

```
Input: points = [[3,12],[-2,5],[-4,1]]
Output: 18
```

**Example 2:**

```
Input: points = [[0,0],[1,1],[1,0],[-1,1]]
Output: 4
```

**Example 3:**

```
Input: points = [[-1000000,-1000000],[1000000,1000000]]
Output: 4000000
```

**Example 4:**

```
Input: points = [[0,0]]
Output: 0
```

 

**Constraints:**

- `1 <= points.length <= 1000`
- `-106 <= xi, yi <= 106`
- All pairs `(xi, yi)` are distinct.

<br/>

## SOLUTION 1: Prim's MST (use PQ, dense graph will TLE)

使用PriorityQueue来实现Prim's。

**time: O(ElogV) = O(V^2^logV) = O(n^2^logn), where n = # of input points**

因为这道题有 **V** 个点，in a dense graph，那就可以有 **E = V^2^** 条边。这样做的话当数据一大必定会TLE

```java
class Edge {
    int from, dest, cost;
    public Edge(int from, int dest, int cost) {
        this.from = from;
        this.dest = dest;
        this.cost = cost;
    }
}

class Solution {
    public int minCostConnectPoints(int[][] points) {
        int N = points.length;
        Map<Integer, List<Edge>> graph = new HashMap<>();
        for (int i = 0; i < points.length; i++) {
            graph.put(i, new ArrayList<>());
        }
        
        // 1. 建图：双重循环把全部的point pairs建立 point--edge--point关系
        for (int i = 0; i < points.length; i++) {
            for (int j = 0; j < points.length; j++) {
                if (j == i) continue;
                
                int x1 = points[i][0], y1 = points[i][1], x2 = points[j][0], y2 = points[j][1];
                int dist = Math.abs(x1 - x2) + Math.abs(y1 - y2);
                graph.get(i).add(new Edge(i, j, dist));
                graph.get(j).add(new Edge(j, i, dist));
            }
        }
        
        // 2.开始Prim's
        Set<Integer> visited = new HashSet<>();
        Queue<Edge> minHeap = new PriorityQueue<>((a, b) -> a.cost - b.cost);
        
        //随便进个Edge 想象成从虚无出发指向dest_id = 0的start Edge 
        //start_id = -1 , dest_id = 0, cost = 0
        Edge startEdge = new Edge(-1, 0, 0); 
        minHeap.offer(startEdge); 
        int totalCost = 0;
        while (!minHeap.isEmpty()) {
            Edge minEdge = minHeap.poll();
            if (!visited.contains(minEdge.dest)) {
                visited.add(minEdge.dest);
                totalCost += minEdge.cost;
                for (Edge neighbor: graph.get(minEdge.dest)) {
                    if (!visited.contains(neighbor.dest)) {
                        minHeap.offer(new Edge(neighbor.from, neighbor.dest, neighbor.cost));
                    }
                }
            }
        }
        
        return visited.size() == N ? totalCost : -1;
    }
}
```

<br/>

<br/>

## SOLUTION 2: Prim's MST (use adj-matrix, works best in dense graph)

SOLUTION1 里用PriorityQueue来实现Prim's的话，会TLE。

这里如果换成adjacency matrix来找到each round's minimum edge(cost) 的话，那可以降低时间

用PriorityQueue做Prim's的话👇

```
while pq is not empty:     |V| rounds
	x = extracted min edge (add x to visited)
	for neighbor in neighbor_of(x):   Sum_x->V O(degree(x))*O(logV)
		decrease neighbor if it's shorter to join MST from x
```

PriorityQueue导致上面这4行总时间是 **O(ElogV) = O(V^2^logV)** (in a dense graph)

那么如果不用PriorityQueue的话，最外层循环任然走 **|V|** 次，但是内层循环每次也走 **O(V)** 次就好。内循环的任务就是

1. 找到当前未 **visited[x]** 过的 **x**  -> **O(V)**

2. 对 **x** 的neighbors做decrease -> **O(V)**

**time:** 所以总时间从 **O(V^2^logV)** 降到了 **O(V^2^)**

<br/>

* `matrix[i][j]` ，instead of using PriorityQueue, 用adjacency matrix来直接索引 **i**  到 **j** 的manhattan distance

* `dist_to_MST[i]` 记录的是 **i** 加入到 MST 的最短的”edge"

    初始化的时候 `dist_to_MST[0] = 0` ，代表我随机选了个起点 index = 0 的point，所以它加入到 MST 的所需要的edge cost = 0

    别的 `dist_to_MST[*] = INF` ，代表别的点都还远离加入MST

* 所以最开始的时候，extracted min就会是index=0的那个点加入MST所需要的edge cost (which is 0)，然后从这个点就会开始 decrease 它邻居所需要加入MST的temp edge cost。

    然后接下来的 **|V|** rounds就不断地重复：extract min, extract后就相当于当前point已经确认加入到MST，然后再对它的neighbors更新之后“可能”加入MST所需要的cost



```java
class Solution {
    public int minCostConnectPoints(int[][] points) {
        int n = points.length;
        // 1. 构图，用adj-matrix记录点与点之间的edge cost
        int[][] matrix = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);
            }
        }
        
        // 2. run Prim's MST
        boolean[] visited = new boolean[n];
        int[] dist_to_MST = new int[n];
        Arrays.fill(dist_to_MST, Integer.MAX_VALUE);
        dist_to_MST[0] = 0;
        int v = 0;
        while (v++ < n) {
            // to find the next point that has temporary min_edge_cost to join MST
            int closest = -1; 
            for (int i = 0; i < n; i++) {
                if (!visited[i] && (closest == -1 || dist_to_MST[i] < dist_to_MST[closest])) {
                    closest = i;
                }
            }
            
            visited[closest] = true;
            
            // decrease other points' possible distance to MST
            for (int pt = 0; pt < n; pt++) {
                if (!visited[pt]) {
                    dist_to_MST[pt] = Math.min(dist_to_MST[pt], matrix[closest][pt]);
                }
            }
        }
        
       	// now dist_to_MST[*] 记录了全部点加入MST时用的边长，所以sum of these就是MST路径
        return Arrays.stream(dist_to_MST).sum();
    }
}
```









