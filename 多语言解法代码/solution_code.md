https://leetcode.cn/problems/01-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int m = mat.size(), n = mat[0].size();
        // è®°å½•ç­”æ¡ˆçš„ç»“æœæ•°ç»„
        vector<vector<int>> res(m, vector<int>(n, -1));
        // åˆå§‹åŒ–é˜Ÿåˆ—ï¼ŒæŠŠé‚£äº›å€¼ä¸º 0 çš„åæ ‡æ”¾åˆ°é˜Ÿåˆ—é‡Œ
        queue<pair<int, int>> q;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (mat[i][j] == 0) {
                    q.push({i, j});
                    res[i][j] = 0;
                }
            }
        }
        // æ‰§è¡Œ BFS ç®—æ³•æ¡†æ¶ï¼Œä»å€¼ä¸º 0 çš„åæ ‡å¼€å§‹å‘å››å‘¨æ‰©æ•£
        vector<vector<int>> dirs{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        while (!q.empty()) {
            auto cur = q.front();
            q.pop();
            int x = cur.first, y = cur.second;
            // å‘å››å‘¨æ‰©æ•£
            for (auto& dir : dirs) {
                int nextX = x + dir[0];
                int nextY = y + dir[1];
                // ç¡®ä¿ç›¸é‚»çš„è¿™ä¸ªåæ ‡æ²¡æœ‰è¶Šç•Œä¸”ä¹‹å‰æœªè¢«è®¡ç®—è¿‡
                if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n
                        && res[nextX][nextY] == -1) {
                    q.push({nextX, nextY});
                    // ä» mat[x][y] èµ°åˆ° mat[nextX][nextY] éœ€è¦ä¸€æ­¥
                    res[nextX][nextY] = res[x][y] + 1;
                }
            }
        }

        return res;
    }
};
```

```go
// by chatGPT (go)
func updateMatrix(mat [][]int) [][]int {
    m, n := len(mat), len(mat[0])
    // è®°å½•ç­”æ¡ˆçš„ç»“æœæ•°ç»„
    res := make([][]int, m)
    for i := range res {
        res[i] = make([]int, n)
        for j := range res[i] {
            res[i][j] = -1
        }
    }
    // åˆå§‹åŒ–é˜Ÿåˆ—ï¼ŒæŠŠé‚£äº›å€¼ä¸º 0 çš„åæ ‡æ”¾åˆ°é˜Ÿåˆ—é‡Œ
    q := make([][2]int, 0)
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if mat[i][j] == 0 {
                q = append(q, [2]int{i, j})
                res[i][j] = 0
            }
        }
    }
    // æ‰§è¡Œ BFS ç®—æ³•æ¡†æ¶ï¼Œä»å€¼ä¸º 0 çš„åæ ‡å¼€å§‹å‘å››å‘¨æ‰©æ•£
    dirs := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}
    for len(q) > 0 {
        cur := q[0]
        q = q[1:]
        x, y := cur[0], cur[1]
        // å‘å››å‘¨æ‰©æ•£
        for _, dir := range dirs {
            nextX, nextY := x+dir[0], y+dir[1]
            // ç¡®ä¿ç›¸é‚»çš„è¿™ä¸ªåæ ‡æ²¡æœ‰è¶Šç•Œä¸”ä¹‹å‰æœªè¢«è®¡ç®—è¿‡
            if nextX >= 0 && nextX < m && nextY >= 0 && nextY < n && res[nextX][nextY] == -1 {
                q = append(q, [2]int{nextX, nextY})
                // ä» mat[x][y] èµ°åˆ° mat[nextX][nextY] éœ€è¦ä¸€æ­¥
                res[nextX][nextY] = res[x][y] + 1
            }
        }
    }

    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int[][] updateMatrix(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        // è®°å½•ç­”æ¡ˆçš„ç»“æœæ•°ç»„
        int[][] res = new int[m][n];
        // åˆå§‹åŒ–å…¨éƒ¨å¡«å……ç‰¹æ®Šå€¼ -1ï¼Œä»£è¡¨æœªè®¡ç®—ï¼Œ
        // å¾…ä¼šå¯ä»¥ç”¨æ¥åˆ¤æ–­åæ ‡æ˜¯å¦å·²ç»è®¡ç®—è¿‡ï¼Œé¿å…é‡å¤éå†
        for (int[] row : res) {
            Arrays.fill(row, -1);
        }

        Queue<int[]> q = new LinkedList<>();
        // åˆå§‹åŒ–é˜Ÿåˆ—ï¼ŒæŠŠé‚£äº›å€¼ä¸º 0 çš„åæ ‡æ”¾åˆ°é˜Ÿåˆ—é‡Œ
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (mat[i][j] == 0) {
                    q.offer(new int[]{i, j});
                    res[i][j] = 0;
                }
            }
        }
        // æ‰§è¡Œ BFS ç®—æ³•æ¡†æ¶ï¼Œä»å€¼ä¸º 0 çš„åæ ‡å¼€å§‹å‘å››å‘¨æ‰©æ•£
        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int x = cur[0], y = cur[1];
            // å‘å››å‘¨æ‰©æ•£
            for (int i = 0; i < 4; i++) {
                int nextX = x + dirs[i][0];
                int nextY = y + dirs[i][1];
                // ç¡®ä¿ç›¸é‚»çš„è¿™ä¸ªåæ ‡æ²¡æœ‰è¶Šç•Œä¸”ä¹‹å‰æœªè¢«è®¡ç®—è¿‡
                if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n
                        && res[nextX][nextY] == -1) {
                    q.offer(new int[]{nextX, nextY});
                    // ä» mat[x][y] èµ°åˆ° mat[nextX][nextY] éœ€è¦ä¸€æ­¥
                    res[nextX][nextY] = res[x][y] + 1;
                }
            }
        }

        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
function updateMatrix(mat) {
  const m = mat.length, n = mat[0].length;
  // è®°å½•ç­”æ¡ˆçš„ç»“æœæ•°ç»„
  const res = new Array(m).fill().map(() => new Array(n).fill(-1));

  const q = [];
  // åˆå§‹åŒ–é˜Ÿåˆ—ï¼ŒæŠŠé‚£äº›å€¼ä¸º 0 çš„åæ ‡æ”¾åˆ°é˜Ÿåˆ—é‡Œ
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (mat[i][j] === 0) {
        q.push([i, j]);
        res[i][j] = 0;
      }
    }
  }
  // æ‰§è¡Œ BFS ç®—æ³•æ¡†æ¶ï¼Œä»å€¼ä¸º 0 çš„åæ ‡å¼€å§‹å‘å››å‘¨æ‰©æ•£
  const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
  while (q.length) {
    const cur = q.shift();
    const x = cur[0], y = cur[1];
    // å‘å››å‘¨æ‰©æ•£
    for (let i = 0; i < 4; i++) {
      const nextX = x + dirs[i][0];
      const nextY = y + dirs[i][1];
      // ç¡®ä¿ç›¸é‚»çš„è¿™ä¸ªåæ ‡æ²¡æœ‰è¶Šç•Œä¸”ä¹‹å‰æœªè¢«è®¡ç®—è¿‡
      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n
        && res[nextX][nextY] === -1) {
        q.push([nextX, nextY]);
        // ä» mat[x][y] èµ°åˆ° mat[nextX][nextY] éœ€è¦ä¸€æ­¥
        res[nextX][nextY] = res[x][y] + 1;
      }
    }
  }

  return res;
}
```

```python
# by chatGPT (python)
from collections import deque

class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        # è®°å½•ç­”æ¡ˆçš„ç»“æœæ•°ç»„
        res = [[-1] * n for _ in range(m)]

        q = deque()
        # åˆå§‹åŒ–é˜Ÿåˆ—ï¼ŒæŠŠé‚£äº›å€¼ä¸º 0 çš„åæ ‡æ”¾åˆ°é˜Ÿåˆ—é‡Œ
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    q.append((i, j))
                    res[i][j] = 0

        # æ‰§è¡Œ BFS ç®—æ³•æ¡†æ¶ï¼Œä»å€¼ä¸º 0 çš„åæ ‡å¼€å§‹å‘å››å‘¨æ‰©æ•£
        dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]
        while q:
            x, y = q.popleft()
            # å‘å››å‘¨æ‰©æ•£
            for dx, dy in dirs:
                nextX, nextY = x + dx, y + dy
                # ç¡®ä¿ç›¸é‚»çš„è¿™ä¸ªåæ ‡æ²¡æœ‰è¶Šç•Œä¸”ä¹‹å‰æœªè¢«è®¡ç®—è¿‡
                if 0 <= nextX < m and 0 <= nextY < n and res[nextX][nextY] == -1:
                    q.append((nextX, nextY))
                    # ä» mat[x][y] èµ°åˆ° mat[nextX][nextY] éœ€è¦ä¸€æ­¥
                    res[nextX][nextY] = res[x][y] + 1

        return res
```

https://leetcode.cn/problems/01-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/0i0mDW çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int memo[201][201];

    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        // æ„é€ å¤‡å¿˜å½•ï¼Œåˆå§‹å€¼å…¨éƒ¨è®¾ä¸º -1
        memset(memo, -1, sizeof(memo));

        return dp(grid, m - 1, n - 1);
    }

    int dp(vector<vector<int>>& grid, int i, int j) {
        // base case
        if (i == 0 && j == 0) {
            return grid[0][0];
        }
        if (i < 0 || j < 0) {
            return INT_MAX;
        }
        // é¿å…é‡å¤è®¡ç®—
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // å°†è®¡ç®—ç»“æœè®°å…¥å¤‡å¿˜å½•
        memo[i][j] = min(
            dp(grid, i - 1, j),
            dp(grid, i, j - 1)
        ) + grid[i][j];

        return memo[i][j];
    }
};
```

```go
// by chatGPT (go)
func minPathSum(grid [][]int) int {
    m := len(grid)
    n := len(grid[0])
    // æ„é€ å¤‡å¿˜å½•ï¼Œåˆå§‹å€¼å…¨éƒ¨è®¾ä¸º -1
    memo := make([][]int, m)
    for i := 0; i < m; i++ {
        memo[i] = make([]int, n)
        for j := 0; j < n; j++ {
            memo[i][j] = -1
        }
    }

    return dp(grid, m - 1, n - 1, memo)
}

func dp(grid [][]int, i int, j int, memo [][]int) int {
    // base case
    if i == 0 && j == 0 {
        return grid[0][0]
    }
    if i < 0 || j < 0 {
        return math.MaxInt32
    }
    // é¿å…é‡å¤è®¡ç®—
    if memo[i][j] != -1 {
        return memo[i][j]
    }
    // å°†è®¡ç®—ç»“æœè®°å…¥å¤‡å¿˜å½•
    left := dp(grid, i - 1, j, memo)
    up := dp(grid, i, j - 1, memo)
    curr := grid[i][j] + min(left, up)
    memo[i][j] = curr
    return curr
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    int[][] memo;

    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        // æ„é€ å¤‡å¿˜å½•ï¼Œåˆå§‹å€¼å…¨éƒ¨è®¾ä¸º -1
        memo = new int[m][n];
        for (int[] row : memo)
            Arrays.fill(row, -1);

        return dp(grid, m - 1, n - 1);
    }

    int dp(int[][] grid, int i, int j) {
        // base case
        if (i == 0 && j == 0) {
            return grid[0][0];
        }
        if (i < 0 || j < 0) {
            return Integer.MAX_VALUE;
        }
        // é¿å…é‡å¤è®¡ç®—
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // å°†è®¡ç®—ç»“æœè®°å…¥å¤‡å¿˜å½•
        memo[i][j] = Math.min(
                dp(grid, i - 1, j),
                dp(grid, i, j - 1)
        ) + grid[i][j];

        return memo[i][j];
    }
}
```

```javascript
// by chatGPT (javascript)
var minPathSum = function(grid) {
    var m = grid.length;
    var n = grid[0].length;
    // æ„é€ å¤‡å¿˜å½•ï¼Œåˆå§‹å€¼å…¨éƒ¨è®¾ä¸º -1
    var memo = new Array(m);
    for (var i = 0; i < memo.length; i++) {
        memo[i] = new Array(n);
        memo[i].fill(-1);
    }

    return dp(grid, m - 1, n - 1, memo);
};

function dp(grid, i, j, memo) {
    // base case
    if (i == 0 && j == 0) {
        return grid[0][0];
    }
    if (i < 0 || j < 0) {
        return Number.MAX_VALUE;
    }
    // é¿å…é‡å¤è®¡ç®—
    if (memo[i][j] != -1) {
        return memo[i][j];
    }
    // å°†è®¡ç®—ç»“æœè®°å…¥å¤‡å¿˜å½•
    memo[i][j] = Math.min(
            dp(grid, i - 1, j, memo),
            dp(grid, i, j - 1, memo)
        ) + grid[i][j];

    return memo[i][j];
}
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.memo = None

    def minPathSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        # æ„é€ å¤‡å¿˜å½•ï¼Œåˆå§‹å€¼å…¨éƒ¨è®¾ä¸º -1
        self.memo = [[-1 for _ in range(n)] for _ in range(m)]

        return self.dp(grid, m - 1, n - 1)

    def dp(self, grid: List[List[int]], i: int, j: int) -> int:
        # base case
        if i == 0 and j == 0:
            return grid[0][0]
        if i < 0 or j < 0:
            return float('inf')
        # é¿å…é‡å¤è®¡ç®—
        if self.memo[i][j] != -1:
            return self.memo[i][j]
        # å°†è®¡ç®—ç»“æœè®°å…¥å¤‡å¿˜å½•
        self.memo[i][j] = min(
            self.dp(grid, i - 1, j),
            self.dp(grid, i, j - 1)
        ) + grid[i][j]

        return self.memo[i][j]
```

https://leetcode.cn/problems/0i0mDW çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/1fGaJU çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        // n ä¸º 3ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º 0 çš„ä¸‰å…ƒç»„
        return nSumTarget(nums, 3, 0, 0);
    }

    /* æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº */
    // n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
    vector<vector<int>> nSumTarget(
            vector<int>& nums, int n, int start, int target) {

        int sz = nums.size();
        vector<vector<int>> res;
        // è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
        if (n < 2 || sz < n) return res;
        // 2Sum æ˜¯ base case
        if (n == 2) {
            // åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
            int lo = start, hi = sz - 1;
            while (lo < hi) {
                int sum = nums[lo] + nums[hi];
                int left = nums[lo], right = nums[hi];
                if (sum < target) {
                    while (lo < hi && nums[lo] == left) lo++;
                } else if (sum > target) {
                    while (lo < hi && nums[hi] == right) hi--;
                } else {
                    res.push_back({left, right});
                    while (lo < hi && nums[lo] == left) lo++;
                    while (lo < hi && nums[hi] == right) hi--;
                }
            }
        } else {
            // n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
            for (int i = start; i < sz; i++) {
                vector<vector<int>>
                        sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
                for (vector<int>& arr : sub) {
                    // (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                    arr.push_back(nums[i]);
                    res.push_back(arr);
                }
                while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    // n ä¸º 3ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º 0 çš„ä¸‰å…ƒç»„
    return nSumTarget(nums, 3, 0, 0)
}

/* æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº */
// n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
func nSumTarget(nums []int, n int, start int, target int) [][]int {
    sz := len(nums)
    var res [][]int
    // è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
    if n < 2 || sz < n {
        return res
    }
    // 2Sum æ˜¯ base case
    if n == 2 {
        // åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
        lo, hi := start, sz-1
        for lo < hi {
            sum := nums[lo] + nums[hi]
            left, right := nums[lo], nums[hi]
            if sum < target {
                for lo < hi && nums[lo] == left {
                    lo++
                }
            } else if sum > target {
                for lo < hi && nums[hi] == right {
                    hi--
                }
            } else {
                res = append(res, []int{left, right})
                for lo < hi && nums[lo] == left {
                    lo++
                }
                for lo < hi && nums[hi] == right {
                    hi--
                }
            }
        }
    } else {
        // n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
        for i := start; i < sz; i++ {
            sub := nSumTarget(nums, n-1, i+1, target-nums[i])
            for _, arr := range sub {
                // (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                arr = append(arr, nums[i])
                res = append(res, arr)
            }
            for i < sz-1 && nums[i] == nums[i+1] {
                i++
            }
        }
    }
    return res
}
```

```java
// by chatGPT (java)
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        // n ä¸º 3ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º 0 çš„ä¸‰å…ƒç»„
        return nSumTarget(nums, 3, 0, 0);
    }

    /* æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº */
    // n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
    public List<List<Integer>> nSumTarget(
            int[] nums, int n, int start, int target) {

        int sz = nums.length;
        List<List<Integer>> res = new ArrayList<>();
        // è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
        if (n < 2 || sz < n) return res;
        // 2Sum æ˜¯ base case
        if (n == 2) {
            // åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
            int lo = start, hi = sz - 1;
            while (lo < hi) {
                int sum = nums[lo] + nums[hi];
                int left = nums[lo], right = nums[hi];
                if (sum < target) {
                    while (lo < hi && nums[lo] == left) lo++;
                } else if (sum > target) {
                    while (lo < hi && nums[hi] == right) hi--;
                } else {
                    List<Integer> triplet = new ArrayList<>();
                    triplet.add(left);
                    triplet.add(right);
                    res.add(triplet);
                    while (lo < hi && nums[lo] == left) lo++;
                    while (lo < hi && nums[hi] == right) hi--;
                }
            }
        } else {
            // n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
            for (int i = start; i < sz; i++) {
                List<List<Integer>> sub =
                        nSumTarget(nums, n - 1, i + 1, target - nums[i]);
                for (List<Integer> arr : sub) {
                    // (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                    arr.add(nums[i]);
                    res.add(arr);
                }
                while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
            }
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var threeSum = function(nums) {
    nums.sort((a, b) => a - b);
    // n ä¸º 3ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º 0 çš„ä¸‰å…ƒç»„
    return nSumTarget(nums, 3, 0, 0);
};

/* æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº */
// n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
var nSumTarget = function(nums, n, start, target) {
    var sz = nums.length;
    var res = [];
    // è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
    if (n < 2 || sz < n) return res;
    // 2Sum æ˜¯ base case
    if (n === 2) {
        // åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
        var lo = start, hi = sz - 1;
        while (lo < hi) {
            var sum = nums[lo] + nums[hi];
            var left = nums[lo], right = nums[hi];
            if (sum < target) {
                while (lo < hi && nums[lo] === left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] === right) hi--;
            } else {
                res.push([left, right]);
                while (lo < hi && nums[lo] === left) lo++;
                while (lo < hi && nums[hi] === right) hi--;
            }
        }
    } else {
        // n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
        for (var i = start; i < sz; i++) {
            var sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
            for (var j = 0; j < sub.length; j++) {
                // (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                sub[j].push(nums[i]);
                res.push(sub[j]);
            }
            while (i < sz - 1 && nums[i] === nums[i + 1]) i++;
        }
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        # n ä¸º 3ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º 0 çš„ä¸‰å…ƒç»„
        return self.nSumTarget(nums, 3, 0, 0)

    # æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº
    # n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
    def nSumTarget(self, nums: List[int], n: int, start: int, target: int) -> List[List[int]]:
        sz = len(nums)
        res = []
        # è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
        if n < 2 or sz < n:
            return res
        # 2Sum æ˜¯ base case
        if n == 2:
            # åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
            lo, hi = start, sz - 1
            while lo < hi:
                _sum = nums[lo] + nums[hi]
                left, right = nums[lo], nums[hi]
                if _sum < target:
                    while lo < hi and nums[lo] == left:
                        lo += 1
                elif _sum > target:
                    while lo < hi and nums[hi] == right:
                        hi -= 1
                else:
                    res.append([left, right])
                    while lo < hi and nums[lo] == left:
                        lo += 1
                    while lo < hi and nums[hi] == right:
                        hi -= 1
        else:
            # n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
            for i in range(start, sz):
                if i > start and nums[i] == nums[i - 1]:
                    continue
                sub = self.nSumTarget(nums, n - 1, i + 1, target - nums[i])
                for arr in sub:
                    # (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                    arr.append(nums[i])
                    res.append(arr)
        return res
```

https://leetcode.cn/problems/1fGaJU çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/2AoeFn çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // å¤‡å¿˜å½•
    int memo[100][100];

    int uniquePaths(int m, int n) {
        memset(memo, 0, sizeof(memo));
        return dp(m - 1, n - 1);
    }

    // å®šä¹‰ï¼šä» (0, 0) åˆ° (x, y) æœ‰ dp(x, y) æ¡è·¯å¾„
    int dp(int x, int y) {
        // base case
        if (x == 0 && y == 0) {
            return 1;
        }
        if (x < 0 || y < 0) {
            return 0;
        }
        // é¿å…å†—ä½™è®¡ç®—
        if (memo[x][y] > 0) {
            return memo[x][y];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // åˆ°è¾¾ (x, y) çš„è·¯å¾„æ•°ç­‰äºåˆ°è¾¾ (x - 1, y) å’Œ (x, y - 1) è·¯å¾„æ•°ä¹‹å’Œ
        memo[x][y] = dp(x - 1, y) + dp(x, y - 1);
        return memo[x][y];
    }
};
```

```go
// by chatGPT (go)
func uniquePaths(m int, n int) int {
    // å¤‡å¿˜å½•
    memo := make([][]int, m)
    for i := range memo {
        memo[i] = make([]int, n)
    }
    return dp(m-1, n-1, memo)
}

// å®šä¹‰ï¼šä» (0, 0) åˆ° (x, y) æœ‰ dp(x, y) æ¡è·¯å¾„
func dp(x int, y int, memo [][]int) int {
    // base case
    if x == 0 && y == 0 {
        return 1
    }
    if x < 0 || y < 0 {
        return 0
    }
    // é¿å…å†—ä½™è®¡ç®—
    if memo[x][y] > 0 {
        return memo[x][y]
    }
    // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
    // åˆ°è¾¾ (x, y) çš„è·¯å¾„æ•°ç­‰äºåˆ°è¾¾ (x - 1, y) å’Œ (x, y - 1) è·¯å¾„æ•°ä¹‹å’Œ
    memo[x][y] = dp(x-1, y, memo) + dp(x, y-1, memo)
    return memo[x][y]
}
```

```java
// by labuladong (java)
class Solution {
    // å¤‡å¿˜å½•
    int[][] memo;

    public int uniquePaths(int m, int n) {
        memo = new int[m][n];
        return dp(m - 1, n - 1);
    }

    // å®šä¹‰ï¼šä» (0, 0) åˆ° (x, y) æœ‰ dp(x, y) æ¡è·¯å¾„
    int dp(int x, int y) {
        // base case
        if (x == 0 && y == 0) {
            return 1;
        }
        if (x < 0 || y < 0) {
            return 0;
        }
        // é¿å…å†—ä½™è®¡ç®—
        if (memo[x][y] > 0) {
            return memo[x][y];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // åˆ°è¾¾ (x, y) çš„è·¯å¾„æ•°ç­‰äºåˆ°è¾¾ (x - 1, y) å’Œ (x, y - 1) è·¯å¾„æ•°ä¹‹å’Œ
        memo[x][y] = dp(x - 1, y) + dp(x, y - 1);
        return memo[x][y];
    }
}
```

```javascript
// by chatGPT (javascript)
var uniquePaths = function(m, n) {
    // å¤‡å¿˜å½•
    let memo = new Array(m).fill().map(() => new Array(n).fill(0));

    // å®šä¹‰ï¼šä» (0, 0) åˆ° (x, y) æœ‰ dp(x, y) æ¡è·¯å¾„
    var dp = function(x, y) {
        // base case
        if (x === 0 && y === 0) {
            return 1;
        }
        if (x < 0 || y < 0) {
            return 0;
        }
        // é¿å…å†—ä½™è®¡ç®—
        if (memo[x][y] > 0) {
            return memo[x][y];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // åˆ°è¾¾ (x, y) çš„è·¯å¾„æ•°ç­‰äºåˆ°è¾¾ (x - 1, y) å’Œ (x, y - 1) è·¯å¾„æ•°ä¹‹å’Œ
        memo[x][y] = dp(x - 1, y) + dp(x, y - 1);
        return memo[x][y];
    };

    return dp(m - 1, n - 1);
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.memo = None
    
    def uniquePaths(self, m: int, n: int) -> int:
        self.memo = [[0] * n for _ in range(m)]
        return self.dp(m-1, n-1)
    
    def dp(self, x: int, y: int) -> int:
        # base case
        if x == 0 and y == 0:
            return 1
        if x < 0 or y < 0:
            return 0
        # é¿å…å†—ä½™è®¡ç®—
        if self.memo[x][y] > 0:
            return self.memo[x][y]
        # çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        # åˆ°è¾¾ (x, y) çš„è·¯å¾„æ•°ç­‰äºåˆ°è¾¾ (x - 1, y) å’Œ (x, y - 1) è·¯å¾„æ•°ä¹‹å’Œ
        self.memo[x][y] = self.dp(x - 1, y) + self.dp(x, y - 1)
        return self.memo[x][y]
```

https://leetcode.cn/problems/2AoeFn çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/3sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        // n ä¸º 3ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º 0 çš„ä¸‰å…ƒç»„
        return nSumTarget(nums, 3, 0, 0);
    }

    /* æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº */
    // n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
    vector<vector<int>> nSumTarget(
            vector<int>& nums, int n, int start, int target) {

        int sz = nums.size();
        vector<vector<int>> res;
        // è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
        if (n < 2 || sz < n) return res;
        // 2Sum æ˜¯ base case
        if (n == 2) {
            // åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
            int lo = start, hi = sz - 1;
            while (lo < hi) {
                int sum = nums[lo] + nums[hi];
                int left = nums[lo], right = nums[hi];
                if (sum < target) {
                    while (lo < hi && nums[lo] == left) lo++;
                } else if (sum > target) {
                    while (lo < hi && nums[hi] == right) hi--;
                } else {
                    res.push_back({left, right});
                    while (lo < hi && nums[lo] == left) lo++;
                    while (lo < hi && nums[hi] == right) hi--;
                }
            }
        } else {
            // n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
            for (int i = start; i < sz; i++) {
                vector<vector<int>>
                        sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
                for (vector<int>& arr : sub) {
                    // (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                    arr.push_back(nums[i]);
                    res.push_back(arr);
                }
                while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    // n ä¸º 3ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º 0 çš„ä¸‰å…ƒç»„
    return nSumTarget(nums, 3, 0, 0)
}

/* æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº */
// n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
func nSumTarget(nums []int, n int, start int, target int) [][]int {
    sz := len(nums)
    var res [][]int
    // è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
    if n < 2 || sz < n {
        return res
    }
    // 2Sum æ˜¯ base case
    if n == 2 {
        // åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
        lo, hi := start, sz-1
        for lo < hi {
            sum := nums[lo] + nums[hi]
            left, right := nums[lo], nums[hi]
            if sum < target {
                for lo < hi && nums[lo] == left {
                    lo++
                }
            } else if sum > target {
                for lo < hi && nums[hi] == right {
                    hi--
                }
            } else {
                res = append(res, []int{left, right})
                for lo < hi && nums[lo] == left {
                    lo++
                }
                for lo < hi && nums[hi] == right {
                    hi--
                }
            }
        }
    } else {
        // n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
        for i := start; i < sz; i++ {
            sub := nSumTarget(nums, n-1, i+1, target-nums[i])
            for _, arr := range sub {
                // (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                arr = append(arr, nums[i])
                res = append(res, arr)
            }
            for i < sz-1 && nums[i] == nums[i+1] {
                i++
            }
        }
    }
    return res
}
```

```java
// by chatGPT (java)
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        // n ä¸º 3ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º 0 çš„ä¸‰å…ƒç»„
        return nSumTarget(nums, 3, 0, 0);
    }

    /* æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº */
    // n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
    public List<List<Integer>> nSumTarget(
            int[] nums, int n, int start, int target) {

        int sz = nums.length;
        List<List<Integer>> res = new ArrayList<>();
        // è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
        if (n < 2 || sz < n) return res;
        // 2Sum æ˜¯ base case
        if (n == 2) {
            // åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
            int lo = start, hi = sz - 1;
            while (lo < hi) {
                int sum = nums[lo] + nums[hi];
                int left = nums[lo], right = nums[hi];
                if (sum < target) {
                    while (lo < hi && nums[lo] == left) lo++;
                } else if (sum > target) {
                    while (lo < hi && nums[hi] == right) hi--;
                } else {
                    res.add(new ArrayList<>(Arrays.asList(left, right)));
                    while (lo < hi && nums[lo] == left) lo++;
                    while (lo < hi && nums[hi] == right) hi--;
                }
            }
        } else {
            // n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
            for (int i = start; i < sz; i++) {
                List<List<Integer>>
                        sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
                for (List<Integer> arr : sub) {
                    // (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                    arr.add(nums[i]);
                    res.add(arr);
                }
                while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
            }
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var threeSum = function(nums) {
  nums.sort((a, b) => a - b);
  // n ä¸º 3ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º 0 çš„ä¸‰å…ƒç»„
  return nSumTarget(nums, 3, 0, 0);
}

/* æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº */
// n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
var nSumTarget = function(nums, n, start, target) {
  var sz = nums.length;
  var res = [];
  // è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
  if (n < 2 || sz < n) return res;
  // 2Sum æ˜¯ base case
  if (n == 2) {
    // åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
    var lo = start, hi = sz - 1;
    while (lo < hi) {
      var sum = nums[lo] + nums[hi];
      var left = nums[lo], right = nums[hi];
      if (sum < target) {
        while (lo < hi && nums[lo] == left) lo++;
      } else if (sum > target) {
        while (lo < hi && nums[hi] == right) hi--;
      } else {
        res.push([left, right]);
        while (lo < hi && nums[lo] == left) lo++;
        while (lo < hi && nums[hi] == right) hi--;
      }
    }
  } else {
    // n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
    for (var i = start; i < sz; i++) {
      var sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
      for (var j = 0; j < sub.length; j++) {
        // (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
        sub[j].push(nums[i]);
        res.push(sub[j]);
      }
      while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
    }
  }
  return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        # n ä¸º 3ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º 0 çš„ä¸‰å…ƒç»„
        return self.nSumTarget(nums, 3, 0, 0)

    # æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº
    # n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
    def nSumTarget(self, nums: List[int], n: int, start: int, target: int) -> List[List[int]]:
        sz = len(nums)
        res = []
        # è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
        if n < 2 or sz < n:
            return res
        # 2Sum æ˜¯ base case
        if n == 2:
            # åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
            lo, hi = start, sz - 1
            while lo < hi:
                s = nums[lo] + nums[hi]
                left, right = nums[lo], nums[hi]
                if s < target:
                    while lo < hi and nums[lo] == left:
                        lo += 1
                elif s > target:
                    while lo < hi and nums[hi] == right:
                        hi -= 1
                else:
                    res.append([left, right])
                    while lo < hi and nums[lo] == left:
                        lo += 1
                    while lo < hi and nums[hi] == right:
                        hi -= 1
        else:
            # n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
            for i in range(start, sz):
                sub = self.nSumTarget(nums, n - 1, i + 1, target - nums[i])
                for arr in sub:
                    # (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                    arr.append(nums[i])
                    res.append(arr)
                while i < sz - 1 and nums[i] == nums[i + 1]:
                    i += 1
        return res
```

https://leetcode.cn/problems/3sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/3sum-closest çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        if (nums.size() < 3) {
            return 0;
        }
        // åˆ«å¿˜äº†è¦å…ˆæ’åºæ•°ç»„
        sort(nums.begin(), nums.end());
        // è®°å½•ä¸‰æ•°ä¹‹å’Œä¸ç›®æ ‡å€¼çš„åå·®
        int delta = INT_MAX;
        for (int i = 0; i < nums.size() - 2; i++) {
            // å›ºå®š nums[i] ä¸ºä¸‰æ•°ä¹‹å’Œä¸­çš„ç¬¬ä¸€ä¸ªæ•°ï¼Œ
            // ç„¶åå¯¹ nums[i+1..] æœç´¢æ¥è¿‘ target - nums[i] çš„ä¸¤æ•°ä¹‹å’Œ
            int sum = nums[i] + twoSumClosest(nums, i + 1, target - nums[i]);
            if (abs(delta) > abs(target - sum)) {
                delta = target - sum;
            }
        }
        return target - delta;
    }

    // åœ¨ nums[start..] æœç´¢æœ€æ¥è¿‘ target çš„ä¸¤æ•°ä¹‹å’Œ
    int twoSumClosest(vector<int>& nums, int start, int target) {
        int lo = start, hi = nums.size() - 1;
        // è®°å½•ä¸¤æ•°ä¹‹å’Œä¸ç›®æ ‡å€¼çš„åå·®
        int delta = INT_MAX;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            if (abs(delta) > abs(target - sum)) {
                delta = target - sum;
            }
            if (sum < target) {
                lo++;
            } else {
                hi--;
            }
        }
        return target - delta;
    }
};
```

```go
// by chatGPT (go)
func threeSumClosest(nums []int, target int) int {
    if len(nums) < 3 {
        return 0
    }
    // å…ˆæ’åºæ•°ç»„
    sort.Ints(nums)
    // è®°å½•ä¸‰æ•°ä¹‹å’Œä¸ç›®æ ‡å€¼çš„åå·®
    delta := math.MaxInt32
    for i := 0; i < len(nums)-2; i++ {
        // å›ºå®š nums[i] ä¸ºä¸‰æ•°ä¹‹å’Œä¸­çš„ç¬¬ä¸€ä¸ªæ•°ï¼Œ
        // ç„¶åå¯¹ nums[i+1..] æœç´¢æ¥è¿‘ target - nums[i] çš„ä¸¤æ•°ä¹‹å’Œ
        sum := nums[i] + twoSumClosest(nums, i+1, target-nums[i])
        if int(math.Abs(float64(delta))) > int(math.Abs(float64(target-sum))) {
            delta = target - sum
        }
    }
    return target - delta
}

// åœ¨ nums[start..] æœç´¢æœ€æ¥è¿‘ target çš„ä¸¤æ•°ä¹‹å’Œ
func twoSumClosest(nums []int, start int, target int) int {
    lo, hi := start, len(nums)-1
    // è®°å½•ä¸¤æ•°ä¹‹å’Œä¸ç›®æ ‡å€¼çš„åå·®
    delta := math.MaxInt32
    for lo < hi {
        sum := nums[lo] + nums[hi]
        if int(math.Abs(float64(delta))) > int(math.Abs(float64(target-sum))) {
            delta = target - sum
        }
        if sum < target {
            lo++
        } else {
            hi--
        }
    }
    return target - delta
}
```

```java
// by labuladong (java)
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        if (nums.length < 3) {
            return 0;
        }
        // åˆ«å¿˜äº†è¦å…ˆæ’åºæ•°ç»„
        Arrays.sort(nums);
        // è®°å½•ä¸‰æ•°ä¹‹å’Œä¸ç›®æ ‡å€¼çš„åå·®
        int delta = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length - 2; i++) {
            // å›ºå®š nums[i] ä¸ºä¸‰æ•°ä¹‹å’Œä¸­çš„ç¬¬ä¸€ä¸ªæ•°ï¼Œ
            // ç„¶åå¯¹ nums[i+1..] æœç´¢æ¥è¿‘ target - nums[i] çš„ä¸¤æ•°ä¹‹å’Œ
            int sum = nums[i] + twoSumClosest(nums, i + 1, target - nums[i]);
            if (Math.abs(delta) > Math.abs(target - sum)) {
                delta = target - sum;
            }
        }
        return target - delta;
    }

    // åœ¨ nums[start..] æœç´¢æœ€æ¥è¿‘ target çš„ä¸¤æ•°ä¹‹å’Œ
    int twoSumClosest(int[] nums, int start, int target) {
        int lo = start, hi = nums.length - 1;
        // è®°å½•ä¸¤æ•°ä¹‹å’Œä¸ç›®æ ‡å€¼çš„åå·®
        int delta = Integer.MAX_VALUE;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            if (Math.abs(delta) > Math.abs(target - sum)) {
                delta = target - sum;
            }
            if (sum < target) {
                lo++;
            } else {
                hi--;
            }
        }
        return target - delta;
    }
}
```

```javascript
// by chatGPT (javascript)
var threeSumClosest = function(nums, target) {
    if (nums.length < 3) {
        return 0;
    }
    // åˆ«å¿˜äº†è¦å…ˆæ’åºæ•°ç»„
    nums.sort(function(a, b) {
        return a - b;
    });
    // è®°å½•ä¸‰æ•°ä¹‹å’Œä¸ç›®æ ‡å€¼çš„åå·®
    var delta = Number.MAX_SAFE_INTEGER;
    for (var i = 0; i < nums.length - 2; i++) {
        // å›ºå®š nums[i] ä¸ºä¸‰æ•°ä¹‹å’Œä¸­çš„ç¬¬ä¸€ä¸ªæ•°ï¼Œ
        // ç„¶åå¯¹ nums[i+1..] æœç´¢æ¥è¿‘ target - nums[i] çš„ä¸¤æ•°ä¹‹å’Œ
        var sum = nums[i] + twoSumClosest(nums, i + 1, target - nums[i]);
        if (Math.abs(delta) > Math.abs(target - sum)) {
            delta = target - sum;
        }
    }
    return target - delta;
};

// åœ¨ nums[start..] æœç´¢æœ€æ¥è¿‘ target çš„ä¸¤æ•°ä¹‹å’Œ
var twoSumClosest = function(nums, start, target) {
    var lo = start, hi = nums.length - 1;
    // è®°å½•ä¸¤æ•°ä¹‹å’Œä¸ç›®æ ‡å€¼çš„åå·®
    var delta = Number.MAX_SAFE_INTEGER;
    while (lo < hi) {
        var sum = nums[lo] + nums[hi];
        if (Math.abs(delta) > Math.abs(target - sum)) {
            delta = target - sum;
        }
        if (sum < target) {
            lo++;
        } else {
            hi--;
        }
    }
    return target - delta;
};
```

```python
# by chatGPT (python)
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        if len(nums) < 3:
            return 0
        # åˆ«å¿˜äº†è¦å…ˆæ’åºæ•°ç»„
        nums.sort()
        # è®°å½•ä¸‰æ•°ä¹‹å’Œä¸ç›®æ ‡å€¼çš„åå·®
        delta = float('inf')
        for i in range(len(nums) - 2):
            # å›ºå®š nums[i] ä¸ºä¸‰æ•°ä¹‹å’Œä¸­çš„ç¬¬ä¸€ä¸ªæ•°ï¼Œ
            # ç„¶åå¯¹ nums[i+1..] æœç´¢æ¥è¿‘ target - nums[i] çš„ä¸¤æ•°ä¹‹å’Œ
            sum_ = nums[i] + self.twoSumClosest(nums, i + 1, target - nums[i])
            if abs(delta) > abs(target - sum_):
                delta = target - sum_
        return target - delta

    # åœ¨ nums[start..] æœç´¢æœ€æ¥è¿‘ target çš„ä¸¤æ•°ä¹‹å’Œ
    def twoSumClosest(self, nums: List[int], start: int, target: int) -> int:
        lo, hi = start, len(nums) - 1
        # è®°å½•ä¸¤æ•°ä¹‹å’Œä¸ç›®æ ‡å€¼çš„åå·®
        delta = float('inf')
        while lo < hi:
            sum_ = nums[lo] + nums[hi]
            if abs(delta) > abs(target - sum_):
                delta = target - sum_
            if sum_ < target:
                lo += 1
            else:
                hi -= 1
        return target - delta
```

https://leetcode.cn/problems/3sum-closest çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/3sum-smaller çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int threeSumSmaller(vector<int>& nums, int target) {
        if (nums.size() < 3) {
            return 0;
        }
        // åˆ«å¿˜äº†è¦å…ˆæ’åºæ•°ç»„
        sort(nums.begin(), nums.end());
        int res = 0;
        for (int i = 0; i < nums.size() - 2; i++) {
            // å›ºå®š nums[i] ä¸ºä¸‰æ•°ä¹‹å’Œä¸­çš„ç¬¬ä¸€ä¸ªæ•°ï¼Œ
            // ç„¶åå¯¹ nums[i+1..] æœç´¢å°äº target - nums[i] çš„ä¸¤æ•°ä¹‹å’Œä¸ªæ•°
            res += twoSumSmaller(nums, i + 1, target - nums[i]);
        }
        return res;
    }

    // åœ¨ nums[start..] æœç´¢å°äº target çš„ä¸¤æ•°ä¹‹å’Œä¸ªæ•°
    int twoSumSmaller(vector<int>& nums, int start, int target) {
        int lo = start, hi = nums.size() - 1;
        int count = 0;
        while (lo < hi) {
            if (nums[lo] + nums[hi] < target) {
                // nums[lo] å’Œ nums[lo+1..hi]
                // ä¸­çš„ä»»ä¸€å…ƒç´ ä¹‹å’Œéƒ½å°äº target
                count += hi - lo;
                lo++;
            } else {
                hi--;
            }
        }
        return count;
    }
};
```

```go
// by chatGPT (go)
func threeSumSmaller(nums []int, target int) int {
    if len(nums) < 3 {
        return 0
    }
    // åˆ«å¿˜äº†è¦å…ˆæ’åºæ•°ç»„
    sort.Ints(nums)
    res := 0
    for i := 0; i < len(nums) - 2; i++ {
        // å›ºå®š nums[i] ä¸ºä¸‰æ•°ä¹‹å’Œä¸­çš„ç¬¬ä¸€ä¸ªæ•°ï¼Œ
        // ç„¶åå¯¹ nums[i+1..] æœç´¢å°äº target - nums[i] çš„ä¸¤æ•°ä¹‹å’Œä¸ªæ•°
        res += twoSumSmaller(nums, i + 1, target - nums[i])
    }
    return res
}

// åœ¨ nums[start..] æœç´¢å°äº target çš„ä¸¤æ•°ä¹‹å’Œä¸ªæ•°
func twoSumSmaller(nums []int, start int, target int) int {
    lo, hi := start, len(nums) - 1
    count := 0
    for lo < hi {
        if nums[lo] + nums[hi] < target {
            // nums[lo] å’Œ nums[lo+1..hi]
            // ä¸­çš„ä»»ä¸€å…ƒç´ ä¹‹å’Œéƒ½å°äº target
            count += hi - lo
            lo++
        } else {
            hi--
        }
    }
    return count
}
```

```java
// by labuladong (java)
class Solution {
    public int threeSumSmaller(int[] nums, int target) {
        if (nums.length < 3) {
            return 0;
        }
        // åˆ«å¿˜äº†è¦å…ˆæ’åºæ•°ç»„
        Arrays.sort(nums);
        int res = 0;
        for (int i = 0; i < nums.length - 2; i++) {
            // å›ºå®š nums[i] ä¸ºä¸‰æ•°ä¹‹å’Œä¸­çš„ç¬¬ä¸€ä¸ªæ•°ï¼Œ
            // ç„¶åå¯¹ nums[i+1..] æœç´¢å°äº target - nums[i] çš„ä¸¤æ•°ä¹‹å’Œä¸ªæ•°
            res += twoSumSmaller(nums, i + 1, target - nums[i]);
        }
        return res;
    }

    // åœ¨ nums[start..] æœç´¢å°äº target çš„ä¸¤æ•°ä¹‹å’Œä¸ªæ•°
    int twoSumSmaller(int[] nums, int start, int target) {
        int lo = start, hi = nums.length - 1;
        int count = 0;
        while (lo < hi) {
            if (nums[lo] + nums[hi] < target) {
                // nums[lo] å’Œ nums[lo+1..hi]
                // ä¸­çš„ä»»ä¸€å…ƒç´ ä¹‹å’Œéƒ½å°äº target
                count += hi - lo;
                lo++;
            } else {
                hi--;
            }
        }
        return count;
    }
}
```

```javascript
// by chatGPT (javascript)
var threeSumSmaller = function(nums, target) {
    // å¦‚æœæ•°ç»„é•¿åº¦å°äº3ï¼Œè¿”å›0
    if(nums.length < 3) {
        return 0;
    }
    // å°†æ•°ç»„å‡åºæ’åº
    nums.sort(function(a,b) {return a - b;});
    // å®šä¹‰å˜é‡resï¼Œåˆå§‹åŒ–ä¸º0
    var res = 0;
    // æšä¸¾ç¬¬ä¸€ä¸ªå…ƒç´ 
    for (var i = 0; i < nums.length - 2; i++) {
        // å¯¹ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹åçš„å…ƒç´ æœç´¢ä¸¤æ•°ä¹‹å’Œå°äºtarget-nums[i]çš„ä¸ªæ•°
        res += twoSumSmaller(nums, i + 1, target - nums[i]);
    }
    // è¿”å›ç­”æ¡ˆ
    return res;

    // æœç´¢nums[start..]å†…ä¸¤æ•°ä¹‹å’Œå°äºtargetçš„ä¸ªæ•°
    function twoSumSmaller(nums, start,Â target) {
        var lo = start, hi = nums.length - 1;
        var count = 0;
        while (lo < hi) {
            // å¦‚æœnums[lo] + nums[hi] < targetï¼Œè¿™æ—¶nums[lo]å’Œnums[lo + 1..hi]ä¸­ä»»æ„ä¸€ä¸ªæ•°ä¸nums[hi]ç›¸åŠ éƒ½ä¼šå°äºtarget
            if (nums[lo] + nums[hi] < target) {
                // è®¡ç®—åŠ å…¥nums[lo]æ—¶å°äºtargetçš„ä¸¤æ•°ä¹‹å’Œçš„ä¸ªæ•°ï¼Œå¹¶å°†loç§»åŠ¨ä¸€ä½
                count += hi - lo;
                lo++;
            } else {
                // å¦‚æœnums[lo] + nums[hi] >= targetï¼Œåˆ™å°†hiå¾€å‰ä¸€ä½
                hi--;
            }
        }
        // è¿”å›å°äºtargetçš„ä¸¤æ•°ä¹‹å’Œçš„ä¸ªæ•°
        return count;
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -> int:
        if len(nums) < 3:
            return 0
        nums.sort()
        res = 0
        for i in range(len(nums) - 2):
            # å›ºå®š nums[i] ä¸ºä¸‰æ•°ä¹‹å’Œä¸­çš„ç¬¬ä¸€ä¸ªæ•°ï¼Œ
            # ç„¶åå¯¹ nums[i+1..] æœç´¢å°äº target - nums[i] çš„ä¸¤æ•°ä¹‹å’Œä¸ªæ•°
            res += self.twoSumSmaller(nums, i + 1, target - nums[i])
        return res

    def twoSumSmaller(self, nums: List[int], start: int, target: int) -> int:
        lo = start
        hi = len(nums) - 1
        count = 0
        while lo < hi:
            if nums[lo] + nums[hi] < target:
                # nums[lo] å’Œ nums[lo+1..hi]
                # ä¸­çš„ä»»ä¸€å…ƒç´ ä¹‹å’Œéƒ½å°äº target
                count += hi - lo
                lo += 1
            else:
                hi -= 1
        return count
```

https://leetcode.cn/problems/3sum-smaller çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/3u1WK4 çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        // p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
        ListNode *p1 = headA, *p2 = headB;
        while (p1 != p2) {
            // p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
            if (p1 == nullptr) p1 = headB;
            else               p1 = p1->next;
            // p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
            if (p2 == nullptr) p2 = headA;
            else               p2 = p2->next;
        }
        return p1;
    }
};
```

```go
// by chatGPT (go)
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    // p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
    p1, p2 := headA, headB
    for p1 != p2 {
        // p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
        if p1 == nil {
            p1 = headB
        } else {
            p1 = p1.Next
        }
        // p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
        if p2 == nil {
            p2 = headA
        } else {
            p2 = p2.Next
        }
    }
    return p1
}
```

```java
// by labuladong (java)
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
        ListNode p1 = headA, p2 = headB;
        while (p1 != p2) {
            // p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
            if (p1 == null) p1 = headB;
            else            p1 = p1.next;
            // p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
            if (p2 == null) p2 = headA;
            else            p2 = p2.next;
        }
        return p1;
    }
}
```

```javascript
// by chatGPT (javascript)
var getIntersectionNode = function(headA, headB) {
    // p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
    let p1 = headA, p2 = headB;
    while (p1 !== p2) {
        // p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
        if (p1 === null) p1 = headB;
        else            p1 = p1.next;
        // p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
        if (p2 === null) p2 = headA;
        else            p2 = p2.next;
    }
    return p1;
};
```

```python
# by chatGPT (python)
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        # p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
        p1, p2 = headA, headB
        while p1 != p2:
            # p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
            if p1 is None:
                p1 = headB
            else:
                p1 = p1.next
            # p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
            if p2 is None:
                p2 = headA
            else:
                p2 = p2.next
        return p1
```

https://leetcode.cn/problems/3u1WK4 çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/4sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        // n ä¸º 4ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º target çš„å››å…ƒç»„
        return nSumTarget(nums, 4, 0, target);
    }

    /* æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº */
    // n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
    vector<vector<int>> nSumTarget(
            vector<int>& nums, int n, int start, int target) {

        int sz = nums.size();
        vector<vector<int>> res;
        // è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
        if (n < 2 || sz < n) return res;
        // 2Sum æ˜¯ base case
        if (n == 2) {
            // åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
            int lo = start, hi = sz - 1;
            while (lo < hi) {
                int sum = nums[lo] + nums[hi];
                int left = nums[lo], right = nums[hi];
                if (sum < target) {
                    while (lo < hi && nums[lo] == left) lo++;
                } else if (sum > target) {
                    while (lo < hi && nums[hi] == right) hi--;
                } else {
                    res.push_back({left, right});
                    while (lo < hi && nums[lo] == left) lo++;
                    while (lo < hi && nums[hi] == right) hi--;
                }
            }
        } else {
            // n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
            for (int i = start; i < sz; i++) {
                vector<vector<int>>
                        sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
                for (vector<int>& arr : sub) {
                    // (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                    arr.push_back(nums[i]);
                    res.push_back(arr);
                }
                while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func fourSum(nums []int, target int) [][]int {
    sort.Ints(nums)
    // n ä¸º 4ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º target çš„å››å…ƒç»„
    return nSumTarget(nums, 4, 0, target)
}

/* æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº */
// n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
func nSumTarget(nums []int, n, start, target int) [][]int {
    sz := len(nums)
    res := [][]int{}
    // è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
    if n < 2 || sz < n {
        return res
    }
    // 2Sum æ˜¯ base case
    if n == 2 {
        // åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
        lo, hi := start, sz-1
        for lo < hi {
            sum := nums[lo] + nums[hi]
            left, right := nums[lo], nums[hi]
            if sum < target {
                for lo < hi && nums[lo] == left {
                    lo++
                }
            } else if sum > target {
                for lo < hi && nums[hi] == right {
                    hi--
                }
            } else {
                res = append(res, []int{left, right})
                for lo < hi && nums[lo] == left {
                    lo++
                }
                for lo < hi && nums[hi] == right {
                    hi--
                }
            }
        }
    } else {
        // n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
        for i := start; i < sz; i++ {
            sub := nSumTarget(nums, n-1, i+1, target-nums[i])
            for _, arr := range sub {
                // (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                arr = append(arr, nums[i])
                res = append(res, arr)
            }
            for i < sz-1 && nums[i] == nums[i+1] {
                i++
            }
        }
    }
    return res
}
```

```java
// by chatGPT (java)
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        // n ä¸º 4ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º target çš„å››å…ƒç»„
        return nSumTarget(nums, 4, 0, target);
    }

    /* æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº */
    // n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
    private List<List<Integer>> nSumTarget(int[] nums, int n, int start, int target) {
        int sz = nums.length;
        List<List<Integer>> res = new ArrayList<>();
        // è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
        if (n < 2 || sz < n) return res;
        // 2Sum æ˜¯ base case
        if (n == 2) {
            // åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
            int lo = start, hi = sz - 1;
            while (lo < hi) {
                int sum = nums[lo] + nums[hi];
                int left = nums[lo], right = nums[hi];
                if (sum < target) {
                    while (lo < hi && nums[lo] == left) lo++;
                } else if (sum > target) {
                    while (lo < hi && nums[hi] == right) hi--;
                } else {
                    res.add(new ArrayList<>(Arrays.asList(left, right)));
                    while (lo < hi && nums[lo] == left) lo++;
                    while (lo < hi && nums[hi] == right) hi--;
                }
            }
        } else {
            // n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
            for (int i = start; i < sz; i++) {
                List<List<Integer>> sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
                for (List<Integer> arr : sub) {
                    // (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                    arr.add(nums[i]);
                    res.add(arr);
                }
                while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
            }
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var fourSum = function(nums, target) {
  nums.sort((a, b) => a - b);
  // n ä¸º 4ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º target çš„å››å…ƒç»„
  return nSumTarget(nums, 4, 0, target);
};

/* æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº */
// n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
var nSumTarget = function(nums, n, start, target) {
  var sz = nums.length;
  var res = [];
  // è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
  if (n < 2 || sz < n) return res;
  // 2Sum æ˜¯ base case
  if (n === 2) {
    // åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
    var lo = start, hi = sz - 1;
    while (lo < hi) {
      var sum = nums[lo] + nums[hi];
      var left = nums[lo], right = nums[hi];
      if (sum < target) {
        while (lo < hi && nums[lo] === left) lo++;
      } else if (sum > target) {
        while (lo < hi && nums[hi] === right) hi--;
      } else {
        res.push([left, right]);
        while (lo < hi && nums[lo] === left) lo++;
        while (lo < hi && nums[hi] === right) hi--;
      }
    }
  } else {
    // n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
    for (var i = start; i < sz; i++) {
      var sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
      for (var arr of sub) {
        // (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
        arr.push(nums[i]);
        res.push(arr);
      }
      while (i < sz - 1 && nums[i] === nums[i + 1]) i++;
    }
  }
  return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        # n ä¸º 4ï¼Œä» nums[0] å¼€å§‹è®¡ç®—å’Œä¸º target çš„å››å…ƒç»„
        return self.nSumTarget(nums, 4, 0, target)
        
    # æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº
    # n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
    def nSumTarget(self, nums: List[int], n: int, start: int, target: int) -> List[List[int]]:
        sz = len(nums)
        res = []
        # è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
        if n < 2 or sz < n:
            return res
        # 2Sum æ˜¯ base case
        if n == 2:
            # åŒæŒ‡é’ˆé‚£ä¸€å¥—æ“ä½œ
            lo, hi = start, sz - 1
            while lo < hi:
                s = nums[lo] + nums[hi]
                left, right = nums[lo], nums[hi]
                if s < target:
                    while lo < hi and nums[lo] == left:
                        lo += 1
                elif s > target:
                    while lo < hi and nums[hi] == right:
                        hi -= 1
                else:
                    res.append([left, right])
                    while lo < hi and nums[lo] == left:
                        lo += 1
                    while lo < hi and nums[hi] == right:
                        hi -= 1
        else:
            # n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
            for i in range(start, sz):
                sub = self.nSumTarget(nums, n - 1, i + 1, target - nums[i])
                for arr in sub:
                    # (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                    arr.append(nums[i])
                    res.append(arr)
                while i < sz - 1 and nums[i] == nums[i + 1]:
                    i += 1
        return res
```

https://leetcode.cn/problems/4sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/8Zf90G çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> stk;
        for (const auto& token : tokens) {
            if (string("+-*/").find(token) != string::npos) {
                // æ˜¯ä¸ªè¿ç®—ç¬¦ï¼Œä»æ ˆé¡¶æ‹¿å‡ºä¸¤ä¸ªæ•°å­—è¿›è¡Œè¿ç®—ï¼Œè¿ç®—ç»“æœå…¥æ ˆ
                int a = stk.top();
                stk.pop();
                int b = stk.top();
                stk.pop();
                switch (token[0]) {
                    case '+':
                        stk.push(b + a);
                        break;
                    case '*':
                        stk.push(b * a);
                        break;
                    // å¯¹äºå‡æ³•å’Œé™¤æ³•ï¼Œé¡ºåºåˆ«æåäº†ï¼Œç¬¬äºŒä¸ªæ•°æ˜¯è¢«é™¤ï¼ˆå‡ï¼‰æ•°
                    case '-':
                        stk.push(b - a);
                        break;
                    case '/':
                        stk.push(b / a);
                        break;
                }
            } else {
                // æ˜¯ä¸ªæ•°å­—ï¼Œç›´æ¥å…¥æ ˆå³å¯
                stk.push(stoi(token));
            }
        }
        // æœ€åæ ˆä¸­å‰©ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå³æ˜¯è®¡ç®—ç»“æœ
        return stk.top();
    }
};
```

```go
// by chatGPT (go)
func evalRPN(tokens []string) int {
    stk := make([]int, 0)
    for _, token := range tokens {
        if strings.Contains("+-*/", token) {
            // æ˜¯ä¸ªè¿ç®—ç¬¦ï¼Œä»æ ˆé¡¶æ‹¿å‡ºä¸¤ä¸ªæ•°å­—è¿›è¡Œè¿ç®—ï¼Œè¿ç®—ç»“æœå…¥æ ˆ
            a, b := stk[len(stk)-1], stk[len(stk)-2]
            stk = stk[:len(stk)-2]
            switch token {
            case "+":
                stk = append(stk, a+b)
            case "*":
                stk = append(stk, a*b)
            // å¯¹äºå‡æ³•å’Œé™¤æ³•ï¼Œé¡ºåºåˆ«æåäº†ï¼Œç¬¬äºŒä¸ªæ•°æ˜¯è¢«é™¤ï¼ˆå‡ï¼‰æ•°
            case "-":
                stk = append(stk, b-a)
            case "/":
                stk = append(stk, b/a)
            }
        } else {
            // æ˜¯ä¸ªæ•°å­—ï¼Œç›´æ¥å…¥æ ˆå³å¯
            num, _ := strconv.Atoi(token)
            stk = append(stk, num)
        }
    }
    // æœ€åæ ˆä¸­å‰©ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå³æ˜¯è®¡ç®—ç»“æœ
    return stk[0]
}
```

```java
// by labuladong (java)
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer> stk = new Stack<>();
        for (String token : tokens) {
            if ("+-*/".contains(token)) {
                // æ˜¯ä¸ªè¿ç®—ç¬¦ï¼Œä»æ ˆé¡¶æ‹¿å‡ºä¸¤ä¸ªæ•°å­—è¿›è¡Œè¿ç®—ï¼Œè¿ç®—ç»“æœå…¥æ ˆ
                int a = stk.pop(), b = stk.pop();
                switch (token) {
                    case "+":
                        stk.push(a + b);
                        break;
                    case "*":
                        stk.push(a * b);
                        break;
                    // å¯¹äºå‡æ³•å’Œé™¤æ³•ï¼Œé¡ºåºåˆ«æåäº†ï¼Œç¬¬äºŒä¸ªæ•°æ˜¯è¢«é™¤ï¼ˆå‡ï¼‰æ•°
                    case "-":
                        stk.push(b - a);
                        break;
                    case "/":
                        stk.push(b / a);
                        break;
                }
            } else {
                // æ˜¯ä¸ªæ•°å­—ï¼Œç›´æ¥å…¥æ ˆå³å¯
                stk.push(Integer.parseInt(token));
            }
        }
        // æœ€åæ ˆä¸­å‰©ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå³æ˜¯è®¡ç®—ç»“æœ
        return stk.pop();
    }
}
```

```javascript
// by chatGPT (javascript)
var evalRPN = function(tokens) {
    let stk = [];
    for (let i = 0; i < tokens.length; i++) {
        let token = tokens[i];
        if ("+-*/".includes(token)) {
            // æ˜¯ä¸ªè¿ç®—ç¬¦ï¼Œä»æ ˆé¡¶æ‹¿å‡ºä¸¤ä¸ªæ•°å­—è¿›è¡Œè¿ç®—ï¼Œè¿ç®—ç»“æœå…¥æ ˆ
            let a = stk.pop(), b = stk.pop();
            switch (token) {
                case "+":
                    stk.push(a + b);
                    break;
                case "*":
                    stk.push(a * b);
                    break;
                // å¯¹äºå‡æ³•å’Œé™¤æ³•ï¼Œé¡ºåºåˆ«æåäº†ï¼Œç¬¬äºŒä¸ªæ•°æ˜¯è¢«é™¤ï¼ˆå‡ï¼‰æ•°
                case "-":
                    stk.push(b - a);
                    break;
                case "/":
                    stk.push(parseInt(b / a));
                    break;
            }
        } else {
            // æ˜¯ä¸ªæ•°å­—ï¼Œç›´æ¥å…¥æ ˆå³å¯
            stk.push(parseInt(token));
        }
    }
    // æœ€åæ ˆä¸­å‰©ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå³æ˜¯è®¡ç®—ç»“æœ
    return stk.pop();
};
```

```python
# by chatGPT (python)
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stk = []
        for token in tokens:
            if token in "+-*/":
                # æ˜¯ä¸ªè¿ç®—ç¬¦ï¼Œä»æ ˆé¡¶æ‹¿å‡ºä¸¤ä¸ªæ•°å­—è¿›è¡Œè¿ç®—ï¼Œè¿ç®—ç»“æœå…¥æ ˆ
                a = stk.pop()
                b = stk.pop()
                if token == "+":
                    stk.append(a + b)
                elif token == "-":
                    stk.append(b - a)
                elif token == "*":
                    stk.append(a * b)
                else: # token == "/"
                    stk.append(int(b / a))
            else:
                # æ˜¯ä¸ªæ•°å­—ï¼Œç›´æ¥å…¥æ ˆå³å¯
                stk.append(int(token))
        # æœ€åæ ˆä¸­å‰©ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå³æ˜¯è®¡ç®—ç»“æœ
        return stk.pop()
```

https://leetcode.cn/problems/8Zf90G çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/B1IidL çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& nums) {
        // å–ä¸¤ç«¯éƒ½é—­çš„äºŒåˆ†æœç´¢
        int left = 0, right = nums.size() - 1;
        // å› ä¸ºé¢˜ç›®å¿…ç„¶æœ‰è§£ï¼Œæ‰€ä»¥è®¾ç½® left == right ä¸ºç»“æŸæ¡ä»¶
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                // mid æœ¬èº«å°±æ˜¯å³°å€¼æˆ–å…¶å·¦ä¾§æœ‰ä¸€ä¸ªå³°å€¼
                right = mid;
            } else {
                // mid å³ä¾§æœ‰ä¸€ä¸ªå³°å€¼
                left = mid + 1;
            }
        }
        return left;
    }
};
```

```go
// by chatGPT (go)
func peakIndexInMountainArray(nums []int) int {
    // å–ä¸¤ç«¯éƒ½é—­çš„äºŒåˆ†æœç´¢
    left, right := 0, len(nums)-1
    // å› ä¸ºé¢˜ç›®å¿…ç„¶æœ‰è§£ï¼Œæ‰€ä»¥è®¾ç½® left == right ä¸ºç»“æŸæ¡ä»¶
    for left < right {
        mid := left + (right-left)/2
        if nums[mid] > nums[mid+1] {
            // mid æœ¬èº«å°±æ˜¯å³°å€¼æˆ–å…¶å·¦ä¾§æœ‰ä¸€ä¸ªå³°å€¼
            right = mid
        } else {
            // mid å³ä¾§æœ‰ä¸€ä¸ªå³°å€¼
            left = mid + 1
        }
    }
    return left
}
```

```java
// by labuladong (java)
class Solution {
    public int peakIndexInMountainArray(int[] nums) {
        // å–ä¸¤ç«¯éƒ½é—­çš„äºŒåˆ†æœç´¢
        int left = 0, right = nums.length - 1;
        // å› ä¸ºé¢˜ç›®å¿…ç„¶æœ‰è§£ï¼Œæ‰€ä»¥è®¾ç½® left == right ä¸ºç»“æŸæ¡ä»¶
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                // mid æœ¬èº«å°±æ˜¯å³°å€¼æˆ–å…¶å·¦ä¾§æœ‰ä¸€ä¸ªå³°å€¼
                right = mid;
            } else {
                // mid å³ä¾§æœ‰ä¸€ä¸ªå³°å€¼
                left = mid + 1;
            }
        }
        return left;
    }
}
```

```javascript
// by chatGPT (javascript)
var peakIndexInMountainArray = function(nums) {
  // å–ä¸¤ç«¯éƒ½é—­çš„äºŒåˆ†æœç´¢
  let left = 0, right = nums.length - 1;
  // å› ä¸ºé¢˜ç›®å¿…ç„¶æœ‰è§£ï¼Œæ‰€ä»¥è®¾ç½® left == right ä¸ºç»“æŸæ¡ä»¶
  while (left < right) {
    let mid = left + Math.floor((right - left) / 2);
    if (nums[mid] > nums[mid + 1]) {
      // mid æœ¬èº«å°±æ˜¯å³°å€¼æˆ–å…¶å·¦ä¾§æœ‰ä¸€ä¸ªå³°å€¼
      right = mid;
    } else {
      // mid å³ä¾§æœ‰ä¸€ä¸ªå³°å€¼
      left = mid + 1;
    }
  }
  return left;
};
```

```python
# by chatGPT (python)
class Solution:
    def peakIndexInMountainArray(self, nums: List[int]) -> int:
        # å–ä¸¤ç«¯éƒ½é—­çš„äºŒåˆ†æœç´¢
        left, right = 0, len(nums) - 1
        # å› ä¸ºé¢˜ç›®å¿…ç„¶æœ‰è§£ï¼Œæ‰€ä»¥è®¾ç½® left == right ä¸ºç»“æŸæ¡ä»¶
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[mid + 1]:
                # mid æœ¬èº«å°±æ˜¯å³°å€¼æˆ–å…¶å·¦ä¾§æœ‰ä¸€ä¸ªå³°å€¼
                right = mid
            else:
                # mid å³ä¾§æœ‰ä¸€ä¸ªå³°å€¼
                left = mid + 1
        return left
```

https://leetcode.cn/problems/B1IidL çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/FortPu çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class RandomizedSet {
    public:
    // å­˜å‚¨å…ƒç´ çš„å€¼
    vector<int> nums;
    // è®°å½•æ¯ä¸ªå…ƒç´ å¯¹åº”åœ¨ nums ä¸­çš„ç´¢å¼•
    unordered_map<int,int> valToIndex;

    bool insert(int val) {
        // è‹¥ val å·²å­˜åœ¨ï¼Œä¸ç”¨å†æ’å…¥
        if (valToIndex.count(val)) {
            return false;
        }
        // è‹¥ val ä¸å­˜åœ¨ï¼Œæ’å…¥åˆ° nums å°¾éƒ¨ï¼Œ
        // å¹¶è®°å½• val å¯¹åº”çš„ç´¢å¼•å€¼
        valToIndex[val] = nums.size();
        nums.push_back(val);
        return true;
    }

    bool remove(int val) {
        // è‹¥ val ä¸å­˜åœ¨ï¼Œä¸ç”¨å†åˆ é™¤
        if (!valToIndex.count(val)) {
            return false;
        }
        // å…ˆæ‹¿åˆ° val çš„ç´¢å¼•
        int index = valToIndex[val];
        // å°†æœ€åä¸€ä¸ªå…ƒç´ å¯¹åº”çš„ç´¢å¼•ä¿®æ”¹ä¸º index
        valToIndex[nums.back()] = index;
        // äº¤æ¢ val å’Œæœ€åä¸€ä¸ªå…ƒç´ 
        swap(nums[index], nums.back());
        // åœ¨æ•°ç»„ä¸­åˆ é™¤å…ƒç´  val
        nums.pop_back();
        // åˆ é™¤å…ƒç´  val å¯¹åº”çš„ç´¢å¼•
        valToIndex.erase(val);
        return true;
    }

    int getRandom() {
        // éšæœºè·å– nums ä¸­çš„ä¸€ä¸ªå…ƒç´ 
        return nums[rand() % nums.size()];
    }
};
```

```go
// by chatGPT (go)
// å®šä¹‰ç»“æ„ä½“
type RandomizedSet struct {
    // å­˜å‚¨å…ƒç´ çš„å€¼
    nums []int
    // è®°å½•æ¯ä¸ªå…ƒç´ å¯¹åº”åœ¨ nums ä¸­çš„ç´¢å¼•
    valToIndex map[int]int
}

// æ’å…¥æ“ä½œ
func (r *RandomizedSet) insert(val int) bool {
    // è‹¥ val å·²å­˜åœ¨ï¼Œä¸ç”¨å†æ’å…¥
    if _, ok := r.valToIndex[val]; ok {
        return false
    }
    // è‹¥ val ä¸å­˜åœ¨ï¼Œæ’å…¥åˆ° nums å°¾éƒ¨ï¼Œ
    // å¹¶è®°å½• val å¯¹åº”çš„ç´¢å¼•å€¼
    r.valToIndex[val] = len(r.nums)
    r.nums = append(r.nums, val)
    return true
}

// åˆ é™¤æ“ä½œ
func (r *RandomizedSet) remove(val int) bool {
    // è‹¥ val ä¸å­˜åœ¨ï¼Œä¸ç”¨å†åˆ é™¤
    if _, ok := r.valToIndex[val]; !ok {
        return false
    }
    // å…ˆæ‹¿åˆ° val çš„ç´¢å¼•
    index := r.valToIndex[val]
    // å°†æœ€åä¸€ä¸ªå…ƒç´ å¯¹åº”çš„ç´¢å¼•ä¿®æ”¹ä¸º index
    r.valToIndex[r.nums[len(r.nums)-1]] = index
    // äº¤æ¢ val å’Œæœ€åä¸€ä¸ªå…ƒç´ 
    r.nums[index], r.nums[len(r.nums)-1] = r.nums[len(r.nums)-1], r.nums[index]
    // åœ¨æ•°ç»„ä¸­åˆ é™¤å…ƒç´  val
    r.nums = r.nums[:len(r.nums)-1]
    // åˆ é™¤å…ƒç´  val å¯¹åº”çš„ç´¢å¼•
    delete(r.valToIndex, val)
    return true
}

// éšæœºè·å–å…ƒç´ 
func (r *RandomizedSet) getRandom() int {
    // éšæœºè·å– nums ä¸­çš„ä¸€ä¸ªå…ƒç´ 
    return r.nums[rand.Intn(len(r.nums))]
}
```

```java
// by chatGPT (java)
class RandomizedSet {
    // å­˜å‚¨å…ƒç´ çš„å€¼
    List<Integer> nums;
    // è®°å½•æ¯ä¸ªå…ƒç´ å¯¹åº”åœ¨ nums ä¸­çš„ç´¢å¼•
    Map<Integer, Integer> valToIndex;

    public boolean insert(int val) {
        // è‹¥ val å·²å­˜åœ¨ï¼Œä¸ç”¨å†æ’å…¥
        if (valToIndex.containsKey(val)) {
            return false;
        }
        // è‹¥ val ä¸å­˜åœ¨ï¼Œæ’å…¥åˆ° nums å°¾éƒ¨ï¼Œ
        // å¹¶è®°å½• val å¯¹åº”çš„ç´¢å¼•å€¼
        valToIndex.put(val, nums.size());
        nums.add(val);
        return true;
    }

    public boolean remove(int val) {
        // è‹¥ val ä¸å­˜åœ¨ï¼Œä¸ç”¨å†åˆ é™¤
        if (!valToIndex.containsKey(val)) {
            return false;
        }
        // å…ˆæ‹¿åˆ° val çš„ç´¢å¼•
        int index = valToIndex.get(val);
        // å°†æœ€åä¸€ä¸ªå…ƒç´ å¯¹åº”çš„ç´¢å¼•ä¿®æ”¹ä¸º index
        valToIndex.put(nums.get(nums.size()-1), index);
        // äº¤æ¢ val å’Œæœ€åä¸€ä¸ªå…ƒç´ 
        Collections.swap(nums, index, nums.size()-1);
        // åœ¨æ•°ç»„ä¸­åˆ é™¤å…ƒç´  val
        nums.remove(nums.size()-1);
        // åˆ é™¤å…ƒç´  val å¯¹åº”çš„ç´¢å¼•
        valToIndex.remove(val);
        return true;
    }

    public int getRandom() {
        // éšæœºè·å– nums ä¸­çš„ä¸€ä¸ªå…ƒç´ 
        return nums.get((int)(Math.random() * nums.size()));
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * Initialize your data structure here.
 */
var RandomizedSet = function() {
    // å­˜å‚¨å…ƒç´ çš„å€¼
    this.nums = [];
    // è®°å½•æ¯ä¸ªå…ƒç´ å¯¹åº”åœ¨ nums ä¸­çš„ç´¢å¼•
    this.valToIndex = new Map();
};

/**
 * Inserts a value to the set. Returns true if the set did not already contain the specified element.
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.insert = function(val) {
    // è‹¥ val å·²å­˜åœ¨ï¼Œä¸ç”¨å†æ’å…¥
    if (this.valToIndex.has(val)) {
        return false;
    }
    // è‹¥ val ä¸å­˜åœ¨ï¼Œæ’å…¥åˆ° nums å°¾éƒ¨ï¼Œ
    // å¹¶è®°å½• val å¯¹åº”çš„ç´¢å¼•å€¼
    this.valToIndex.set(val, this.nums.length);
    this.nums.push(val);
    return true;
};

/**
 * Removes a value from the set. Returns true if the set contained the specified element.
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.remove = function(val) {
    // è‹¥ val ä¸å­˜åœ¨ï¼Œä¸ç”¨å†åˆ é™¤
    if (!this.valToIndex.has(val)) {
        return false;
    }
    // å…ˆæ‹¿åˆ° val çš„ç´¢å¼•
    const index = this.valToIndex.get(val);
    // å°†æœ€åä¸€ä¸ªå…ƒç´ å¯¹åº”çš„ç´¢å¼•ä¿®æ”¹ä¸º index
    this.valToIndex.set(this.nums[this.nums.length - 1], index);
    // äº¤æ¢ val å’Œæœ€åä¸€ä¸ªå…ƒç´ 
    [this.nums[index], this.nums[this.nums.length - 1]] = [this.nums[this.nums.length - 1], this.nums[index]];
    // åœ¨æ•°ç»„ä¸­åˆ é™¤å…ƒç´  val
    this.nums.pop();
    // åˆ é™¤å…ƒç´  val å¯¹åº”çš„ç´¢å¼•
    this.valToIndex.delete(val);
    return true;
};

/**
 * Get a random element from the set.
 * @return {number}
 */
RandomizedSet.prototype.getRandom = function() {
    // éšæœºè·å– nums ä¸­çš„ä¸€ä¸ªå…ƒç´ 
    return this.nums[Math.floor(Math.random() * this.nums.length)];
};
```

```python
# by chatGPT (python)
class RandomizedSet:
    def __init__(self):
        # å­˜å‚¨å…ƒç´ çš„å€¼
        self.nums = []
        # è®°å½•æ¯ä¸ªå…ƒç´ å¯¹åº”åœ¨ nums ä¸­çš„ç´¢å¼•
        self.valToIndex = {}

    def insert(self, val: int) -> bool:
        # è‹¥ val å·²å­˜åœ¨ï¼Œä¸ç”¨å†æ’å…¥
        if val in self.valToIndex:
            return False
        # è‹¥ val ä¸å­˜åœ¨ï¼Œæ’å…¥åˆ° nums å°¾éƒ¨ï¼Œ
        # å¹¶è®°å½• val å¯¹åº”çš„ç´¢å¼•å€¼
        self.valToIndex[val] = len(self.nums)
        self.nums.append(val)
        return True

    def remove(self, val: int) -> bool:
        # è‹¥ val ä¸å­˜åœ¨ï¼Œä¸ç”¨å†åˆ é™¤
        if val not in self.valToIndex:
            return False
        # å…ˆæ‹¿åˆ° val çš„ç´¢å¼•
        index = self.valToIndex[val]
        # å°†æœ€åä¸€ä¸ªå…ƒç´ å¯¹åº”çš„ç´¢å¼•ä¿®æ”¹ä¸º index
        self.valToIndex[self.nums[-1]] = index
        # äº¤æ¢ val å’Œæœ€åä¸€ä¸ªå…ƒç´ 
        self.nums[index], self.nums[-1] = self.nums[-1], self.nums[index]
        # åœ¨æ•°ç»„ä¸­åˆ é™¤å…ƒç´  val
        self.nums.pop()
        # åˆ é™¤å…ƒç´  val å¯¹åº”çš„ç´¢å¼•
        self.valToIndex.pop(val)
        return True

    def getRandom(self) -> int:
        # éšæœºè·å– nums ä¸­çš„ä¸€ä¸ªå…ƒç´ 
        return self.nums[random.randint(0, len(self.nums) - 1)]
```

https://leetcode.cn/problems/FortPu çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/Gu0c2T çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
private:
    // å¤‡å¿˜å½•
    vector<int> memo;
    // dp å‡½æ•°
    int dp(vector<int>& nums, int start) {
        if (start >= nums.size()) {
            return 0;
        }
        // é¿å…é‡å¤è®¡ç®—
        if (memo[start] != -1) {
            return memo[start];
        }
        int res = max(dp(nums, start + 1),
                      nums[start] + dp(nums, start + 2));
        // è®°å…¥å¤‡å¿˜å½•
        memo[start] = res;
        return res;
    }

public:
    // ä¸»å‡½æ•°
    int rob(vector<int>& nums) {
        // åˆå§‹åŒ–å¤‡å¿˜å½•
        memo.resize(nums.size(), -1);
        // å¼ºç›—ä»ç¬¬ 0 é—´æˆ¿å­å¼€å§‹æŠ¢åŠ«
        return dp(nums, 0);
    }
};
```

```go
// by chatGPT (go)
import (
    "fmt"
)

func rob(nums []int) int {
    // åˆå§‹åŒ–å¤‡å¿˜å½•
    memo := make([]int, len(nums))
    for i := 0; i < len(memo); i++ {
        memo[i] = -1
    }
    // å¼ºç›—ä»ç¬¬ 0 é—´æˆ¿å­å¼€å§‹æŠ¢åŠ«
    return dp(nums, 0, memo)
}

// è¿”å› dp[start..] èƒ½æŠ¢åˆ°çš„æœ€å¤§å€¼
func dp(nums []int, start int, memo []int) int {
    if start >= len(nums) {
        return 0
    }
    // é¿å…é‡å¤è®¡ç®—
    if memo[start] != -1 {
        return memo[start]
    }

    res := max(dp(nums, start+1, memo), nums[start]+dp(nums, start+2, memo))
    // è®°å…¥å¤‡å¿˜å½•
    memo[start] = res
    return res
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {
    // å¤‡å¿˜å½•
    private int[] memo;
    // ä¸»å‡½æ•°
    public int rob(int[] nums) {
        // åˆå§‹åŒ–å¤‡å¿˜å½•
        memo = new int[nums.length];
        Arrays.fill(memo, -1);
        // å¼ºç›—ä»ç¬¬ 0 é—´æˆ¿å­å¼€å§‹æŠ¢åŠ«
        return dp(nums, 0);
    }

    // è¿”å› dp[start..] èƒ½æŠ¢åˆ°çš„æœ€å¤§å€¼
    private int dp(int[] nums, int start) {
        if (start >= nums.length) {
            return 0;
        }
        // é¿å…é‡å¤è®¡ç®—
        if (memo[start] != -1) return memo[start];

        int res = Math.max(dp(nums, start + 1),
                nums[start] + dp(nums, start + 2));
        // è®°å…¥å¤‡å¿˜å½•
        memo[start] = res;
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var rob = function(nums) {
    // å¤‡å¿˜å½•
    const memo = new Array(nums.length).fill(-1);
    
    // è¿”å› dp[start..] èƒ½æŠ¢åˆ°çš„æœ€å¤§å€¼
    const dp = (start) => {
        if (start >= nums.length) {
            return 0;
        }
        // é¿å…é‡å¤è®¡ç®—
        if (memo[start] != -1) return memo[start];

        const res = Math.max(dp(start + 1), nums[start] + dp(start + 2));
        // è®°å…¥å¤‡å¿˜å½•
        memo[start] = res;
        return res;
    }

    // å¼ºç›—ä»ç¬¬ 0 é—´æˆ¿å­å¼€å§‹æŠ¢åŠ«
    return dp(0);
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        # å¤‡å¿˜å½•
        self.memo = None
    
    # ä¸»å‡½æ•°
    def rob(self, nums: List[int]) -> int:
        # åˆå§‹åŒ–å¤‡å¿˜å½•
        self.memo = [-1] * len(nums)
        # å¼ºç›—ä»ç¬¬ 0 é—´æˆ¿å­å¼€å§‹æŠ¢åŠ«
        return self.dp(nums, 0)
    
    # è¿”å› dp[start..] èƒ½æŠ¢åˆ°çš„æœ€å¤§å€¼
    def dp(self, nums: List[int], start: int) -> int:
        if start >= len(nums):
            return 0
        # é¿å…é‡å¤è®¡ç®—
        if self.memo[start] != -1:
            return self.memo[start]
        res = max(self.dp(nums, start + 1),
                  nums[start] + self.dp(nums, start + 2))
        # è®°å…¥å¤‡å¿˜å½•
        self.memo[start] = res
        return res
```

https://leetcode.cn/problems/Gu0c2T çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/IDBivT çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    vector<string> generateParenthesis(int n) {
        if (n == 0) return {};
        // è®°å½•æ‰€æœ‰åˆæ³•çš„æ‹¬å·ç»„åˆ
        vector<string> res;
        // å›æº¯è¿‡ç¨‹ä¸­çš„è·¯å¾„
        string track;
        // å¯ç”¨çš„å·¦æ‹¬å·å’Œå³æ‹¬å·æ•°é‡åˆå§‹åŒ–ä¸º n
        backtrack(n, n, track, res);
        return res;
    }

    // å¯ç”¨çš„å·¦æ‹¬å·æ•°é‡ä¸º left ä¸ªï¼Œå¯ç”¨çš„å³æ‹¬å·æ•°é‡ä¸º rgiht ä¸ª
    void backtrack(int left, int right, 
                string& track, vector<string>& res) {
        // è‹¥å·¦æ‹¬å·å‰©ä¸‹çš„å¤šï¼Œè¯´æ˜ä¸åˆæ³•
        if (right < left) return;
        // æ•°é‡å°äº 0 è‚¯å®šæ˜¯ä¸åˆæ³•çš„
        if (left < 0 || right < 0) return;
        // å½“æ‰€æœ‰æ‹¬å·éƒ½æ°å¥½ç”¨å®Œæ—¶ï¼Œå¾—åˆ°ä¸€ä¸ªåˆæ³•çš„æ‹¬å·ç»„åˆ
        if (left == 0 && right == 0) {
            res.push_back(track);
            return;
        }
        
        // å°è¯•æ”¾ä¸€ä¸ªå·¦æ‹¬å·
        track.push_back('('); // é€‰æ‹©
        backtrack(left - 1, right, track, res);
        track.pop_back(); // æ’¤æ¶ˆé€‰æ‹©

        // å°è¯•æ”¾ä¸€ä¸ªå³æ‹¬å·
        track.push_back(')'); // é€‰æ‹©
        backtrack(left, right - 1, track, res);
        track.pop_back(); // æ’¤æ¶ˆé€‰æ‹©
    }
}
```

```go
// by chatGPT (go)
func generateParenthesis(n int) []string {
    if n == 0 {
        return []string{}
    }
    // è®°å½•æ‰€æœ‰åˆæ³•çš„æ‹¬å·ç»„åˆ
    var res []string
    // å›æº¯è¿‡ç¨‹ä¸­çš„è·¯å¾„
    var track string
    // å¯ç”¨çš„å·¦æ‹¬å·å’Œå³æ‹¬å·æ•°é‡åˆå§‹åŒ–ä¸º n
    backtrack(n, n, &track, &res)
    return res
}

// å¯ç”¨çš„å·¦æ‹¬å·æ•°é‡ä¸º left ä¸ªï¼Œå¯ç”¨çš„å³æ‹¬å·æ•°é‡ä¸º right ä¸ª
func backtrack(left, right int, track *string, res *[]string) {
    // è‹¥å·¦æ‹¬å·å‰©ä¸‹çš„å¤šï¼Œè¯´æ˜ä¸åˆæ³•
    if right < left {
        return
    }
    // æ•°é‡å°äº 0 è‚¯å®šæ˜¯ä¸åˆæ³•çš„
    if left < 0 || right < 0 {
        return
    }
    // å½“æ‰€æœ‰æ‹¬å·éƒ½æ°å¥½ç”¨å®Œæ—¶ï¼Œå¾—åˆ°ä¸€ä¸ªåˆæ³•çš„æ‹¬å·ç»„åˆ
    if left == 0 && right == 0 {
        *res = append(*res, *track)
        return
    }

    // å°è¯•æ”¾ä¸€ä¸ªå·¦æ‹¬å·
    *track += "(" // é€‰æ‹©
    backtrack(left-1, right, track, res)
    *track = (*track)[:len(*track)-1] // æ’¤æ¶ˆé€‰æ‹©

    // å°è¯•æ”¾ä¸€ä¸ªå³æ‹¬å·
    *track += ")" // é€‰æ‹©
    backtrack(left, right-1, track, res)
    *track = (*track)[:len(*track)-1] // æ’¤æ¶ˆé€‰æ‹©
}
```

```java
// by chatGPT (java)
class Solution {
    public List<String> generateParenthesis(int n) {
        if (n == 0) return new ArrayList<>();
        // è®°å½•æ‰€æœ‰åˆæ³•çš„æ‹¬å·ç»„åˆ
        List<String> res = new ArrayList<>();
        // å›æº¯è¿‡ç¨‹ä¸­çš„è·¯å¾„
        StringBuilder track = new StringBuilder();
        // å¯ç”¨çš„å·¦æ‹¬å·å’Œå³æ‹¬å·æ•°é‡åˆå§‹åŒ–ä¸º n
        backtrack(n, n, track, res);
        return res;
    }

    // å¯ç”¨çš„å·¦æ‹¬å·æ•°é‡ä¸º left ä¸ªï¼Œå¯ç”¨çš„å³æ‹¬å·æ•°é‡ä¸º right ä¸ª
    void backtrack(int left, int right, 
                StringBuilder track, List<String> res) {
        // è‹¥å·¦æ‹¬å·å‰©ä¸‹çš„å¤šï¼Œè¯´æ˜ä¸åˆæ³•
        if (right < left) return;
        // æ•°é‡å°äº 0 è‚¯å®šæ˜¯ä¸åˆæ³•çš„
        if (left < 0 || right < 0) return;
        // å½“æ‰€æœ‰æ‹¬å·éƒ½æ°å¥½ç”¨å®Œæ—¶ï¼Œå¾—åˆ°ä¸€ä¸ªåˆæ³•çš„æ‹¬å·ç»„åˆ
        if (left == 0 && right == 0) {
            res.add(track.toString());
            return;
        }
        
        // å°è¯•æ”¾ä¸€ä¸ªå·¦æ‹¬å·
        track.append('('); // é€‰æ‹©
        backtrack(left - 1, right, track, res);
        track.deleteCharAt(track.length() - 1); // æ’¤æ¶ˆé€‰æ‹©

        // å°è¯•æ”¾ä¸€ä¸ªå³æ‹¬å·
        track.append(')'); // é€‰æ‹©
        backtrack(left, right - 1, track, res);
        track.deleteCharAt(track.length() - 1); // æ’¤æ¶ˆé€‰æ‹©
    }
}
```

```javascript
// by chatGPT (javascript)
var generateParenthesis = function(n) {
    if (n === 0) return [];
    // è®°å½•æ‰€æœ‰åˆæ³•çš„æ‹¬å·ç»„åˆ
    var res = [];
    // å›æº¯è¿‡ç¨‹ä¸­çš„è·¯å¾„
    var track = "";
    // å¯ç”¨çš„å·¦æ‹¬å·å’Œå³æ‹¬å·æ•°é‡åˆå§‹åŒ–ä¸º n
    backtrack(n, n, track, res);
    return res;
};

// å¯ç”¨çš„å·¦æ‹¬å·æ•°é‡ä¸º left ä¸ªï¼Œå¯ç”¨çš„å³æ‹¬å·æ•°é‡ä¸º rgiht ä¸ª
var backtrack = function(left, right, track, res) {
    // è‹¥å·¦æ‹¬å·å‰©ä¸‹çš„å¤šï¼Œè¯´æ˜ä¸åˆæ³•
    if (right < left) return;
    // æ•°é‡å°äº 0 è‚¯å®šæ˜¯ä¸åˆæ³•çš„
    if (left < 0 || right < 0) return;
    // å½“æ‰€æœ‰æ‹¬å·éƒ½æ°å¥½ç”¨å®Œæ—¶ï¼Œå¾—åˆ°ä¸€ä¸ªåˆæ³•çš„æ‹¬å·ç»„åˆ
    if (left === 0 && right === 0) {
        res.push(track);
        return;
    }

    // å°è¯•æ”¾ä¸€ä¸ªå·¦æ‹¬å·
    track += '('; // é€‰æ‹©
    backtrack(left - 1, right, track, res);
    track = track.substring(0, track.length - 1); // æ’¤æ¶ˆé€‰æ‹©

    // å°è¯•æ”¾ä¸€ä¸ªå³æ‹¬å·
    track += ')'; // é€‰æ‹©
    backtrack(left, right - 1, track, res);
    track = track.substring(0, track.length - 1); // æ’¤æ¶ˆé€‰æ‹©
};
```

```python
# by chatGPT (python)
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        if n == 0:
            return []
        # è®°å½•æ‰€æœ‰åˆæ³•çš„æ‹¬å·ç»„åˆ
        res = []
        # å›æº¯è¿‡ç¨‹ä¸­çš„è·¯å¾„
        track = ""
        # å¯ç”¨çš„å·¦æ‹¬å·å’Œå³æ‹¬å·æ•°é‡åˆå§‹åŒ–ä¸º n
        self.backtrack(n, n, track, res)
        return res

    # å¯ç”¨çš„å·¦æ‹¬å·æ•°é‡ä¸º left ä¸ªï¼Œå¯ç”¨çš„å³æ‹¬å·æ•°é‡ä¸º rgiht ä¸ª
    def backtrack(self, left: int, right: int, track: str, res: List[str]) -> None:
        # è‹¥å³æ‹¬å·å‰©ä¸‹çš„å¤šï¼Œè¯´æ˜ä¸åˆæ³•
        if right < left:
            return
        # æ•°é‡å°äº 0 è‚¯å®šæ˜¯ä¸åˆæ³•çš„
        if left < 0 or right < 0:
            return
        # å½“æ‰€æœ‰æ‹¬å·éƒ½æ°å¥½ç”¨å®Œæ—¶ï¼Œå¾—åˆ°ä¸€ä¸ªåˆæ³•çš„æ‹¬å·ç»„åˆ
        if left == 0 and right == 0:
            res.append(track)
            return

        # å°è¯•æ”¾ä¸€ä¸ªå·¦æ‹¬å·
        track += '(' # é€‰æ‹©
        self.backtrack(left - 1, right, track, res)
        track = track[:-1] # æ’¤æ¶ˆé€‰æ‹©

        # å°è¯•æ”¾ä¸€ä¸ªå³æ‹¬å·
        track += ')' # é€‰æ‹©
        self.backtrack(left, right - 1, track, res)
        track = track[:-1] # æ’¤æ¶ˆé€‰æ‹©
```

https://leetcode.cn/problems/IDBivT çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/M1oyTv çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    string minWindow(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;

        int left = 0, right = 0;
        int valid = 0;
        // è®°å½•æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•åŠé•¿åº¦
        int start = 0, len = INT_MAX;
        /**<extend down -200>
        ![](../pictures/slidingwindow/1.png)
        */
        while (right < s.size()) {
            // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
            char c = s[right];
            // å³ç§»çª—å£
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c])
                    valid++;
            }

            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (valid == need.size()) {
                /**<extend down -200>
                ![](../pictures/slidingwindow/2.png)
                */
                // åœ¨è¿™é‡Œæ›´æ–°æœ€å°è¦†ç›–å­ä¸²
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
                char d = s[left];
                // å·¦ç§»çª—å£
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
            /**<extend up -50>
            ![](../pictures/slidingwindow/4.png)
            */
        }
        // è¿”å›æœ€å°è¦†ç›–å­ä¸²
        return len == INT_MAX ?
                "" : s.substr(start, len);
    }
};
```

```go
// by chatGPT (go)
func minWindow(s string, t string) string {
    need := make(map[byte]int)
    window := make(map[byte]int)
    for i := 0; i < len(t); i++ {
        need[t[i]]++
    }

    left, right, valid := 0, 0, 0 
    // è®°å½•æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•åŠé•¿åº¦
    start, len := 0, math.MaxInt32
    /**<extend down -200>
    ![](../pictures/slidingwindow/1.png)
    */
    for right < len(s) {
        // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
        c := s[right]
        // å³ç§»çª—å£
        right++
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        if _, ok := need[c]; ok {
            window[c]++
            if window[c] == need[c] {
                valid++
            }
        }

        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        for valid == len(need) {
        	/**<extend down -200>
            ![](../pictures/slidingwindow/2.png)
            */
            // åœ¨è¿™é‡Œæ›´æ–°æœ€å°è¦†ç›–å­ä¸²
            if right-left < len {
                start = left
                len = right - left
            }

            // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
            d := s[left]
            // å·¦ç§»çª—å£
            left++
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if _, ok := need[d]; ok {
                if window[d] == need[d] {
                    valid--
                }
                window[d]--
            }
        }
        /**<extend up -50>
        ![](../pictures/slidingwindow/4.png)
        */
    }
    // è¿”å›æœ€å°è¦†ç›–å­ä¸²
    if len == math.MaxInt32 {
    	return ""
    }
    return s[start : start+len]
}
```

```java
// by chatGPT (java)
class Solution {
    public String minWindow(String s, String t) {
        HashMap<Character, Integer> need = new HashMap<>();
        HashMap<Character, Integer> window = new HashMap<>();
        for (char c : t.toCharArray()) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        int left = 0, right = 0;
        int valid = 0;
        // è®°å½•æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•åŠé•¿åº¦
        int start = 0, len = Integer.MAX_VALUE;
        /**<extend down -200>
        ![](../pictures/slidingwindow/1.png)
        */
        while (right < s.length()) {
            // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
            char c = s.charAt(right);
            // å³ç§»çª—å£
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c).equals(need.get(c))) {
                    valid++;
                }
            }

            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (valid == need.size()) {
                /**<extend down -200>
                ![](../pictures/slidingwindow/2.png)
                */
                // åœ¨è¿™é‡Œæ›´æ–°æœ€å°è¦†ç›–å­ä¸²
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
                char d = s.charAt(left);
                // å·¦ç§»çª—å£
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if (need.containsKey(d)) {
                    if (window.get(d).equals(need.get(d))) {
                        valid--;
                    }
                    window.put(d, window.get(d) - 1);
                }
            }
            /**<extend up -50>
            ![](../pictures/slidingwindow/4.png)
            */
        }
        // è¿”å›æœ€å°è¦†ç›–å­ä¸²
        return len == Integer.MAX_VALUE ?
                "" : s.substring(start, start + len);
    }
}
```

```javascript
// by chatGPT (javascript)
var minWindow = function(s, t) {
    var need = new Map();
    var window = new Map();
    for (var c of t) {
        need.set(c, need.has(c) ? need.get(c) + 1 : 1);
    }

    var left = 0, right = 0;
    var valid = 0;
    // è®°å½•æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•åŠé•¿åº¦
    var start = 0, len = Number.MAX_SAFE_INTEGER;
    /**<extend down -200>
    ![](../pictures/slidingwindow/1.png)
    */
    while (right < s.length) {
        // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
        var c = s[right];
        // å³ç§»çª—å£
        right++;
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        if (need.has(c)) {
            window.set(c, window.has(c) ? window.get(c) + 1 : 1);
            if (window.get(c) === need.get(c))
                valid++;
        }

        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        while (valid === need.size) {
            /**<extend down -200>
            ![](../pictures/slidingwindow/2.png)
            */
            // åœ¨è¿™é‡Œæ›´æ–°æœ€å°è¦†ç›–å­ä¸²
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
            var d = s[left];
            // å·¦ç§»çª—å£
            left++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.has(d)) {
                if (window.get(d) === need.get(d))
                    valid--;
                window.set(d, window.get(d) - 1);
            }
        }
        /**<extend up -50>
        ![](../pictures/slidingwindow/4.png)
        */
    }
    // è¿”å›æœ€å°è¦†ç›–å­ä¸²
    return len === Number.MAX_SAFE_INTEGER ?
            "" : s.substring(start, start + len);
};
```

```python
# by chatGPT (python)
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        from collections import defaultdict
        need, window = defaultdict(int), defaultdict(int)
        for c in t:
            need[c] += 1
        
        left, right = 0, 0
        valid = 0
        # è®°å½•æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•åŠé•¿åº¦
        start, length = 0, float('inf')
        # ![](../pictures/slidingwindow/1.png)
        while right < len(s):
            # c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
            c = s[right]
            # å³ç§»çª—å£
            right += 1
            # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if c in need:
                window[c] += 1
                if window[c] == need[c]:
                    valid += 1
            
            # åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while valid == len(need):
                # ![](../pictures/slidingwindow/2.png)
                # åœ¨è¿™é‡Œæ›´æ–°æœ€å°è¦†ç›–å­ä¸²
                if right - left < length:
                    start = left
                    length = right - left
                # d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
                d = s[left]
                # å·¦ç§»çª—å£
                left += 1
                # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if d in need:
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1
            # ![](../pictures/slidingwindow/4.png)
        # è¿”å›æœ€å°è¦†ç›–å­ä¸²
        return '' if length == float('inf') else s[start:start+length]
```

https://leetcode.cn/problems/M1oyTv çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/MPnaiL çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:

    // åˆ¤æ–­ s ä¸­æ˜¯å¦å­˜åœ¨ t çš„æ’åˆ—
    bool checkInclusion(string t, string s) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;

        int left = 0, right = 0;
        int valid = 0;
        while (right < s.size()) {
            char c = s[right];
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c])
                    valid++;
            }

            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (right - left >= t.size()) {
                // åœ¨è¿™é‡Œåˆ¤æ–­æ˜¯å¦æ‰¾åˆ°äº†åˆæ³•çš„å­ä¸²
                if (valid == need.size())
                    return true;
                char d = s[left];
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        // æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å­ä¸²
        return false;
    }
};
```

```go
// by chatGPT (go)
func checkInclusion(t string, s string) bool {
    need := make(map[byte]int)
    window := make(map[byte]int)
    for i := range t {
        need[t[i]]++
    }

    left, right := 0, 0
    valid := 0
    for right < len(s) {
        c := s[right]
        right++
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        if _, ok := need[c]; ok {
            window[c]++
            if window[c] == need[c] {
                valid++
            }
        }

        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        for right-left >= len(t) {
            // åœ¨è¿™é‡Œåˆ¤æ–­æ˜¯å¦æ‰¾åˆ°äº†åˆæ³•çš„å­ä¸²
            if valid == len(need) {
                return true
            }
            d := s[left]
            left++
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if _, ok := need[d]; ok {
                if window[d] == need[d] {
                    valid--
                }
                window[d]--
            }
        }
    }
    // æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å­ä¸²
    return false
}
```

```java
// by chatGPT (java)
class Solution {
    public boolean checkInclusion(String t, String s) {
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);

        int left = 0, right = 0;
        int valid = 0;
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c).equals(need.get(c)))
                    valid++;
            }

            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (right - left >= t.length()) {
                // åœ¨è¿™é‡Œåˆ¤æ–­æ˜¯å¦æ‰¾åˆ°äº†åˆæ³•çš„å­ä¸²
                if (valid == need.size())
                    return true;
                char d = s.charAt(left);
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if (need.containsKey(d)) {
                    if (window.get(d).equals(need.get(d)))
                        valid--;
                    window.put(d, window.get(d) - 1);
                }
            }
        }
        // æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å­ä¸²
        return false;
    }
}
```

```javascript
// by chatGPT (javascript)
var checkInclusion = function(t, s) {
  const need = new Map();
  const window = new Map();
  for (let c of t) {
    need.set(c, (need.get(c) || 0) + 1);
  }

  let left = 0, right = 0;
  let valid = 0;
  while (right < s.length) {
    const c = s[right];
    right++;
    // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
    if (need.has(c)) {
      window.set(c, (window.get(c) || 0) + 1);
      if (window.get(c) === need.get(c)) {
        valid++;
      }
    }

    // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
    while (right - left >= t.length) {
      // åœ¨è¿™é‡Œåˆ¤æ–­æ˜¯å¦æ‰¾åˆ°äº†åˆæ³•çš„å­ä¸²
      if (valid === need.size) {
        return true;
      }
      const d = s[left];
      left++;
      // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
      if (need.has(d)) {
        if (window.get(d) === need.get(d)) {
          valid--;
        }
        window.set(d, (window.get(d) || 0) - 1);
      }
    }
  }
  // æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å­ä¸²
  return false;
};
```

```python
# by chatGPT (python)
class Solution:
    def checkInclusion(self, t: str, s: str) -> bool:
        need, window = {}, {}
        for c in t:
            need[c] = need.get(c, 0) + 1
        
        left, right = 0, 0
        valid = 0
        while right < len(s):
            c = s[right]
            right += 1
            # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if c in need:
                window[c] = window.get(c, 0) + 1
                if window[c] == need[c]:
                    valid += 1
            
            # åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while right - left >= len(t):
                # åœ¨è¿™é‡Œåˆ¤æ–­æ˜¯å¦æ‰¾åˆ°äº†åˆæ³•çš„å­ä¸²
                if valid == len(need):
                    return True
                d = s[left]
                left += 1
                # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if d in need:
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1
        
        # æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å­ä¸²
        return False
```

https://leetcode.cn/problems/MPnaiL çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/N6YdxV çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        return left_bound(nums, target);
    }
    
    // æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†ç®—æ³•
    int left_bound(vector<int>& nums, int target) {
        if (nums.size() == 0) return -1;
        int left = 0;
        int right = nums.size(); // æ³¨æ„
        
        while (left < right) { // æ³¨æ„
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid; // æ³¨æ„
            }
        }
        return left;
    }
};
```

```go
// by chatGPT (go)
func searchInsert(nums []int, target int) int {
    return leftBound(nums, target)
}

//æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†ç®—æ³•
func leftBound(nums []int, target int) int {
    if len(nums) == 0 {
        return -1
    }
    left, right := 0, len(nums)

    for left < right {
        mid := left + (right - left)/2
        if nums[mid] == target {
            right = mid
        } else if nums[mid] < target {
            left = mid + 1
        } else if nums[mid] > target {
            right = mid
        }
    }
    return left
}
```

```java
// by labuladong (java)
class Solution {
    public int searchInsert(int[] nums, int target) {
        return left_bound(nums, target);
    }

    // æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†ç®—æ³•
    int left_bound(int[] nums, int target) {
        if (nums.length == 0) return -1;
        int left = 0;
        int right = nums.length; // æ³¨æ„

        while (left < right) { // æ³¨æ„
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid; // æ³¨æ„
            }
        }
        return left;
    }
}
```

```javascript
// by chatGPT (javascript)
var Solution = function() {};

Solution.prototype.searchInsert = function(nums, target) {
  return this.left_bound(nums, target);
};

// æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†ç®—æ³•
Solution.prototype.left_bound = function(nums, target) {
  if (nums.length == 0) return -1;
  var left = 0;
  var right = nums.length; // æ³¨æ„

  while (left < right) { // æ³¨æ„
    var mid = left + Math.floor((right - left) / 2);
    if (nums[mid] == target) {
      right = mid;
    } else if (nums[mid] < target) {
      left = mid + 1;
    } else if (nums[mid] > target) {
      right = mid; // æ³¨æ„
    }
  }
  return left;
};
```

```python
# by chatGPT (python)
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        return self.left_bound(nums, target)
    
    # æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†ç®—æ³•
    def left_bound(self, nums: List[int], target: int) -> int:
        if len(nums) == 0:
            return -1
        left, right = 0, len(nums) # æ³¨æ„

        while left < right: # æ³¨æ„
            mid = left + (right - left) // 2
            if nums[mid] == target:
                right = mid
            elif nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid # æ³¨æ„

        return left
```

https://leetcode.cn/problems/N6YdxV çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/NUPfPr çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (int num : nums) sum += num;
        // å’Œä¸ºå¥‡æ•°æ—¶ï¼Œä¸å¯èƒ½åˆ’åˆ†æˆä¸¤ä¸ªå’Œç›¸ç­‰çš„é›†åˆ
        if (sum % 2 != 0) return false;
        int n = nums.size();
        sum = sum / 2;
        vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));
        // base case
        for (int i = 0; i <= n; i++)
            dp[i][0] = true;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= sum; j++) {
                if (j - nums[i - 1] < 0) {
                    // èƒŒåŒ…å®¹é‡ä¸è¶³ï¼Œä¸èƒ½è£…å…¥ç¬¬ i ä¸ªç‰©å“
                    dp[i][j] = dp[i - 1][j];
                } else {
                    // è£…å…¥æˆ–ä¸è£…å…¥èƒŒåŒ…
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
                }
            }
        }
        return dp[n][sum];
    }
};
```

```go
// by chatGPT (go)
func canPartition(nums []int) bool {
    sum := 0
    for _, num := range nums {
        sum += num
    }
    // å’Œä¸ºå¥‡æ•°æ—¶ï¼Œä¸å¯èƒ½åˆ’åˆ†æˆä¸¤ä¸ªå’Œç›¸ç­‰çš„é›†åˆ
    if sum%2 != 0 {
        return false
    }
    n := len(nums)
    sum = sum / 2
    dp := make([][]bool, n+1)
    for i := 0; i <= n; i++ {
        dp[i] = make([]bool, sum+1)
        // base case
        dp[i][0] = true
    }

    for i := 1; i <= n; i++ {
        for j := 1; j <= sum; j++ {
            if j-nums[i-1] < 0 {
                // èƒŒåŒ…å®¹é‡ä¸è¶³ï¼Œä¸èƒ½è£…å…¥ç¬¬ i ä¸ªç‰©å“
                dp[i][j] = dp[i-1][j]
            } else {
                // è£…å…¥æˆ–ä¸è£…å…¥èƒŒåŒ…
                dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]]
            }
        }
    }
    return dp[n][sum]
}
```

```java
// by labuladong (java)
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) sum += num;
        // å’Œä¸ºå¥‡æ•°æ—¶ï¼Œä¸å¯èƒ½åˆ’åˆ†æˆä¸¤ä¸ªå’Œç›¸ç­‰çš„é›†åˆ
        if (sum % 2 != 0) return false;
        int n = nums.length;
        sum = sum / 2;
        boolean[][] dp = new boolean[n + 1][sum + 1];
        // base case
        for (int i = 0; i <= n; i++)
            dp[i][0] = true;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= sum; j++) {
                if (j - nums[i - 1] < 0) {
                    // èƒŒåŒ…å®¹é‡ä¸è¶³ï¼Œä¸èƒ½è£…å…¥ç¬¬ i ä¸ªç‰©å“
                    dp[i][j] = dp[i - 1][j];
                } else {
                    // è£…å…¥æˆ–ä¸è£…å…¥èƒŒåŒ…
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
                }
            }
        }
        return dp[n][sum];
    }
}
```

```javascript
// by chatGPT (javascript)
var canPartition = function(nums) {
    let sum = 0;
    for (let num of nums) {
        sum += num;
    }
    // å’Œä¸ºå¥‡æ•°æ—¶ï¼Œä¸å¯èƒ½åˆ’åˆ†æˆä¸¤ä¸ªå’Œç›¸ç­‰çš„é›†åˆ
    if (sum % 2 !== 0) {
        return false;
    }
    let n = nums.length;
    sum = sum / 2;
    let dp = new Array(n + 1).fill(false).map(() => new Array(sum + 1).fill(false));
    // base case
    for (let i = 0; i <= n; i++) {
        dp[i][0] = true;
    }

    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= sum; j++) {
            if (j - nums[i - 1] < 0) {
                // èƒŒåŒ…å®¹é‡ä¸è¶³ï¼Œä¸èƒ½è£…å…¥ç¬¬ i ä¸ªç‰©å“
                dp[i][j] = dp[i - 1][j];
            } else {
                // è£…å…¥æˆ–ä¸è£…å…¥èƒŒåŒ…
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
            }
        }
    }
    return dp[n][sum];
};
```

```python
# by chatGPT (python)
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sum = 0
        for num in nums:
            sum += num
        # å’Œä¸ºå¥‡æ•°æ—¶ï¼Œä¸å¯èƒ½åˆ’åˆ†æˆä¸¤ä¸ªå’Œç›¸ç­‰çš„é›†åˆ
        if sum % 2 != 0:
            return False
        n = len(nums)
        sum = sum // 2
        dp = [[False] * (sum + 1) for _ in range(n + 1)]
        # base case
        for i in range(n + 1):
            dp[i][0] = True

        for i in range(1, n + 1):
            for j in range(1, sum + 1):
                if j - nums[i - 1] < 0:
                    # èƒŒåŒ…å®¹é‡ä¸è¶³ï¼Œä¸èƒ½è£…å…¥ç¬¬ i ä¸ªç‰©å“
                    dp[i][j] = dp[i - 1][j]
                else:
                    # è£…å…¥æˆ–ä¸è£…å…¥èƒŒåŒ…
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]
        return dp[n][sum]
```

https://leetcode.cn/problems/NUPfPr çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/O4NDxx çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class NumMatrix {
private:
    // preSum[i][j] è®°å½•çŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
    vector<vector<int>> preSum;

public:
    NumMatrix(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        if (m == 0 || n == 0) return;
        // æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
        preSum = vector<vector<int>>(m + 1, vector<int>(n + 1, 0));
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];
            }
        }
    }

    // è®¡ç®—å­çŸ©é˜µ [x1, y1, x2, y2] çš„å…ƒç´ å’Œ
    int sumRegion(int x1, int y1, int x2, int y2) {
        // ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
        return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];
    }
};
```

```go
// by chatGPT (go)
type NumMatrix struct {
    // preSum[i][j] è®°å½•çŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
    preSum [][]int
}

func Constructor(matrix [][]int) NumMatrix {
    m, n := len(matrix), len(matrix[0])
    if m == 0 || n == 0 {
        return NumMatrix{}
    }
    // æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
    preSum := make([][]int, m+1)
    for i := range preSum {
        preSum[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            // è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
            preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i-1][j-1] - preSum[i-1][j-1]
        }
    }
    return NumMatrix{preSum}
}

// è®¡ç®—å­çŸ©é˜µ [x1, y1, x2, y2] çš„å…ƒç´ å’Œ
func (this *NumMatrix) SumRegion(x1 int, y1 int, x2 int, y2 int) int {
    // ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
    return this.preSum[x2+1][y2+1] - this.preSum[x1][y2+1] - this.preSum[x2+1][y1] + this.preSum[x1][y1]
}
```

```java
// by labuladong (java)
class NumMatrix {
    // preSum[i][j] è®°å½•çŸ©é˜µ [0, 0, i-1, j-1] çš„å…ƒç´ å’Œ
    private int[][] preSum;

    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        if (m == 0 || n == 0) return;
        // æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
        preSum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];
            }
        }
    }

    // è®¡ç®—å­çŸ©é˜µ [x1, y1, x2, y2] çš„å…ƒç´ å’Œ
    public int sumRegion(int x1, int y1, int x2, int y2) {
        // ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
        return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];
    }
}
```

```javascript
// by chatGPT (javascript)
var NumMatrix = function(matrix) {
    // preSum[i][j] è®°å½•çŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
    var preSum;

    var m = matrix.length, n = matrix[0].length;
    if (m == 0 || n == 0) return;
    // æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
    preSum = new Array(m + 1);
    for (var i = 0; i <= m; i++) {
        preSum[i] = new Array(n + 1).fill(0);
    }
    for (var i = 1; i <= m; i++) {
        for (var j = 1; j <= n; j++) {
            // è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
            preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];
        }
    }

    // è®¡ç®—å­çŸ©é˜µ [x1, y1, x2, y2] çš„å…ƒç´ å’Œ
    this.sumRegion = function(x1, y1, x2, y2) {
        // ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
        return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];
    }
};
```

```python
# by chatGPT (python)
class NumMatrix:
    def __init__(self, matrix: List[List[int]]):
        m, n = len(matrix), len(matrix[0])
        if m == 0 or n == 0:
            return
        # æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
        self.preSum = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
                self.preSum[i][j] = self.preSum[i - 1][j] + self.preSum[i][j - 1] + matrix[i - 1][j - 1] - self.preSum[i - 1][j - 1]

    # è®¡ç®—å­çŸ©é˜µ [x1, y1, x2, y2] çš„å…ƒç´ å’Œ
    def sumRegion(self, x1: int, y1: int, x2: int, y2: int) -> int:
        # ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
        return self.preSum[x2 + 1][y2 + 1] - self.preSum[x1][y2 + 1] - self.preSum[x2 + 1][y1] + self.preSum[x1][y1]
```

https://leetcode.cn/problems/O4NDxx çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/OrIXps çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class LRUCache {
    int cap;
    unordered_map<int, int> cache;
    list<int> keys;

public:
    LRUCache(int capacity) {
        this->cap = capacity;
    }

    int get(int key) {
        auto it = cache.find(key);
        if (it == cache.end()) {
            return -1;
        }
        // å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
        makeRecently(key);
        return it->second;
    }

    void put(int key, int val) {
        auto it = cache.find(key);
        if (it != cache.end()) {
            // ä¿®æ”¹ key çš„å€¼
            it->second = val;
            // å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
            makeRecently(key);
            return;
        }

        if (cache.size() >= this->cap) {
            // é“¾è¡¨å¤´éƒ¨å°±æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ key
            int oldestKey = keys.front();
            keys.pop_front();
            cache.erase(oldestKey);
        }
        // å°†æ–°çš„ key æ·»åŠ é“¾è¡¨å°¾éƒ¨
        keys.push_back(key);
        cache[key] = val;
    }

private:
    void makeRecently(int key) {
        int val = cache[key];
        // åˆ é™¤ keyï¼Œé‡æ–°æ’å…¥åˆ°é˜Ÿå°¾
        keys.remove(key);
        keys.push_back(key);
        cache[key] = val;
    }
};
```

```go
// by chatGPT (go)
type LRUCache struct {
    cap  int
    cache map[int]int
}

// Constructor åˆ›å»ºä¸€ä¸ª LRU Cache å®ä¾‹
func Constructor(capacity int) LRUCache {
    return LRUCache{
        cap:  capacity,
        cache: make(map[int]int),
    }
}

// Get è·å–ä¸€ä¸ª key çš„å€¼
func (this *LRUCache) Get(key int) int {
    if val, ok := this.cache[key]; ok {
        this.makeRecently(key)
        return val
    }
    return -1
}

// Put æ’å…¥ä¸€ä¸ª key/value
func (this *LRUCache) Put(key int, value int) {
    if _, ok := this.cache[key]; ok {
        this.cache[key] = value
        this.makeRecently(key)
        return
    }
    if len(this.cache) >= this.cap {
        this.removeLeastRecently()
    }
    this.cache[key] = value
}

// makeRecently å°†ä¸€ä¸ªå…ƒç´ æ ‡è®°ä¸ºæœ€è¿‘ä½¿ç”¨çš„
func (this *LRUCache) makeRecently(key int) {
    val := this.cache[key]
    delete(this.cache, key)
    this.cache[key] = val
}

// removeLeastRecently ç§»é™¤æœ€è¿‘æœªä½¿ç”¨çš„å…ƒç´ 
func (this *LRUCache) removeLeastRecently() {
    for k := range this.cache {
        delete(this.cache, k)
        break
    }
}
```

```java
// by labuladong (java)
class LRUCache {
    int cap;
    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();
    public LRUCache(int capacity) {
        this.cap = capacity;
    }

    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        // å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
        makeRecently(key);
        return cache.get(key);
    }

    public void put(int key, int val) {
        if (cache.containsKey(key)) {
            // ä¿®æ”¹ key çš„å€¼
            cache.put(key, val);
            // å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
            makeRecently(key);
            return;
        }

        if (cache.size() >= this.cap) {
            // é“¾è¡¨å¤´éƒ¨å°±æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ key
            int oldestKey = cache.keySet().iterator().next();
            cache.remove(oldestKey);
        }
        // å°†æ–°çš„ key æ·»åŠ é“¾è¡¨å°¾éƒ¨
        cache.put(key, val);
    }

    private void makeRecently(int key) {
        int val = cache.get(key);
        // åˆ é™¤ keyï¼Œé‡æ–°æ’å…¥åˆ°é˜Ÿå°¾
        cache.remove(key);
        cache.put(key, val);
    }
}
```

```javascript
// by chatGPT (javascript)
var LRUCache = function(capacity) {
  this.cap = capacity;
  this.cache = new Map();
};

LRUCache.prototype.get = function(key) {
  if (!this.cache.has(key)) {
    return -1;
  }
  // å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
  this.makeRecently(key);
  return this.cache.get(key);
};

LRUCache.prototype.put = function(key, val) {
  if (this.cache.has(key)) {
    // ä¿®æ”¹ key çš„å€¼
    this.cache.set(key, val);
    // å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
    this.makeRecently(key);
    return;
  }

  if (this.cache.size >= this.cap) {
    // é“¾è¡¨å¤´éƒ¨å°±æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ key
    const oldestKey = this.cache.keys().next().value;
    this.cache.delete(oldestKey);
  }
  // å°†æ–°çš„ key æ·»åŠ é“¾è¡¨å°¾éƒ¨
  this.cache.set(key, val);
};

LRUCache.prototype.makeRecently = function(key) {
  const val = this.cache.get(key);
  // åˆ é™¤ keyï¼Œé‡æ–°æ’å…¥åˆ°é˜Ÿå°¾
  this.cache.delete(key);
  this.cache.set(key, val);
};
```

```python
# by chatGPT (python)
class LRUCache:
    def __init__(self, capacity: int):
        self.cap = capacity
        self.cache = {}

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        # å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
        self.makeRecently(key)
        return self.cache[key]

    def put(self, key: int, val: int) -> None:
        if key in self.cache:
            # ä¿®æ”¹ key çš„å€¼
            self.cache[key] = val
            # å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
            self.makeRecently(key)
            return

        if len(self.cache) >= self.cap:
            # é“¾è¡¨å¤´éƒ¨å°±æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ key
            oldest_key = next(iter(self.cache))
            self.cache.pop(oldest_key)

        # å°†æ–°çš„ key æ·»åŠ é“¾è¡¨å°¾éƒ¨
        self.cache[key] = val

    def makeRecently(self, key: int) -> None:
        val = self.cache[key]
        # åˆ é™¤ keyï¼Œé‡æ–°æ’å…¥åˆ°é˜Ÿå°¾
        del self.cache[key]
        self.cache[key] = val
```

https://leetcode.cn/problems/OrIXps çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/PzWKhm çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];

        vector<int> memo1(n, -1);
        vector<int> memo2(n, -1);
        // ä¸¤æ¬¡è°ƒç”¨ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„å¤‡å¿˜å½•
        return max(
            dp(nums, 0, n - 2, memo1),
            dp(nums, 1, n - 1, memo2)
        );
    }

    // å®šä¹‰ï¼šè®¡ç®—é—­åŒºé—´ [start,end] çš„æœ€ä¼˜ç»“æœ
    int dp(vector<int>& nums, int start, int end, vector<int>& memo) {
        if (start > end) {
            return 0;
        }

        if (memo[start] != -1) {
            return memo[start];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        int res = max(
            dp(nums, start + 2, end, memo) + nums[start],
            dp(nums, start + 1, end, memo)
        );

        memo[start] = res;
        return res;
    }
};
```

```go
// by chatGPT (go)
import "fmt"

func rob(nums []int) int {
    n := len(nums)
    if n == 1 {
        return nums[0]
    }

    memo1 := make([]int, n)
    memo2 := make([]int, n)
    for i := range memo1 {
        memo1[i] = -1
        memo2[i] = -1
    }
    // ä¸¤æ¬¡è°ƒç”¨ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„å¤‡å¿˜å½•
    return max(dp(nums, 0, n - 2, memo1), dp(nums, 1, n - 1, memo2))
}

// å®šä¹‰ï¼šè®¡ç®—é—­åŒºé—´ [start,end] çš„æœ€ä¼˜ç»“æœ
func dp(nums []int, start, end int, memo []int) int {
    if start > end {
        return 0
    }

    if memo[start] != -1 {
        return memo[start]
    }
    // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
    res := max(dp(nums, start + 2, end, memo) + nums[start], dp(nums, start + 1, end, memo))

    memo[start] = res
    return res
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {

    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];

        int[] memo1 = new int[n];
        int[] memo2 = new int[n];
        Arrays.fill(memo1, -1);
        Arrays.fill(memo2, -1);
        // ä¸¤æ¬¡è°ƒç”¨ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„å¤‡å¿˜å½•
        return Math.max(
                dp(nums, 0, n - 2, memo1),
                dp(nums, 1, n - 1, memo2)
        );
    }

    // å®šä¹‰ï¼šè®¡ç®—é—­åŒºé—´ [start,end] çš„æœ€ä¼˜ç»“æœ
    int dp(int[] nums, int start, int end, int[] memo) {
        if (start > end) {
            return 0;
        }

        if (memo[start] != -1) {
            return memo[start];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        int res = Math.max(
                dp(nums, start + 2, end, memo) + nums[start],
                dp(nums, start + 1, end, memo)
        );

        memo[start] = res;
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var rob = function(nums) {
    const n = nums.length;
    if (n === 1) return nums[0];

    const memo1 = new Array(n).fill(-1);
    const memo2 = new Array(n).fill(-1);
    // ä¸¤æ¬¡è°ƒç”¨ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„å¤‡å¿˜å½•
    return Math.max(
        dp(nums, 0, n - 2, memo1),
        dp(nums, 1, n - 1, memo2)
    );
};

// å®šä¹‰ï¼šè®¡ç®—é—­åŒºé—´ [start,end] çš„æœ€ä¼˜ç»“æœ
function dp(nums, start, end, memo) {
    if (start > end) {
        return 0;
    }

    if (memo[start] !== -1) {
        return memo[start];
    }
    // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
    const res = Math.max(
        dp(nums, start + 2, end, memo) + nums[start],
        dp(nums, start + 1, end, memo)
    );

    memo[start] = res;
    return res;
}
```

```python
# by chatGPT (python)
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return nums[0]
        memo1 = [-1]*n
        memo2 = [-1]*n
        # ä¸¤æ¬¡è°ƒç”¨ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„å¤‡å¿˜å½•
        return max(
            self.dp(nums, 0, n-2, memo1),
            self.dp(nums, 1, n-1, memo2)
        )

    # å®šä¹‰ï¼šè®¡ç®—é—­åŒºé—´ [start,end] çš„æœ€ä¼˜ç»“æœ
    def dp(self, nums: List[int], start: int, end: int, memo: List[int]) -> int:
        if start > end:
            return 0
        if memo[start] != -1:
            return memo[start]
        # çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        res = max(
            self.dp(nums, start+2, end, memo) + nums[start],
            self.dp(nums, start+1, end, memo)
        )
        memo[start] = res
        return res
```

https://leetcode.cn/problems/PzWKhm çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/QA2IGt çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        // å»ºå›¾ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        vector<vector<int>> graph(numCourses);
        for (auto& edge : prerequisites) {
            int from = edge[1], to = edge[0];
            graph[from].push_back(to);
        }
        // è®¡ç®—å…¥åº¦ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        vector<int> indegree(numCourses);
        for (auto& edge : prerequisites) {
            int from = edge[1], to = edge[0];
            indegree[to]++;
        }

        // æ ¹æ®å…¥åº¦åˆå§‹åŒ–é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        queue<int> q;
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) {
                q.push(i);
            }
        }

        // è®°å½•æ‹“æ‰‘æ’åºç»“æœ
        vector<int> res(numCourses);
        // è®°å½•éå†èŠ‚ç‚¹çš„é¡ºåºï¼ˆç´¢å¼•ï¼‰
        int count = 0;
        // å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            // å¼¹å‡ºèŠ‚ç‚¹çš„é¡ºåºå³ä¸ºæ‹“æ‰‘æ’åºç»“æœ
            res[count] = cur;
            count++;
            for (int next : graph[cur]) {
                indegree[next]--;
                if (indegree[next] == 0) {
                    q.push(next);
                }
            }
        }

        if (count != numCourses) {
            // å­˜åœ¨ç¯ï¼Œæ‹“æ‰‘æ’åºä¸å­˜åœ¨
            return {};
        }
        
        return res;
    }
};
```

```go
// by chatGPT (go)
// ä¸»å‡½æ•°
func findOrder(numCourses int, prerequisites [][]int) []int {
    // å»ºå›¾ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
    graph := buildGraph(numCourses, prerequisites)
    // è®¡ç®—å…¥åº¦ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
    indegree := make([]int, numCourses)
    for _, edge := range prerequisites {
        _, to := edge[1], edge[0]
        indegree[to]++
    }

    // æ ¹æ®å…¥åº¦åˆå§‹åŒ–é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
    q := make([]int, 0)
    for i := 0; i < numCourses; i++ {
        if indegree[i] == 0 {
            q = append(q, i)
        }
    }

    // è®°å½•æ‹“æ‰‘æ’åºç»“æœ
    res := make([]int, numCourses)
    // è®°å½•éå†èŠ‚ç‚¹çš„é¡ºåºï¼ˆç´¢å¼•ï¼‰
    count := 0
    // å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•
    for len(q) > 0 {
        cur := q[0]
        q = q[1:]
        // å¼¹å‡ºèŠ‚ç‚¹çš„é¡ºåºå³ä¸ºæ‹“æ‰‘æ’åºç»“æœ
        res[count] = cur
        count++
        for _, next := range graph[cur] {
            indegree[next]--
            if indegree[next] == 0 {
                q = append(q, next)
            }
        }
    }

    if count != numCourses {
        // å­˜åœ¨ç¯ï¼Œæ‹“æ‰‘æ’åºä¸å­˜åœ¨
        return []int{}
    }

    return res
}

// å»ºå›¾å‡½æ•°
func buildGraph(numCourses int, prerequisites [][]int) [] []int {
    // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
    graph := make([][]int, numCourses)
    for i := 0; i < numCourses; i++ {
        graph[i] = make([]int, 0)
    }
    for _, edge := range prerequisites {
        from, to := edge[1], edge[0]
        // ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
        // åœ¨å›¾ä¸­æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
        graph[from] = append(graph[from], to)
    }
    return graph
}
```

```java
// by labuladong (java)
class Solution {
    // ä¸»å‡½æ•°
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // å»ºå›¾ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
        // è®¡ç®—å…¥åº¦ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        int[] indegree = new int[numCourses];
        for (int[] edge : prerequisites) {
            int from = edge[1], to = edge[0];
            indegree[to]++;
        }

        // æ ¹æ®å…¥åº¦åˆå§‹åŒ–é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) {
                q.offer(i);
                /**<extend up -200>
                ![](../pictures/æ‹“æ‰‘æ’åº/6.jpeg)
                */
            }
        }

        // è®°å½•æ‹“æ‰‘æ’åºç»“æœ
        int[] res = new int[numCourses];
        // è®°å½•éå†èŠ‚ç‚¹çš„é¡ºåºï¼ˆç´¢å¼•ï¼‰
        int count = 0;
        // å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•
        while (!q.isEmpty()) {
            int cur = q.poll();
            // å¼¹å‡ºèŠ‚ç‚¹çš„é¡ºåºå³ä¸ºæ‹“æ‰‘æ’åºç»“æœ
            res[count] = cur;
            count++;
            for (int next : graph[cur]) {
                /**<extend up -200>
                ![](../pictures/æ‹“æ‰‘æ’åº/7.jpeg)
                */
                indegree[next]--;
                if (indegree[next] == 0) {
                    q.offer(next);
                }
            }
        }

        if (count != numCourses) {
            // å­˜åœ¨ç¯ï¼Œæ‹“æ‰‘æ’åºä¸å­˜åœ¨
            return new int[]{};
        }
        
        return res;
    }

    // å»ºå›¾å‡½æ•°
    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
        List<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : prerequisites) {
            int from = edge[1], to = edge[0];
            // ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
            // åœ¨å›¾ä¸­æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
            graph[from].add(to);
        }
        return graph;
    }
}
```

```javascript
// by chatGPT (javascript)
var findOrder = function(numCourses, prerequisites) {
    // å»ºå›¾ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
    const graph = buildGraph(numCourses, prerequisites);
    // è®¡ç®—å…¥åº¦ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
    const indegree = new Array(numCourses).fill(0);
    for (const [from, to] of prerequisites) {
        indegree[to]++;
    }

    // æ ¹æ®å…¥åº¦åˆå§‹åŒ–é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
    const q = [];
    for (let i = 0; i < numCourses; i++) {
        if (indegree[i] === 0) {
            q.push(i);
            /**<extend up -200>
            ![](../pictures/æ‹“æ‰‘æ’åº/6.jpeg)
            */
        }
    }

    // è®°å½•æ‹“æ‰‘æ’åºç»“æœ
    const res = new Array(numCourses);
    // è®°å½•éå†èŠ‚ç‚¹çš„é¡ºåºï¼ˆç´¢å¼•ï¼‰
    let count = 0;
    // å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•
    while (q.length > 0) {
        const cur = q.shift();
        // å¼¹å‡ºèŠ‚ç‚¹çš„é¡ºåºå³ä¸ºæ‹“æ‰‘æ’åºç»“æœ
        res[count] = cur;
        count++;
        for (const next of graph[cur]) {
            /**<extend up -200>
            ![](../pictures/æ‹“æ‰‘æ’åº/7.jpeg)
            */
            indegree[next]--;
            if (indegree[next] === 0) {
                q.push(next);
            }
        }
    }

    if (count !== numCourses) {
        // å­˜åœ¨ç¯ï¼Œæ‹“æ‰‘æ’åºä¸å­˜åœ¨
        return [];
    }

    return res;
};

// å»ºå›¾å‡½æ•°
function buildGraph(numCourses, prerequisites) {
    // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
    const graph = new Array(numCourses).map(() => []);
    for (const [from, to] of prerequisites) {
        // ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
        // åœ¨å›¾ä¸­æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
        graph[from].push(to);
    }
    return graph;
}
```

```python
# by chatGPT (python)
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        # å»ºå›¾ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        graph = self.buildGraph(numCourses, prerequisites)
        # è®¡ç®—å…¥åº¦ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        indegree = [0] * numCourses
        for edge in prerequisites:
            from_, to = edge[1], edge[0]
            indegree[to] += 1

        # æ ¹æ®å…¥åº¦åˆå§‹åŒ–é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        q = collections.deque()
        for i in range(numCourses):
            if indegree[i] == 0:
                q.append(i)

        # è®°å½•æ‹“æ‰‘æ’åºç»“æœ
        res = [0] * numCourses
        # è®°å½•éå†èŠ‚ç‚¹çš„é¡ºåºï¼ˆç´¢å¼•ï¼‰
        count = 0
        # å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•
        while q:
            cur = q.popleft()
            # å¼¹å‡ºèŠ‚ç‚¹çš„é¡ºåºå³ä¸ºæ‹“æ‰‘æ’åºç»“æœ
            res[count] = cur
            count += 1
            for next_ in graph[cur]:
                indegree[next_] -= 1
                if indegree[next_] == 0:
                    q.append(next_)

        if count != numCourses:
            # å­˜åœ¨ç¯ï¼Œæ‹“æ‰‘æ’åºä¸å­˜åœ¨
            return []

        return res

    # å»ºå›¾å‡½æ•°
    def buildGraph(self, numCourses: int, prerequisites: List[List[int]]) -> List[List[int]]:
        # å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
        graph = [[] for _ in range(numCourses)]
        for edge in prerequisites:
            from_, to = edge[1], edge[0]
            # ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
            # åœ¨å›¾ä¸­æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
            graph[from_].append(to)
        return graph
```

https://leetcode.cn/problems/QA2IGt çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/SLwz0R çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // ä¸»å‡½æ•°
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        // åˆ é™¤å€’æ•°ç¬¬ n ä¸ªï¼Œè¦å…ˆæ‰¾å€’æ•°ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
        ListNode* x = findFromEnd(dummy, n + 1);
        // åˆ æ‰å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
        x->next = x->next->next;
        return dummy->next;
    }

    // è¿”å›é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
    ListNode* findFromEnd(ListNode* head, int k) {
        ListNode* p1 = head;
        // p1 å…ˆèµ° k æ­¥
        for (int i = 0; i < k; i++) {
            p1 = p1->next;
        }
        ListNode* p2 = head;
        // p1 å’Œ p2 åŒæ—¶èµ° n - k æ­¥
        while (p1 != nullptr) {
            p2 = p2->next;
            p1 = p1->next;
        }
        // p2 ç°åœ¨æŒ‡å‘ç¬¬ n - k ä¸ªèŠ‚ç‚¹
        return p2;
    }
};
```

```go
// by chatGPT (go)
// removeNthFromEnd ä¸»å‡½æ•°
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    dummy := &ListNode{-1, head}
    // åˆ é™¤å€’æ•°ç¬¬ n ä¸ªï¼Œè¦å…ˆæ‰¾å€’æ•°ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
    x := findFromEnd(dummy, n + 1)
    // åˆ æ‰å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
    x.Next = x.Next.Next
    return dummy.Next
}

// findFromEnd è¿”å›é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
func findFromEnd(head *ListNode, k int) *ListNode {
    p1 := head
    // p1 å…ˆèµ° k æ­¥
    for i := 0; i < k; i++ {
        p1 = p1.Next
    }
    p2 := head
    // p1 å’Œ p2 åŒæ—¶èµ° n - k æ­¥
    for p1 != nil {
        p2 = p2.Next
        p1 = p1.Next
    }
    // p2 ç°åœ¨æŒ‡å‘ç¬¬ n - k ä¸ªèŠ‚ç‚¹
    return p2
}
```

```java
// by labuladong (java)
class Solution {
    // ä¸»å‡½æ•°
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        // åˆ é™¤å€’æ•°ç¬¬ n ä¸ªï¼Œè¦å…ˆæ‰¾å€’æ•°ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
        ListNode x = findFromEnd(dummy, n + 1);
        // åˆ æ‰å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
        x.next = x.next.next;
        return dummy.next;
    }

    // è¿”å›é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
    ListNode findFromEnd(ListNode head, int k) {
        ListNode p1 = head;
        // p1 å…ˆèµ° k æ­¥
        for (int i = 0; i < k; i++) {
            p1 = p1.next;
        }
        ListNode p2 = head;
        // p1 å’Œ p2 åŒæ—¶èµ° n - k æ­¥
        while (p1 != null) {
            p2 = p2.next;
            p1 = p1.next;
        }
        // p2 ç°åœ¨æŒ‡å‘ç¬¬ n - k ä¸ªèŠ‚ç‚¹
        return p2;
    }
}
```

```javascript
// by chatGPT (javascript)
var removeNthFromEnd = function(head, n) {
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    var dummy = new ListNode(-1);
    dummy.next = head;
    // åˆ é™¤å€’æ•°ç¬¬ n ä¸ªï¼Œè¦å…ˆæ‰¾å€’æ•°ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
    var x = findFromEnd(dummy, n + 1);
    // åˆ æ‰å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
    x.next = x.next.next;
    return dummy.next;
};

// è¿”å›é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
var findFromEnd = function(head, k) {
    var p1 = head;
    // p1 å…ˆèµ° k æ­¥
    for (var i = 0; i < k; i++) {
        p1 = p1.next;
    }
    var p2 = head;
    // p1 å’Œ p2 åŒæ—¶èµ° n - k æ­¥
    while (p1 != null) {
        p2 = p2.next;
        p1 = p1.next;
    }
    // p2 ç°åœ¨æŒ‡å‘ç¬¬ n - k ä¸ªèŠ‚ç‚¹
    return p2;
};
```

```python
# by chatGPT (python)
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        # è™šæ‹Ÿå¤´ç»“ç‚¹
        dummy = ListNode(-1)
        dummy.next = head
        # åˆ é™¤å€’æ•°ç¬¬ n ä¸ªï¼Œè¦å…ˆæ‰¾å€’æ•°ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
        x = self.findFromEnd(dummy, n + 1)
        # åˆ æ‰å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
        x.next = x.next.next
        return dummy.next

    # è¿”å›é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
    def findFromEnd(self, head: ListNode, k: int) -> ListNode:
        p1 = head
        # p1 å…ˆèµ° k æ­¥
        for i in range(k):
            p1 = p1.next
        p2 = head
        # p1 å’Œ p2 åŒæ—¶èµ° n - k æ­¥
        while p1:
            p2 = p2.next
            p1 = p1.next
        # p2 ç°åœ¨æŒ‡å‘ç¬¬ n - k ä¸ªèŠ‚ç‚¹
        return p2
```

https://leetcode.cn/problems/SLwz0R çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/SsGoHC çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        // æŒ‰åŒºé—´çš„ start å‡åºæ’åˆ—
        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b) {
            return a[0] < b[0];
        });

        res.push_back(intervals[0]);
        for (int i = 1; i < intervals.size(); i++) {
            vector<int>& curr = intervals[i];
            // res ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨
            vector<int>& last = res.back();
            if (curr[0] <= last[1]) {
                last[1] = max(last[1], curr[1]);
            } else {
                // å¤„ç†ä¸‹ä¸€ä¸ªå¾…åˆå¹¶åŒºé—´
                res.push_back(curr);
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func merge(intervals [][]int) [][]int {
    res := [][]int{}
    // æŒ‰åŒºé—´çš„ start å‡åºæ’åˆ—
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    res = append(res, intervals[0])
    for i := 1; i < len(intervals); i++ {
        curr := intervals[i]
        // res ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨
        last := res[len(res)-1]
        if curr[0] <= last[1] {
            last[1] = max(last[1], curr[1])
        } else {
            // å¤„ç†ä¸‹ä¸€ä¸ªå¾…åˆå¹¶åŒºé—´
            res = append(res, curr)
        }
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int[][] merge(int[][] intervals) {
        LinkedList<int[]> res = new LinkedList<>();
        // æŒ‰åŒºé—´çš„ start å‡åºæ’åˆ—
        Arrays.sort(intervals, (a, b) -> {
            return a[0] - b[0];
        });

        res.add(intervals[0]);
        for (int i = 1; i < intervals.length; i++) {
            int[] curr = intervals[i];
            // res ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨
            int[] last = res.getLast();
            if (curr[0] <= last[1]) {
                last[1] = Math.max(last[1], curr[1]);
            } else {
                // å¤„ç†ä¸‹ä¸€ä¸ªå¾…åˆå¹¶åŒºé—´
                res.add(curr);
            }
        }
        return res.toArray(new int[0][0]);
    }
}
```

```javascript
// by chatGPT (javascript)
var merge = function(intervals) {
    let res = [];
    // æŒ‰åŒºé—´çš„ start å‡åºæ’åˆ—
    intervals.sort((a, b) => {
        return a[0] - b[0];
    });

    res.push(intervals[0]);
    for (let i = 1; i < intervals.length; i++) {
        let curr = intervals[i];
        // res ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨
        let last = res[res.length - 1];
        if (curr[0] <= last[1]) {
            last[1] = Math.max(last[1], curr[1]);
        } else {
            // å¤„ç†ä¸‹ä¸€ä¸ªå¾…åˆå¹¶åŒºé—´
            res.push(curr);
        }
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        res = []
        # æŒ‰åŒºé—´çš„ start å‡åºæ’åˆ—
        intervals.sort(key=lambda x: x[0])
        res.append(intervals[0])
        for curr in intervals[1:]:
            # res ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨
            last = res[-1]
            if curr[0] <= last[1]:
                last[1] = max(last[1], curr[1])
            else:
                # å¤„ç†ä¸‹ä¸€ä¸ªå¾…åˆå¹¶åŒºé—´
                res.append(curr)
        return res
```

https://leetcode.cn/problems/SsGoHC çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/TVdhkn çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    vector<vector<int>> res;
    vector<vector<int>> subsets(vector<int>& nums) {
        // è®°å½•èµ°è¿‡çš„è·¯å¾„
        vector<int> track;
        backtrack(nums, 0, track);
        return res;
    }

    void backtrack(vector<int>& nums, int start, vector<int>& track) {
        res.push_back(track);
        for (int i = start; i < nums.size(); i++) {
            // åšé€‰æ‹©
            track.push_back(nums[i]);
            // å›æº¯
            backtrack(nums, i + 1, track);
            // æ’¤é”€é€‰æ‹©
            track.pop_back();
        }
    }
};
```

```go
// by chatGPT (go)
// LeetCode Solution for Subsets
func subsets(nums []int) [][]int {
    var res [][]int
    backtrack := func(nums []int, start int, track []int) {
        tmp := make([]int, len(track))
        copy(tmp, track)
        res = append(res, tmp)
        for i := start; i < len(nums); i++ {
            // åšé€‰æ‹©
            track = append(track, nums[i])
            // å›æº¯
            backtrack(nums, i+1, track)
            // æ’¤é”€é€‰æ‹©
            track = track[:len(track)-1]
        }
    }
    backtrack(nums, 0, []int{})
    return res
}
```

```java
// by chatGPT (java)
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    
    public List<List<Integer>> subsets(int[] nums) {
        List<Integer> track = new ArrayList<>();
        backtrack(nums, 0, track);
        return res;
    }
    
    private void backtrack(int[] nums, int start, List<Integer> track) {
        res.add(new ArrayList<>(track));
        for (int i = start; i < nums.length; i++) {
            // åšé€‰æ‹©
            track.add(nums[i]);
            // å›æº¯
            backtrack(nums, i + 1, track);
            // æ’¤é”€é€‰æ‹©
            track.remove(track.size() - 1);
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var subsets = function(nums) {
    // è®°å½•èµ°è¿‡çš„è·¯å¾„
    var res = [];
    var backtrack = function(nums, start, track) {
        res.push(track.slice()); // æ·»åŠ è·¯å¾„çš„æ‹·è´
        for (var i = start; i < nums.length; i++) {
            // åšé€‰æ‹©
            track.push(nums[i]);
            // å›æº¯
            backtrack(nums, i + 1, track);
            // æ’¤é”€é€‰æ‹©
            track.pop();
        }
    }
    var track = [];
    backtrack(nums, 0, track);
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.res = []
    
    def subsets(self, nums: List[int]) -> List[List[int]]:
        # è®°å½•èµ°è¿‡çš„è·¯å¾„
        track = []
        self.backtrack(nums, 0, track)
        return self.res

    def backtrack(self, nums: List[int], start: int, track: List[int]) -> None:
        self.res.append(track[:])
        for i in range(start, len(nums)):
            # åšé€‰æ‹©
            track.append(nums[i])
            # å›æº¯
            self.backtrack(nums, i + 1, track)
            # æ’¤é”€é€‰æ‹©
            track.pop()
```

https://leetcode.cn/problems/TVdhkn çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/UHnkqh çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        ListNode* last = reverseList(head->next);
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/3.jpg)
        */
        head->next->next = head;
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/4.jpg)
        */
        head->next = nullptr;
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/5.jpg)
        */
        return last;
    }
};
```

```go
// by chatGPT (go)
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    // å“‘èŠ‚ç‚¹ï¼Œæ–¹ä¾¿å¤„ç†åˆ é™¤å¤´èŠ‚ç‚¹çš„æƒ…å†µ
    dummy := &ListNode{Val: 0, Next: head}

    // å¿«æŒ‡é’ˆå…ˆèµ° n æ­¥
    fast := head
    for i := 0; i < n; i++ {
        fast = fast.Next
    }

    // æ…¢æŒ‡é’ˆå’Œå¿«æŒ‡é’ˆä¸€èµ·èµ°ï¼Œç›´åˆ°å¿«æŒ‡é’ˆåˆ°è¾¾é“¾è¡¨å°¾éƒ¨
    slow := dummy
    for fast != nil {
        slow = slow.Next
        fast = fast.Next
    }

    // åˆ é™¤å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
    slow.Next = slow.Next.Next

    // è¿”å›å¤´èŠ‚ç‚¹
    return dummy.Next
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode last = reverseList(head.next);
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/3.jpg)
        */
        head.next.next = head;
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/4.jpg)
        */
        head.next = null;
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/5.jpg)
        */
        return last;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„ æœ€é•¿å­ä¸² çš„é•¿åº¦ã€‚
 *
 * ç¤ºä¾‹ 1:
 *
 * è¾“å…¥: "abcabcbb"
 * è¾“å‡º: 3
 * è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ "abc"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚
 *
 * ç¤ºä¾‹ 2:
 *
 * è¾“å…¥: "bbbbb"
 * è¾“å‡º: 1
 * è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ "b"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 1ã€‚
 *
 * ç¤ºä¾‹ 3:
 *
 * è¾“å…¥: "pwwkew"
 * è¾“å‡º: 3
 * è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ "wke"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚
 *      è¯·æ³¨æ„ï¼Œä½ çš„ç­”æ¡ˆå¿…é¡»æ˜¯ å­ä¸² çš„é•¿åº¦ï¼Œ"pwke" æ˜¯ä¸€ä¸ªå­åºåˆ—ï¼Œä¸æ˜¯å­ä¸²ã€‚
 */

var lengthOfLongestSubstring = function(s) {
    let n = s.length, ans = 0;
    let index = new Map(); // å­˜å‚¨å­—ç¬¦ä¸Šä¸€æ¬¡å‡ºç°çš„ä½ç½®
    // iä¸ºå·¦æŒ‡é’ˆï¼Œjä¸ºå³æŒ‡é’ˆ
    for (let j = 0, i = 0; j < n; j++) {
        if (index.has(s[j])) {
            // å¦‚æœæœ‰é‡å¤çš„å­—ç¬¦ï¼Œç§»åŠ¨å·¦æŒ‡é’ˆåˆ°ä¸Šä¸€ä¸ªåŒæ ·å­—ç¬¦çš„åä¸€ä¸ªä½ç½®
            i = Math.max(index.get(s[j]) + 1, i);
        }
        ans = Math.max(ans, j - i + 1); // æ›´æ–°ç»“æœ
        index.set(s[j], j); // æ›´æ–°å­—ç¬¦çš„ä½ç½®
    }
    return ans;
};
```

```python
# by chatGPT (python)
# è¯·ä¿ç•™æ‰€æœ‰ä¸­æ–‡æ³¨é‡Šï¼
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        # æ–°å»ºä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹ï¼Œé¿å…ç‰¹åˆ¤å¤´èŠ‚ç‚¹çš„æƒ…å†µ
        dummy = ListNode(0, head)
        # å¿«æŒ‡é’ˆå…ˆèµ°næ­¥
        fast = head
        for i in range(n):
            fast = fast.next
        # æ…¢æŒ‡é’ˆå¼€å§‹èµ°ï¼Œä¸å¿«æŒ‡é’ˆä¿æŒnæ­¥çš„è·ç¦»
        slow = dummy
        while fast is not None:
            fast = fast.next
            slow = slow.next
        # æ­¤æ—¶slowæŒ‡å‘çš„æ˜¯å€’æ•°ç¬¬n+1ä¸ªèŠ‚ç‚¹ï¼Œåˆ é™¤ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å³å¯
        slow.next = slow.next.next
        return dummy.next
```

https://leetcode.cn/problems/UHnkqh çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/VabMRr çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    vector<int> findAnagrams(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;

        int left = 0, right = 0;
        int valid = 0;
        vector<int> res; // è®°å½•ç»“æœ
        while (right < s.size()) {
            char c = s[right];
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c])
                    valid++;
            }
            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (right - left >= t.size()) {
                // å½“çª—å£ç¬¦åˆæ¡ä»¶æ—¶ï¼ŒæŠŠèµ·å§‹ç´¢å¼•åŠ å…¥ res
                if (valid == need.size())
                    res.push_back(left);
                char d = s[left];
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func findAnagrams(s string, t string) []int {
    need, window := make(map[byte]int), make(map[byte]int)
    for i := range t {
        need[t[i]]++
    }

    left, right := 0, 0
    valid := 0
    var res []int
    for right < len(s) {
        c := s[right]
        right++
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        update := func(c byte) {
            if _, ok := need[c]; ok {
                window[c]++
                if window[c] == need[c] {
                    valid++
                }
            }
        }
        update(c)
        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        for right - left >= len(t) {
            // å½“çª—å£ç¬¦åˆæ¡ä»¶æ—¶ï¼ŒæŠŠèµ·å§‹ç´¢å¼•åŠ å…¥ res
            if valid == len(need) {
                res = append(res, left)
            }
            d := s[left]
            left++
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            update := func(d byte) {
                if _, ok := need[d]; ok {
                    if window[d] == need[d] {
                        valid--
                    }
                    window[d]--
                }
            }
            update(d)
        }
    }
    return res
}
```

```java
// by chatGPT (java)
class Solution {
    public List<Integer> findAnagrams(String s, String t) {
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        for (char c : t.toCharArray()) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }

        int left = 0, right = 0, valid = 0;
        List<Integer> res = new ArrayList<>(); // è®°å½•ç»“æœ
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c).equals(need.get(c))) {
                    valid++;
                }
            }
            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (right - left >= t.length()) {
                // å½“çª—å£ç¬¦åˆæ¡ä»¶æ—¶ï¼ŒæŠŠèµ·å§‹ç´¢å¼•åŠ å…¥ res
                if (valid == need.size()) {
                    res.add(left);
                }
                char d = s.charAt(left);
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if (need.containsKey(d)) {
                    if (window.get(d).equals(need.get(d))) {
                        valid--;
                    }
                    window.put(d, window.get(d) - 1);
                }
            }
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var findAnagrams = function(s, t) {
    var need = {}, window = {};
    for (var i = 0; i < t.length; i++) {
        var c = t[i];
        need[c] = (need[c] || 0) + 1;
    }

    var left = 0, right = 0;
    var valid = 0;
    var res = [];
    while (right < s.length) {
        var c = s[right];
        right++;

        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        if (need.hasOwnProperty(c)) {
            window[c] = (window[c] || 0) + 1;
            if (window[c] === need[c])
                valid++;
        }
        
        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        while (right - left >= t.length) {
            // å½“çª—å£ç¬¦åˆæ¡ä»¶æ—¶ï¼ŒæŠŠèµ·å§‹ç´¢å¼•åŠ å…¥ res
            if (valid === Object.keys(need).length)
                res.push(left);
            var d = s[left];
            left++;

            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.hasOwnProperty(d)) {
                if (window[d] === need[d])
                    valid--;
                window[d]--;
            }
        }
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def findAnagrams(self, s: str, t: str) -> List[int]:
        need, window = {}, {}
        for c in t:
            need[c] = need.get(c, 0) + 1  # ç»Ÿè®¡ç›®æ ‡å­—ç¬¦ä¸²ä¸­å­—ç¬¦å‡ºç°æ¬¡æ•°

        left, right = 0, 0
        valid = 0
        res = []
        while right < len(s):
            c = s[right]  # ç§»å…¥çª—å£çš„å­—ç¬¦
            right += 1
            # è¿›è¡Œçª—å£å†…æ•°æ®çš„æ›´æ–°
            if c in need:
                window[c] = window.get(c, 0) + 1
                if window[c] == need[c]:
                    valid += 1

            # åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while right - left >= len(t):
                # å½“çª—å£ç¬¦åˆæ¡ä»¶æ—¶ï¼ŒæŠŠèµ·å§‹ç´¢å¼•åŠ å…¥ res
                if valid == len(need):
                    res.append(left)
                d = s[left]  # ç§»å‡ºçª—å£çš„å­—ç¬¦
                left += 1
                # è¿›è¡Œçª—å£å†…æ•°æ®çš„æ›´æ–°
                if d in need:
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1

        return res
```

https://leetcode.cn/problems/VabMRr çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/VvJkup çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> res;

    /* ä¸»å‡½æ•°ï¼Œè¾“å…¥ä¸€ç»„ä¸é‡å¤çš„æ•°å­—ï¼Œè¿”å›å®ƒä»¬çš„å…¨æ’åˆ— */
    vector<vector<int>> permute(vector<int>& nums) {
        // è®°å½•ã€Œè·¯å¾„ã€
        vector<int> track;
        // ã€Œè·¯å¾„ã€ä¸­çš„å…ƒç´ ä¼šè¢«æ ‡è®°ä¸º trueï¼Œé¿å…é‡å¤ä½¿ç”¨
        vector<bool> used(nums.size(), false);

        backtrack(nums, track, used);
        return res;
    }

    // è·¯å¾„ï¼šè®°å½•åœ¨ track ä¸­
    // é€‰æ‹©åˆ—è¡¨ï¼šnums ä¸­ä¸å­˜åœ¨äº track çš„é‚£äº›å…ƒç´ ï¼ˆused[i] ä¸º falseï¼‰
    // ç»“æŸæ¡ä»¶ï¼šnums ä¸­çš„å…ƒç´ å…¨éƒ½åœ¨ track ä¸­å‡ºç°
    void backtrack(vector<int>& nums, vector<int>& track, vector<bool>& used) {
        // è§¦å‘ç»“æŸæ¡ä»¶
        if (track.size() == nums.size()) {
            res.push_back(track);
            return;
        }

        for (int i = 0; i < nums.size(); i++) {
            // æ’é™¤ä¸åˆæ³•çš„é€‰æ‹©
            if (used[i]) {
                /**<extend up -200>
                ![](../pictures/backtracking/6.jpg)
                */
                // nums[i] å·²ç»åœ¨ track ä¸­ï¼Œè·³è¿‡
                continue;
            }
            // åšé€‰æ‹©
            track.push_back(nums[i]);
            used[i] = true;
            // è¿›å…¥ä¸‹ä¸€å±‚å†³ç­–æ ‘
            backtrack(nums, track, used);
            // å–æ¶ˆé€‰æ‹©
            track.pop_back();
            used[i] = false;
        }
    }
};
```

```go
// by chatGPT (go)
func permute(nums []int) [][]int {
    res := [][]int{}

    /* backtrack å‡½æ•°ä¼šç”¨åˆ°çš„å‚æ•° */
    var backtrack func(nums, track []int, used []bool)
    backtrack = func(nums, track []int, used []bool) {
        // ã€Œå–æ¶ˆé€‰æ‹©ã€çš„è¿‡ç¨‹æ˜¯æ’¤é”€ä¸Šä¸€æ¬¡çš„é€‰æ‹©ï¼Œæ‰€ä»¥ä¸éœ€è¦ç»“æŸæ¡ä»¶
        if len(track) == len(nums) {
            temp := make([]int, len(track))
            copy(temp, track)
            res = append(res, temp)
            return
        }

        for i := 0; i < len(nums); i++ {
            // æ’é™¤ä¸åˆæ³•çš„é€‰æ‹©
            if used[i] {
                continue
            }
            // åšé€‰æ‹©
            track = append(track, nums[i])
            used[i] = true
            // è¿›å…¥ä¸‹ä¸€å±‚å†³ç­–æ ‘
            backtrack(nums, track, used)
            // ã€Œå–æ¶ˆé€‰æ‹©ã€ï¼Œè¿›è¡Œå›æº¯
            track = track[:len(track)-1]
            used[i] = false
        }
    }

    backtrack(nums, []int{}, make([]bool, len(nums)))
    return res
}
```

```java
// by labuladong (java)
class Solution {

    List<List<Integer>> res = new LinkedList<>();

    /* ä¸»å‡½æ•°ï¼Œè¾“å…¥ä¸€ç»„ä¸é‡å¤çš„æ•°å­—ï¼Œè¿”å›å®ƒä»¬çš„å…¨æ’åˆ— */
    List<List<Integer>> permute(int[] nums) {
        // è®°å½•ã€Œè·¯å¾„ã€
        LinkedList<Integer> track = new LinkedList<>();
        // ã€Œè·¯å¾„ã€ä¸­çš„å…ƒç´ ä¼šè¢«æ ‡è®°ä¸º trueï¼Œé¿å…é‡å¤ä½¿ç”¨
        boolean[] used = new boolean[nums.length];
        
        backtrack(nums, track, used);
        return res;
    }

    // è·¯å¾„ï¼šè®°å½•åœ¨ track ä¸­
    // é€‰æ‹©åˆ—è¡¨ï¼šnums ä¸­ä¸å­˜åœ¨äº track çš„é‚£äº›å…ƒç´ ï¼ˆused[i] ä¸º falseï¼‰
    // ç»“æŸæ¡ä»¶ï¼šnums ä¸­çš„å…ƒç´ å…¨éƒ½åœ¨ track ä¸­å‡ºç°
    void backtrack(int[] nums, LinkedList<Integer> track, boolean[] used) {
        // è§¦å‘ç»“æŸæ¡ä»¶
        if (track.size() == nums.length) {
            res.add(new LinkedList(track));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            // æ’é™¤ä¸åˆæ³•çš„é€‰æ‹©
            if (used[i]) {
                /**<extend up -200>
                ![](../pictures/backtracking/6.jpg)
                */
                // nums[i] å·²ç»åœ¨ track ä¸­ï¼Œè·³è¿‡
                continue;
            }
            // åšé€‰æ‹©
            track.add(nums[i]);
            used[i] = true;
            // è¿›å…¥ä¸‹ä¸€å±‚å†³ç­–æ ‘
            backtrack(nums, track, used);
            // å–æ¶ˆé€‰æ‹©
            track.removeLast();
            used[i] = false;
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var permute = function(nums) {
  const res = [];

  const backtrack = (track, used) => {
    if (track.length === nums.length) {
      res.push([...track]);
      return;
    }

    for (let i = 0; i < nums.length; i++) {
      if (used[i]) {
        // nums[i] å·²ç»åœ¨ track ä¸­ï¼Œè·³è¿‡
        continue;
      }
      track.push(nums[i]);
      used[i] = true;
      backtrack(track, used);
      track.pop();
      used[i] = false;
    }
  };

  backtrack([], []);
  return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.res = []

    def permute(self, nums: List[int]) -> List[List[int]]:
        track = []
        used = [False] * len(nums)
        self.backtrack(nums, track, used)
        return self.res

    def backtrack(self, nums: List[int], track: List[int], used: List[bool]) -> None:
        if len(track) == len(nums):
            self.res.append(track.copy())
            return

        for i in range(len(nums)):
            if used[i]:
                # nums[i] å·²ç»åœ¨ track ä¸­ï¼Œè·³è¿‡
                continue
            track.append(nums[i])
            used[i] = True
            self.backtrack(nums, track, used)
            track.pop()
            used[i] = False
```

https://leetcode.cn/problems/VvJkup çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/WhsWhI çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        // è½¬åŒ–æˆå“ˆå¸Œé›†åˆï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨æŸä¸ªå…ƒç´ 
        unordered_set<int> set;
        for (int num : nums) {
            set.insert(num);
        }

        int res = 0;

        for (int num : set) {
            if (set.count(num - 1)) {
                // num ä¸æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œè·³è¿‡
                continue;
            }
            // num æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œå¼€å§‹å‘ä¸Šè®¡ç®—è¿ç»­å­åºåˆ—çš„é•¿åº¦
            int curNum = num;
            int curLen = 1;

            while (set.count(curNum + 1)) {
                curNum += 1;
                curLen += 1;
            }
            // æ›´æ–°æœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦
            res = max(res, curLen);
        }

        return res;
    }
};
```

```go
// by chatGPT (go)
func longestConsecutive(nums []int) int {
    // è½¬åŒ–æˆå“ˆå¸Œé›†åˆï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨æŸä¸ªå…ƒç´ 
    set := make(map[int]bool)
    for _, num := range nums {
        set[num] = true
    }

    res := 0

    for num := range set {
        if set[num-1] {
            // num ä¸æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œè·³è¿‡
            continue
        }
        // num æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œå¼€å§‹å‘ä¸Šè®¡ç®—è¿ç»­å­åºåˆ—çš„é•¿åº¦
        curNum := num
        curLen := 1

        for set[curNum+1] {
            curNum += 1
            curLen += 1
        }
        // æ›´æ–°æœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦
        res = max(res, curLen)
    }

    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int longestConsecutive(int[] nums) {
        // è½¬åŒ–æˆå“ˆå¸Œé›†åˆï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨æŸä¸ªå…ƒç´ 
        HashSet<Integer> set = new HashSet<Integer>();
        for (int num : nums) {
            set.add(num);
        }

        int res = 0;

        for (int num : set) {
            if (set.contains(num - 1)) {
                // num ä¸æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œè·³è¿‡
                continue;
            }
            // num æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œå¼€å§‹å‘ä¸Šè®¡ç®—è¿ç»­å­åºåˆ—çš„é•¿åº¦
            int curNum = num;
            int curLen = 1;

            while (set.contains(curNum + 1)) {
                curNum += 1;
                curLen += 1;
            }
            // æ›´æ–°æœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦
            res = Math.max(res, curLen);
        }

        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var longestConsecutive = function(nums) {
    // è½¬åŒ–æˆå“ˆå¸Œé›†åˆï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨æŸä¸ªå…ƒç´ 
    const set = new Set(nums);
    let res = 0;

    for (const num of set) {
        if (set.has(num - 1)) {
            // num ä¸æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œè·³è¿‡
            continue;
        }
        // num æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œå¼€å§‹å‘ä¸Šè®¡ç®—è¿ç»­å­åºåˆ—çš„é•¿åº¦
        let curNum = num;
        let curLen = 1;

        while (set.has(curNum + 1)) {
            curNum += 1;
            curLen += 1;
        }
        // æ›´æ–°æœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦
        res = Math.max(res, curLen);
    }

    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        # è½¬åŒ–æˆå“ˆå¸Œé›†åˆï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨æŸä¸ªå…ƒç´ 
        num_set = set(nums)
        
        res = 0
        
        for num in num_set:
            if num - 1 in num_set:
                # num ä¸æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œè·³è¿‡
                continue
            # num æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œå¼€å§‹å‘ä¸Šè®¡ç®—è¿ç»­å­åºåˆ—çš„é•¿åº¦
            cur_num = num
            cur_len = 1
            
            while cur_num + 1 in num_set:
                cur_num += 1
                cur_len += 1
            # æ›´æ–°æœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦
            res = max(res, cur_len)
        
        return res
```

https://leetcode.cn/problems/WhsWhI çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/XltzEq çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isPalindrome(string s) {
        // å…ˆæŠŠæ‰€æœ‰å­—ç¬¦è½¬åŒ–æˆå°å†™ï¼Œå¹¶è¿‡æ»¤æ‰ç©ºæ ¼å’Œæ ‡ç‚¹è¿™ç±»å­—ç¬¦
        string filtered;
        for (int i = 0; i < s.length(); i++) {
            char c = s[i];
            if (isalnum(c)) { // ä½¿ç”¨isalnumå‡½æ•°åˆ¤æ–­æ˜¯å¦ä¸ºå­—æ¯æˆ–æ•°å­—
                filtered += tolower(c); // ä½¿ç”¨tolowerå‡½æ•°å°†å­—ç¬¦è½¬æ¢ä¸ºå°å†™
            }
        }

        // ç„¶åå¯¹å‰©ä¸‹çš„è¿™äº›ç›®æ ‡å­—ç¬¦æ‰§è¡ŒåŒæŒ‡é’ˆç®—æ³•ï¼Œåˆ¤æ–­å›æ–‡ä¸²
        s = filtered;
        // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
        int left = 0, right = s.length() - 1;
        while (left < right) {
            if (s[left] != s[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
};
```

```go
// by chatGPT (go)
func isPalindrome(s string) bool {
    // å…ˆæŠŠæ‰€æœ‰å­—ç¬¦è½¬åŒ–æˆå°å†™ï¼Œå¹¶è¿‡æ»¤æ‰ç©ºæ ¼å’Œæ ‡ç‚¹è¿™ç±»å­—ç¬¦
    sb := strings.Builder{}
    for _, c := range s {
        if unicode.IsLetter(c) || unicode.IsDigit(c) {
            sb.WriteRune(unicode.ToLower(c))
        }
    }

    // ç„¶åå¯¹å‰©ä¸‹çš„è¿™äº›ç›®æ ‡å­—ç¬¦æ‰§è¡ŒåŒæŒ‡é’ˆç®—æ³•ï¼Œåˆ¤æ–­å›æ–‡ä¸²
    s = sb.String()
    // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
    left, right := 0, len(s)-1
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isPalindrome(String s) {
        // å…ˆæŠŠæ‰€æœ‰å­—ç¬¦è½¬åŒ–æˆå°å†™ï¼Œå¹¶è¿‡æ»¤æ‰ç©ºæ ¼å’Œæ ‡ç‚¹è¿™ç±»å­—ç¬¦
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (Character.isLetterOrDigit(c)) {
                sb.append(Character.toLowerCase(c));
            }
        }

        // ç„¶åå¯¹å‰©ä¸‹çš„è¿™äº›ç›®æ ‡å­—ç¬¦æ‰§è¡ŒåŒæŒ‡é’ˆç®—æ³•ï¼Œåˆ¤æ–­å›æ–‡ä¸²
        s = sb.toString();
        // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
        int left = 0, right = s.length() - 1;
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

```javascript
// by chatGPT (javascript)
var isPalindrome = function(s) {
  // å…ˆæŠŠæ‰€æœ‰å­—ç¬¦è½¬åŒ–æˆå°å†™ï¼Œå¹¶è¿‡æ»¤æ‰ç©ºæ ¼å’Œæ ‡ç‚¹è¿™ç±»å­—ç¬¦
  let sb = '';
  for (let i = 0; i < s.length; i++) {
    let c = s.charAt(i);
    if (/[0-9a-zA-Z]/.test(c)) {
      sb += c.toLowerCase();
    }
  }

  // ç„¶åå¯¹å‰©ä¸‹çš„è¿™äº›ç›®æ ‡å­—ç¬¦æ‰§è¡ŒåŒæŒ‡é’ˆç®—æ³•ï¼Œåˆ¤æ–­å›æ–‡ä¸²
  s = sb;
  // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
  let left = 0, right = s.length - 1;
  while (left < right) {
    if (s.charAt(left) !== s.charAt(right)) {
      return false;
    }
    left++;
    right--;
  }
  return true;
}
```

```python
# by chatGPT (python)
class Solution:
    def isPalindrome(self, s: str) -> bool:
        # å…ˆæŠŠæ‰€æœ‰å­—ç¬¦è½¬åŒ–æˆå°å†™ï¼Œå¹¶è¿‡æ»¤æ‰ç©ºæ ¼å’Œæ ‡ç‚¹è¿™ç±»å­—ç¬¦
        sb = []
        for c in s:
            if c.isalnum():
                sb.append(c.lower())
                
        # ç„¶åå¯¹å‰©ä¸‹çš„è¿™äº›ç›®æ ‡å­—ç¬¦æ‰§è¡ŒåŒæŒ‡é’ˆç®—æ³•ï¼Œåˆ¤æ–­å›æ–‡ä¸²
        s = ''.join(sb)
        # ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
        left, right = 0, len(s) - 1
        while left < right:
            if s[left] != s[right]:
                return False
            left += 1
            right -= 1
        return True
```

https://leetcode.cn/problems/XltzEq çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/YaVDxD çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        if (nums.empty()) return 0;
        return dp(nums, 0, target);
    }

    // å¤‡å¿˜å½•
    unordered_map<string, int> memo;

    int dp(vector<int>& nums, int i, int remain) {
        // base case
        if (i == nums.size()) {
            if (remain == 0) return 1;
            return 0;
        }
        // æŠŠå®ƒä¿©è½¬æˆå­—ç¬¦ä¸²æ‰èƒ½ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®
        string key = to_string(i) + "," + to_string(remain);
        // é¿å…é‡å¤è®¡ç®—
        if (memo.count(key)) {
            return memo[key];
        }
        // è¿˜æ˜¯ç©·ä¸¾
        int result = dp(nums, i + 1, remain - nums[i]) + dp(nums, i + 1, remain + nums[i]);
        // è®°å…¥å¤‡å¿˜å½•
        memo[key] = result;
        return result;
    }
};
```

```go
// by chatGPT (go)
func findTargetSumWays(nums []int, target int) int {
    if len(nums) == 0 {
        return 0
    }
    //åˆå§‹åŒ–å¤‡å¿˜å½•
    memo := make(map[string]int)
    return dp(nums, 0, target, memo)
}

func dp(nums []int, i int, remain int, memo map[string]int) int {
    //åŸºæœ¬æƒ…å†µ
    if i == len(nums) {
        if remain == 0 {
            return 1
        }
        return 0
    }
    key := fmt.Sprintf("%d,%d", i, remain)
    //é¿å…é‡å¤è®¡ç®—
    if _, ok := memo[key]; ok {
        return memo[key]
    }
    //ç©·ä¸¾
    result := dp(nums, i+1, remain-nums[i], memo) + dp(nums, i+1, remain+nums[i], memo)
    //è®°å½•ç»“æœåˆ°å¤‡å¿˜å½•
    memo[key] = result
    return result
}
```

```java
// by labuladong (java)
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        if (nums.length == 0) return 0;
        return dp(nums, 0, target);
    }

    // å¤‡å¿˜å½•
    HashMap<String, Integer> memo = new HashMap<>();

    int dp(int[] nums, int i, int remain) {
        // base case
        if (i == nums.length) {
            if (remain == 0) return 1;
            return 0;
        }
        // æŠŠå®ƒä¿©è½¬æˆå­—ç¬¦ä¸²æ‰èƒ½ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®
        String key = i + "," + remain;
        // é¿å…é‡å¤è®¡ç®—
        if (memo.containsKey(key)) {
            return memo.get(key);
        }
        // è¿˜æ˜¯ç©·ä¸¾
        int result = dp(nums, i + 1, remain - nums[i]) + dp(nums, i + 1, remain + nums[i]);
        // è®°å…¥å¤‡å¿˜å½•
        memo.put(key, result);
        return result;
    }
}
```

```javascript
// by chatGPT (javascript)
var findTargetSumWays = function(nums, target) {
    if (nums.length === 0) return 0;
    // å¤‡å¿˜å½•
    let memo = new Map();

    function dp(nums, i, remain) {
        // base case
        if (i === nums.length) {
            if (remain === 0) return 1;
            return 0;
        }
        // æŠŠå®ƒä¿©è½¬æˆå­—ç¬¦ä¸²æ‰èƒ½ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®
        let key = i + "," + remain;
        // é¿å…é‡å¤è®¡ç®—
        if (memo.has(key)) {
            return memo.get(key);
        }
        // è¿˜æ˜¯ç©·ä¸¾
        let result = dp(nums, i + 1, remain - nums[i]) + dp(nums, i + 1, remain + nums[i]);
        // è®°å…¥å¤‡å¿˜å½•
        memo.set(key, result);
        return result;
    }

    return dp(nums, 0, target);
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.memo = {}
    
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        if len(nums) == 0:
            return 0
        return self.dp(nums, 0, target)
    
    def dp(self, nums: List[int], i: int, remain: int) -> int:
        # base case
        if i == len(nums):
            if remain == 0:
                return 1
            return 0
        # æŠŠå®ƒä¿©è½¬æˆå­—ç¬¦ä¸²æ‰èƒ½ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®
        key = str(i) + "," + str(remain)
        # é¿å…é‡å¤è®¡ç®—
        if key in self.memo:
            return self.memo[key]
        # è¿˜æ˜¯ç©·ä¸¾
        result = self.dp(nums, i + 1, remain - nums[i]) + self.dp(nums, i + 1, remain + nums[i])
        # è®°å…¥å¤‡å¿˜å½•
        self.memo[key] = result
        return result
```

https://leetcode.cn/problems/YaVDxD çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/Ygoe9J çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    vector<vector<int>> res;
    list<int> track;

public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        if (candidates.empty()) {
            return res;
        }
        backtrack(candidates, 0, target, 0);
        return res;
    }

    // å›æº¯ç®—æ³•ä¸»å‡½æ•°
    void backtrack(vector<int>& candidates, int start, int target, int sum) {
        if (sum == target) {
            // æ‰¾åˆ°ç›®æ ‡å’Œ
            res.push_back(vector<int>(track.begin(), track.end()));
            return;
        }

        if (sum > target) {
            // è¶…è¿‡ç›®æ ‡å’Œï¼Œç›´æ¥ç»“æŸ
            return;
        }

        // å›æº¯ç®—æ³•æ¡†æ¶
        for (int i = start; i < candidates.size(); i++) {
            // é€‰æ‹© candidates[i]
            track.push_back(candidates[i]);
            sum += candidates[i];
            // é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
            backtrack(candidates, i, target, sum);
            // æ’¤é”€é€‰æ‹© candidates[i]
            sum -= candidates[i];
            track.pop_back();
        }
    }
};
```

```go
// by chatGPT (go)
func combinationSum(candidates []int, target int) [][]int {
    res := [][]int{}
    if len(candidates) == 0 {
        return res
    }
    backtrack(candidates, []int{}, target, 0, &res)
    return res
}

// å›æº¯ç®—æ³•æ¡†æ¶
func backtrack(candidates []int, path []int, target, sum int, res *[][]int) {
    if sum == target {
        // æ‰¾åˆ°ç›®æ ‡å’Œ
        *res = append(*res, append([]int{}, path...))
        return
    }
    if sum > target {
        // è¶…è¿‡ç›®æ ‡å’Œï¼Œç›´æ¥ç»“æŸ
        return
    }
    for i := 0; i < len(candidates); i++ {
        // é€‰æ‹© candidates[i]
        path = append(path, candidates[i])
        sum += candidates[i]
        // é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
        backtrack(candidates[i:], path, target, sum, res)
        // æ’¤é”€é€‰æ‹© candidates[i]
        sum -= candidates[i]
        path = path[:len(path)-1]
    }
}
```

```java
// by labuladong (java)
class Solution {
    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if (candidates.length == 0) {
            return res;
        }
        backtrack(candidates, 0, target, 0);
        return res;
    }

    // è®°å½•å›æº¯çš„è·¯å¾„
    LinkedList<Integer> track = new LinkedList<>();

    // å›æº¯ç®—æ³•ä¸»å‡½æ•°
    void backtrack(int[] candidates, int start, int target, int sum) {
        if (sum == target) {
            // æ‰¾åˆ°ç›®æ ‡å’Œ
            res.add(new LinkedList<>(track));
            return;
        }

        if (sum > target) {
            // è¶…è¿‡ç›®æ ‡å’Œï¼Œç›´æ¥ç»“æŸ
            return;
        }

        // å›æº¯ç®—æ³•æ¡†æ¶
        for (int i = start; i < candidates.length; i++) {
            // é€‰æ‹© candidates[i]
            track.add(candidates[i]);
            sum += candidates[i];
            // é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
            backtrack(candidates, i, target, sum);
            // æ’¤é”€é€‰æ‹© candidates[i]
            sum -= candidates[i];
            track.removeLast();
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var combinationSum = function(candidates, target) {
    var res = [];
    if (candidates.length === 0) {
        return res;
    }

    // è®°å½•å›æº¯çš„è·¯å¾„
    var track = [];

    // å›æº¯ç®—æ³•ä¸»å‡½æ•°
    var backtrack = function(candidates, start, target, sum) {
        if (sum === target) {
            // æ‰¾åˆ°ç›®æ ‡å’Œ
            res.push([...track]);
            return;
        }

        if (sum > target) {
            // è¶…è¿‡ç›®æ ‡å’Œï¼Œç›´æ¥ç»“æŸ
            return;
        }

        // å›æº¯ç®—æ³•æ¡†æ¶
        for (var i = start; i < candidates.length; i++) {
            // é€‰æ‹© candidates[i]
            track.push(candidates[i]);
            sum += candidates[i];
            // é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
            backtrack(candidates, i, target, sum);
            // æ’¤é”€é€‰æ‹© candidates[i]
            sum -= candidates[i];
            track.pop();
        }
    };

    backtrack(candidates, 0, target, 0);
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.res = []
        self.track = []

    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        if not candidates:
            return self.res
        self.backtrack(candidates, 0, target, 0)
        return self.res

    # è®°å½•å›æº¯çš„è·¯å¾„
    def backtrack(self, candidates, start, target, summation):
        if summation == target:
            # æ‰¾åˆ°ç›®æ ‡å’Œ
            self.res.append(self.track[:])
            return
        if summation > target:
            # è¶…è¿‡ç›®æ ‡å’Œï¼Œç›´æ¥ç»“æŸ
            return
        # å›æº¯ç®—æ³•æ¡†æ¶
        for i in range(start, len(candidates)):
            # é€‰æ‹© candidates[i]
            self.track.append(candidates[i])
            summation += candidates[i]
            # é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
            self.backtrack(candidates, i, target, summation)
            # æ’¤é”€é€‰æ‹© candidates[i]
            summation -= candidates[i]
            self.track.pop()
```

https://leetcode.cn/problems/Ygoe9J çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/ZL6zAn çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        // è®°å½•å²›å±¿çš„æœ€å¤§é¢ç§¯
        int res = 0;
        int m = grid.size(), n = grid[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // æ·¹æ²¡å²›å±¿ï¼Œå¹¶æ›´æ–°æœ€å¤§å²›å±¿é¢ç§¯
                    res = max(res, dfs(grid, i, j));
                }
            }
        }
        return res;
    }

    // æ·¹æ²¡ä¸ (i, j) ç›¸é‚»çš„é™†åœ°ï¼Œå¹¶è¿”å›æ·¹æ²¡çš„é™†åœ°é¢ç§¯
    int dfs(vector<vector<int>>& grid, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return 0;
        }
        if (grid[i][j] == 0) {
            // å·²ç»æ˜¯æµ·æ°´äº†
            return 0;
        }
        // å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = 0;

        return dfs(grid, i + 1, j)
                + dfs(grid, i, j + 1)
                + dfs(grid, i - 1, j)
                + dfs(grid, i, j - 1) + 1;
    }
};
```

```go
// by chatGPT (go)
// è®°å½•å²›å±¿çš„æœ€å¤§é¢ç§¯
func maxAreaOfIsland(grid [][]int) int {
    res := 0
    m, n := len(grid), len(grid[0])
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if grid[i][j] == 1 {
                // æ·¹æ²¡å²›å±¿ï¼Œå¹¶æ›´æ–°æœ€å¤§å²›å±¿é¢ç§¯
                res = max(res, dfs(grid, i, j))
            }
        }
    }
    return res
}

// æ·¹æ²¡ä¸ (i, j) ç›¸é‚»çš„é™†åœ°ï¼Œå¹¶è¿”å›æ·¹æ²¡çš„é™†åœ°é¢ç§¯
func dfs(grid [][]int, i, j int) int {
    m, n := len(grid), len(grid[0])
    if i < 0 || j < 0 || i >= m || j >= n {
        // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
        return 0
    }
    if grid[i][j] == 0 {
        // å·²ç»æ˜¯æµ·æ°´äº†
        return 0
    }
    // å°† (i, j) å˜æˆæµ·æ°´
    grid[i][j] = 0

    return dfs(grid, i+1, j) +
        dfs(grid, i, j+1) +
        dfs(grid, i-1, j) +
        dfs(grid, i, j-1) + 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        // è®°å½•å²›å±¿çš„æœ€å¤§é¢ç§¯
        int res = 0;
        int m = grid.length, n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // æ·¹æ²¡å²›å±¿ï¼Œå¹¶æ›´æ–°æœ€å¤§å²›å±¿é¢ç§¯
                    res = Math.max(res, dfs(grid, i, j));
                }
            }
        }
        return res;
    }

    // æ·¹æ²¡ä¸ (i, j) ç›¸é‚»çš„é™†åœ°ï¼Œå¹¶è¿”å›æ·¹æ²¡çš„é™†åœ°é¢ç§¯
    int dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return 0;
        }
        if (grid[i][j] == 0) {
            // å·²ç»æ˜¯æµ·æ°´äº†
            return 0;
        }
        // å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = 0;

        return dfs(grid, i + 1, j)
                + dfs(grid, i, j + 1)
                + dfs(grid, i - 1, j)
                + dfs(grid, i, j - 1) + 1;
    }
}
```

```javascript
// by chatGPT (javascript)
var maxAreaOfIsland = function(grid) {
    let res = 0;
    let m = grid.length, n = grid[0].length;

    function dfs(grid, i, j) {
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return 0;
        }
        if (grid[i][j] == 0) {
            // å·²ç»æ˜¯æµ·æ°´äº†
            return 0;
        }
        // å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = 0;

        return dfs(grid, i + 1, j)
                + dfs(grid, i, j + 1)
                + dfs(grid, i - 1, j)
                + dfs(grid, i, j - 1) + 1;
    }

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                res = Math.max(res, dfs(grid, i, j));
            }
        }
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        # è®°å½•å²›å±¿çš„æœ€å¤§é¢ç§¯
        res = 0
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    # æ·¹æ²¡å²›å±¿ï¼Œå¹¶æ›´æ–°æœ€å¤§å²›å±¿é¢ç§¯
                    res = max(res, self.dfs(grid, i, j))
        return res
    
    # æ·¹æ²¡ä¸ (i, j) ç›¸é‚»çš„é™†åœ°ï¼Œå¹¶è¿”å›æ·¹æ²¡çš„é™†åœ°é¢ç§¯
    def dfs(self, grid: List[List[int]], i: int, j: int) -> int:
        m, n = len(grid), len(grid[0])
        if i < 0 or j < 0 or i >= m or j >= n:
            # è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return 0
        if grid[i][j] == 0:
            # å·²ç»æ˜¯æµ·æ°´äº†
            return 0
        # å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = 0
        
        return (self.dfs(grid, i + 1, j) 
                + self.dfs(grid, i, j + 1) 
                + self.dfs(grid, i - 1, j) 
                + self.dfs(grid, i, j - 1) + 1)
```

https://leetcode.cn/problems/ZL6zAn çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/aMhZSa çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode *slow, *fast;
        slow = fast = head;
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
        }

        if (fast != nullptr)
            slow = slow->next;

        ListNode *left = head;
        ListNode *right = reverse(slow);
        while (right != nullptr) {
            if (left->val != right->val)
                return false;
            left = left->next;
            right = right->next;
        }

        return true;
    }

    ListNode* reverse(ListNode* head) {
        ListNode *pre = nullptr, *cur = head;
        while (cur != nullptr) {
            ListNode *next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
};
```

```go
// by chatGPT (go)
func isPalindrome(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    if fast != nil {
        slow = slow.Next
    }
    left, right := head, reverse(slow)
    for right != nil {
        if left.Val != right.Val {
            return false
        }
        left = left.Next
        right = right.Next
    }
    return true
}

func reverse(head *ListNode) *ListNode {
    var pre *ListNode
    cur := head
    for cur != nil {
        next := cur.Next
        cur.Next = pre
        pre = cur
        cur = next
    }
    return pre
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode slow, fast;
        slow = fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        if (fast != null)
            slow = slow.next;

        ListNode left = head;
        ListNode right = reverse(slow);
        while (right != null) {
            if (left.val != right.val)
                return false;
            left = left.next;
            right = right.next;
        }

        return true;
    }

    ListNode reverse(ListNode head) {
        ListNode pre = null, cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

```javascript
// by chatGPT (javascript)
var isPalindrome = function(head) {
    let slow, fast;
    slow = fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    if (fast != null)
        slow = slow.next;

    let left = head;
    let right = reverse(slow);
    while (right != null) {
        if (left.val != right.val)
            return false;
        left = left.next;
        right = right.next;
    }

    return true;
};

var reverse = function(head) {
    let pre = null, cur = head;
    while (cur != null) {
        let next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
};
```

```python
# by chatGPT (python)
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        if fast:
            slow = slow.next
        
        left = head
        right = self.reverse(slow)
        while right:
            if left.val != right.val:
                return False
            left = left.next
            right = right.next
        
        return True

    def reverse(self, head: ListNode) -> ListNode:
        pre, cur = None, head
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
```

https://leetcode.cn/problems/aMhZSa çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/add-binary çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    string addBinary(string a, string b) {
        // å…ˆæŠŠè¾“å…¥çš„è¿™ä¸¤ä¸ªäºŒè¿›åˆ¶ä¸²åè½¬ï¼Œä½ä½æ”¾åœ¨å‰é¢ï¼Œæ–¹ä¾¿å¤„ç†è¿›ä½
        reverse(a.begin(), a.end());
        reverse(b.begin(), b.end());
        // å­˜å‚¨ç»“æœ
        string res = "";

        int m = a.size(), n = b.size();
        // carry è®°å½•è¿›ä½
        int carry = 0;
        int i = 0;

        // å¼€å§‹ç±»ä¼¼ [2. ä¸¤æ•°ç›¸åŠ ](#2) çš„åŠ æ³•æ¨¡æ‹Ÿé€»è¾‘
        // åªæ˜¯è¿™é‡Œè¿ç®—çš„æ˜¯äºŒè¿›åˆ¶å­—ç¬¦ä¸²
        while (i < max(m, n) || carry > 0) {
            int val = carry;
            val += i < m ? (a[i] - '0') : 0;
            val += i < n ? (b[i] - '0') : 0;
            res.push_back(val % 2 + '0');
            carry = val / 2;
            i++;
        }

        reverse(res.begin(), res.end());
        return res;
    }
};
```

```go
// by chatGPT (go)
func addBinary(a string, b string) string {
    // å…ˆæŠŠè¾“å…¥çš„è¿™ä¸¤ä¸ªäºŒè¿›åˆ¶ä¸²åè½¬ï¼Œä½ä½æ”¾åœ¨å‰é¢ï¼Œæ–¹ä¾¿å¤„ç†è¿›ä½
    reverse := func(str string) string {
        reversed := []rune(str)
        for i, j := 0, len(reversed)-1; i < j; i, j = i+1, j-1 {
            reversed[i], reversed[j] = reversed[j], reversed[i]
        }
        return string(reversed)
    }
    a = reverse(a)
    b = reverse(b)
    // å­˜å‚¨ç»“æœ
    var sb strings.Builder

    m, n := len(a), len(b)
    // carry è®°å½•è¿›ä½
    carry := 0
    i := 0

    // å¼€å§‹ç±»ä¼¼ [2. ä¸¤æ•°ç›¸åŠ ](#2) çš„åŠ æ³•æ¨¡æ‹Ÿé€»è¾‘
    // åªæ˜¯è¿™é‡Œè¿ç®—çš„æ˜¯äºŒè¿›åˆ¶å­—ç¬¦ä¸²
    for i < max(m, n) || carry > 0 {
        val := carry
        if i < m {
            val += int(a[i] - '0')
        }
        if i < n {
            val += int(b[i] - '0')
        }
        sb.WriteString(strconv.Itoa(val % 2))
        carry = val / 2
        i++
    }

    return reverse(sb.String())
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public String addBinary(String a, String b) {
        // å…ˆæŠŠè¾“å…¥çš„è¿™ä¸¤ä¸ªäºŒè¿›åˆ¶ä¸²åè½¬ï¼Œä½ä½æ”¾åœ¨å‰é¢ï¼Œæ–¹ä¾¿å¤„ç†è¿›ä½
        a = new StringBuilder(a).reverse().toString();
        b = new StringBuilder(b).reverse().toString();
        // å­˜å‚¨ç»“æœ
        StringBuilder sb = new StringBuilder();

        int m = a.length(), n = b.length();
        // carry è®°å½•è¿›ä½
        int carry = 0;
        int i = 0;

        // å¼€å§‹ç±»ä¼¼ [2. ä¸¤æ•°ç›¸åŠ ](#2) çš„åŠ æ³•æ¨¡æ‹Ÿé€»è¾‘
        // åªæ˜¯è¿™é‡Œè¿ç®—çš„æ˜¯äºŒè¿›åˆ¶å­—ç¬¦ä¸²
        while (i < Math.max(m, n) || carry > 0) {
            int val = carry;
            val += i < m ? (a.charAt(i) - '0') : 0;
            val += i < n ? (b.charAt(i) - '0') : 0;
            sb.append(val % 2);
            carry = val / 2;
            i++;
        }

        return sb.reverse().toString();
    }
}
```

```javascript
// by chatGPT (javascript)
var addBinary = function(a, b) {
  // å…ˆæŠŠè¾“å…¥çš„è¿™ä¸¤ä¸ªäºŒè¿›åˆ¶ä¸²åè½¬ï¼Œä½ä½æ”¾åœ¨å‰é¢ï¼Œæ–¹ä¾¿å¤„ç†è¿›ä½
  a = a.split("").reverse().join("");
  b = b.split("").reverse().join("");
  // å­˜å‚¨ç»“æœ
  var sb = "";

  var m = a.length, n = b.length;
  // carry è®°å½•è¿›ä½
  var carry = 0;
  var i = 0;

  // å¼€å§‹ç±»ä¼¼ [2. ä¸¤æ•°ç›¸åŠ ](#2) çš„åŠ æ³•æ¨¡æ‹Ÿé€»è¾‘
  // åªæ˜¯è¿™é‡Œè¿ç®—çš„æ˜¯äºŒè¿›åˆ¶å­—ç¬¦ä¸²
  while (i < Math.max(m, n) || carry > 0) {
    var val = carry;
    val += i < m ? parseInt(a.charAt(i)) : 0;
    val += i < n ? parseInt(b.charAt(i)) : 0;
    sb += (val % 2);
    carry = Math.floor(val / 2);
    i++;
  }

  return sb.split("").reverse().join("");
};
```

```python
# by chatGPT (python)
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        # å…ˆæŠŠè¾“å…¥çš„è¿™ä¸¤ä¸ªäºŒè¿›åˆ¶ä¸²åè½¬ï¼Œä½ä½æ”¾åœ¨å‰é¢ï¼Œæ–¹ä¾¿å¤„ç†è¿›ä½
        a = a[::-1]
        b = b[::-1]
        # å­˜å‚¨ç»“æœ
        sb = []

        m, n = len(a), len(b)
        # carry è®°å½•è¿›ä½
        carry = 0
        i = 0

        # å¼€å§‹ç±»ä¼¼ [2. ä¸¤æ•°ç›¸åŠ ](#2) çš„åŠ æ³•æ¨¡æ‹Ÿé€»è¾‘
        # åªæ˜¯è¿™é‡Œè¿ç®—çš„æ˜¯äºŒè¿›åˆ¶å­—ç¬¦ä¸²
        while i < max(m, n) or carry > 0:
            val = carry
            val += int(a[i]) if i < m else 0
            val += int(b[i]) if i < n else 0
            sb.append(str(val % 2))
            carry = val // 2
            i += 1

        return "".join(sb[::-1])
```

https://leetcode.cn/problems/add-binary çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/add-two-numbers çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // åœ¨ä¸¤æ¡é“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        ListNode *p1 = l1, *p2 = l2;
        // è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
        ListNode *dummy = new ListNode(-1);
        // æŒ‡é’ˆ p è´Ÿè´£æ„å»ºæ–°é“¾è¡¨
        ListNode *p = dummy;
        // è®°å½•è¿›ä½
        int carry = 0;
        // å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
        while (p1 != nullptr || p2 != nullptr || carry > 0) {
            // å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
            int val = carry;
            if (p1 != nullptr) {
                val += p1->val;
                p1 = p1->next;
            }
            if (p2 != nullptr) {
                val += p2->val;
                p2 = p2->next;
            }
            // å¤„ç†è¿›ä½æƒ…å†µ
            carry = val / 10;
            val = val % 10;
            // æ„å»ºæ–°èŠ‚ç‚¹
            p->next = new ListNode(val);
            p = p->next;
        }
        // è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
        return dummy->next;
    }
};
```

```go
// by chatGPT (go)
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    // åœ¨ä¸¤æ¡é“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
    p1, p2 := l1, l2
    // è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
    dummy := &ListNode{-1, nil}
    // æŒ‡é’ˆ p è´Ÿè´£æ„å»ºæ–°é“¾è¡¨
    p := dummy
    // è®°å½•è¿›ä½
    carry := 0
    // å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
    for p1 != nil || p2 != nil || carry > 0 {
        // å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
        val := carry
        if p1 != nil {
            val += p1.Val
            p1 = p1.Next
        }
        if p2 != nil {
            val += p2.Val
            p2 = p2.Next
        }
        // å¤„ç†è¿›ä½æƒ…å†µ
        carry = val / 10
        val = val % 10
        // æ„å»ºæ–°èŠ‚ç‚¹
        p.Next = &ListNode{val, nil}
        p = p.Next
    }
    // è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
    return dummy.Next
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // åœ¨ä¸¤æ¡é“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        ListNode p1 = l1, p2 = l2;
        // è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
        ListNode dummy = new ListNode(-1);
        // æŒ‡é’ˆ p è´Ÿè´£æ„å»ºæ–°é“¾è¡¨
        ListNode p = dummy;
        // è®°å½•è¿›ä½
        int carry = 0;
        // å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
        while (p1 != null || p2 != null || carry > 0) {
            // å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
            int val = carry;
            if (p1 != null) {
                val += p1.val;
                p1 = p1.next;
            }
            if (p2 != null) {
                val += p2.val;
                p2 = p2.next;
            }
            // å¤„ç†è¿›ä½æƒ…å†µ
            carry = val / 10;
            val = val % 10;
            // æ„å»ºæ–°èŠ‚ç‚¹
            p.next = new ListNode(val);
            p = p.next;
        }
        // è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
        return dummy.next;
    }
}
```

```javascript
// by chatGPT (javascript)
var addTwoNumbers = function(l1, l2) {
    // åœ¨ä¸¤æ¡é“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
    let p1 = l1, p2 = l2;
    // è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
    let dummy = new ListNode(-1);
    // æŒ‡é’ˆ p è´Ÿè´£æ„å»ºæ–°é“¾è¡¨
    let p = dummy;
    // è®°å½•è¿›ä½
    let carry = 0;
    // å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
    while (p1 !== null || p2 !== null || carry > 0) {
        // å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
        let val = carry;
        if (p1 !== null) {
            val += p1.val;
            p1 = p1.next;
        }
        if (p2 !== null) {
            val += p2.val;
            p2 = p2.next;
        }
        // å¤„ç†è¿›ä½æƒ…å†µ
        carry = Math.floor(val / 10);
        val = val % 10;
        // æ„å»ºæ–°èŠ‚ç‚¹
        p.next = new ListNode(val);
        p = p.next;
    }
    // è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
    return dummy.next;
};
```

```python
# by chatGPT (python)
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        # åœ¨ä¸¤æ¡é“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        p1, p2 = l1, l2
        # è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
        dummy = ListNode(-1)
        # æŒ‡é’ˆ p è´Ÿè´£æ„å»ºæ–°é“¾è¡¨
        p = dummy
        # è®°å½•è¿›ä½
        carry = 0
        # å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
        while p1 or p2 or carry:
            # å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
            val = carry
            if p1:
                val += p1.val
                p1 = p1.next
            if p2:
                val += p2.val
                p2 = p2.next
            # å¤„ç†è¿›ä½æƒ…å†µ
            carry, val = divmod(val, 10)
            # æ„å»ºæ–°èŠ‚ç‚¹
            p.next = ListNode(val)
            p = p.next
        # è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
        return dummy.next
```

https://leetcode.cn/problems/add-two-numbers çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/add-two-numbers-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // æŠŠé“¾è¡¨å…ƒç´ è½¬å…¥æ ˆä¸­
        stack<int> stk1, stk2;
        while (l1 != nullptr) {
            stk1.push(l1->val);
            l1 = l1->next;
        }
        while (l2 != nullptr) {
            stk2.push(l2->val);
            l2 = l2->next;
        }

        // æ¥ä¸‹æ¥åŸºæœ¬ä¸Šæ˜¯å¤ç”¨æˆ‘åœ¨ç¬¬ 2 é¢˜çš„ä»£ç é€»è¾‘
        // æ³¨æ„æ–°èŠ‚ç‚¹è¦ç›´æ¥æ’å…¥åˆ° dummy åé¢

        // è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
        ListNode* dummy = new ListNode(-1);

        // è®°å½•è¿›ä½
        int carry = 0;
        // å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
        while (!stk1.empty() || !stk2.empty() || carry > 0) {
            // å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
            int val = carry;
            if (!stk1.empty()) {
                val += stk1.top();
                stk1.pop();
            }
            if (!stk2.empty()) {
                val += stk2.top();
                stk2.pop();
            }
            // å¤„ç†è¿›ä½æƒ…å†µ
            carry = val / 10;
            val = val % 10;
            // æ„å»ºæ–°èŠ‚ç‚¹ï¼Œç›´æ¥æ¥åœ¨ dummy åé¢
            ListNode* newNode = new ListNode(val);
            newNode->next = dummy->next;
            dummy->next = newNode;
        }
        // è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
        ListNode* result = dummy->next;
        delete dummy;
        return result;
    }
};
```

```go
// by chatGPT (go)
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    // æŠŠé“¾è¡¨å…ƒç´ è½¬å…¥æ ˆä¸­
    stk1 := []int{}
    for l1 != nil {
        stk1 = append(stk1, l1.Val)
        l1 = l1.Next
    }
    stk2 := []int{}
    for l2 != nil {
        stk2 = append(stk2, l2.Val)
        l2 = l2.Next
    }

    // æ¥ä¸‹æ¥åŸºæœ¬ä¸Šæ˜¯å¤ç”¨æˆ‘åœ¨ç¬¬ 2 é¢˜çš„ä»£ç é€»è¾‘
    // æ³¨æ„æ–°èŠ‚ç‚¹è¦ç›´æ¥æ’å…¥åˆ° dummy åé¢

    // è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
    dummy := &ListNode{-1, nil}

    // è®°å½•è¿›ä½
    carry := 0
    // å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
    for len(stk1) > 0 || len(stk2) > 0 || carry > 0 {
        // å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
        val := carry
        if len(stk1) > 0 {
            val += stk1[len(stk1)-1]
            stk1 = stk1[:len(stk1)-1]
        }
        if len(stk2) > 0 {
            val += stk2[len(stk2)-1]
            stk2 = stk2[:len(stk2)-1]
        }
        // å¤„ç†è¿›ä½æƒ…å†µ
        carry = val / 10
        val = val % 10
        // æ„å»ºæ–°èŠ‚ç‚¹ï¼Œç›´æ¥æ¥åœ¨ dummy åé¢
        newNode := &ListNode{val, dummy.Next}
        dummy.Next = newNode
    }
    // è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
    return dummy.Next
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // æŠŠé“¾è¡¨å…ƒç´ è½¬å…¥æ ˆä¸­
        Stack<Integer> stk1 = new Stack<>();
        while (l1 != null) {
            stk1.push(l1.val);
            l1 = l1.next;
        }
        Stack<Integer> stk2 = new Stack<>();
        while (l2 != null) {
            stk2.push(l2.val);
            l2 = l2.next;
        }

        // æ¥ä¸‹æ¥åŸºæœ¬ä¸Šæ˜¯å¤ç”¨æˆ‘åœ¨ç¬¬ 2 é¢˜çš„ä»£ç é€»è¾‘
        // æ³¨æ„æ–°èŠ‚ç‚¹è¦ç›´æ¥æ’å…¥åˆ° dummy åé¢

        // è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
        ListNode dummy = new ListNode(-1);

        // è®°å½•è¿›ä½
        int carry = 0;
        // å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
        while (!stk1.isEmpty() || !stk2.isEmpty() || carry > 0) {
            // å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
            int val = carry;
            if (!stk1.isEmpty()) {
                val += stk1.pop();
            }
            if (!stk2.isEmpty()) {
                val += stk2.pop();
            }
            // å¤„ç†è¿›ä½æƒ…å†µ
            carry = val / 10;
            val = val % 10;
            // æ„å»ºæ–°èŠ‚ç‚¹ï¼Œç›´æ¥æ¥åœ¨ dummy åé¢
            ListNode newNode = new ListNode(val);
            newNode.next = dummy.next;
            dummy.next = newNode;
        }
        // è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
        return dummy.next;
    }
}
```

```javascript
// by chatGPT (javascript)
var addTwoNumbers = function(l1, l2) {
  // æŠŠé“¾è¡¨å…ƒç´ è½¬å…¥æ ˆä¸­
  const stk1 = [];
  while (l1 !== null) {
    stk1.push(l1.val);
    l1 = l1.next;
  }
  const stk2 = [];
  while (l2 !== null) {
    stk2.push(l2.val);
    l2 = l2.next;
  }

  // æ¥ä¸‹æ¥åŸºæœ¬ä¸Šæ˜¯å¤ç”¨æˆ‘åœ¨ç¬¬ 2 é¢˜çš„ä»£ç é€»è¾‘
  // æ³¨æ„æ–°èŠ‚ç‚¹è¦ç›´æ¥æ’å…¥åˆ° dummy åé¢

  // è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
  const dummy = new ListNode(-1);

  // è®°å½•è¿›ä½
  let carry = 0;
  // å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
  while (stk1.length || stk2.length || carry > 0) {
    // å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
    let val = carry;
    if (stk1.length) {
      val += stk1.pop();
    }
    if (stk2.length) {
      val += stk2.pop();
    }
    // å¤„ç†è¿›ä½æƒ…å†µ
    carry = Math.floor(val / 10);
    val = val % 10;
    // æ„å»ºæ–°èŠ‚ç‚¹ï¼Œç›´æ¥æ¥åœ¨ dummy åé¢
    const newNode = new ListNode(val);
    newNode.next = dummy.next;
    dummy.next = newNode;
  }
  // è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
  return dummy.next;
};
```

```python
# by chatGPT (python)
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        # æŠŠé“¾è¡¨å…ƒç´ è½¬å…¥æ ˆä¸­
        stk1 = []
        while l1:
            stk1.append(l1.val)
            l1 = l1.next
        stk2 = []
        while l2:
            stk2.append(l2.val)
            l2 = l2.next

        # æ¥ä¸‹æ¥åŸºæœ¬ä¸Šæ˜¯å¤ç”¨æˆ‘åœ¨ç¬¬ 2 é¢˜çš„ä»£ç é€»è¾‘
        # æ³¨æ„æ–°èŠ‚ç‚¹è¦ç›´æ¥æ’å…¥åˆ° dummy åé¢

        # è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
        dummy = ListNode(-1)

        # è®°å½•è¿›ä½
        carry = 0
        # å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
        while stk1 or stk2 or carry > 0:
            # å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
            val = carry
            if stk1:
                val += stk1.pop()
            if stk2:
                val += stk2.pop()
            # å¤„ç†è¿›ä½æƒ…å†µ
            carry = val // 10
            val = val % 10
            # æ„å»ºæ–°èŠ‚ç‚¹ï¼Œç›´æ¥æ¥åœ¨ dummy åé¢
            newNode = ListNode(val)
            newNode.next = dummy.next
            dummy.next = newNode
        # è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
        return dummy.next
```

https://leetcode.cn/problems/add-two-numbers-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/additive-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isAdditiveNumber(string num) {
        // ç©·ä¸¾å‰ä¸¤ä¸ªæ•°å­—
        int n = num.size();
        for (int i = 1; i <= n; i++) {
            for (int j = i + 1; j <= n; j++) {
                string first = num.substr(0, i);
                string second = num.substr(i, j-i);
                if (isValid(num, first, second)) {
                    return true;
                }
            }
        }
        return false;
    }

private:
    // å®šä¹‰ï¼šnum å‰ä¸¤ä¸ªæ•°å­—åˆ†åˆ«æ˜¯ first å’Œ secondï¼Œåˆ¤æ–­ num æ˜¯å¦æ»¡è¶³ç´¯åŠ æ•°çš„æ€§è´¨
    bool isValid(string num, string first, string second) {
        if ((first[0] == '0' && first.size() > 1)
                || (second[0] == '0' && second.size() > 1)) {
            // 0 å¼€å¤´çš„æ•°å­—ï¼Œåªèƒ½æ˜¯ 0 æœ¬èº«
            return false;
        }
        string sumStr = strAdd(first, second);
        string next = num.substr(first.size() + second.size());
        if (next.find(sumStr) != 0) {
            // ä¸æ»¡è¶³ç´¯åŠ æ•°çš„æ€§è´¨
            return false;
        }
        if (next == sumStr) {
            // å·²ç»åŒ¹é…å®Œæ•´ä¸ªå­—ç¬¦ä¸²
            return true;
        }
        // æ ¹æ®é€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œç»§ç»­åŒ¹é…åé¢çš„ä¸‰ä¸ªæ•°å­—ï¼Œæˆ‘è¿™é‡Œç”¨é€’å½’çš„æ–¹å¼å»æ¯”è¾ƒï¼Œå› ä¸ºå®¹æ˜“å†™
        // ä½ ä¹Ÿå¯ä»¥æ”¹ç”¨è¿­ä»£å†™æ³•ï¼Œä¸€æ ·çš„
        return isValid(num.substr(first.size()), second, sumStr);
    }

    // æ¨¡æ‹ŸåŠ æ³•ç«–å¼è¿ç®—ï¼Œå…·ä½“å¯ä»¥çœ‹ä¸‹è¿™é“é¢˜
    // https://leetcode-cn.com/problems/add-strings/
    string strAdd(string a, string b) {
        int n = a.size(), m = b.size();
        int i = n - 1, j = m - 1, add = 0;
        string builder;
        while (i >= 0 || j >= 0 || add != 0) {
            int x = i >= 0 ? a[i] - '0' : 0;
            int y = j >= 0 ? b[j] - '0' : 0;
            int result = x + y + add;
            builder.push_back(result % 10 + '0');
            add = result / 10;
            i--;
            j--;
        }
        reverse(builder.begin(), builder.end());
        return builder;
    }
};
```

```go
// by chatGPT (go)
import (
	"strconv"
	"strings"
)

// isAdditiveNumber - ç©·ä¸¾å‰ä¸¤ä¸ªæ•°å­—
func isAdditiveNumber(num string) bool {
	n := len(num)
	for i := 1; i <= n; i++ {
		for j := i + 1; j <= n; j++ {
			first := num[:i]
			second := num[i:j]
			if isValid(num, first, second) {
				return true
			}
		}
	}
	return false
}

// isValid - å®šä¹‰:num å‰ä¸¤ä¸ªæ•°å­—åˆ†åˆ«æ˜¯ first å’Œ secondï¼Œåˆ¤æ–­ num æ˜¯å¦æ»¡è¶³ç´¯åŠ æ•°çš„æ€§è´¨
func isValid(num string, first string, second string) bool {
	if (strings.HasPrefix(first, "0") && len(first) > 1) ||
		(strings.HasPrefix(second, "0") && len(second) > 1) {
		// 0 å¼€å¤´çš„æ•°å­—ï¼Œåªèƒ½æ˜¯ 0 æœ¬èº«
		return false
	}
	sumStr := strAdd(first, second)
	next := num[len(first)+len(second):]
	if !strings.HasPrefix(next, sumStr) {
		// ä¸æ»¡è¶³ç´¯åŠ æ•°çš„æ€§è´¨
		return false
	}
	if next == sumStr {
		// å·²ç»åŒ¹é…å®Œæ•´ä¸ªå­—ç¬¦ä¸²
		return true
	}
	// æ ¹æ®é€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œç»§ç»­åŒ¹é…åé¢çš„ä¸‰ä¸ªæ•°å­—ï¼Œæˆ‘è¿™é‡Œç”¨é€’å½’çš„æ–¹å¼å»æ¯”è¾ƒï¼Œå› ä¸ºå®¹æ˜“å†™
	// ä½ ä¹Ÿå¯ä»¥æ”¹ç”¨è¿­ä»£å†™æ³•ï¼Œä¸€æ ·çš„
	return isValid(num[len(first):], second, sumStr)
}

// strAdd - æ¨¡æ‹ŸåŠ æ³•ç«–å¼è¿ç®—ï¼Œå…·ä½“å¯ä»¥çœ‹ä¸‹è¿™é“é¢˜
// https://leetcode.cn/problems/add-strings/
func strAdd(a, b string) string {
	i, j, carry := len(a)-1, len(b)-1, 0
	ans := ""
	for i >= 0 || j >= 0 {
		x, _ := strconv.Atoi(string(a[i]))
		y, _ := strconv.Atoi(string(b[j]))
		sum := x + y + carry
		tmp := sum % 10
		carry = sum / 10
		ans = strconv.Itoa(tmp) + ans
		i--
		j--
	}
	if carry > 0 {
		ans = "1" + ans
	}
	return ans
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isAdditiveNumber(String num) {
        // ç©·ä¸¾å‰ä¸¤ä¸ªæ•°å­—
        int n = num.length();
        for (int i = 1; i <= n; i++) {
            // å…ˆç©·ä¸¾ç¬¬ä¸€ä¸ªæ•°å­—
            String first = num.substring(0, i);
            for (int j = i + 1; j <= n; j++) {
                // å†ç©·ä¸¾ç¬¬äºŒä¸ªæ•°å­—
                String second = num.substring(i, j);
                if (isValid(num, first, second)) {
                    return true;
                }
            }
        }
        return false;
    }

    // å®šä¹‰ï¼šnum å‰ä¸¤ä¸ªæ•°å­—åˆ†åˆ«æ˜¯ first å’Œ secondï¼Œåˆ¤æ–­ num æ˜¯å¦æ»¡è¶³ç´¯åŠ æ•°çš„æ€§è´¨
    boolean isValid(String num, String first, String second) {
        if (first.startsWith("0") && first.length() > 1
                || second.startsWith("0") && second.length() > 1) {
            // 0 å¼€å¤´çš„æ•°å­—ï¼Œåªèƒ½æ˜¯ 0 æœ¬èº«
            return false;
        }
        String sumStr = strAdd(first, second);
        String next = num.substring(first.length() + second.length());
        if (!next.startsWith(sumStr)) {
            // ä¸æ»¡è¶³ç´¯åŠ æ•°çš„æ€§è´¨
            return false;
        }
        if (next.equals(sumStr)) {
            // å·²ç»åŒ¹é…å®Œæ•´ä¸ªå­—ç¬¦ä¸²
            return true;
        }
        // æ ¹æ®é€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œç»§ç»­åŒ¹é…åé¢çš„ä¸‰ä¸ªæ•°å­—ï¼Œæˆ‘è¿™é‡Œç”¨é€’å½’çš„æ–¹å¼å»æ¯”è¾ƒï¼Œå› ä¸ºå®¹æ˜“å†™
        // ä½ ä¹Ÿå¯ä»¥æ”¹ç”¨è¿­ä»£å†™æ³•ï¼Œä¸€æ ·çš„
        return isValid(num.substring(first.length()), second, sumStr);
    }

    // æ¨¡æ‹ŸåŠ æ³•ç«–å¼è¿ç®—ï¼Œå…·ä½“å¯ä»¥çœ‹ä¸‹è¿™é“é¢˜
    // https://leetcode.cn/problems/add-strings/
    String strAdd(String a, String b) {
        int n = a.length(), m = b.length();
        int i = n - 1, j = m - 1, add = 0;
        StringBuilder builder = new StringBuilder();
        while (i >= 0 || j >= 0 || add != 0) {
            int x = i >= 0 ? a.charAt(i) - '0' : 0;
            int y = j >= 0 ? b.charAt(j) - '0' : 0;
            int result = x + y + add;
            builder.append(result % 10);
            add = result / 10;
            i--;
            j--;
        }
        return builder.reverse().toString();
    }
}
```

```javascript
// by chatGPT (javascript)
var isAdditiveNumber = function(num) {
    // ç©·ä¸¾å‰ä¸¤ä¸ªæ•°å­—
    let n = num.length;
    for (let i = 1; i <= n; i++) {
        for (let j = i + 1; j <= n; j++) {
            let first = num.substring(0, i);
            let second = num.substring(i, j);
            if (isValid(num, first, second)) {
                return true;
            }
        }
    }
    return false;
}

var isValid = function(num, first, second) {
    if ((first.startsWith("0") && first.length > 1)
            || (second.startsWith("0") && second.length > 1)) {
        // 0 å¼€å¤´çš„æ•°å­—ï¼Œåªèƒ½æ˜¯ 0 æœ¬èº«
        return false;
    }
    let sumStr = strAdd(first, second);
    let next = num.substring(first.length + second.length);
    if (!next.startsWith(sumStr)) {
        // ä¸æ»¡è¶³ç´¯åŠ æ•°çš„æ€§è´¨
        return false;
    }
    if (next === sumStr) {
        // å·²ç»åŒ¹é…å®Œæ•´ä¸ªå­—ç¬¦ä¸²
        return true;
    }
    // æ ¹æ®é€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œç»§ç»­åŒ¹é…åé¢çš„ä¸‰ä¸ªæ•°å­—ï¼Œæˆ‘è¿™é‡Œç”¨é€’å½’çš„æ–¹å¼å»æ¯”è¾ƒï¼Œå› ä¸ºå®¹æ˜“å†™
    // ä½ ä¹Ÿå¯ä»¥æ”¹ç”¨è¿­ä»£å†™æ³•ï¼Œä¸€æ ·çš„
    return isValid(num.substring(first.length), second, sumStr);
}

var strAdd = function(a, b) {
    let n = a.length, m = b.length;
    let i = n - 1, j = m - 1, add = 0;
    let builder = [];
    while (i >= 0 || j >= 0 || add != 0) {
        let x = i >= 0 ? a.charAt(i) - '0' : 0;
        let y = j >= 0 ? b.charAt(j) - '0' : 0;
        let result = x + y + add;
        builder.push(result % 10);
        add = Math.floor(result / 10);
        i--;
        j--;
    }
    return builder.reverse().join('');
}
```

```python
# by chatGPT (python)
class Solution:
    def isAdditiveNumber(self, num):
        # ç©·ä¸¾å‰ä¸¤ä¸ªæ•°å­—
        n = len(num)
        for i in range(1, n + 1):
            for j in range(i + 1, n + 1):
                first = num[0 : i]
                second = num[i : j]
                if self.isValid(num, first, second):
                    return True
        return False

    def isValid(self, num, first, second):
        # å®šä¹‰ï¼šnum å‰ä¸¤ä¸ªæ•°å­—åˆ†åˆ«æ˜¯ first å’Œ secondï¼Œåˆ¤æ–­ num æ˜¯å¦æ»¡è¶³ç´¯åŠ æ•°çš„æ€§è´¨
        if (first.startswith("0") and len(first) > 1) or (second.startswith("0") and len(second) > 1):
            # 0 å¼€å¤´çš„æ•°å­—ï¼Œåªèƒ½æ˜¯ 0 æœ¬èº«
            return False
        sumStr = self.strAdd(first, second)
        next = num[len(first) + len(second):]
        if not next.startswith(sumStr):
            # ä¸æ»¡è¶³ç´¯åŠ æ•°çš„æ€§è´¨
            return False
        if next == sumStr:
            # å·²ç»åŒ¹é…å®Œæ•´ä¸ªå­—ç¬¦ä¸²
            return True
        # æ ¹æ®é€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œç»§ç»­åŒ¹é…åé¢çš„ä¸‰ä¸ªæ•°å­—ï¼Œæˆ‘è¿™é‡Œç”¨é€’å½’çš„æ–¹å¼å»æ¯”è¾ƒï¼Œå› ä¸ºå®¹æ˜“å†™
        # ä½ ä¹Ÿå¯ä»¥æ”¹ç”¨è¿­ä»£å†™æ³•ï¼Œä¸€æ ·çš„
        return self.isValid(num[len(first):], second, sumStr)

    def strAdd(self, a, b):
        # æ¨¡æ‹ŸåŠ æ³•ç«–å¼è¿ç®—ï¼Œå…·ä½“å¯ä»¥çœ‹ä¸‹è¿™é“é¢˜
        # https://leetcode.cn/problems/add-strings/
        n, m = len(a), len(b)
        i, j, add = n - 1, m - 1, 0
        builder = []
        while i >= 0 or j >= 0 or add != 0:
            x = int(a[i]) if i >= 0 else 0
            y = int(b[j]) if j >= 0 else 0
            result = x + y + add
            builder.append(result % 10)
            add = result // 10
            i -= 1
            j -= 1
        return ''.join(str(i) for i in builder[::-1])
```

https://leetcode.cn/problems/additive-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/advantage-shuffle çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        // ç»™ nums2 é™åºæ’åº
        priority_queue<pair<int, int>> maxpq;
        for (int i = 0; i < n; i++) {
            maxpq.push({i, nums2[i]});
        }
        // ç»™ nums1 å‡åºæ’åº
        sort(nums1.begin(), nums1.end());

        // nums1[left] æ˜¯æœ€å°å€¼ï¼Œnums1[right] æ˜¯æœ€å¤§å€¼
        int left = 0, right = n - 1;
        vector<int> res(n);

        while (!maxpq.empty()) {
            auto [i, maxval] = maxpq.top(); maxpq.pop();
            // maxval æ˜¯ nums2 ä¸­çš„æœ€å¤§å€¼ï¼Œi æ˜¯å¯¹åº”ç´¢å¼•
            if (maxval < nums1[right]) {
                // å¦‚æœ nums1[right] èƒ½èƒœè¿‡ maxvalï¼Œé‚£å°±è‡ªå·±ä¸Š
                res[i] = nums1[right];
                right--;
            } else {
                // å¦åˆ™ç”¨æœ€å°å€¼æ··ä¸€ä¸‹ï¼Œå…»ç²¾è“„é”
                res[i] = nums1[left];
                left++;
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func advantageCount(nums1 []int, nums2 []int) []int {
    n := len(nums1)
    // ç»™ nums2 é™åºæ’åº
    maxpq := make(PriorityQueue, 0)
    heap.Init(&maxpq)
    for i := 0; i < n; i++ {
        heap.Push(&maxpq, []int{i, nums2[i]})
    }
    // ç»™ nums1 å‡åºæ’åº
    sort.Ints(nums1)

    // nums1[left] æ˜¯æœ€å°å€¼ï¼Œnums1[right] æ˜¯æœ€å¤§å€¼
    left, right := 0, n-1
    res := make([]int, n)

    for maxpq.Len() > 0 {
        pair := heap.Pop(&maxpq).([]int)
        // maxval æ˜¯ nums2 ä¸­çš„æœ€å¤§å€¼ï¼Œi æ˜¯å¯¹åº”ç´¢å¼•
        i, maxval := pair[0], pair[1]
        if maxval < nums1[right] {
            // å¦‚æœ nums1[right] èƒ½èƒœè¿‡ maxvalï¼Œé‚£å°±è‡ªå·±ä¸Š
            res[i] = nums1[right]
            right--
        } else {
            // å¦åˆ™ç”¨æœ€å°å€¼æ··ä¸€ä¸‹ï¼Œå…»ç²¾è“„é”
            res[i] = nums1[left]
            left++
        }
    }
    return res
}

// å®šä¹‰ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ç±»å‹ PriorityQueueï¼Œç”¨äºæŒ‰ç…§æŒ‡å®šæ¯”è¾ƒå‡½æ•°æ’åº
type PriorityQueue [][]int

func (pq PriorityQueue) Len() int {
    return len(pq)
}

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i][1] > pq[j][1]
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    item := x.([]int)
    *pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
}
```

```java
// by labuladong (java)
class Solution {
    public int[] advantageCount(int[] nums1, int[] nums2) {
        int n = nums1.length;
        // ç»™ nums2 é™åºæ’åº
        PriorityQueue<int[]> maxpq = new PriorityQueue<>(
                (int[] pair1, int[] pair2) -> {
                    return pair2[1] - pair1[1];
                }
        );
        for (int i = 0; i < n; i++) {
            maxpq.offer(new int[]{i, nums2[i]});
        }
        // ç»™ nums1 å‡åºæ’åº
        Arrays.sort(nums1);

        // nums1[left] æ˜¯æœ€å°å€¼ï¼Œnums1[right] æ˜¯æœ€å¤§å€¼
        int left = 0, right = n - 1;
        int[] res = new int[n];

        while (!maxpq.isEmpty()) {
            int[] pair = maxpq.poll();
            // maxval æ˜¯ nums2 ä¸­çš„æœ€å¤§å€¼ï¼Œi æ˜¯å¯¹åº”ç´¢å¼•
            int i = pair[0], maxval = pair[1];
            if (maxval < nums1[right]) {
                // å¦‚æœ nums1[right] èƒ½èƒœè¿‡ maxvalï¼Œé‚£å°±è‡ªå·±ä¸Š
                res[i] = nums1[right];
                right--;
            } else {
                // å¦åˆ™ç”¨æœ€å°å€¼æ··ä¸€ä¸‹ï¼Œå…»ç²¾è“„é”
                res[i] = nums1[left];
                left++;
            }
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var advantageCount = function(nums1, nums2) {
    var n = nums1.length;
    //ç»™ nums2 é™åºæ’åº
    var maxpq = new PriorityQueue((pair1, pair2) => pair2[1] - pair1[1]);
    for (var i = 0; i < n; i++) {
        maxpq.offer([i, nums2[i]]);
    }
    //ç»™ nums1 å‡åºæ’åº
    nums1.sort((a, b) => a - b);
    // nums1[left] æ˜¯æœ€å°å€¼ï¼Œnums1[right] æ˜¯æœ€å¤§å€¼
    var left = 0, right = n - 1;
    var res = new Array(n);

    while (!maxpq.isEmpty()) {
        var pair = maxpq.poll();
        // maxval æ˜¯ nums2 ä¸­çš„æœ€å¤§å€¼ï¼Œi æ˜¯å¯¹åº”ç´¢å¼•
        var i = pair[0], maxval = pair[1];
        if (maxval < nums1[right]) {
            // å¦‚æœ nums1[right] èƒ½èƒœè¿‡ maxvalï¼Œé‚£å°±è‡ªå·±ä¸Š
            res[i] = nums1[right];
            right--;
        } else {
            // å¦åˆ™ç”¨æœ€å°å€¼æ··ä¸€ä¸‹ï¼Œå…»ç²¾è“„é”
            res[i] = nums1[left];
            left++;
        }
    }
    return res;
}
```

```python
# by chatGPT (python)
class Solution:
    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:
        n = len(nums1)
        # ç»™ nums2 é™åºæ’åº
        maxpq = []
        for i in range(n):
            maxpq.append([i, nums2[i]])
        maxpq.sort(key=lambda x: -x[1])

        # ç»™ nums1 å‡åºæ’åº
        nums1.sort()

        # nums1[left] æ˜¯æœ€å°å€¼ï¼Œnums1[right] æ˜¯æœ€å¤§å€¼
        left, right = 0, n - 1
        res = [0] * n

        while maxpq:
            pair = maxpq.pop(0)
            # maxval æ˜¯ nums2 ä¸­çš„æœ€å¤§å€¼ï¼Œi æ˜¯å¯¹åº”ç´¢å¼•
            i, maxval = pair[0], pair[1]
            if maxval < nums1[right]:
                # å¦‚æœ nums1[right] èƒ½èƒœè¿‡ maxvalï¼Œé‚£å°±è‡ªå·±ä¸Š
                res[i] = nums1[right]
                right -= 1
            else:
                # å¦åˆ™ç”¨æœ€å°å€¼æ··ä¸€ä¸‹ï¼Œå…»ç²¾è“„é”
                res[i] = nums1[left]
                left += 1
        return res
```

https://leetcode.cn/problems/advantage-shuffle çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/all-paths-from-source-to-target çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    // è®°å½•æ‰€æœ‰è·¯å¾„
    vector<vector<int>> res;

public:
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        deque<int> path;
        traverse(graph, 0, path);
        return res;
    }

    /* å›¾çš„éå†æ¡†æ¶ */
    void traverse(vector<vector<int>>& graph, int s, deque<int>& path) {

        // æ·»åŠ èŠ‚ç‚¹ s åˆ°è·¯å¾„
        path.push_back(s);

        int n = graph.size();
        if (s == n - 1) {
            // åˆ°è¾¾ç»ˆç‚¹
            res.push_back(vector<int>(path.begin(), path.end()));
            path.pop_back();
            return;
        }

        // é€’å½’æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹
        for (int v : graph[s]) {
            traverse(graph, v, path);
        }

        // ä»è·¯å¾„ç§»å‡ºèŠ‚ç‚¹ s
        path.pop_back();
    }
};
```

```go
// by chatGPT (go)
func allPathsSourceTarget(graph [][]int) [][]int {
    res := [][]int{}
    path := []int{}
    
    var traverse func(graph [][]int, s int, path []int)
    traverse = func(graph [][]int, s int, path []int) {
        // æ·»åŠ èŠ‚ç‚¹ s åˆ°è·¯å¾„
        path = append(path, s)

        n := len(graph)
        if s == n - 1 {
            // åˆ°è¾¾ç»ˆç‚¹
            tmp := make([]int, len(path))
            copy(tmp, path)
            res = append(res, tmp)
            path = path[:len(path) - 1]
            return
        }

        // é€’å½’æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹
        for _, v := range graph[s] {
            traverse(graph, v, path)
        }

        // ä»è·¯å¾„ç§»å‡ºèŠ‚ç‚¹ s
        path = path[:len(path) - 1]
    }
    
    traverse(graph, 0, path)
    return res
}
```

```java
// by labuladong (java)
class Solution {
    // è®°å½•æ‰€æœ‰è·¯å¾„
    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        LinkedList<Integer> path = new LinkedList<>();
        traverse(graph, 0, path);
        return res;
    }

    /* å›¾çš„éå†æ¡†æ¶ */
    void traverse(int[][] graph, int s, LinkedList<Integer> path) {

        // æ·»åŠ èŠ‚ç‚¹ s åˆ°è·¯å¾„
        path.addLast(s);

        int n = graph.length;
        if (s == n - 1) {
            // åˆ°è¾¾ç»ˆç‚¹
            res.add(new LinkedList<>(path));
            path.removeLast();
            return;
        }

        // é€’å½’æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹
        for (int v : graph[s]) {
            traverse(graph, v, path);
        }

        // ä»è·¯å¾„ç§»å‡ºèŠ‚ç‚¹ s
        path.removeLast();
    }
}
```

```javascript
// by chatGPT (javascript)
var allPathsSourceTarget = function(graph) {
    // è®°å½•æ‰€æœ‰è·¯å¾„
    var res = [];

    var traverse = function(graph, s, path) {
        // æ·»åŠ èŠ‚ç‚¹ s åˆ°è·¯å¾„
        path.push(s);

        var n = graph.length;
        if (s === n - 1) {
            // åˆ°è¾¾ç»ˆç‚¹
            res.push(path.slice());
            path.pop();
            return;
        }

        // é€’å½’æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹
        for (var i = 0; i < graph[s].length; i++) {
            traverse(graph, graph[s][i], path);
        }

        // ä»è·¯å¾„ç§»å‡ºèŠ‚ç‚¹ s
        path.pop();
    };

    var path = [];
    traverse(graph, 0, path);

    return res;
};
```

```python
# by chatGPT (python)
from typing import List

class Solution:
    def __init__(self):
        # è®°å½•æ‰€æœ‰è·¯å¾„
        self.res = []

    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        path = []
        self.traverse(graph, 0, path)
        return self.res

    """ å›¾çš„éå†æ¡†æ¶ """
    def traverse(self, graph: List[List[int]], s: int, path: List[int]) -> None:
        # æ·»åŠ èŠ‚ç‚¹ s åˆ°è·¯å¾„
        path.append(s)

        n = len(graph)
        if s == n - 1:
            # åˆ°è¾¾ç»ˆç‚¹
            self.res.append(path[:])
            path.pop()
            return

        # é€’å½’æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹
        for v in graph[s]:
            self.traverse(graph, v, path)

        # ä»è·¯å¾„ç§»å‡ºèŠ‚ç‚¹ s
        path.pop()
```

https://leetcode.cn/problems/all-paths-from-source-to-target çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/bP4bmD çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    // è®°å½•æ‰€æœ‰è·¯å¾„
    vector<vector<int>> res;

public:
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        deque<int> path;
        traverse(graph, 0, path);
        return res;
    }

    /* å›¾çš„éå†æ¡†æ¶ */
    void traverse(vector<vector<int>>& graph, int s, deque<int>& path) {

        // æ·»åŠ èŠ‚ç‚¹ s åˆ°è·¯å¾„
        path.push_back(s);

        int n = graph.size();
        if (s == n - 1) {
            // åˆ°è¾¾ç»ˆç‚¹
            res.push_back(vector<int>(path.begin(), path.end()));
            path.pop_back();
            return;
        }

        // é€’å½’æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹
        for (int v : graph[s]) {
            traverse(graph, v, path);
        }

        // ä»è·¯å¾„ç§»å‡ºèŠ‚ç‚¹ s
        path.pop_back();
    }
};
```

```go
// by chatGPT (go)
func allPathsSourceTarget(graph [][]int) [][]int {
    // è®°å½•æ‰€æœ‰è·¯å¾„
    res := [][]int{}
    var traverse func(graph [][]int, s int, path []int)

    traverse = func(graph [][]int, s int, path []int) {
        // æ·»åŠ èŠ‚ç‚¹ s åˆ°è·¯å¾„
        path = append(path, s)

        n := len(graph)
        if s == n-1 {
            // åˆ°è¾¾ç»ˆç‚¹
            tmp := make([]int, len(path))
            copy(tmp, path)
            res = append(res, tmp)
            path = path[:len(path)-1]
            return
        }

        // é€’å½’æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹
        for _, v := range graph[s] {
            traverse(graph, v, path)
        }

        // ä»è·¯å¾„ç§»å‡ºèŠ‚ç‚¹ s
        path = path[:len(path)-1]
    }

    path := make([]int, 0)
    traverse(graph, 0, path)
    return res
}
```

```java
// by labuladong (java)
class Solution {
    // è®°å½•æ‰€æœ‰è·¯å¾„
    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        LinkedList<Integer> path = new LinkedList<>();
        traverse(graph, 0, path);
        return res;
    }

    /* å›¾çš„éå†æ¡†æ¶ */
    void traverse(int[][] graph, int s, LinkedList<Integer> path) {

        // æ·»åŠ èŠ‚ç‚¹ s åˆ°è·¯å¾„
        path.addLast(s);

        int n = graph.length;
        if (s == n - 1) {
            // åˆ°è¾¾ç»ˆç‚¹
            res.add(new LinkedList<>(path));
            path.removeLast();
            return;
        }

        // é€’å½’æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹
        for (int v : graph[s]) {
            traverse(graph, v, path);
        }

        // ä»è·¯å¾„ç§»å‡ºèŠ‚ç‚¹ s
        path.removeLast();
    }
}
```

```javascript
// by chatGPT (javascript)
var allPathsSourceTarget = function(graph) {
    // è®°å½•æ‰€æœ‰è·¯å¾„
    let res = [];

    let traverse = function(graph, s, path) {
        // æ·»åŠ èŠ‚ç‚¹ s åˆ°è·¯å¾„
        path.push(s);

        let n = graph.length;
        if (s == n - 1) {
            // åˆ°è¾¾ç»ˆç‚¹
            res.push([...path]);
            path.pop();
            return;
        }

        // é€’å½’æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹
        for (let v of graph[s]) {
            traverse(graph, v, path);
        }

        // ä»è·¯å¾„ç§»å‡ºèŠ‚ç‚¹ s
        path.pop();
    };

    let path = [];
    traverse(graph, 0, path);

    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    # è®°å½•æ‰€æœ‰è·¯å¾„
    res = []

    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        path = []
        self.traverse(graph, 0, path)
        return self.res

    # å›¾çš„éå†æ¡†æ¶
    def traverse(self, graph: List[List[int]], s: int, path: List[int]) -> None:

        # æ·»åŠ èŠ‚ç‚¹ s åˆ°è·¯å¾„
        path.append(s)

        n = len(graph)
        if s == n - 1:
            # åˆ°è¾¾ç»ˆç‚¹
            self.res.append(path[:])
            path.pop()
            return

        # é€’å½’æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹
        for v in graph[s]:
            self.traverse(graph, v, path)

        # ä»è·¯å¾„ç§»å‡ºèŠ‚ç‚¹ s
        path.pop()
```

https://leetcode.cn/problems/bP4bmD çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int translateNum(int num) {
        string s = to_string(num);
        int n = s.length();
        if (n < 1) {
            return 0;
        }
        // å®šä¹‰ï¼šdp[i] è¡¨ç¤º s[0..i-1] çš„è§£ç æ–¹å¼æ•°é‡
        vector<int> dp(n + 1);
        // base case: s ä¸ºç©ºæˆ–è€… s åªæœ‰ä¸€ä¸ªå­—ç¬¦çš„æƒ…å†µ
        dp[0] = 1;
        dp[1] = 1;

        // æ³¨æ„ dp æ•°ç»„å’Œ s ä¹‹é—´çš„ç´¢å¼•åç§»ä¸€ä½
        for (int i = 2; i <= n; i++) {
            char c = s[i - 1], d = s[i - 2];
            if ('0' <= c && c <= '9') {
                // 1. s[i] æœ¬èº«å¯ä»¥ä½œä¸ºä¸€ä¸ªå­—æ¯
                dp[i] += dp[i - 1];
            }
            if (d == '1' || d == '2' && c <= '5') {
                // 2. s[i] å’Œ s[i - 1] ç»“åˆèµ·æ¥è¡¨ç¤ºä¸€ä¸ªå­—æ¯
                dp[i] += dp[i - 2];
            }
        }
        return dp[n];
    }
};
```

```go
// by chatGPT (go)
func translateNum(num int) int {
    s := strconv.Itoa(num)
    n := len(s)
    if n < 1 {
        return 0
    }
    // å®šä¹‰ï¼šdp[i] è¡¨ç¤º s[0..i-1] çš„è§£ç æ–¹å¼æ•°é‡
    dp := make([]int, n+1)
    // base case: s ä¸ºç©ºæˆ–è€… s åªæœ‰ä¸€ä¸ªå­—ç¬¦çš„æƒ…å†µ
    dp[0] = 1
    dp[1] = 1

    // æ³¨æ„ dp æ•°ç»„å’Œ s ä¹‹é—´çš„ç´¢å¼•åç§»ä¸€ä½
    for i := 2; i <= n; i++ {
        c, d := s[i-1], s[i-2]
        if '0' <= c && c <= '9' {
            // 1. s[i] æœ¬èº«å¯ä»¥ä½œä¸ºä¸€ä¸ªå­—æ¯
            dp[i] += dp[i-1]
        }
        if (d == '1' || (d == '2' && c <= '5')) {
            // 2. s[i] å’Œ s[i - 1] ç»“åˆèµ·æ¥è¡¨ç¤ºä¸€ä¸ªå­—æ¯
            dp[i] += dp[i-2]
        }
    }
    return dp[n]
}
```

```java
// by labuladong (java)
class Solution {
    public int translateNum(int num) {
        String s = num + "";
        int n = s.length();
        if (n < 1) {
            return 0;
        }
        // å®šä¹‰ï¼šdp[i] è¡¨ç¤º s[0..i-1] çš„è§£ç æ–¹å¼æ•°é‡
        int[] dp = new int[n + 1];
        // base case: s ä¸ºç©ºæˆ–è€… s åªæœ‰ä¸€ä¸ªå­—ç¬¦çš„æƒ…å†µ
        dp[0] = 1;
        dp[1] = 1;

        // æ³¨æ„ dp æ•°ç»„å’Œ s ä¹‹é—´çš„ç´¢å¼•åç§»ä¸€ä½
        for (int i = 2; i <= n; i++) {
            char c = s.charAt(i - 1), d = s.charAt(i - 2);
            if ('0' <= c && c <= '9') {
                // 1. s[i] æœ¬èº«å¯ä»¥ä½œä¸ºä¸€ä¸ªå­—æ¯
                dp[i] += dp[i - 1];
            }
            if (d == '1' || d == '2' && c <= '5') {
                // 2. s[i] å’Œ s[i - 1] ç»“åˆèµ·æ¥è¡¨ç¤ºä¸€ä¸ªå­—æ¯
                dp[i] += dp[i - 2];
            }
        }
        return dp[n];
    }
}
```

```javascript
// by chatGPT (javascript)
var translateNum = function(num) {
    var s = num.toString();
    var n = s.length;
    if (n < 1) {
        return 0;
    }
    // å®šä¹‰ï¼šdp[i] è¡¨ç¤º s[0..i-1] çš„è§£ç æ–¹å¼æ•°é‡
    var dp = new Array(n + 1).fill(0);
    // base case: s ä¸ºç©ºæˆ–è€… s åªæœ‰ä¸€ä¸ªå­—ç¬¦çš„æƒ…å†µ
    dp[0] = 1;
    dp[1] = 1;

    // æ³¨æ„ dp æ•°ç»„å’Œ s ä¹‹é—´çš„ç´¢å¼•åç§»ä¸€ä½
    for (var i = 2; i <= n; i++) {
        var c = s.charAt(i - 1), d = s.charAt(i - 2);
        if ('0' <= c && c <= '9') {
            // 1. s[i] æœ¬èº«å¯ä»¥ä½œä¸ºä¸€ä¸ªå­—æ¯
            dp[i] += dp[i - 1];
        }
        if (d == '1' || d == '2' && c <= '5') {
            // 2. s[i] å’Œ s[i - 1] ç»“åˆèµ·æ¥è¡¨ç¤ºä¸€ä¸ªå­—æ¯
            dp[i] += dp[i - 2];
        }
    }
    return dp[n];
};
```

```python
# by chatGPT (python)
class Solution:
    def translateNum(self, num: int) -> int:
        s = str(num)
        n = len(s)
        if n < 1:
            return 0
        # å®šä¹‰ï¼šdp[i] è¡¨ç¤º s[0..i-1] çš„è§£ç æ–¹å¼æ•°é‡
        dp = [0] * (n + 1)
        # base case: s ä¸ºç©ºæˆ–è€… s åªæœ‰ä¸€ä¸ªå­—ç¬¦çš„æƒ…å†µ
        dp[0] = 1
        dp[1] = 1

        # æ³¨æ„ dp æ•°ç»„å’Œ s ä¹‹é—´çš„ç´¢å¼•åç§»ä¸€ä½
        for i in range(2, n + 1):
            c = s[i - 1]
            d = s[i - 2]
            if '0' <= c <= '9':
                # 1. s[i] æœ¬èº«å¯ä»¥ä½œä¸ºä¸€ä¸ªå­—æ¯
                dp[i] += dp[i - 1]
            if d == '1' or (d == '2' and c <= '5'):
                # 2. s[i] å’Œ s[i - 1] ç»“åˆèµ·æ¥è¡¨ç¤ºä¸€ä¸ªå­—æ¯
                dp[i] += dp[i - 2]
        return dp[n]
```

https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    string minNumber(vector<int>& nums) {
        int n = nums.size();
        vector<string> strs(n);
        for (int i = 0; i < n; i++) {
            strs[i] = to_string(nums[i]);
        }
        sort(strs.begin(), strs.end(), [](const string& s1, const string& s2) {
            // çœ‹çœ‹é‚£ç§æ‹¼æ¥æ–¹å¼å¾—åˆ°çš„æ•°å­—æ›´å°ï¼Œæ’å‰é¢
            // ä¸ç”¨è½¬æˆ int ç±»å‹ï¼Œå› ä¸ºå­—ç¬¦ä¸²çš„æ¯”è¾ƒç®—æ³•å’Œæ­£æ•´æ•°çš„æ¯”è¾ƒç®—æ³•æ˜¯ä¸€æ ·çš„
            // è€Œä¸”æ‹¼æ¥å­—ç¬¦ä¸²æ¯”è¾ƒé•¿ï¼Œä¼šå¯¼è‡´ int ç±»å‹æº¢å‡º
            return (s1 + s2) < (s2 + s1);
        });

        return accumulate(strs.begin(), strs.end(), string(""));
    }
};
```

```go
// by chatGPT (go)
func minNumber(nums []int) string {
    n := len(nums)
    strs := make([]string, n)
    for i := 0; i < n; i++ {
        strs[i] = strconv.Itoa(nums[i])
    }
    sort.Slice(strs, func(i, j int) bool {
        // çœ‹çœ‹é‚£ç§æ‹¼æ¥æ–¹å¼å¾—åˆ°çš„æ•°å­—æ›´å°ï¼Œæ’å‰é¢
        // ä¸ç”¨è½¬æˆ int ç±»å‹ï¼Œå› ä¸ºå­—ç¬¦ä¸²çš„æ¯”è¾ƒç®—æ³•å’Œæ­£æ•´æ•°çš„æ¯”è¾ƒç®—æ³•æ˜¯ä¸€æ ·çš„
        // è€Œä¸”æ‹¼æ¥å­—ç¬¦ä¸²æ¯”è¾ƒé•¿ï¼Œä¼šå¯¼è‡´ int ç±»å‹æº¢å‡º
        return strs[i]+strs[j] < strs[j]+strs[i]
    })

    return strings.Join(strs, "")
}
```

```java
// by labuladong (java)
class Solution {
    public String minNumber(int[] nums) {
        int n = nums.length;
        String[] strs = new String[n];
        for (int i = 0; i < n; i++) {
            strs[i] = Integer.toString(nums[i]);
        }
        Arrays.sort(strs, (s1, s2) -> {
            // çœ‹çœ‹é‚£ç§æ‹¼æ¥æ–¹å¼å¾—åˆ°çš„æ•°å­—æ›´å°ï¼Œæ’å‰é¢
            // ä¸ç”¨è½¬æˆ int ç±»å‹ï¼Œå› ä¸ºå­—ç¬¦ä¸²çš„æ¯”è¾ƒç®—æ³•å’Œæ­£æ•´æ•°çš„æ¯”è¾ƒç®—æ³•æ˜¯ä¸€æ ·çš„
            // è€Œä¸”æ‹¼æ¥å­—ç¬¦ä¸²æ¯”è¾ƒé•¿ï¼Œä¼šå¯¼è‡´ int ç±»å‹æº¢å‡º
            return (s1 + s2).compareTo(s2 + s1);
        });

        return String.join("", strs);
    }
}
```

```javascript
// by chatGPT (javascript)
var minNumber = function(nums) {
    const n = nums.length;
    const strs = new Array(n);
    for (let i = 0; i < n; i++) {
        strs[i] = nums[i].toString();
    }
    strs.sort((s1, s2) => {
        // çœ‹çœ‹é‚£ç§æ‹¼æ¥æ–¹å¼å¾—åˆ°çš„æ•°å­—æ›´å°ï¼Œæ’å‰é¢
        // ä¸ç”¨è½¬æˆ int ç±»å‹ï¼Œå› ä¸ºå­—ç¬¦ä¸²çš„æ¯”è¾ƒç®—æ³•å’Œæ­£æ•´æ•°çš„æ¯”è¾ƒç®—æ³•æ˜¯ä¸€æ ·çš„
        // è€Œä¸”æ‹¼æ¥å­—ç¬¦ä¸²æ¯”è¾ƒé•¿ï¼Œä¼šå¯¼è‡´ int ç±»å‹æº¢å‡º
        return (s1 + s2).localeCompare(s2 + s1);
    });

    return strs.join("");
}
```

```python
# by chatGPT (python)
class Solution:
    def minNumber(self, nums: List[int]) -> str:
        n = len(nums)
        strs = [str(num) for num in nums]

        def compare(s1: str, s2: str) -> int:
            # çœ‹çœ‹é‚£ç§æ‹¼æ¥æ–¹å¼å¾—åˆ°çš„æ•°å­—æ›´å°ï¼Œæ’å‰é¢
            # ä¸ç”¨è½¬æˆ int ç±»å‹ï¼Œå› ä¸ºå­—ç¬¦ä¸²çš„æ¯”è¾ƒç®—æ³•å’Œæ­£æ•´æ•°çš„æ¯”è¾ƒç®—æ³•æ˜¯ä¸€æ ·çš„
            # è€Œä¸”æ‹¼æ¥å­—ç¬¦ä¸²æ¯”è¾ƒé•¿ï¼Œä¼šå¯¼è‡´ int ç±»å‹æº¢å‡º
            return -1 if s1 + s2 < s2 + s1 else 1

        strs.sort(key=functools.cmp_to_key(compare))

        return ''.join(strs)
```

https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int strToInt(string str) {
        int n = str.length();
        int i = 0;
        // è®°å½•æ­£è´Ÿå·
        int sign = 1;
        // ç”¨ long é¿å… int æº¢å‡º
        long res = 0;
        // è·³è¿‡å‰å¯¼ç©ºæ ¼
        while (i < n && str[i] == ' ') {
            i++;
        }
        if (i == n) {
            return 0;
        }

        // è®°å½•ç¬¦å·ä½
        if (str[i] == '-') {
            sign = -1;
            i++;
        } else if (str[i] == '+') {
            i++;
        }
        if (i == n) {
            return 0;
        }

        // ç»Ÿè®¡æ•°å­—ä½
        while (i < n && '0' <= str[i] && str[i] <= '9') {
            res = res * 10 + str[i] - '0';
            if (res > INT_MAX) {
                break;
            }
            i++;
        }
        // å¦‚æœæº¢å‡ºï¼Œå¼ºè½¬æˆ int å°±ä¼šå’ŒçœŸå®å€¼ä¸åŒ
        if ((int) res != res) {
            return sign == 1 ? INT_MAX : INT_MIN;
        }
        return (int) res * sign;
    }
};
```

```go
// by chatGPT (go)
func myAtoi(str string) int {
    n := len(str)
    i := 0
    // è®°å½•æ­£è´Ÿå·
    sign := 1
    // ç”¨ long é¿å… int æº¢å‡º
    var res int64 = 0
    // è·³è¿‡å‰å¯¼ç©ºæ ¼
    for i < n && str[i] == ' ' {
        i++
    }
    if i == n {
        return 0
    }

    // è®°å½•ç¬¦å·ä½
    if str[i] == '-' {
        sign = -1
        i++
    } else if str[i] == '+' {
        i++
    }
    if i == n {
        return 0
    }

    // ç»Ÿè®¡æ•°å­—ä½
    for i < n && '0' <= str[i] && str[i] <= '9' {
        res = res * 10 + int64(str[i]-'0')
        if res > math.MaxInt32 {
            break
        }
        i++
    }
    // å¦‚æœæº¢å‡ºï¼Œå¼ºè½¬æˆ int å°±ä¼šå’ŒçœŸå®å€¼ä¸åŒ
    if int(res) != res {
        if sign == 1 {
            return math.MaxInt32
        } else {
            return math.MinInt32
        }
    }
    return int(res) * sign
}
```

```java
// by labuladong (java)
class Solution {
    public int myAtoi(String str) {
        int n = str.length();
        int i = 0;
        // è®°å½•æ­£è´Ÿå·
        int sign = 1;
        // ç”¨ long é¿å… int æº¢å‡º
        long res = 0;
        // è·³è¿‡å‰å¯¼ç©ºæ ¼
        while (i < n && str.charAt(i) == ' ') {
            i++;
        }
        if (i == n) {
            return 0;
        }

        // è®°å½•ç¬¦å·ä½
        if (str.charAt(i) == '-') {
            sign = -1;
            i++;
        } else if (str.charAt(i) == '+') {
            i++;
        }
        if (i == n) {
            return 0;
        }

        // ç»Ÿè®¡æ•°å­—ä½
        while (i < n && '0' <= str.charAt(i) && str.charAt(i) <= '9') {
            res = res * 10 + str.charAt(i) - '0';
            if (res > Integer.MAX_VALUE) {
                break;
            }
            i++;
        }
        // å¦‚æœæº¢å‡ºï¼Œå¼ºè½¬æˆ int å°±ä¼šå’ŒçœŸå®å€¼ä¸åŒ
        if ((int) res != res) {
            return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
        }
        return (int) res * sign;
    }
}
```

```javascript
// by chatGPT (javascript)
var myAtoi = function(str) {
    let n = str.length;
    let i = 0;
    // è®°å½•æ­£è´Ÿå·
    let sign = 1;
    // ç”¨ BigInt é¿å… int æº¢å‡º
    let res = BigInt(0);
    // è·³è¿‡å‰å¯¼ç©ºæ ¼
    while (i < n && str[i] === ' ') {
        i++;
    }
    if (i === n) {
        return 0;
    }

    // è®°å½•ç¬¦å·ä½
    if (str[i] === '-') {
        sign = -1;
        i++;
    } else if (str[i] === '+') {
        i++;
    }
    if (i === n) {
        return 0;
    }

    // ç»Ÿè®¡æ•°å­—ä½
    while (i < n && '0' <= str[i] && str[i] <= '9') {
        res = res * BigInt(10) + BigInt(str[i].charCodeAt() - '0'.charCodeAt());
        if (res > BigInt(Number.MAX_VALUE)) {
            break;
        }
        i++;
    }
    // å¦‚æœæº¢å‡ºï¼Œå¼ºè½¬æˆ int å°±ä¼šå’ŒçœŸå®å€¼ä¸åŒ
    if (res > BigInt(Number.MAX_VALUE)) {
        return sign === 1 ? Number.MAX_VALUE : Number.MIN_VALUE;
    }
    return Number(res) * sign;
};
```

```python
# by chatGPT (python)
class Solution:
    def myAtoi(self, s: str) -> int:
        n = len(s)
        i = 0
        # è®°å½•æ­£è´Ÿå·
        sign = 1
        # ç”¨ long é¿å… int æº¢å‡º
        res = 0
        # è·³è¿‡å‰å¯¼ç©ºæ ¼
        while i < n and s[i] == ' ':
            i += 1
        if i == n:
            return 0

        # è®°å½•ç¬¦å·ä½
        if s[i] == '-':
            sign = -1
            i += 1
        elif s[i] == '+':
            i += 1
        if i == n:
            return 0

        # ç»Ÿè®¡æ•°å­—ä½
        while i < n and '0' <= s[i] <= '9':
            res = res * 10 + ord(s[i]) - ord('0')
            if res > pow(2, 31) - 1:
                break
            i += 1
        # å¦‚æœæº¢å‡ºï¼Œå¼ºè½¬æˆ int å°±ä¼šå’ŒçœŸå®å€¼ä¸åŒ
        if res != int(res):
            return sign == 1 and pow(2, 31) - 1 or -pow(2, 31)
        return int(res) * sign
```

https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
// åŸå§‹æ€è·¯
class MinStack1 {
    // è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    stack<int> stk;
    // é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
    stack<int> minStk;

public:
    void push(int val) {
        stk.push(val);
        // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        if (minStk.empty() || val <= minStk.top()) {
            // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
            minStk.push(val);
        }
        else {
            // æ’å…¥çš„è¿™ä¸ªå…ƒç´ æ¯”è¾ƒå¤§
            minStk.push(minStk.top());
        }
    }

    void pop() {
        stk.pop();
        minStk.pop();
    }

    int top() {
        return stk.top();
    }

    int getMin() {
        // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        return minStk.top();
    }
};
// ä¼˜åŒ–ç‰ˆ
class MinStack {
    // è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    stack<int> stk;
    // é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
    stack<int> minStk;

public:
    void push(int val) {
        stk.push(val);
        // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        if (minStk.empty() || val <= minStk.top()) {
            // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
            minStk.push(val);
        }
    }

    void pop() {
        // æ³¨æ„ Java çš„è¯­è¨€ç‰¹æ€§ï¼Œæ¯”è¾ƒ Integer ç›¸ç­‰è¦ç”¨ equals æ–¹æ³•
        if (stk.top() == minStk.top()) {
            // å¼¹å‡ºçš„å…ƒç´ æ˜¯å…¨æ ˆæœ€å°çš„
            minStk.pop();
        }
        stk.pop();
    }

    int top() {
        return stk.top();
    }

    int getMin() {
        // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        return minStk.top();
    }
};
```

```go
// by chatGPT (go)
type MinStack1 struct {
    stk    []int
    minStk []int
}

func (this *MinStack1) Push(val int) {
    this.stk = append(this.stk, val)
    // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    if len(this.minStk) == 0 || val <= this.minStk[len(this.minStk)-1] {
        // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
        this.minStk = append(this.minStk, val)
    } else {
        // æ’å…¥çš„è¿™ä¸ªå…ƒç´ æ¯”è¾ƒå¤§
        this.minStk = append(this.minStk, this.minStk[len(this.minStk)-1])
    }
}

func (this *MinStack1) Pop() {
    this.stk = this.stk[:len(this.stk)-1]
    this.minStk = this.minStk[:len(this.minStk)-1]
}

func (this *MinStack1) Top() int {
    return this.stk[len(this.stk)-1]
}

func (this *MinStack1) GetMin() int {
    // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    return this.minStk[len(this.minStk)-1]
}

type MinStack struct {
    stk    []int
    minStk []int
}

func (this *MinStack) Push(val int) {
    this.stk = append(this.stk, val)
    // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    if len(this.minStk) == 0 || val <= this.minStk[len(this.minStk)-1] {
        // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
        this.minStk = append(this.minStk, val)
    }
}

func (this *MinStack) Pop() {
    // æ³¨æ„ go çš„è¯­è¨€ç‰¹æ€§ï¼Œæ¯”è¾ƒ int ç›¸ç­‰å¯ä»¥ç›´æ¥ä½¿ç”¨ ==
    if this.stk[len(this.stk)-1] == this.minStk[len(this.minStk)-1] {
        // å¼¹å‡ºçš„å…ƒç´ æ˜¯å…¨æ ˆæœ€å°çš„
        this.minStk = this.minStk[:len(this.minStk)-1]
    }
    this.stk = this.stk[:len(this.stk)-1]
}

func (this *MinStack) Top() int {
    return this.stk[len(this.stk)-1]
}

func (this *MinStack) GetMin() int {
    // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    return this.minStk[len(this.minStk)-1]
}
```

```java
// by labuladong (java)
// åŸå§‹æ€è·¯
class MinStack1 {
    // è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    Stack<Integer> stk = new Stack<>();
    // é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
    Stack<Integer> minStk = new Stack<>();

    public void push(int val) {
        stk.push(val);
        // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        if (minStk.isEmpty() || val <= minStk.peek()) {
            // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
            minStk.push(val);
        } else {
            // æ’å…¥çš„è¿™ä¸ªå…ƒç´ æ¯”è¾ƒå¤§
            minStk.push(minStk.peek());
        }
    }
    
    public void pop() {
        stk.pop();
        minStk.pop();
    }
    
    public int top() {
        return stk.peek();
    }
    
    public int getMin() {
        // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        return minStk.peek();
    }
}
// ä¼˜åŒ–ç‰ˆ
class MinStack {
    // è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    Stack<Integer> stk = new Stack<>();
    // é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
    Stack<Integer> minStk = new Stack<>();

    public void push(int val) {
        stk.push(val);
        // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        if (minStk.isEmpty() || val <= minStk.peek()) {
            // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
            minStk.push(val);
        }
    }

    public void pop() {
        // æ³¨æ„ Java çš„è¯­è¨€ç‰¹æ€§ï¼Œæ¯”è¾ƒ Integer ç›¸ç­‰è¦ç”¨ equals æ–¹æ³•
        if (stk.peek().equals(minStk.peek())) {
            // å¼¹å‡ºçš„å…ƒç´ æ˜¯å…¨æ ˆæœ€å°çš„
            minStk.pop();
        }
        stk.pop();
    }

    public int top() {
        return stk.peek();
    }

    public int getMin() {
        // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        return minStk.peek();
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @constructor
 */
var MinStack1 = function() {
    // è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    this.stk = [];
    // é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
    this.minStk = [];
};

/**
 * @param {number} val
 * @return {void}
 */
MinStack1.prototype.push = function(val) {
    this.stk.push(val);
    // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    if (this.minStk.length === 0 || val <= this.minStk[this.minStk.length - 1]) {
        // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
        this.minStk.push(val);
    } else {
        // æ’å…¥çš„è¿™ä¸ªå…ƒç´ æ¯”è¾ƒå¤§
        this.minStk.push(this.minStk[this.minStk.length - 1]);
    }
};

/**
 * @return {void}
 */
MinStack1.prototype.pop = function() {
    this.stk.pop();
    this.minStk.pop();
};

/**
 * @return {number}
 */
MinStack1.prototype.top = function() {
    return this.stk[this.stk.length - 1];
};

/**
 * @return {number}
 */
MinStack1.prototype.getMin = function() {
    // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    return this.minStk[this.minStk.length - 1];
};

/**
 * @constructor
 */
var MinStack = function() {
    // è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    this.stk = [];
    // é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
    this.minStk = [];
};

/**
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function(val) {
    this.stk.push(val);
    // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    if (this.minStk.length === 0 || val <= this.minStk[this.minStk.length - 1]) {
        // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
        this.minStk.push(val);
    }
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    // æ³¨æ„ JavaScript çš„è¯­è¨€ç‰¹æ€§ï¼Œæ¯”è¾ƒ Number å¯ä»¥ç›´æ¥ä½¿ç”¨ ===
    if (this.stk[this.stk.length - 1] === this.minStk[this.minStk.length - 1]) {
        // å¼¹å‡ºçš„å…ƒç´ æ˜¯å…¨æ ˆæœ€å°çš„
        this.minStk.pop();
    }
    this.stk.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.stk[this.stk.length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
    // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    return this.minStk[this.minStk.length - 1];
};
```

```python
# by chatGPT (python)
# åŸå§‹æ€è·¯
class MinStack1:
    def __init__(self):
        # è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
        self.stk = []
        # é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
        self.minStk = []

    def push(self, val: int) -> None:
        self.stk.append(val)
        # ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        if not self.minStk or val <= self.minStk[-1]:
            # æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
            self.minStk.append(val)
        else:
            # æ’å…¥çš„è¿™ä¸ªå…ƒç´ æ¯”è¾ƒå¤§
            self.minStk.append(self.minStk[-1])
    
    def pop(self) -> None:
        self.stk.pop()
        self.minStk.pop()
    
    def top(self) -> int:
        return self.stk[-1]
    
    def getMin(self) -> int:
        # minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        return self.minStk[-1]


# ä¼˜åŒ–ç‰ˆ
class MinStack:
    def __init__(self):
        # è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
        self.stk = []
        # é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
        self.minStk = []

    def push(self, val: int) -> None:
        self.stk.append(val)
        # ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        if not self.minStk or val <= self.minStk[-1]:
            # æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
            self.minStk.append(val)

    def pop(self) -> None:
        # æ³¨æ„ Python çš„è¯­è¨€ç‰¹æ€§ï¼Œæ¯”è¾ƒ Integer ç›¸ç­‰ä¸éœ€è¦è°ƒç”¨ equals æ–¹æ³•
        if self.stk[-1] == self.minStk[-1]:
            # å¼¹å‡ºçš„å…ƒç´ æ˜¯å…¨æ ˆæœ€å°çš„
            self.minStk.pop()
        self.stk.pop()

    def top(self) -> int:
        return self.stk[-1]

    def getMin(self) -> int:
        # minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        return self.minStk[-1]
```

https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2));
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][1], -prices[i]);
        }
        return dp[n - 1][0];
    }
};
```

```go
// by chatGPT (go)
func maxProfit(prices []int) int {
    n := len(prices)
    dp := make([][]int, n)
    for i := 0; i < n; i++ {
        dp[i] = make([]int, 2)
        if i - 1 == -1 {
            // base case
            dp[i][0] = 0
            dp[i][1] = -prices[i]
            continue
        }
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
        dp[i][1] = max(dp[i-1][1], -prices[i])
    }
    return dp[n-1][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
        }
        return dp[n - 1][0];
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    const n = prices.length;
    const dp = new Array(n).map(() => new Array(2));
    for (let i = 0; i < n; i++) {
        if (i - 1 === -1) {
            // base case
            dp[i][0] = 0;
            dp[i][1] = -prices[i];
            continue;
        }
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
    }
    return dp[n - 1][0];
};
```

```python
# by chatGPT (python)
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0] * 2 for _ in range(n)]
        for i in range(n):
            if i - 1 == -1:
                # base case
                dp[i][0] = 0
                dp[i][1] = -prices[i]
                continue
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            dp[i][1] = max(dp[i - 1][1], -prices[i])
        return dp[n - 1][0]
```

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2));
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
};
```

```go
// by chatGPT (go)
func maxProfit(prices []int) int {
    n := len(prices)
    dp := make([][]int, n)
    for i := 0; i < n; i++ {
        dp[i] = make([]int, 2)
        if i-1 == -1 {
            // base case
            dp[i][0] = 0
            dp[i][1] = -prices[i]
            continue
        }
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
    }
    return dp[n-1][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
}
```

```javascript
// by chatGPT (javascript)
var maxProfit = function(prices) {
    const n = prices.length;
    const dp = new Array(n).fill(0).map(() => new Array(2).fill(0));
    for (let i = 0; i < n; i++) {
        if (i - 1 === -1) {
            // base case
            dp[i][0] = 0;
            dp[i][1] = -prices[i];
            continue;
        }
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    return dp[n - 1][0];
};
```

```python
# by chatGPT (python)
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0] * 2 for _ in range(n)]
        for i in range(n):
            if i - 1 == -1:
                dp[i][0] = 0
                dp[i][1] = -prices[i]
                continue
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
        return dp[n - 1][0]
```

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int max_k = 2, n = prices.size();
        int dp[n][max_k + 1][2];
        for (int i = 0; i < n; i++) {
            for (int k = max_k; k >= 1; k--) {
                if (i - 1 == -1) {
                    // å¤„ç† base case
                    dp[i][k][0] = 0;
                    dp[i][k][1] = -prices[i];
                    continue;
                }
                dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
                dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
            }
        }
        // ç©·ä¸¾äº† n Ã— max_k Ã— 2 ä¸ªçŠ¶æ€ï¼Œæ­£ç¡®ã€‚
        return dp[n - 1][max_k][0];
    }
};
```

```go
// by chatGPT (go)
func maxProfit(prices []int) int {
    max_k, n := 2, len(prices)
    dp := make([][][]int, n)
    for i := range dp {
        dp[i] = make([][]int, max_k+1)
        for j := range dp[i] {
            dp[i][j] = make([]int, 2)
        }
    }
    for i := 0; i < n; i++ {
        for k := max_k; k >= 1; k-- {
            if i-1 == -1 {
                // å¤„ç† base case
                dp[i][k][0] = 0
                dp[i][k][1] = -prices[i]
                continue
            }
            dp[i][k][0] = func() int {
                if dp[i-1][k][0] > dp[i-1][k][1]+prices[i] {
                    return dp[i-1][k][0]
                }
                return dp[i-1][k][1] + prices[i]
            }()
            dp[i][k][1] = func() int {
                if dp[i-1][k][1] > dp[i-1][k-1][0]-prices[i] {
                    return dp[i-1][k][1]
                }
                return dp[i-1][k-1][0] - prices[i]
            }()
        }
    }
    // ç©·ä¸¾äº† n Ã— max_k Ã— 2 ä¸ªçŠ¶æ€ï¼Œæ­£ç¡®ã€‚
    return dp[n-1][max_k][0]
}
```

```java
// by labuladong (java)
class Solution {
    public int maxProfit(int[] prices) {
        int max_k = 2, n = prices.length;
        int[][][] dp = new int[n][max_k + 1][2];
        for (int i = 0; i < n; i++) {
            for (int k = max_k; k >= 1; k--) {
                if (i - 1 == -1) {
                    // å¤„ç† base case
                    dp[i][k][0] = 0;
                    dp[i][k][1] = -prices[i];
                    continue;
                }
                dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
                dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
            }
        }
        // ç©·ä¸¾äº† n Ã— max_k Ã— 2 ä¸ªçŠ¶æ€ï¼Œæ­£ç¡®ã€‚
        return dp[n - 1][max_k][0];
    }
}
```

```javascript
// by chatGPT (javascript)
var maxProfit = function(prices) {
    let max_k = 2, n = prices.length;
    let dp = Array(n).fill().map(() => Array(max_k + 1).fill().map(() => Array(2).fill(0)));
    for (let i = 0; i < n; i++) {
        for (let k = max_k; k >= 1; k--) {
            if (i - 1 == -1) {
                // å¤„ç† base case
                dp[i][k][0] = 0;
                dp[i][k][1] = -prices[i];
                continue;
            }
            dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
            dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
        }
    }
    // ç©·ä¸¾äº† n Ã— max_k Ã— 2 ä¸ªçŠ¶æ€ï¼Œæ­£ç¡®ã€‚
    return dp[n - 1][max_k][0];
};
```

```python
# by chatGPT (python)
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_k = 2
        n = len(prices)
        dp = [[[0 for _ in range(2)] for _ in range(max_k + 1)] for _ in range(n)]
        for i in range(n):
            for k in range(max_k, 0, -1):
                if i - 1 == -1:
                    # å¤„ç† base case
                    dp[i][k][0] = 0
                    dp[i][k][1] = -prices[i]
                    continue
                dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
                dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
        # ç©·ä¸¾äº† n Ã— max_k Ã— 2 ä¸ªçŠ¶æ€ï¼Œæ­£ç¡®ã€‚
        return dp[n - 1][max_k][0]
```

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxProfit(int max_k, vector<int>& prices) {
        int n = prices.size();
        if (n <= 0) {
            return 0;
        }
        if (max_k > n / 2) {
            // äº¤æ˜“æ¬¡æ•° k æ²¡æœ‰é™åˆ¶çš„æƒ…å†µ
            return maxProfit_k_inf(prices);
        }

        // base caseï¼š
        // dp[-1][...][0] = dp[...][0][0] = 0
        // dp[-1][...][1] = dp[...][0][1] = -infinity
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(max_k + 1, vector<int>(2)));
        // k = 0 æ—¶çš„ base case
        for (int i = 0; i < n; i++) {
            dp[i][0][1] = INT_MIN;
            dp[i][0][0] = 0;
        }

        for (int i = 0; i < n; i++) {
            for (int k = max_k; k >= 1; k--) {
                if (i - 1 == -1) {
                    // å¤„ç† i = -1 æ—¶çš„ base case
                    dp[i][k][0] = 0;
                    dp[i][k][1] = -prices[i];
                    continue;
                }
                // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
                dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);
                dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);
            }
        }
        return dp[n - 1][max_k][0];
    }

private:
    // ç¬¬ 122 é¢˜ï¼Œk æ— é™çš„è§£æ³•
    int maxProfit_k_inf(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2));
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
};
```

```go
// by chatGPT (go)
func maxProfit(max_k int, prices []int) int {
    n := len(prices)
    if n <= 0 {
        return 0
    }
    if max_k > n/2 {
        // äº¤æ˜“æ¬¡æ•° k æ²¡æœ‰é™åˆ¶çš„æƒ…å†µ
        return maxProfitKInf(prices)
    }

    // base caseï¼š
    // dp[-1][...][0] = dp[...][0][0] = 0
    // dp[-1][...][1] = dp[...][0][1] = -infinity
    dp := make([][][]int, n)
    for i := 0; i < n; i++ {
        dp[i] = make([][]int, max_k+1)
        for k := 0; k <= max_k; k++ {
            dp[i][k] = make([]int, 2)
        }
    }

    // k = 0 æ—¶çš„ base case
    for i := 0; i < n; i++ {
        dp[i][0][1] = -1 << 31
        dp[i][0][0] = 0
    }

    for i := 0; i < n; i++ {
        for k := max_k; k >= 1; k-- {
            if i-1 == -1 {
                // å¤„ç† i = -1 æ—¶çš„ base case
                dp[i][k][0] = 0
                dp[i][k][1] = -prices[i]
                continue
            }
            // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
            dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]+prices[i])
            dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i])
        }
    }
    return dp[n-1][max_k][0]
}

// ç¬¬ 122 é¢˜ï¼Œk æ— é™çš„è§£æ³•
func maxProfitKInf(prices []int) int {
    n := len(prices)
    dp := make([][]int, n)
    for i := 0; i < n; i++ {
        dp[i] = make([]int, 2)
    }

    for i := 0; i < n; i++ {
        if i-1 == -1 {
            // base case
            dp[i][0] = 0
            dp[i][1] = -prices[i]
            continue
        }
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
    }
    return dp[n-1][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int maxProfit(int max_k, int[] prices) {
        int n = prices.length;
        if (n <= 0) {
            return 0;
        }
        if (max_k > n / 2) {
            // äº¤æ˜“æ¬¡æ•° k æ²¡æœ‰é™åˆ¶çš„æƒ…å†µ
            return maxProfit_k_inf(prices);
        }

        // base caseï¼š
        // dp[-1][...][0] = dp[...][0][0] = 0
        // dp[-1][...][1] = dp[...][0][1] = -infinity
        int[][][] dp = new int[n][max_k + 1][2];
        // k = 0 æ—¶çš„ base case
        for (int i = 0; i < n; i++) {
            dp[i][0][1] = Integer.MIN_VALUE;
            dp[i][0][0] = 0;
        }

        for (int i = 0; i < n; i++)
            for (int k = max_k; k >= 1; k--) {
                if (i - 1 == -1) {
                    // å¤„ç† i = -1 æ—¶çš„ base case
                    dp[i][k][0] = 0;
                    dp[i][k][1] = -prices[i];
                    continue;
                }
                // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
                dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);
                dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);
            }
        return dp[n - 1][max_k][0];
    }

    // ç¬¬ 122 é¢˜ï¼Œk æ— é™çš„è§£æ³•
    private int maxProfit_k_inf(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
}
```

```javascript
// by chatGPT (javascript)
var maxProfit = function(max_k, prices) {
    var n = prices.length;
    if (n <= 0) {
        return 0;
    }
    if (max_k > Math.floor(n / 2)) {
        // äº¤æ˜“æ¬¡æ•° k æ²¡æœ‰é™åˆ¶çš„æƒ…å†µ
        return maxProfit_k_inf(prices);
    }

    // base caseï¼š
    // dp[-1][...][0] = dp[...][0][0] = 0
    // dp[-1][...][1] = dp[...][0][1] = -infinity
    var dp = new Array(n).fill(0).map(()=>new Array(max_k + 1).fill(0).map(()=>new Array(2).fill(0)));
    // k = 0 æ—¶çš„ base case
    for (var i = 0; i < n; i++) {
        dp[i][0][1] = Number.NEGATIVE_INFINITY;
        dp[i][0][0] = 0;
    }

    for (var i = 0; i < n; i++)
        for (var k = max_k; k >= 1; k--) {
            if (i - 1 == -1) {
                // å¤„ç† i = -1 æ—¶çš„ base case
                dp[i][k][0] = 0;
                dp[i][k][1] = -prices[i];
                continue;
            }
            // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
            dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);
            dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);
        }
    return dp[n - 1][max_k][0];
}

// ç¬¬ 122 é¢˜ï¼Œk æ— é™çš„è§£æ³•
var maxProfit_k_inf = function(prices) {
    var n = prices.length;
    var dp = new Array(n).fill(0).map(()=>new Array(2).fill(0));
    for (var i = 0; i < n; i++) {
        if (i - 1 == -1) {
            // base case
            dp[i][0] = 0;
            dp[i][1] = -prices[i];
            continue;
        }
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    return dp[n - 1][0];
}
```

```python
# by chatGPT (python)
class Solution:
    def maxProfit(self, max_k: int, prices: List[int]) -> int:
        n = len(prices)
        if n <= 0:
            return 0
        if max_k > n // 2:
            # äº¤æ˜“æ¬¡æ•° k æ²¡æœ‰é™åˆ¶çš„æƒ…å†µ
            return self.maxProfit_k_inf(prices)

        # base caseï¼š
        # dp[-1][...][0] = dp[...][0][0] = 0
        # dp[-1][...][1] = dp[...][0][1] = -infinity
        dp = [[[0] * 2 for _ in range(max_k + 1)] for _ in range(n)]
        # k = 0 æ—¶çš„ base case
        for i in range(n):
            dp[i][0][1] = float('-inf')
            dp[i][0][0] = 0

        for i in range(n):
            for k in range(max_k, 0, -1):
                if i - 1 == -1:
                    # å¤„ç† i = -1 æ—¶çš„ base case
                    dp[i][k][0] = 0
                    dp[i][k][1] = -prices[i]
                    continue
                # çŠ¶æ€è½¬ç§»æ–¹ç¨‹
                dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i])
                dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i])
        return dp[n - 1][max_k][0]

    # ç¬¬ 122 é¢˜ï¼Œk æ— é™çš„è§£æ³•
    def maxProfit_k_inf(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0] * 2 for _ in range(n)]
        for i in range(n):
            if i - 1 == -1:
                # base case
                dp[i][0] = 0
                dp[i][1] = -prices[i]
                continue
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
        return dp[n - 1][0]
```

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2));
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case 1
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            if (i - 2 == -1) {
                // base case 2
                dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                // i - 2 å°äº 0 æ—¶æ ¹æ®çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ¨å‡ºå¯¹åº” base case
                dp[i][1] = max(dp[i - 1][1], -prices[i]);
                //   dp[i][1]
                // = max(dp[i-1][1], dp[-1][0] - prices[i])
                // = max(dp[i-1][1], 0 - prices[i])
                // = max(dp[i-1][1], -prices[i])
                continue;
            }
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
};
```

```go
// by chatGPT (go)
func maxProfit(prices []int) int {
    n := len(prices)
    dp := make([][2]int, n)
    for i := 0; i < n; i++ {
        if i-1 == -1 {
            // base case 1
            dp[i][0] = 0
            dp[i][1] = -prices[i]
            continue
        }
        if i-2 == -1 {
            // base case 2
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
            // i - 2 å°äº 0 æ—¶æ ¹æ®çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ¨å‡ºå¯¹åº” base case
            dp[i][1] = max(dp[i-1][1], -prices[i])
            //   dp[i][1]
            // = max(dp[i-1][1], dp[-1][0] - prices[i])
            // = max(dp[i-1][1], 0 - prices[i])
            // = max(dp[i-1][1], -prices[i])
            continue
        }
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i])
    }
    return dp[n-1][0]
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case 1
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            if (i - 2 == -1) {
                // base case 2
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                // i - 2 å°äº 0 æ—¶æ ¹æ®çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ¨å‡ºå¯¹åº” base case
                dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
                //   dp[i][1]
                // = max(dp[i-1][1], dp[-1][0] - prices[i])
                // = max(dp[i-1][1], 0 - prices[i])
                // = max(dp[i-1][1], -prices[i])
                continue;
            }
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let n = prices.length;
    let dp = Array.from(Array(n), () => new Array(2).fill(0));
    for (let i = 0; i < n; i++) {
        if (i - 1 == -1) {
            // base case 1
            dp[i][0] = 0;
            dp[i][1] = -prices[i];
            continue;
        }
        if (i - 2 == -1) {
            // base case 2
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            // i - 2 å°äº 0 æ—¶æ ¹æ®çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ¨å‡ºå¯¹åº” base case
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
            //   dp[i][1]
            // = max(dp[i-1][1], dp[-1][0] - prices[i])
            // = max(dp[i-1][1], 0 - prices[i])
            // = max(dp[i-1][1], -prices[i])
            continue;
        }
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);
    }
    return dp[n - 1][0];
};
```

```python
# by chatGPT (python)
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0]*2 for _ in range(n)]
        for i in range(n):
            if i - 1 == -1:
                # base case 1
                dp[i][0] = 0
                dp[i][1] = -prices[i]
                continue
            if i - 2 == -1:
                # base case 2
                dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
                # i - 2 å°äº 0 æ—¶æ ¹æ®çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ¨å‡ºå¯¹åº” base case
                dp[i][1] = max(dp[i - 1][1], -prices[i])
                #   dp[i][1]
                # = max(dp[i-1][1], dp[-1][0] - prices[i])
                # = max(dp[i-1][1], 0 - prices[i])
                # = max(dp[i-1][1], -prices[i])
                continue
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i])
        return dp[n - 1][0]
```

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2));
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i] - fee;
                //   dp[i][1]
                // = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee)
                // = max(dp[-1][1], dp[-1][0] - prices[i] - fee)
                // = max(-inf, 0 - prices[i] - fee)
                // = -prices[i] - fee
                continue;
            }
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
        }
        return dp[n - 1][0];
    }
};
```

```go
// by chatGPT (go)
func maxProfit(prices []int, fee int) int {
    n := len(prices)
    dp := make([][2]int, n)
    for i := 0; i < n; i++ {
        if i-1 == -1 {
            // base case
            dp[i][0] = 0
            dp[i][1] = -prices[i] - fee
            // dp[i][1]
            // = max(dp[i-1][1], dp[i-1][0]-prices[i]-fee)
            // = max(dp[-1][1], dp[-1][0]-prices[i]-fee)
            // = max(-inf, 0-prices[i]-fee)
            // = -prices[i]-fee
            continue
        }
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]-fee)
    }
    return dp[n-1][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i] - fee;
                //   dp[i][1]
                // = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee)
                // = max(dp[-1][1], dp[-1][0] - prices[i] - fee)
                // = max(-inf, 0 - prices[i] - fee)
                // = -prices[i] - fee
                continue;
            }
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
        }
        return dp[n - 1][0];
    }
}
```

```javascript
// by chatGPT (javascript)
var maxProfit = function(prices, fee) {
    const n = prices.length;
    const dp = new Array(n).map(() => new Array(2).fill(0));
    for (let i = 0; i < n; i++) {
        if (i - 1 === -1) {
            // base case
            dp[i][0] = 0;
            dp[i][1] = -prices[i] - fee;
            //   dp[i][1]
            // = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee)
            // = max(dp[-1][1], dp[-1][0] - prices[i] - fee)
            // = max(-inf, 0 - prices[i] - fee)
            // = -prices[i] - fee
            continue;
        }
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
    }
    return dp[n - 1][0];
};
```

```python
# by chatGPT (python)
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        dp = [[0]*2 for _ in range(n)]
        for i in range(n):
            if i - 1 == -1:
                # base case
                dp[i][0] = 0
                dp[i][1] = -prices[i] - fee
                #   dp[i][1]
                # = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee)
                # = max(dp[-1][1], dp[-1][0] - prices[i] - fee)
                # = max(-inf, 0 - prices[i] - fee)
                # = -prices[i] - fee
                continue
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee)
        return dp[n - 1][0]
```

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/binary-search çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // æ³¨æ„

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1; // æ³¨æ„
            else if (nums[mid] > target)
                right = mid - 1; // æ³¨æ„
        }
        return -1;
    }
};
```

```go
// by chatGPT (go)
func search(nums []int, target int) int {
    left := 0
    right := len(nums) - 1 // æ³¨æ„

    for left <= right {
        mid := left + (right - left) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1 // æ³¨æ„
        } else if nums[mid] > target {
            right = mid - 1 // æ³¨æ„
        }
    }
    return -1
}
```

```java
// by labuladong (java)
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1; // æ³¨æ„

        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1; // æ³¨æ„
            else if (nums[mid] > target)
                right = mid - 1; // æ³¨æ„
        }
        return -1;
    }
}
```

```javascript
// by chatGPT (javascript)
var search = function(nums, target) {
    var left = 0;
    var right = nums.length - 1; // æ³¨æ„

    while (left <= right) {
        var mid = left + Math.floor((right - left) / 2);
        if (nums[mid] == target)
            return mid;
        else if (nums[mid] < target)
            left = mid + 1; // æ³¨æ„
        else if (nums[mid] > target)
            right = mid - 1; // æ³¨æ„
    }
    return -1;
};
```

```python
# by chatGPT (python)
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1  # æ³¨æ„

        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1  # æ³¨æ„
            elif nums[mid] > target:
                right = mid - 1  # æ³¨æ„

        return -1
```

https://leetcode.cn/problems/binary-search çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    TreeNode* bstToGst(TreeNode* root) {
        traverse(root);
        return root;
    }

    // è®°å½•ç´¯åŠ å’Œ
    int sum = 0;
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        traverse(root->right);
        // ç»´æŠ¤ç´¯åŠ å’Œ
        sum += root->val;
        // å°† BST è½¬åŒ–æˆç´¯åŠ æ ‘
        root->val = sum;
        traverse(root->left);
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func bstToGst(root *TreeNode) *TreeNode {
    var sum int
    // å®šä¹‰ä¸­åºéå†å‡½æ•°ï¼Œå†…éƒ¨ç»´æŠ¤sumå˜é‡
    var traverse func(node *TreeNode)
    traverse = func(node *TreeNode) {
        if node == nil {
            return
        }
        traverse(node.Right)
        // ç»´æŠ¤ç´¯åŠ å’Œ
        sum += node.Val
        // å°†BSTè½¬åŒ–ä¸ºç´¯åŠ æ ‘
        node.Val = sum
        traverse(node.Left)
    }
    traverse(root)
    return root
}
```

```java
// by labuladong (java)
class Solution {
    public TreeNode bstToGst(TreeNode root) {
        traverse(root);
        return root;
    }

    // è®°å½•ç´¯åŠ å’Œ
    int sum = 0;
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        traverse(root.right);
        // ç»´æŠ¤ç´¯åŠ å’Œ
        sum += root.val;
        // å°† BST è½¬åŒ–æˆç´¯åŠ æ ‘
        root.val = sum;
        traverse(root.left);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var bstToGst = function(root) {
  let sum = 0;
  
  const traverse = function(root) {
    if (root == null) {
      return;
    }
    traverse(root.right);
    // ç»´æŠ¤ç´¯åŠ å’Œ
    sum += root.val;
    // å°† BST è½¬åŒ–æˆç´¯åŠ æ ‘
    root.val = sum;
    traverse(root.left);
  }
  
  traverse(root);
  return root;
};
```

```python
# by chatGPT (python)
class Solution:
    def bstToGst(self, root: TreeNode) -> TreeNode:
        # è®°å½•ç´¯åŠ å’Œ
        sum = 0
        
        # ä¸­åºéå†BSTï¼Œé€’å½’åœ°å¯¹BSTèŠ‚ç‚¹çš„å€¼è¿›è¡Œç´¯åŠ å’Œæ“ä½œ
        def traverse(root: TreeNode) -> None:
            nonlocal sum
            if not root:
                return
            traverse(root.right)
            # ç»´æŠ¤ç´¯åŠ å’Œ
            sum += root.val
            # å°† BST è½¬åŒ–æˆç´¯åŠ æ ‘
            root.val = sum
            traverse(root.left)
            
        traverse(root)
        return root
```

https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/binary-tree-inorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    /* åŠ¨æ€è§„åˆ’æ€è·¯ */
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„ä¸­åºéå†ç»“æœ
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        if (root == NULL) {
            return res;
        }
        vector<int> left = inorderTraversal(root->left);
        res.insert(res.end(), left.begin(), left.end());
        res.push_back(root->val);
        vector<int> right = inorderTraversal(root->right);
        res.insert(res.end(), right.begin(), right.end());
        return res;
    }

    /* å›æº¯ç®—æ³•æ€è·¯ */
    vector<int> res;

    // è¿”å›å‰åºéå†ç»“æœ
    vector<int> inorderTraversal2(TreeNode* root) {
        traverse(root);
        return res;
    }

    // äºŒå‰æ ‘éå†å‡½æ•°
    void traverse(TreeNode* root) {
        if (root == NULL) {
            return;
        }
        traverse(root->left);
        // ä¸­åºéå†ä½ç½®
        res.push_back(root->val);
        traverse(root->right);
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

// åŠ¨æ€è§„åˆ’æ€è·¯
// å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„ä¸­åºéå†ç»“æœ
func inorderTraversal(root *TreeNode) []int {
    res := []int{}
    if root == nil {
        return res
    }
    res = append(res, inorderTraversal(root.Left)...)
    res = append(res, root.Val)
    res = append(res, inorderTraversal(root.Right)...)
    return res
}

// å›æº¯ç®—æ³•æ€è·¯
func inorderTraversal2(root *TreeNode) []int {
    res := []int{}
    // äºŒå‰æ ‘éå†å‡½æ•°
    var traverse func(node *TreeNode)
    traverse = func(node *TreeNode) {
        if node == nil {
            return
        }
        traverse(node.Left)
        // ä¸­åºéå†ä½ç½®
        res = append(res, node.Val)
        traverse(node.Right)
    }

    traverse(root)
    return res
}
```

```java
// by labuladong (java)
class Solution {
    /* åŠ¨æ€è§„åˆ’æ€è·¯ */
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„ä¸­åºéå†ç»“æœ
    public List<Integer> inorderTraversal(TreeNode root) {
        LinkedList<Integer> res = new LinkedList<>();
        if (root == null) {
            return res;
        }
        res.addAll(inorderTraversal(root.left));
        res.add(root.val);
        res.addAll(inorderTraversal(root.right));
        return res;
    }

    /* å›æº¯ç®—æ³•æ€è·¯ */
    LinkedList<Integer> res = new LinkedList<>();

    // è¿”å›å‰åºéå†ç»“æœ
    public List<Integer> inorderTraversal2(TreeNode root) {
        traverse(root);
        return res;
    }

    // äºŒå‰æ ‘éå†å‡½æ•°
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        traverse(root.left);
        // ä¸­åºéå†ä½ç½®
        res.add(root.val);
        traverse(root.right);
    }
}
```

```javascript
// by chatGPT (javascript)
var inorderTraversal = function(root) {
    let res = new LinkedList();
    if (root === null) {
        return res;
    }
    res.addAll(inorderTraversal(root.left));
    res.add(root.val);
    res.addAll(inorderTraversal(root.right));
    return res;
};

var inorderTraversal2 = function(root) {
    let res = new LinkedList();
    if (root === null) {
        return res;
    }
    
    traverse(root);
    return res;
};

const traverse = function(root, res) {
    if (root === null) {
        return;
    }
    traverse(root.left, res);
    // ä¸­åºéå†ä½ç½®
    res.add(root.val);
    traverse(root.right, res);
}
```

```python
# by chatGPT (python)
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        """åŠ¨æ€è§„åˆ’æ€è·¯
        å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„ä¸­åºéå†ç»“æœ
        """
        res = []
        if not root:
            return res
        res += self.inorderTraversal(root.left)
        res.append(root.val)
        res += self.inorderTraversal(root.right)
        return res
    
    def inorderTraversal2(self, root: TreeNode) -> List[int]:
        """å›æº¯ç®—æ³•æ€è·¯"""
        self.res = []
        self.traverse(root)
        return self.res
    
    def traverse(self, root: TreeNode):
        """äºŒå‰æ ‘éå†å‡½æ•°"""
        if not root:
            return
        self.traverse(root.left)
        # ä¸­åºéå†ä½ç½®
        self.res.append(root.val)
        self.traverse(root.right)
```

https://leetcode.cn/problems/binary-tree-inorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/binary-tree-level-order-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (root == nullptr) {
            return res;
        }

        queue<TreeNode*> q;
        q.push(root);
        // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while (!q.empty()) {
            int sz = q.size();
            // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            vector<int> level;
            // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for (int i = 0; i < sz; i++) {
                TreeNode* cur = q.front();
                q.pop();
                level.push_back(cur->val);
                if (cur->left != nullptr)
                    q.push(cur->left);
                if (cur->right != nullptr)
                    q.push(cur->right);
            }
            res.push_back(level);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func levelOrder(root *TreeNode) [][]int {
    res := [][]int{}
    if root == nil {
        return res
    }

    q := []*TreeNode{root}
    // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
    for len(q) > 0 {
        sz := len(q)
        // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
        level := []int{}
        // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]
            level = append(level, cur.Val)
            if cur.Left != nil {
                q = append(q, cur.Left)
            }
            if cur.Right != nil {
                q = append(q, cur.Right)
            }
        }
        res = append(res, level)
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        if (root == null) {
            return res;
        }

        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while (!q.isEmpty()) {
            int sz = q.size();
            // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            List<Integer> level = new LinkedList<>();
            // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                level.add(cur.val);
                if (cur.left != null)
                    q.offer(cur.left);
                if (cur.right != null)
                    q.offer(cur.right);
            }
            res.add(level);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var levelOrder = function(root) {
    let res = [];
    if (root == null) {
        return res;
    }

    let q = [];
    q.push(root);
    // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
    while (q.length > 0) {
        let sz = q.length;
        // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
        let level = [];
        // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
        for (let i = 0; i < sz; i++) {
            let cur = q.shift();
            level.push(cur.val);
            if (cur.left != null)
                q.push(cur.left);
            if (cur.right != null)
                q.push(cur.right);
        }
        res.push(level);
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []
        if not root:
            return res

        q = []
        q.append(root)
        # while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while q:
            sz = len(q)
            # è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            level = []
            # for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for i in range(sz):
                cur = q.pop(0)
                level.append(cur.val)
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
            res.append(level)
        return res
```

https://leetcode.cn/problems/binary-tree-level-order-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/binary-tree-level-order-traversal-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> res;
        if (root == NULL) {
            return res;
        }

        queue<TreeNode*> q;
        q.push(root);
        // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while (!q.empty()) {
            int sz = q.size();
            // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            vector<int> level;
            // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for (int i = 0; i < sz; i++) {
                TreeNode* cur = q.front();
                q.pop();
                level.push_back(cur->val);
                if (cur->left != NULL)
                    q.push(cur->left);
                if (cur->right != NULL)
                    q.push(cur->right);
            }
            // æŠŠæ¯ä¸€å±‚æ·»åŠ åˆ°å¤´éƒ¨ï¼Œå°±æ˜¯è‡ªåº•å‘ä¸Šçš„å±‚åºéå†ã€‚
            res.insert(res.begin(), level);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func levelOrderBottom(root *TreeNode) [][]int {
    res := make([][]int, 0)
    if root == nil {
        return res
    }

    q := make([]*TreeNode, 0)
    q = append(q, root)
    // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
    for len(q) > 0 {
        sz := len(q)
        // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
        level := make([]int, 0)
        // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]
            level = append(level, cur.Val)
            if cur.Left != nil {
                q = append(q, cur.Left)
            }
            if cur.Right != nil {
                q = append(q, cur.Right)
            }
        }
        // æŠŠæ¯ä¸€å±‚æ·»åŠ åˆ°å¤´éƒ¨ï¼Œå°±æ˜¯è‡ªåº•å‘ä¸Šçš„å±‚åºéå†ã€‚
        res = append([][]int{level}, res...)
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        LinkedList<List<Integer>> res = new LinkedList<>();
        if (root == null) {
            return res;
        }

        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while (!q.isEmpty()) {
            int sz = q.size();
            // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            List<Integer> level = new LinkedList<>();
            // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                level.add(cur.val);
                if (cur.left != null)
                    q.offer(cur.left);
                if (cur.right != null)
                    q.offer(cur.right);
            }
            // æŠŠæ¯ä¸€å±‚æ·»åŠ åˆ°å¤´éƒ¨ï¼Œå°±æ˜¯è‡ªåº•å‘ä¸Šçš„å±‚åºéå†ã€‚
            res.addFirst(level);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var levelOrderBottom = function(root) {
    let res = [];
    if (root == null) {
        return res;
    }

    let q = [];
    q.push(root);
    // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
    while (q.length > 0) {
        let sz = q.length;
        // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
        let level = [];
        // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
        for (let i = 0; i < sz; i++) {
            let cur = q.shift();
            level.push(cur.val);
            if (cur.left != null)
                q.push(cur.left);
            if (cur.right != null)
                q.push(cur.right);
        }
        // æŠŠæ¯ä¸€å±‚æ·»åŠ åˆ°å¤´éƒ¨ï¼Œå°±æ˜¯è‡ªåº•å‘ä¸Šçš„å±‚åºéå†ã€‚
        res.unshift(level);
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        res = []
        if not root:
            return res
        
        q = collections.deque([root])
        # while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while q:
            sz = len(q)
            # è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            level = []
            # for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for i in range(sz):
                cur = q.popleft()
                level.append(cur.val)
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
            # æŠŠæ¯ä¸€å±‚æ·»åŠ åˆ°å¤´éƒ¨ï¼Œå°±æ˜¯è‡ªåº•å‘ä¸Šçš„å±‚åºéå†ã€‚
            res.insert(0, level)
        return res
```

https://leetcode.cn/problems/binary-tree-level-order-traversal-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/binary-tree-postorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    /* åŠ¨æ€è§„åˆ’æ€è·¯ */
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„ååºéå†ç»“æœ
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if (root == nullptr) {
            return res;
        }
        // ååºéå†ç»“æœç‰¹ç‚¹ï¼šå…ˆæ˜¯å·¦å­æ ‘ï¼Œæ¥ç€æ˜¯å³å­æ ‘ï¼Œæœ€åæ˜¯æ ¹èŠ‚ç‚¹çš„å€¼
        auto left = postorderTraversal(root->left);
        auto right = postorderTraversal(root->right);
        res.insert(res.end(), left.begin(), left.end());
        res.insert(res.end(), right.begin(), right.end());
        res.push_back(root->val);
        return res;
    }

    /* å›æº¯ç®—æ³•æ€è·¯ */
    vector<int> res;

    // è¿”å›ååºéå†ç»“æœ
    vector<int> postorderTraversal2(TreeNode* root) {
        traverse(root);
        return res;
    }

    // äºŒå‰æ ‘éå†å‡½æ•°
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        traverse(root->left);
        traverse(root->right);
        // ååºéå†ä½ç½®
        res.push_back(root->val);
    }
};
```

```go
// by chatGPT (go)
// åŠ¨æ€è§„åˆ’æ€è·¯
// å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„ååºéå†ç»“æœ
func postorderTraversal(root *TreeNode) []int {
    res := []int{}
    if root == nil {
        return res
    }
    // ååºéå†ç»“æœç‰¹ç‚¹ï¼šå…ˆæ˜¯å·¦å­æ ‘ï¼Œæ¥ç€æ˜¯å³å­æ ‘ï¼Œæœ€åæ˜¯æ ¹èŠ‚ç‚¹çš„å€¼
    res = append(res, postorderTraversal(root.Left)...)
    res = append(res, postorderTraversal(root.Right)...)
    res = append(res, root.Val)
    return res
}

// å›æº¯ç®—æ³•æ€è·¯
func postorderTraversal2(root *TreeNode) []int {
    res := []int{}
    traverse(root, &res)
    return res
}

// äºŒå‰æ ‘éå†å‡½æ•°
func traverse(root *TreeNode, res *[]int) {
    if root == nil {
        return
    }
    traverse(root.Left, res)
    traverse(root.Right, res)
    // ååºéå†ä½ç½®
    *res = append(*res, root.Val)
}
```

```java
// by labuladong (java)
class Solution {
    /* åŠ¨æ€è§„åˆ’æ€è·¯ */
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„ååºéå†ç»“æœ
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> res = new LinkedList<>();
        if (root == null) {
            return res;
        }
        // ååºéå†ç»“æœç‰¹ç‚¹ï¼šå…ˆæ˜¯å·¦å­æ ‘ï¼Œæ¥ç€æ˜¯å³å­æ ‘ï¼Œæœ€åæ˜¯æ ¹èŠ‚ç‚¹çš„å€¼
        res.addAll(postorderTraversal(root.left));
        res.addAll(postorderTraversal(root.right));
        res.add(root.val);
        return res;
    }

    /* å›æº¯ç®—æ³•æ€è·¯ */
    LinkedList<Integer> res = new LinkedList<>();

    // è¿”å›ååºéå†ç»“æœ
    public List<Integer> postorderTraversal2(TreeNode root) {
        traverse(root);
        return res;
    }

    // äºŒå‰æ ‘éå†å‡½æ•°
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        traverse(root.left);
        traverse(root.right);
        // ååºéå†ä½ç½®
        res.add(root.val);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    const res = [];
    /* åŠ¨æ€è§„åˆ’æ€è·¯ */
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„ååºéå†ç»“æœ
    if (root == null) {
        return res;
    }
    // ååºéå†ç»“æœç‰¹ç‚¹ï¼šå…ˆæ˜¯å·¦å­æ ‘ï¼Œæ¥ç€æ˜¯å³å­æ ‘ï¼Œæœ€åæ˜¯æ ¹èŠ‚ç‚¹çš„å€¼
    res.push(...postorderTraversal(root.left));
    res.push(...postorderTraversal(root.right));
    res.push(root.val);

    /* å›æº¯ç®—æ³•æ€è·¯ */
    /*LinkedList<Integer> res = new LinkedList<>();*/

    // è¿”å›ååºéå†ç»“æœ
    // public List<Integer> postorderTraversal2(TreeNode root) {
    //     traverse(root);
    //     return res;
    // }

    // äºŒå‰æ ‘éå†å‡½æ•°
    // void traverse(TreeNode root) {
    //     if (root == null) {
    //         return;
    //     }
    //     traverse(root.left);
    //     traverse(root.right);
    //     // ååºéå†ä½ç½®
    //     res.add(root.val);
    // }

    return res;
}
```

```python
# by chatGPT (python)
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        # ååºéå†ç»“æœç‰¹ç‚¹ï¼šå…ˆæ˜¯å·¦å­æ ‘ï¼Œæ¥ç€æ˜¯å³å­æ ‘ï¼Œæœ€åæ˜¯æ ¹èŠ‚ç‚¹çš„å€¼
        res += self.postorderTraversal(root.left)
        res += self.postorderTraversal(root.right)
        res.append(root.val)
        return res

    res = []

    def postorderTraversal2(self, root: TreeNode) -> List[int]:
        self.traverse(root)
        return self.res

    def traverse(self, root: TreeNode):
        if not root:
            return
        self.traverse(root.left)
        self.traverse(root.right)
        # ååºéå†ä½ç½®
        self.res.append(root.val)
```

https://leetcode.cn/problems/binary-tree-postorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/binary-tree-preorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
private:
    /* åŠ¨æ€è§„åˆ’æ€è·¯ */
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„å‰åºéå†ç»“æœ
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        if (!root) {
            return res;
        }
        // å‰åºéå†ç»“æœç‰¹ç‚¹ï¼šç¬¬ä¸€ä¸ªæ˜¯æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œæ¥ç€æ˜¯å·¦å­æ ‘ï¼Œæœ€åæ˜¯å³å­æ ‘
        res.push_back(root->val);
        vector<int> left = preorderTraversal(root->left);
        res.insert(res.end(), left.begin(), left.end());
        vector<int> right = preorderTraversal(root->right);
        res.insert(res.end(), right.begin(), right.end());
        return res;
    }

    /* å›æº¯ç®—æ³•æ€è·¯ */
    vector<int> res;

    // äºŒå‰æ ‘éå†å‡½æ•°
    void traverse(TreeNode* root) {
        if (!root) {
            return;
        }
        // å‰åºéå†ä½ç½®
        res.push_back(root->val);
        traverse(root->left);
        traverse(root->right);
    }

public:
    // è¿”å›å‰åºéå†ç»“æœ
    vector<int> preorderTraversal2(TreeNode* root) {
        traverse(root);
        return res;
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
 
func preorderTraversal(root *TreeNode) []int {
    var res []int
    if root == nil {
        return res
    }

    // åŠ¨æ€è§„åˆ’æ€è·¯
    // å‰åºéå†ç»“æœç‰¹ç‚¹ï¼šç¬¬ä¸€ä¸ªæ˜¯æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œæ¥ç€æ˜¯å·¦å­æ ‘ï¼Œæœ€åæ˜¯å³å­æ ‘
    res = append(res, root.Val)
    res = append(res, preorderTraversal(root.Left)...)
    res = append(res, preorderTraversal(root.Right)...)

    // å›æº¯ç®—æ³•æ€è·¯
    // traverse(root, &res)

    return res
}

// å›æº¯ç®—æ³•
// func traverse(root *TreeNode, res *[]int) {
//     if root == nil {
//         return
//     }
//     *res = append(*res, root.Val)
//     traverse(root.Left, res)
//     traverse(root.Right, res)
// }
```

```java
// by labuladong (java)
class Solution {
    /* åŠ¨æ€è§„åˆ’æ€è·¯ */
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„å‰åºéå†ç»“æœ
    public List<Integer> preorderTraversal(TreeNode root) {
        LinkedList<Integer> res = new LinkedList<>();
        if (root == null) {
            return res;
        }
        // å‰åºéå†ç»“æœç‰¹ç‚¹ï¼šç¬¬ä¸€ä¸ªæ˜¯æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œæ¥ç€æ˜¯å·¦å­æ ‘ï¼Œæœ€åæ˜¯å³å­æ ‘
        res.add(root.val);
        res.addAll(preorderTraversal(root.left));
        res.addAll(preorderTraversal(root.right));
        return res;
    }

    /* å›æº¯ç®—æ³•æ€è·¯ */
    LinkedList<Integer> res = new LinkedList<>();

    // è¿”å›å‰åºéå†ç»“æœ
    public List<Integer> preorderTraversal2(TreeNode root) {
        traverse(root);
        return res;
    }

    // äºŒå‰æ ‘éå†å‡½æ•°
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        // å‰åºéå†ä½ç½®
        res.add(root.val);
        traverse(root.left);
        traverse(root.right);
    }
}
```

```javascript
// by chatGPT (javascript)
var Solution = function() {

    /* åŠ¨æ€è§„åˆ’æ€è·¯ */
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„å‰åºéå†ç»“æœ
    this.preorderTraversal = function(root) {
        let res = [];
        if (root == null) {
            return res;
        }
        // å‰åºéå†ç»“æœç‰¹ç‚¹ï¼šç¬¬ä¸€ä¸ªæ˜¯æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œæ¥ç€æ˜¯å·¦å­æ ‘ï¼Œæœ€åæ˜¯å³å­æ ‘
        res.push(root.val);
        res = res.concat(this.preorderTraversal(root.left));
        res = res.concat(this.preorderTraversal(root.right));
        return res;
    };

    /* å›æº¯ç®—æ³•æ€è·¯ */
    let res = [];

    // è¿”å›å‰åºéå†ç»“æœ
    this.preorderTraversal2 = function(root) {
        traverse(root);
        return res;
    };

    // äºŒå‰æ ‘éå†å‡½æ•°
    function traverse(root) {
        if (root == null) {
            return;
        }
        // å‰åºéå†ä½ç½®
        res.push(root.val);
        traverse(root.left);
        traverse(root.right);
    }
};
```

```python
# by chatGPT (python)
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    # åŠ¨æ€è§„åˆ’æ€è·¯
    # å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„å‰åºéå†ç»“æœ
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        # å‰åºéå†ç»“æœç‰¹ç‚¹ï¼šç¬¬ä¸€ä¸ªæ˜¯æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œæ¥ç€æ˜¯å·¦å­æ ‘ï¼Œæœ€åæ˜¯å³å­æ ‘
        res.append(root.val)
        res.extend(self.preorderTraversal(root.left))
        res.extend(self.preorderTraversal(root.right))
        return res

    # å›æº¯ç®—æ³•æ€è·¯
    def __init__(self):
        self.res = []

    # è¿”å›å‰åºéå†ç»“æœ
    def preorderTraversal2(self, root: TreeNode) -> List[int]:
        self.traverse(root)
        return self.res

    # äºŒå‰æ ‘éå†å‡½æ•°
    def traverse(self, root: TreeNode) -> None:
        if not root:
            return
        # å‰åºéå†ä½ç½®
        self.res.append(root.val)
        self.traverse(root.left)
        self.traverse(root.right)
```

https://leetcode.cn/problems/binary-tree-preorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (root == nullptr) {
            return res;
        }

        queue<TreeNode*> q;
        q.push(root);
        // ä¸º true æ—¶å‘å³ï¼Œfalse æ—¶å‘å·¦
        bool flag = true;

        // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while (!q.empty()) {
            int sz = q.size();
            // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            list<int> level;
            // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for (int i = 0; i < sz; i++) {
                TreeNode* cur = q.front();
                q.pop();
                // å®ç° z å­—å½¢éå†
                if (flag) {
                    level.push_back(cur->val);
                } else {
                    level.push_front(cur->val);
                }
                if (cur->left != nullptr)
                    q.push(cur->left);
                if (cur->right != nullptr)
                    q.push(cur->right);
            }
            // åˆ‡æ¢æ–¹å‘
            flag = !flag;
            res.emplace_back(level.begin(), level.end());
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func zigzagLevelOrder(root *TreeNode) [][]int {
    res := make([][]int, 0)
    if root == nil {
        return res
    }

    q := make([]*TreeNode, 0)
    q = append(q, root)
    // ä¸º true æ—¶å‘å³ï¼Œfalse æ—¶å‘å·¦
    flag := true

    // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
    for len(q) > 0 {
        sz := len(q)
        // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
        level := make([]int, 0, sz)
        // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]
            // å®ç° z å­—å½¢éå†
            if flag {
                level = append(level, cur.Val)
            } else {
                level = append([]int{cur.Val}, level...)
            }
            if cur.Left != nil {
                q = append(q, cur.Left)
            }
            if cur.Right != nil {
                q = append(q, cur.Right)
            }
        }
        // åˆ‡æ¢æ–¹å‘
        flag = !flag
        res = append(res, level)
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        if (root == null) {
            return res;
        }

        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        // ä¸º true æ—¶å‘å³ï¼Œfalse æ—¶å‘å·¦
        boolean flag = true;

        // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while (!q.isEmpty()) {
            int sz = q.size();
            // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            LinkedList<Integer> level = new LinkedList<>();
            // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                // å®ç° z å­—å½¢éå†
                if (flag) {
                    level.addLast(cur.val);
                } else {
                    level.addFirst(cur.val);
                }
                if (cur.left != null)
                    q.offer(cur.left);
                if (cur.right != null)
                    q.offer(cur.right);
            }
            // åˆ‡æ¢æ–¹å‘
            flag = !flag;
            res.add(level);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var zigzagLevelOrder = function(root) {
    let res = [];
    if (root == null) {
        return res;
    }

    let q = [];
    q.push(root);
    // ä¸º true æ—¶å‘å³ï¼Œfalse æ—¶å‘å·¦
    let flag = true;

    // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
    while (q.length > 0) {
        let sz = q.length;
        // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
        let level = [];
        // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
        for (let i = 0; i < sz; i++) {
            let cur = q.shift();
            // å®ç° z å­—å½¢éå†
            if (flag) {
                level.push(cur.val);
            } else {
                level.unshift(cur.val);
            }
            if (cur.left != null)
                q.push(cur.left);
            if (cur.right != null)
                q.push(cur.right);
        }
        // åˆ‡æ¢æ–¹å‘
        flag = !flag;
        res.push(level);
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []
        if not root:
            return res

        q = collections.deque()
        q.append(root)
        # ä¸º True æ—¶å‘å³ï¼ŒFalse æ—¶å‘å·¦
        flag = True

        # while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while q:
            sz = len(q)
            # è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            level = collections.deque()
            # for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for i in range(sz):
                cur = q.popleft()
                # å®ç° z å­—å½¢éå†
                if flag:
                    level.append(cur.val)
                else:
                    level.appendleft(cur.val)
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
            # åˆ‡æ¢æ–¹å‘
            flag = not flag
            res.append(list(level))
        return res
```

https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isStraight(vector<int>& nums) {
        unordered_set<int> numSet;
        int maxVal = INT_MIN, minVal = INT_MAX;
        for (int num : nums) {
            if (num == 0) {
                // å°ç‹ä¸ç”¨ç®¡
                continue;
            }
            if (numSet.count(num)) {
                // å‡ºç°é‡å¤ï¼Œä¸å¯èƒ½æ˜¯é¡ºå­
                return false;
            }
            numSet.insert(num);

            maxVal = max(maxVal, num);
            minVal = min(minVal, num);
        }
        // è€ƒè™‘åˆ°å¤§å°ç‹ï¼Œåªè¦å·®å°äº 4 å°±ä¸€å®šå¯ä»¥å‡‘å‡ºé¡ºå­
        return maxVal - minVal <= 4;
    }
};
```

```go
// by chatGPT (go)
func isStraight(nums []int) bool {
    numSet := make(map[int]bool)
    max, min := math.MinInt32, math.MaxInt32
    for _, num := range nums {
        if num == 0 {
            // å°ç‹ä¸ç”¨ç®¡
            continue
        }
        if numSet[num] {
            // å‡ºç°é‡å¤ï¼Œä¸å¯èƒ½æ˜¯é¡ºå­
            return false
        }
        numSet[num] = true

        max = int(math.Max(float64(max), float64(num)))
        min = int(math.Min(float64(min), float64(num)))
    }
    // è€ƒè™‘åˆ°å¤§å°ç‹ï¼Œåªè¦å·®å°äº 4 å°±ä¸€å®šå¯ä»¥å‡‘å‡ºé¡ºå­
    return max - min <= 4
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isStraight(int[] nums) {
        Set<Integer> numSet = new HashSet<>();
        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;
        for (int num : nums) {
            if (num == 0) {
                // å°ç‹ä¸ç”¨ç®¡
                continue;
            }
            if (numSet.contains(num)) {
                // å‡ºç°é‡å¤ï¼Œä¸å¯èƒ½æ˜¯é¡ºå­
                return false;
            }
            numSet.add(num);

            max = Math.max(max, num);
            min = Math.min(min, num);
        }
        // è€ƒè™‘åˆ°å¤§å°ç‹ï¼Œåªè¦å·®å°äº 4 å°±ä¸€å®šå¯ä»¥å‡‘å‡ºé¡ºå­
        return max - min <= 4;
    }
}
```

```javascript
// by chatGPT (javascript)
var isStraight = function(nums) {
    let numSet = new Set();
    let max = -Infinity, min = Infinity;
    for (let num of nums) {
        if (num === 0) {
            // å°ç‹ä¸ç”¨ç®¡
            continue;
        }
        if (numSet.has(num)) {
            // å‡ºç°é‡å¤ï¼Œä¸å¯èƒ½æ˜¯é¡ºå­
            return false;
        }
        numSet.add(num);

        max = Math.max(max, num);
        min = Math.min(min, num);
    }
    // è€ƒè™‘åˆ°å¤§å°ç‹ï¼Œåªè¦å·®å°äº 4 å°±ä¸€å®šå¯ä»¥å‡‘å‡ºé¡ºå­
    return max - min <= 4;
};
```

```python
# by chatGPT (python)
class Solution:
    def isStraight(self, nums: List[int]) -> bool:
        numSet = set()
        maximum, minimum = float('-inf'), float('inf')
        for num in nums:
            if num == 0:
                # å°ç‹ä¸ç”¨ç®¡
                continue
            if num in numSet:
                # å‡ºç°é‡å¤ï¼Œä¸å¯èƒ½æ˜¯é¡ºå­
                return False
            numSet.add(num)
            maximum = max(maximum, num)
            minimum = min(minimum, num)
        # è€ƒè™‘åˆ°å¤§å°ç‹ï¼Œåªè¦å·®å°äº 4 å°±ä¸€å®šå¯ä»¥å‡‘å‡ºé¡ºå­
        return maximum - minimum <= 4
```

https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int add(int a, int b) {
        if (a == 0 || b == 0) {
            return a == 0 ? b : a;
        }
        // è®¾ a = 1001
        // è®¾ b = 0101
        // æ±‚å’Œ 1100
        int sum = a ^ b;
        // è¿›ä½ 0001 << 1 = 0010
        int carry = (a & b) << 1;
        // add(1100, 0010)
        return add(sum, carry);
    }
};
```

```go
// by chatGPT (go)
func add(a int, b int) int {
    if a == 0 || b == 0 {
        if a == 0 {
            return b
        } else {
            return a
        }
    }

    // è®¾ a = 1001
    // è®¾ b = 0101
    // æ±‚å’Œ 1100
    sum := a ^ b

    // è¿›ä½ 0001 << 1 = 0010
    carry := (a & b) << 1

    // add(1100, 0010)
    return add(sum, carry)
}
```

```java
// by labuladong (java)
class Solution {
    public int add(int a, int b) {
        if(a == 0 || b == 0) {
            return a == 0 ? b : a;
        }
        // è®¾ a = 1001
        // è®¾ b = 0101
        // æ±‚å’Œ 1100
        int sum = a ^ b;
        // è¿›ä½ 0001 << 1 = 0010
        int carry = (a & b) << 1;
        // add(1100, 0010)
        return add(sum, carry);
    }
}
```

```javascript
// by chatGPT (javascript)
var add = function(a, b) {
    if (a == 0 || b == 0) {
        return a == 0 ? b : a;
    }
    // è®¾ a = 1001
    // è®¾ b = 0101
    // æ±‚å’Œ 1100
    let sum = a ^ b;
    // è¿›ä½ 0001 << 1 = 0010
    let carry = (a & b) << 1;
    // add(1100, 0010)
    return add(sum, carry);
};
```

```python
# by chatGPT (python)
class Solution:
    def add(self, a: int, b: int) -> int:
        if a == 0 or b == 0:
            return b if a == 0 else a
        # è®¾ a = 1001
        # è®¾ b = 0101
        # æ±‚å’Œ 1100
        sum = a ^ b
        # è¿›ä½ 0001 << 1 = 0010
        carry = (a & b) << 1
        # add(1100, 0010)
        return self.add(sum, carry)
```

https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/bulb-switcher çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int bulbSwitch(int n) {
        return (int) sqrt(n);
    }
};
```

```go
// by chatGPT (go)
func bulbSwitch(n int) int {
    return int(math.Sqrt(float64(n)))
}
```

```java
// by labuladong (java)
class Solution {
    public int bulbSwitch(int n) {
        return (int)Math.sqrt(n);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @return {number}
 */
var bulbSwitch = function(n) {
  return Math.floor(Math.sqrt(n));
};
```

```python
# by chatGPT (python)
class Solution:
    def bulbSwitch(self, n: int) -> int:
        return int(n ** 0.5)
```

https://leetcode.cn/problems/bulb-switcher çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/burst-balloons çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        // æ·»åŠ ä¸¤ä¾§çš„è™šæ‹Ÿæ°”çƒ
        vector<int> points(n + 2);
        points[0] = points[n + 1] = 1;
        for (int i = 1; i <= n; i++) {
            points[i] = nums[i - 1];
        }
        // base case å·²ç»éƒ½è¢«åˆå§‹åŒ–ä¸º 0
        vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));
        // å¼€å§‹çŠ¶æ€è½¬ç§»
        // i åº”è¯¥ä»ä¸‹å¾€ä¸Š
        for (int i = n; i >= 0; i--) {
            // j åº”è¯¥ä»å·¦å¾€å³
            for (int j = i + 1; j < n + 2; j++) {
                // æœ€åæˆ³ç ´çš„æ°”çƒæ˜¯å“ªä¸ªï¼Ÿ
                for (int k = i + 1; k < j; k++) {
                    // æ‹©ä¼˜åšé€‰æ‹©
                    dp[i][j] = max(
                            dp[i][j],
                            dp[i][k] + dp[k][j] + points[i] * points[j] * points[k]
                    );
                }
            }
        }
        return dp[0][n + 1];
    }
};
```

```go
// by chatGPT (go)
func maxCoins(nums []int) int {
    n := len(nums)
    // æ·»åŠ ä¸¤ä¾§çš„è™šæ‹Ÿæ°”çƒ
    points := make([]int, n+2)
    points[0] = points[n+1] = 1
    for i := 1; i <= n; i++ {
        points[i] = nums[i-1]
    }
    // base case å·²ç»éƒ½è¢«åˆå§‹åŒ–ä¸º 0
    dp := make([][]int, n+2)
    for i := 0; i <= n+1; i++ {
        dp[i] = make([]int, n+2)
    }
    // å¼€å§‹çŠ¶æ€è½¬ç§»
    // i åº”è¯¥ä»ä¸‹å¾€ä¸Š
    for i := n; i >= 0; i-- {
        // j åº”è¯¥ä»å·¦å¾€å³
        for j := i + 1; j < n+2; j++ {
            // æœ€åæˆ³ç ´çš„æ°”çƒæ˜¯å“ªä¸ªï¼Ÿ
            for k := i + 1; k < j; k++ {
                // æ‹©ä¼˜åšé€‰æ‹©
                dp[i][j] = max(dp[i][j], dp[i][k]+dp[k][j]+points[i]*points[j]*points[k])
            }
        }
    }
    return dp[0][n+1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        // æ·»åŠ ä¸¤ä¾§çš„è™šæ‹Ÿæ°”çƒ
        int[] points = new int[n + 2];
        points[0] = points[n + 1] = 1;
        for (int i = 1; i <= n; i++) {
            points[i] = nums[i - 1];
        }
        // base case å·²ç»éƒ½è¢«åˆå§‹åŒ–ä¸º 0
        int[][] dp = new int[n + 2][n + 2];
        // å¼€å§‹çŠ¶æ€è½¬ç§»
        // i åº”è¯¥ä»ä¸‹å¾€ä¸Š
        for (int i = n; i >= 0; i--) {
            // j åº”è¯¥ä»å·¦å¾€å³
            for (int j = i + 1; j < n + 2; j++) {
                // æœ€åæˆ³ç ´çš„æ°”çƒæ˜¯å“ªä¸ªï¼Ÿ
                for (int k = i + 1; k < j; k++) {
                    // æ‹©ä¼˜åšé€‰æ‹©
                    dp[i][j] = Math.max(
                            dp[i][j],
                            dp[i][k] + dp[k][j] + points[i] * points[j] * points[k]
                    );
                }
            }
        }
        return dp[0][n + 1];
    }
}
```

```javascript
// by chatGPT (javascript)
var maxCoins = function(nums) {
    let n = nums.length;
    // æ·»åŠ ä¸¤ä¾§çš„è™šæ‹Ÿæ°”çƒ
    let points = new Array(n + 2).fill(0);
    points[0] = points[n + 1] = 1;
    for (let i = 1; i <= n; i++) {
        points[i] = nums[i - 1];
    }
    // base case å·²ç»éƒ½è¢«åˆå§‹åŒ–ä¸º 0
    let dp = new Array(n + 2).fill().map(() => new Array(n + 2).fill(0));
    // å¼€å§‹çŠ¶æ€è½¬ç§»
    // i åº”è¯¥ä»ä¸‹å¾€ä¸Š
    for (let i = n; i >= 0; i--) {
        // j åº”è¯¥ä»å·¦å¾€å³
        for (let j = i + 1; j < n + 2; j++) {
            // æœ€åæˆ³ç ´çš„æ°”çƒæ˜¯å“ªä¸ªï¼Ÿ
            for (let k = i + 1; k < j; k++) {
                // æ‹©ä¼˜åšé€‰æ‹©
                dp[i][j] = Math.max(
                    dp[i][j],
                    dp[i][k] + dp[k][j] + points[i] * points[j] * points[k]
                );
            }
        }
    }
    return dp[0][n + 1];
};
```

```python
# by chatGPT (python)
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        n = len(nums)
        # æ·»åŠ ä¸¤ä¾§çš„è™šæ‹Ÿæ°”çƒ
        points = [0] * (n + 2)
        points[0], points[n + 1] = 1, 1
        for i in range(1, n + 1):
            points[i] = nums[i - 1]
        # base case å·²ç»éƒ½è¢«åˆå§‹åŒ–ä¸º 0
        dp = [[0] * (n + 2) for _ in range(n + 2)]
        # å¼€å§‹çŠ¶æ€è½¬ç§»
        # i åº”è¯¥ä»ä¸‹å¾€ä¸Š
        for i in range(n, -1, -1):
            # j åº”è¯¥ä»å·¦å¾€å³
            for j in range(i + 1, n + 2):
                # æœ€åæˆ³ç ´çš„æ°”çƒæ˜¯å“ªä¸ªï¼Ÿ
                for k in range(i + 1, j):
                    # æ‹©ä¼˜åšé€‰æ‹©
                    dp[i][j] = max(
                        dp[i][j],
                        dp[i][k] + dp[k][j] + points[i] * points[j] * points[k]
                    )
        return dp[0][n + 1]
```

https://leetcode.cn/problems/burst-balloons çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/c32eOV çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fast, *slow;
        fast = slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) break;
            /**<extend down -200>
            ![](../pictures/åŒæŒ‡é’ˆ/3.jpeg)
            */
        }
        // ä¸Šé¢çš„ä»£ç ç±»ä¼¼ hasCycle å‡½æ•°
        if (fast == nullptr || fast->next == nullptr) {
            // fast é‡åˆ°ç©ºæŒ‡é’ˆè¯´æ˜æ²¡æœ‰ç¯
            return nullptr;
        }

        // é‡æ–°æŒ‡å‘å¤´ç»“ç‚¹
        slow = head;
        /**<extend up -100>
        ![](../pictures/åŒæŒ‡é’ˆ/2.jpeg)
        */
        // å¿«æ…¢æŒ‡é’ˆåŒæ­¥å‰è¿›ï¼Œç›¸äº¤ç‚¹å°±æ˜¯ç¯èµ·ç‚¹
        while (slow != fast) {
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

```go
// by chatGPT (go)
func detectCycle(head *ListNode) *ListNode {
    fast, slow := head, head
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        slow = slow.Next
        if fast == slow {
            break
            /**<extend down -200>
            ![](../pictures/åŒæŒ‡é’ˆ/3.jpeg)
            */
        }
    }
    // ä¸Šé¢çš„ä»£ç ç±»ä¼¼ hasCycle å‡½æ•°
    if fast == nil || fast.Next == nil {
        // fast é‡åˆ°ç©ºæŒ‡é’ˆè¯´æ˜æ²¡æœ‰ç¯
        return nil
    }

    // é‡æ–°æŒ‡å‘å¤´ç»“ç‚¹
    slow = head
    /**<extend up -100>
    ![](../pictures/åŒæŒ‡é’ˆ/2.jpeg)
    */
    // å¿«æ…¢æŒ‡é’ˆåŒæ­¥å‰è¿›ï¼Œç›¸äº¤ç‚¹å°±æ˜¯ç¯èµ·ç‚¹
    for slow != fast {
        fast = fast.Next
        slow = slow.Next
    }
    return slow
}
```

```java
// by labuladong (java)
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
            /**<extend down -200>
            ![](../pictures/åŒæŒ‡é’ˆ/3.jpeg)
            */
        }
        // ä¸Šé¢çš„ä»£ç ç±»ä¼¼ hasCycle å‡½æ•°
        if (fast == null || fast.next == null) {
            // fast é‡åˆ°ç©ºæŒ‡é’ˆè¯´æ˜æ²¡æœ‰ç¯
            return null;
        }

        // é‡æ–°æŒ‡å‘å¤´ç»“ç‚¹
        slow = head;
        /**<extend up -100>
        ![](../pictures/åŒæŒ‡é’ˆ/2.jpeg)
        */
        // å¿«æ…¢æŒ‡é’ˆåŒæ­¥å‰è¿›ï¼Œç›¸äº¤ç‚¹å°±æ˜¯ç¯èµ·ç‚¹
        while (slow != fast) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

```javascript
// by chatGPT (javascript)
var detectCycle = function(head) {
    let fast, slow;
    fast = slow = head;
    while (fast !== null && fast.next !== null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast === slow) break;
        /**<extend down -200>
        ![](../pictures/åŒæŒ‡é’ˆ/3.jpeg)
        */
    }
    // ä¸Šé¢çš„ä»£ç ç±»ä¼¼ hasCycle å‡½æ•°
    if (fast === null || fast.next === null) {
        // fast é‡åˆ°ç©ºæŒ‡é’ˆè¯´æ˜æ²¡æœ‰ç¯
        return null;
    }

    // é‡æ–°æŒ‡å‘å¤´ç»“ç‚¹
    slow = head;
    /**<extend up -100>
    ![](../pictures/åŒæŒ‡é’ˆ/2.jpeg)
    */
    // å¿«æ…¢æŒ‡é’ˆåŒæ­¥å‰è¿›ï¼Œç›¸äº¤ç‚¹å°±æ˜¯ç¯èµ·ç‚¹
    while (slow !== fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
};
```

```python
# by chatGPT (python)
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast, slow = head, head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                break
            """
            <extend down -200>
            ![](../pictures/åŒæŒ‡é’ˆ/3.jpeg)
            """
        # ä¸Šé¢çš„ä»£ç ç±»ä¼¼ hasCycle å‡½æ•°
        if not fast or not fast.next:
            # fast é‡åˆ°ç©ºæŒ‡é’ˆè¯´æ˜æ²¡æœ‰ç¯
            return None

        # é‡æ–°æŒ‡å‘å¤´ç»“ç‚¹
        slow = head
        """
        <extend up -100>
        ![](../pictures/åŒæŒ‡é’ˆ/2.jpeg)
        """
        # å¿«æ…¢æŒ‡é’ˆåŒæ­¥å‰è¿›ï¼Œç›¸äº¤ç‚¹å°±æ˜¯ç¯èµ·ç‚¹
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return slow
```

https://leetcode.cn/problems/c32eOV çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int shipWithinDays(vector<int>& weights, int days) {
        int left = 0;
        int right = 1;
        for (int w : weights) {
            left = max(left, w);
            right += w;
        }

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (f(weights, mid) <= days) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return left;
    }

    // å®šä¹‰ï¼šå½“è¿è½½èƒ½åŠ›ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å¤©è¿å®Œæ‰€æœ‰è´§ç‰©
    // f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
    int f(vector<int>& weights, int x) {
        int days = 0;
        for (int i = 0; i < weights.size(); ) {
            // å°½å¯èƒ½å¤šè£…è´§ç‰©
            int cap = x;
            while (i < weights.size()) {
                if (cap < weights[i]) break;
                else cap -= weights[i];
                i++;
            }
            days++;
        }
        return days;
    }
};
```

```go
// by chatGPT (go)
func shipWithinDays(weights []int, days int) int {
    left := 0
    right := 1
    for _, w := range weights {
        left = max(left, w)
        right += w
    }

    for left < right {
        mid := left + (right-left)/2
        if f(weights, mid) <= days {
            right = mid
        } else {
            left = mid + 1
        }
    }

    return left
}

// å®šä¹‰ï¼šå½“è¿è½½èƒ½åŠ›ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å¤©è¿å®Œæ‰€æœ‰è´§ç‰©
// f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
func f(weights []int, x int) int {
    days := 0
    for i := 0; i < len(weights); {
        // å°½å¯èƒ½å¤šè£…è´§ç‰©
        cap := x
        for i < len(weights) {
            if cap < weights[i] {
                break
            } else {
                cap -= weights[i]
                i++
            }
        }
        days++
    }
    return days
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int shipWithinDays(int[] weights, int days) {
        int left = 0;
        int right = 1;
        for (int w : weights) {
            left = Math.max(left, w);
            right += w;
        }

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (f(weights, mid) <= days) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return left;
    }

    // å®šä¹‰ï¼šå½“è¿è½½èƒ½åŠ›ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å¤©è¿å®Œæ‰€æœ‰è´§ç‰©
    // f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
    int f(int[] weights, int x) {
        int days = 0;
        for (int i = 0; i < weights.length; ) {
            // å°½å¯èƒ½å¤šè£…è´§ç‰©
            int cap = x;
            while (i < weights.length) {
                if (cap < weights[i]) break;
                else cap -= weights[i];
                i++;
            }
            days++;
        }
        return days;
    }
}
```

```javascript
// by chatGPT (javascript)
var shipWithinDays = function(weights, days) {
    let left = 0;
    let right = 1;
    for (let w of weights) {
        left = Math.max(left, w);
        right += w;
    }

    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (f(weights, mid) <= days) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
};

// å®šä¹‰ï¼šå½“è¿è½½èƒ½åŠ›ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å¤©è¿å®Œæ‰€æœ‰è´§ç‰©
// f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
function f(weights, x) {
    let days = 0;
    for (let i = 0; i < weights.length; ) {
        // å°½å¯èƒ½å¤šè£…è´§ç‰©
        let cap = x;
        while (i < weights.length) {
            if (cap < weights[i]) break;
            else cap -= weights[i];
            i++;
        }
        days++;
    }
    return days;
}
```

```python
# by chatGPT (python)
class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        left = max(weights)
        right = sum(weights)

        while left < right:
            mid = (left + right) // 2
            if self.f(weights, mid) <= days:
                right = mid
            else:
                left = mid + 1

        return left

    # å®šä¹‰ï¼šå½“è¿è½½èƒ½åŠ›ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å¤©è¿å®Œæ‰€æœ‰è´§ç‰©
    # f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
    def f(self, weights, x):
        days = 0
        i = 0
        while i < len(weights):
            # å°½å¯èƒ½å¤šè£…è´§ç‰©
            cap = x
            while i < len(weights):
                if cap < weights[i]:
                    break
                else:
                    cap -= weights[i]
                    i += 1
            days += 1
        return days
```

https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/car-pooling çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        // æœ€å¤šæœ‰ 1000 ä¸ªè½¦ç«™
        vector<int> nums(1001, 0);
        // æ„é€ å·®åˆ†è§£æ³•
        Difference df(nums);

        for (const auto& trip : trips) {
            // ä¹˜å®¢æ•°é‡
            int val = trip[0];
            // ç¬¬ trip[1] ç«™ä¹˜å®¢ä¸Šè½¦
            int i = trip[1];
            // ç¬¬ trip[2] ç«™ä¹˜å®¢å·²ç»ä¸‹è½¦ï¼Œ
            // å³ä¹˜å®¢åœ¨è½¦ä¸Šçš„åŒºé—´æ˜¯ [trip[1], trip[2] - 1]
            int j = trip[2] - 1;
            // è¿›è¡ŒåŒºé—´æ“ä½œ
            df.increment(i, j, val);
        }

        vector<int> res = df.result();

        // å®¢è½¦è‡ªå§‹è‡³ç»ˆéƒ½ä¸åº”è¯¥è¶…è½½
        for (int i = 0; i < res.size(); i++) {
            if (capacity < res[i]) {
                return false;
            }
        }
        return true;
    }

    // å·®åˆ†æ•°ç»„å·¥å…·ç±»
    class Difference {
        // å·®åˆ†æ•°ç»„
        vector<int> diff;

        /* è¾“å…¥ä¸€ä¸ªåˆå§‹æ•°ç»„ï¼ŒåŒºé—´æ“ä½œå°†åœ¨è¿™ä¸ªæ•°ç»„ä¸Šè¿›è¡Œ */
        public:
        Difference(vector<int>& nums) {
            diff.resize(nums.size());
            // æ ¹æ®åˆå§‹æ•°ç»„æ„é€ å·®åˆ†æ•°ç»„
            diff[0] = nums[0];
            for (int i = 1; i < nums.size(); i++) {
                diff[i] = nums[i] - nums[i - 1];
            }
        }

        /* ç»™é—­åŒºé—´ [i, j] å¢åŠ  valï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰*/
        void increment(int i, int j, int val) {
            diff[i] += val;
            if (j + 1 < diff.size()) {
                diff[j + 1] -= val;
            }
        }

        /* è¿”å›ç»“æœæ•°ç»„ */
        vector<int> result() {
            vector<int> res(diff.size());
            // æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
            res[0] = diff[0];
            for (int i = 1; i < diff.size(); i++) {
                res[i] = res[i - 1] + diff[i];
            }
            return res;
        }
    };
};
```

```go
// by chatGPT (go)
func carPooling(trips [][]int, capacity int) bool {
    // æœ€å¤šæœ‰ 1000 ä¸ªè½¦ç«™
    nums := make([]int, 1001)
    // æ„é€ å·®åˆ†è§£æ³•
    df := Difference{nums}

    for _, trip := range trips {
        // ä¹˜å®¢æ•°é‡
        val := trip[0]
        // ç¬¬ trip[1] ç«™ä¹˜å®¢ä¸Šè½¦
        i := trip[1]
        // ç¬¬ trip[2] ç«™ä¹˜å®¢å·²ç»ä¸‹è½¦ï¼Œ
        // å³ä¹˜å®¢åœ¨è½¦ä¸Šçš„åŒºé—´æ˜¯ [trip[1], trip[2] - 1]
        j := trip[2] - 1
        // è¿›è¡ŒåŒºé—´æ“ä½œ
        df.increment(i, j, val)
    }

    res := df.result()

    // å®¢è½¦è‡ªå§‹è‡³ç»ˆéƒ½ä¸åº”è¯¥è¶…è½½
    for _, val := range res {
        if capacity < val {
            return false
        }
    }
    return true
}

// å·®åˆ†æ•°ç»„å·¥å…·ç±»
type Difference struct {
    // å·®åˆ†æ•°ç»„
    diff []int
}

/* è¾“å…¥ä¸€ä¸ªåˆå§‹æ•°ç»„ï¼ŒåŒºé—´æ“ä½œå°†åœ¨è¿™ä¸ªæ•°ç»„ä¸Šè¿›è¡Œ */
func (df *Difference) Difference(nums []int) {
    df.diff = make([]int, len(nums))
    // æ ¹æ®åˆå§‹æ•°ç»„æ„é€ å·®åˆ†æ•°ç»„
    df.diff[0] = nums[0]
    for i := 1; i < len(nums); i++ {
        df.diff[i] = nums[i] - nums[i-1]
    }
}

/* ç»™é—­åŒºé—´ [i, j] å¢åŠ  valï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰*/
func (df *Difference) increment(i int, j int, val int) {
    df.diff[i] += val
    if j+1 < len(df.diff) {
        df.diff[j+1] -= val
    }
}

/* è¿”å›ç»“æœæ•°ç»„ */
func (df *Difference) result() []int {
    res := make([]int, len(df.diff))
    // æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
    res[0] = df.diff[0]
    for i := 1; i < len(df.diff); i++ {
        res[i] = res[i-1] + df.diff[i]
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        // æœ€å¤šæœ‰ 1000 ä¸ªè½¦ç«™
        int[] nums = new int[1001];
        // æ„é€ å·®åˆ†è§£æ³•
        Difference df = new Difference(nums);

        for (int[] trip : trips) {
            // ä¹˜å®¢æ•°é‡
            int val = trip[0];
            // ç¬¬ trip[1] ç«™ä¹˜å®¢ä¸Šè½¦
            int i = trip[1];
            // ç¬¬ trip[2] ç«™ä¹˜å®¢å·²ç»ä¸‹è½¦ï¼Œ
            // å³ä¹˜å®¢åœ¨è½¦ä¸Šçš„åŒºé—´æ˜¯ [trip[1], trip[2] - 1]
            int j = trip[2] - 1;
            // è¿›è¡ŒåŒºé—´æ“ä½œ
            df.increment(i, j, val);
        }

        int[] res = df.result();

        // å®¢è½¦è‡ªå§‹è‡³ç»ˆéƒ½ä¸åº”è¯¥è¶…è½½
        for (int i = 0; i < res.length; i++) {
            if (capacity < res[i]) {
                return false;
            }
        }
        return true;
    }

    // å·®åˆ†æ•°ç»„å·¥å…·ç±»
    class Difference {
        // å·®åˆ†æ•°ç»„
        private int[] diff;

        /* è¾“å…¥ä¸€ä¸ªåˆå§‹æ•°ç»„ï¼ŒåŒºé—´æ“ä½œå°†åœ¨è¿™ä¸ªæ•°ç»„ä¸Šè¿›è¡Œ */
        public Difference(int[] nums) {
            assert nums.length > 0;
            diff = new int[nums.length];
            // æ ¹æ®åˆå§‹æ•°ç»„æ„é€ å·®åˆ†æ•°ç»„
            diff[0] = nums[0];
            for (int i = 1; i < nums.length; i++) {
                diff[i] = nums[i] - nums[i - 1];
            }
        }

        /* ç»™é—­åŒºé—´ [i, j] å¢åŠ  valï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰*/
        public void increment(int i, int j, int val) {
            diff[i] += val;
            if (j + 1 < diff.length) {
                diff[j + 1] -= val;
            }
        }

        /* è¿”å›ç»“æœæ•°ç»„ */
        public int[] result() {
            int[] res = new int[diff.length];
            // æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
            res[0] = diff[0];
            for (int i = 1; i < diff.length; i++) {
                res[i] = res[i - 1] + diff[i];
            }
            return res;
        }
    }

}
```

```javascript
// by chatGPT (javascript)
var carPooling = function(trips, capacity) {
    // æœ€å¤šæœ‰ 1000 ä¸ªè½¦ç«™
    const nums = new Array(1001).fill(0);
    // æ„é€ å·®åˆ†è§£æ³•
    const df = new Difference(nums);

    for (const trip of trips) {
        // ä¹˜å®¢æ•°é‡
        const val = trip[0];
        // ç¬¬ trip[1] ç«™ä¹˜å®¢ä¸Šè½¦
        const i = trip[1];
        // ç¬¬ trip[2] ç«™ä¹˜å®¢å·²ç»ä¸‹è½¦ï¼Œ
        // å³ä¹˜å®¢åœ¨è½¦ä¸Šçš„åŒºé—´æ˜¯ [trip[1], trip[2] - 1]
        const j = trip[2] - 1;
        // è¿›è¡ŒåŒºé—´æ“ä½œ
        df.increment(i, j, val);
    }

    const res = df.result();

    // å®¢è½¦è‡ªå§‹è‡³ç»ˆéƒ½ä¸åº”è¯¥è¶…è½½
    for (let i = 0; i < res.length; i++) {
        if (capacity < res[i]) {
            return false;
        }
    }
    return true;

    // å·®åˆ†æ•°ç»„å·¥å…·ç±»
    function Difference(nums) {
        // å·®åˆ†æ•°ç»„
        let diff = new Array(nums.length).fill(0);

        /* è¾“å…¥ä¸€ä¸ªåˆå§‹æ•°ç»„ï¼ŒåŒºé—´æ“ä½œå°†åœ¨è¿™ä¸ªæ•°ç»„ä¸Šè¿›è¡Œ */
        this.increment = function(i, j, val) {
            diff[i] += val;
            if (j + 1 < diff.length) {
                diff[j + 1] -= val;
            }
        }

        /* è¿”å›ç»“æœæ•°ç»„ */
        this.result = function() {
            const res = new Array(diff.length).fill(0);
            // æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
            res[0] = diff[0];
            for (let i = 1; i < diff.length; i++) {
                res[i] = res[i - 1] + diff[i];
            }
            return res;
        }

        // æ ¹æ®åˆå§‹æ•°ç»„æ„é€ å·®åˆ†æ•°ç»„
        diff[0] = nums[0];
        for (let i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        # æœ€å¤šæœ‰ 1000 ä¸ªè½¦ç«™
        nums = [0] * 1001
        # æ„é€ å·®åˆ†è§£æ³•
        df = self.Difference(nums)

        for trip in trips:
            # ä¹˜å®¢æ•°é‡
            val = trip[0]
            # ç¬¬ trip[1] ç«™ä¹˜å®¢ä¸Šè½¦
            i = trip[1]
            # ç¬¬ trip[2] ç«™ä¹˜å®¢å·²ç»ä¸‹è½¦ï¼Œ
            # å³ä¹˜å®¢åœ¨è½¦ä¸Šçš„åŒºé—´æ˜¯ [trip[1], trip[2] - 1]
            j = trip[2] - 1
            # è¿›è¡ŒåŒºé—´æ“ä½œ
            df.increment(i, j, val)

        res = df.result()

        # å®¢è½¦è‡ªå§‹è‡³ç»ˆéƒ½ä¸åº”è¯¥è¶…è½½
        for i in range(len(res)):
            if capacity < res[i]:
                return False
        return True

    # å·®åˆ†æ•°ç»„å·¥å…·ç±»
    class Difference:
        # å·®åˆ†æ•°ç»„
        diff = []

        """è¾“å…¥ä¸€ä¸ªåˆå§‹æ•°ç»„ï¼ŒåŒºé—´æ“ä½œå°†åœ¨è¿™ä¸ªæ•°ç»„ä¸Šè¿›è¡Œ"""
        def __init__(self, nums):
            assert len(nums) > 0
            self.diff = [0] * len(nums)
            # æ ¹æ®åˆå§‹æ•°ç»„æ„é€ å·®åˆ†æ•°ç»„
            self.diff[0] = nums[0]
            for i in range(1, len(nums)):
                self.diff[i] = nums[i] - nums[i - 1]

        """ç»™é—­åŒºé—´ [i, j] å¢åŠ  valï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰"""
        def increment(self, i, j, val):
            self.diff[i] += val
            if j + 1 < len(self.diff):
                self.diff[j + 1] -= val

        """è¿”å›ç»“æœæ•°ç»„"""
        def result(self):
            res = [0] * len(self.diff)
            # æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
            res[0] = self.diff[0]
            for i in range(1, len(self.diff)):
                res[i] = res[i - 1] + self.diff[i]
            return res
```

https://leetcode.cn/problems/car-pooling çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/cheapest-flights-within-k-stops çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    unordered_map<int, vector<vector<int>>> indegree;
    int src, dst;
    // å¤‡å¿˜å½•
    vector<vector<int>> memo;

public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {
        // å°†ä¸­è½¬ç«™ä¸ªæ•°è½¬åŒ–æˆè¾¹çš„æ¡æ•°
        K++;
        this->src = src;
        this->dst = dst;
        // åˆå§‹åŒ–å¤‡å¿˜å½•ï¼Œå…¨éƒ¨å¡«ä¸€ä¸ªç‰¹æ®Šå€¼
        memo = vector<vector<int>>(n, vector<int>(K + 1, -888));

        for (auto &f : flights) {
            int from = f[0];
            int to = f[1];
            int price = f[2];
            // è®°å½•è°æŒ‡å‘è¯¥èŠ‚ç‚¹ï¼Œä»¥åŠä¹‹é—´çš„æƒé‡
            indegree[to].push_back(vector<int>{from, price});
        }

        return dp(dst, K);
    }

    // å®šä¹‰ï¼šä» src å‡ºå‘ï¼Œk æ­¥ä¹‹å†…åˆ°è¾¾ s çš„æœ€çŸ­è·¯å¾„æƒé‡
    int dp(int s, int k) {
        // base case
        if (s == src) {
            return 0;
        }
        if (k == 0) {
            return -1;
        }
        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢å†—ä½™è®¡ç®—
        if (memo[s][k] != -888) {
            return memo[s][k];
        }

        // åˆå§‹åŒ–ä¸ºæœ€å¤§å€¼ï¼Œæ–¹ä¾¿ç­‰ä¼šå–æœ€å°å€¼
        int res = INT_MAX;
        if (indegree.count(s)) {
            // å½“ s æœ‰å…¥åº¦èŠ‚ç‚¹æ—¶ï¼Œåˆ†è§£ä¸ºå­é—®é¢˜
            auto &v = indegree[s];
            for (auto &p : v) {
                int from = p[0];
                int price = p[1];
                // ä» src åˆ°è¾¾ç›¸é‚»çš„å…¥åº¦èŠ‚ç‚¹æ‰€éœ€çš„æœ€çŸ­è·¯å¾„æƒé‡
                int subProblem = dp(from, k - 1);
                /**<extend up -300>
                ![](../pictures/æ—…è¡Œæœ€çŸ­è·¯å¾„/4.jpeg)
                */
                // è·³è¿‡æ— è§£çš„æƒ…å†µ
                if (subProblem != -1) {
                    res = min(res, subProblem + price);
                }
            }
        }
        // å­˜å…¥å¤‡å¿˜å½•
        memo[s][k] = res == INT_MAX ? -1 : res;
        return memo[s][k];
    }
};
```

```go
// by chatGPT (go)
func findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {
    // å°†ä¸­è½¬ç«™ä¸ªæ•°è½¬åŒ–æˆè¾¹çš„æ¡æ•°
    K++
    // åˆå§‹åŒ–å¤‡å¿˜å½•ï¼Œå…¨éƒ¨å¡«ä¸€ä¸ªç‰¹æ®Šå€¼
    memo := make([][]int, n)
    for i := range memo {
        memo[i] = make([]int, K+1)
        for j := range memo[i] {
            memo[i][j] = -888
        }
    }

    indegree := make(map[int][][]int)
    for _, f := range flights {
        from, to, price := f[0], f[1], f[2]
        // è®°å½•è°æŒ‡å‘è¯¥èŠ‚ç‚¹ï¼Œä»¥åŠä¹‹é—´çš„æƒé‡
        indegree[to] = append(indegree[to], []int{from, price})
    }

    return dp(dst, K, src, memo, indegree)
}

// å®šä¹‰ï¼šä» src å‡ºå‘ï¼Œk æ­¥ä¹‹å†…åˆ°è¾¾ s çš„æœ€çŸ­è·¯å¾„æƒé‡
func dp(s int, k int, src int, memo [][]int, indegree map[int][][]int) int {
    // base case
    if s == src {
        return 0
    }
    if k == 0 {
        return -1
    }
    // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢å†—ä½™è®¡ç®—
    if memo[s][k] != -888 {
        return memo[s][k]
    }

    // åˆå§‹åŒ–ä¸ºæœ€å¤§å€¼ï¼Œæ–¹ä¾¿ç­‰ä¼šå–æœ€å°å€¼
    res := math.MaxInt32
    if v, ok := indegree[s]; ok {
        // å½“ s æœ‰å…¥åº¦èŠ‚ç‚¹æ—¶ï¼Œåˆ†è§£ä¸ºå­é—®é¢˜
        for _, edge := range v {
            from, price := edge[0], edge[1]
            // ä» src åˆ°è¾¾ç›¸é‚»çš„å…¥åº¦èŠ‚ç‚¹æ‰€éœ€çš„æœ€çŸ­è·¯å¾„æƒé‡
            subProblem := dp(from, k-1, src, memo, indegree)
            // è·³è¿‡æ— è§£çš„æƒ…å†µ
            if subProblem != -1 {
                res = min(res, subProblem+price)
            }
        }
    }
    // å­˜å…¥å¤‡å¿˜å½•
    if res == math.MaxInt32 {
        memo[s][k] = -1
    } else {
        memo[s][k] = res
    }
    return memo[s][k]
}

func min(x, y int) int {
    if x < y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {
    HashMap<Integer, List<int[]>> indegree;
    int src, dst;
    // å¤‡å¿˜å½•
    int[][] memo;

    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        // å°†ä¸­è½¬ç«™ä¸ªæ•°è½¬åŒ–æˆè¾¹çš„æ¡æ•°
        K++;
        this.src = src;
        this.dst = dst;
        // åˆå§‹åŒ–å¤‡å¿˜å½•ï¼Œå…¨éƒ¨å¡«ä¸€ä¸ªç‰¹æ®Šå€¼
        memo = new int[n][K + 1];
        for (int[] row : memo) {
            Arrays.fill(row, -888);
        }

        indegree = new HashMap<>();
        for (int[] f : flights) {
            int from = f[0];
            int to = f[1];
            int price = f[2];
            // è®°å½•è°æŒ‡å‘è¯¥èŠ‚ç‚¹ï¼Œä»¥åŠä¹‹é—´çš„æƒé‡
            indegree.putIfAbsent(to, new LinkedList<>());
            indegree.get(to).add(new int[]{from, price});
        }

        return dp(dst, K);
    }

    // å®šä¹‰ï¼šä» src å‡ºå‘ï¼Œk æ­¥ä¹‹å†…åˆ°è¾¾ s çš„æœ€çŸ­è·¯å¾„æƒé‡
    int dp(int s, int k) {
        // base case
        if (s == src) {
            return 0;
        }
        if (k == 0) {
            return -1;
        }
        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢å†—ä½™è®¡ç®—
        if (memo[s][k] != -888) {
            return memo[s][k];
        }

        // åˆå§‹åŒ–ä¸ºæœ€å¤§å€¼ï¼Œæ–¹ä¾¿ç­‰ä¼šå–æœ€å°å€¼
        int res = Integer.MAX_VALUE;
        if (indegree.containsKey(s)) {
            // å½“ s æœ‰å…¥åº¦èŠ‚ç‚¹æ—¶ï¼Œåˆ†è§£ä¸ºå­é—®é¢˜
            for (int[] v : indegree.get(s)) {
                int from = v[0];
                int price = v[1];
                // ä» src åˆ°è¾¾ç›¸é‚»çš„å…¥åº¦èŠ‚ç‚¹æ‰€éœ€çš„æœ€çŸ­è·¯å¾„æƒé‡
                int subProblem = dp(from, k - 1);
                /**<extend up -300>
                ![](../pictures/æ—…è¡Œæœ€çŸ­è·¯å¾„/4.jpeg)
                */
                // è·³è¿‡æ— è§£çš„æƒ…å†µ
                if (subProblem != -1) {
                    res = Math.min(res, subProblem + price);
                }
            }
        }
        // å­˜å…¥å¤‡å¿˜å½•
        memo[s][k] = res == Integer.MAX_VALUE ? -1 : res;
        return memo[s][k];
    }
}
```

```javascript
// by chatGPT (javascript)
var findCheapestPrice = function(n, flights, src, dst, K) {
    // å°†ä¸­è½¬ç«™ä¸ªæ•°è½¬åŒ–æˆè¾¹çš„æ¡æ•°
    K++;
    // å®šä¹‰å¤‡å¿˜å½•
    const memo = Array.from({ length: n }, () => Array(K + 1).fill(-888));
    // åˆå§‹åŒ–èµ·ç‚¹å’Œç»ˆç‚¹
    const [source, target] = [src, dst];

    // æ„å»ºå…¥åº¦å­—å…¸
    const indegree = new Map();
    for (const [from, to, price] of flights) {
        indegree.set(to, (indegree.get(to) || []).concat([[from, price]]));
    }

    function dp(s, k) {
        // base case
        if (s === source) {
            return 0;
        }
        if (k === 0) {
            return -1;
        }
        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢å†—ä½™è®¡ç®—
        if (memo[s][k] !== -888) {
            return memo[s][k];
        }

        // åˆå§‹åŒ–ä¸ºæœ€å¤§å€¼ï¼Œæ–¹ä¾¿ç­‰ä¼šå–æœ€å°å€¼
        let res = Infinity;
        if (indegree.has(s)) {
            // å½“ s æœ‰å…¥åº¦èŠ‚ç‚¹æ—¶ï¼Œåˆ†è§£ä¸ºå­é—®é¢˜
            for (const [from, price] of indegree.get(s)) {
                // ä» src åˆ°è¾¾ç›¸é‚»çš„å…¥åº¦èŠ‚ç‚¹æ‰€éœ€çš„æœ€çŸ­è·¯å¾„æƒé‡
                const subProblem = dp(from, k - 1);
                /**<extend up -300>
                ![](../pictures/æ—…è¡Œæœ€çŸ­è·¯å¾„/4.jpeg)
                */
                // è·³è¿‡æ— è§£çš„æƒ…å†µ
                if (subProblem !== -1) {
                    res = Math.min(res, subProblem + price);
                }
            }
        }
        // å­˜å…¥å¤‡å¿˜å½•
        memo[s][k] = res === Infinity ? -1 : res;
        return memo[s][k];
    }

    return dp(target, K);
};
```

```python
# by chatGPT (python)
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        # å°†ä¸­è½¬ç«™ä¸ªæ•°è½¬åŒ–æˆè¾¹çš„æ¡æ•°
        K += 1
        # åˆå§‹åŒ–å¤‡å¿˜å½•ï¼Œå…¨éƒ¨å¡«ä¸€ä¸ªç‰¹æ®Šå€¼
        memo = [[-888] * (K + 1) for _ in range(n)]
        # å®šä¹‰å…¥åº¦å­—å…¸
        indegree = {}
        for f in flights:
            from_, to, price = f
            # è®°å½•è°æŒ‡å‘è¯¥èŠ‚ç‚¹ï¼Œä»¥åŠä¹‹é—´çš„æƒé‡
            if to not in indegree:
                indegree[to] = []
            indegree[to].append([from_, price])

        # å®šä¹‰ï¼šä» src å‡ºå‘ï¼Œk æ­¥ä¹‹å†…åˆ°è¾¾ s çš„æœ€çŸ­è·¯å¾„æƒé‡
        def dp(s: int, k: int) -> int:
            # base case
            if s == src:
                return 0
            if k == 0:
                return -1
            # æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢å†—ä½™è®¡ç®—
            if memo[s][k] != -888:
                return memo[s][k]

            # åˆå§‹åŒ–ä¸ºæœ€å¤§å€¼ï¼Œæ–¹ä¾¿ç­‰ä¼šå–æœ€å°å€¼
            res = float('inf')
            if s in indegree:
                # å½“ s æœ‰å…¥åº¦èŠ‚ç‚¹æ—¶ï¼Œåˆ†è§£ä¸ºå­é—®é¢˜
                for v in indegree[s]:
                    from_, price = v
                    # ä» src åˆ°è¾¾ç›¸é‚»çš„å…¥åº¦èŠ‚ç‚¹æ‰€éœ€çš„æœ€çŸ­è·¯å¾„æƒé‡
                    sub_problem = dp(from_, k - 1)
                    # è·³è¿‡æ— è§£çš„æƒ…å†µ
                    if sub_problem != -1:
                        res = min(res, sub_problem + price)

            # å­˜å…¥å¤‡å¿˜å½•
            memo[s][k] = -1 if res == float('inf') else res
            return memo[s][k]

        return dp(dst, K)
```

https://leetcode.cn/problems/cheapest-flights-within-k-stops çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/chou-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int nthUglyNumber(int n) {
        // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæŒ‡å‘æœ‰åºé“¾è¡¨å¤´ç»“ç‚¹çš„æŒ‡é’ˆ
        int p2 = 1, p3 = 1, p5 = 1;
        // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæœ‰åºé“¾è¡¨çš„å¤´èŠ‚ç‚¹çš„å€¼
        int product2 = 1, product3 = 1, product5 = 1;
        // å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
        int ugly[n + 1];
        // å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        int p = 1;

        // å¼€å§‹åˆå¹¶ä¸‰ä¸ªæœ‰åºé“¾è¡¨
        while (p <= n) {
            // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
            int minVal = min({product2, product3, product5});
            // æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
            ugly[p] = minVal;
            p++;
            // å‰è¿›å¯¹åº”æœ‰åºé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
            if (minVal == product2) {
                product2 = 2 * ugly[p2];
                p2++;
            }
            if (minVal == product3) {
                product3 = 3 * ugly[p3];
                p3++;
            }
            if (minVal == product5) {
                product5 = 5 * ugly[p5];
                p5++;
            }
        }
        // è¿”å›ç¬¬ n ä¸ªä¸‘æ•°
        return ugly[n];
    }
};
```

```go
// by chatGPT (go)
func nthUglyNumber(n int) int {
    // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæŒ‡å‘æœ‰åºé“¾è¡¨å¤´ç»“ç‚¹çš„æŒ‡é’ˆ
    p2, p3, p5 := 1, 1, 1
    // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæœ‰åºé“¾è¡¨çš„å¤´èŠ‚ç‚¹çš„å€¼
    product2, product3, product5 := 1, 1, 1
    // å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
    ugly := make([]int, n+1)
    // å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
    p := 1

    // å¼€å§‹åˆå¹¶ä¸‰ä¸ªæœ‰åºé“¾è¡¨
    for p <= n {
        // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
        min := min(min(product2, product3), product5)
        // æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
        ugly[p] = min
        p++
        // å‰è¿›å¯¹åº”æœ‰åºé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        if min == product2 {
            product2 = 2 * ugly[p2]
            p2++
        }
        if min == product3 {
            product3 = 3 * ugly[p3]
            p3++
        }
        if min == product5 {
            product5 = 5 * ugly[p5]
            p5++
        }
    }
    // è¿”å›ç¬¬ n ä¸ªä¸‘æ•°
    return ugly[n]
}

func min(x, y int) int {
    if x < y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {
    public int nthUglyNumber(int n) {
        // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæŒ‡å‘æœ‰åºé“¾è¡¨å¤´ç»“ç‚¹çš„æŒ‡é’ˆ
        int p2 = 1, p3 = 1, p5 = 1;
        // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæœ‰åºé“¾è¡¨çš„å¤´èŠ‚ç‚¹çš„å€¼
        int product2 = 1, product3 = 1, product5 = 1;
        // å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
        int[] ugly = new int[n + 1];
        // å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        int p = 1;

        // å¼€å§‹åˆå¹¶ä¸‰ä¸ªæœ‰åºé“¾è¡¨
        while (p <= n) {
            // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
            int min = Math.min(Math.min(product2, product3), product5);
            // æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
            ugly[p] = min;
            p++;
            // å‰è¿›å¯¹åº”æœ‰åºé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
            if (min == product2) {
                product2 = 2 * ugly[p2];
                p2++;
            }
            if (min == product3) {
                product3 = 3 * ugly[p3];
                p3++;
            }
            if (min == product5) {
                product5 = 5 * ugly[p5];
                p5++;
            }
        }
        // è¿”å›ç¬¬ n ä¸ªä¸‘æ•°
        return ugly[n];
    }
}
```

```javascript
// by chatGPT (javascript)
var nthUglyNumber = function(n) {
    // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæŒ‡å‘æœ‰åºé“¾è¡¨å¤´ç»“ç‚¹çš„æŒ‡é’ˆ
    let p2 = 1, p3 = 1, p5 = 1;
    // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæœ‰åºé“¾è¡¨çš„å¤´èŠ‚ç‚¹çš„å€¼
    let product2 = 1, product3 = 1, product5 = 1;
    // å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
    let ugly = new Array(n+1);
    // å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
    let p = 1;

    // å¼€å§‹åˆå¹¶ä¸‰ä¸ªæœ‰åºé“¾è¡¨
    while (p <= n) {
        // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
        let min = Math.min(Math.min(product2, product3), product5);
        // æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
        ugly[p] = min;
        p++;
        // å‰è¿›å¯¹åº”æœ‰åºé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        if (min === product2) {
            product2 = 2 * ugly[p2];
            p2++;
        }
        if (min === product3) {
            product3 = 3 * ugly[p3];
            p3++;
        }
        if (min === product5) {
            product5 = 5 * ugly[p5];
            p5++;
        }
    }
    // è¿”å›ç¬¬ n ä¸ªä¸‘æ•°
    return ugly[n];
};
```

```python
# by chatGPT (python)
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        # å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæŒ‡å‘æœ‰åºé“¾è¡¨å¤´ç»“ç‚¹çš„æŒ‡é’ˆ
        p2, p3, p5 = 1, 1, 1
        # å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæœ‰åºé“¾è¡¨çš„å¤´èŠ‚ç‚¹çš„å€¼
        product2, product3, product5 = 1, 1, 1
        # å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
        ugly = [0] * (n+1)
        # å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        p = 1

        # å¼€å§‹åˆå¹¶ä¸‰ä¸ªæœ‰åºé“¾è¡¨
        while p <= n:
            # å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
            min_val = min(product2, product3, product5)
            # æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
            ugly[p] = min_val
            p += 1
            # å‰è¿›å¯¹åº”æœ‰åºé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
            if min_val == product2:
                product2 = 2 * ugly[p2]
                p2 += 1
            if min_val == product3:
                product3 = 3 * ugly[p3]
                p3 += 1
            if min_val == product5:
                product5 = 5 * ugly[p5]
                p5 += 1

        # è¿”å›ç¬¬ n ä¸ªä¸‘æ•°
        return ugly[n]
```

https://leetcode.cn/problems/chou-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/climbing-stairs çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // å¤‡å¿˜å½•
    vector<int> memo;

    int climbStairs(int n) {
        memo.resize(n + 1, 0);
        return dp(n);
    }

    // å®šä¹‰ï¼šçˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ä¸º dp(n)
    int dp(int n) {
        // base case
        if (n <= 2) {
            return n;
        }
        if (memo[n] > 0) {
            return memo[n];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // çˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ç­‰äºçˆ¬åˆ° n - 1 çš„æ–¹æ³•ä¸ªæ•°å’Œçˆ¬åˆ° n - 2 çš„æ–¹æ³•ä¸ªæ•°ä¹‹å’Œã€‚
        memo[n] = dp(n - 1) + dp(n - 2);
        return memo[n];
    }
};
```

```go
// by chatGPT (go)
func climbStairs(n int) int {
    memo := make([]int, n+1)
    var dp func(int) int
    dp = func(n int) int {
        // base case
        if n <= 2 {
            return n
        }
        if memo[n] > 0 {
            return memo[n]
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // çˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ç­‰äºçˆ¬åˆ° n - 1 çš„æ–¹æ³•ä¸ªæ•°å’Œçˆ¬åˆ° n - 2 çš„æ–¹æ³•ä¸ªæ•°ä¹‹å’Œã€‚
        memo[n] = dp(n-1) + dp(n-2)
        return memo[n]
    }
    return dp(n)
}
```

```java
// by labuladong (java)
class Solution {
    // å¤‡å¿˜å½•
    int[] memo;

    public int climbStairs(int n) {
        memo = new int[n + 1];
        return dp(n);
    }

    // å®šä¹‰ï¼šçˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ä¸º dp(n)
    int dp(int n) {
        // base case
        if (n <= 2) {
            return n;
        }
        if (memo[n] > 0) {
            return memo[n];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // çˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ç­‰äºçˆ¬åˆ° n - 1 çš„æ–¹æ³•ä¸ªæ•°å’Œçˆ¬åˆ° n - 2 çš„æ–¹æ³•ä¸ªæ•°ä¹‹å’Œã€‚
        memo[n] = dp(n - 1) + dp(n - 2);
        return memo[n];
    }
}
```

```javascript
// by chatGPT (javascript)
var climbStairs = function(n) {
    // å¤‡å¿˜å½•
    const memo = new Array(n + 1).fill(0);
    return dp(n);

    // å®šä¹‰ï¼šçˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ä¸º dp(n)
    function dp(n) {
        // base case
        if (n <= 2) {
            return n;
        }
        if (memo[n] > 0) {
            return memo[n];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // çˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ç­‰äºçˆ¬åˆ° n - 1 çš„æ–¹æ³•ä¸ªæ•°å’Œçˆ¬åˆ° n - 2 çš„æ–¹æ³•ä¸ªæ•°ä¹‹å’Œã€‚
        memo[n] = dp(n - 1) + dp(n - 2);
        return memo[n];
    }
};
```

```python
# by chatGPT (python)
class Solution:
    # å¤‡å¿˜å½•
    memo = []

    def climbStairs(self, n: int) -> int:
        self.memo = [0] * (n + 1)
        return self.dp(n)

    # å®šä¹‰ï¼šçˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ä¸º dp(n)
    def dp(self, n: int) -> int:
        # base case
        if n <= 2:
            return n
        if self.memo[n] > 0:
            return self.memo[n]
        # çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        # çˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ç­‰äºçˆ¬åˆ° n - 1 çš„æ–¹æ³•ä¸ªæ•°å’Œçˆ¬åˆ° n - 2 çš„æ–¹æ³•ä¸ªæ•°ä¹‹å’Œã€‚
        self.memo[n] = self.dp(n - 1) + self.dp(n - 2)
        return self.memo[n]
```

https://leetcode.cn/problems/climbing-stairs çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/coin-change çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    vector<int> memo;

    public:
    int coinChange(vector<int>& coins, int amount) {
        memo.resize(amount + 1);
        // dp æ•°ç»„å…¨éƒ½åˆå§‹åŒ–ä¸ºç‰¹æ®Šå€¼
        fill(memo.begin(), memo.end(), -666);
        return dp(coins, amount);
    }

    int dp(vector<int>& coins, int amount) {
        if (amount == 0) return 0;
        if (amount < 0) return -1;
        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[amount] != -666)
            return memo[amount];

        int res = INT_MAX;
        for (int coin : coins) {
            // è®¡ç®—å­é—®é¢˜çš„ç»“æœ
            int subProblem = dp(coins, amount - coin);
            /**<extend up -200> 
            ![](../pictures/åŠ¨æ€è§„åˆ’è¯¦è§£è¿›é˜¶/5.jpg)
            */
            // å­é—®é¢˜æ— è§£åˆ™è·³è¿‡
            if (subProblem == -1) continue;
            // åœ¨å­é—®é¢˜ä¸­é€‰æ‹©æœ€ä¼˜è§£ï¼Œç„¶ååŠ ä¸€
            res = min(res, subProblem + 1);
        }
        // æŠŠè®¡ç®—ç»“æœå­˜å…¥å¤‡å¿˜å½•
        memo[amount] = (res == INT_MAX) ? -1 : res;
        return memo[amount];
    }
};
```

```go
// by chatGPT (go)
func coinChange(coins []int, amount int) int {
    memo := make([]int, amount+1)
    for i := 0; i <= amount; i++ {
        memo[i] = -666
    }
    return dp(coins, amount, memo)
}

func dp(coins []int, amount int, memo []int) int {
    if amount == 0 {
        return 0
    }
    if amount < 0 {
        return -1
    }
    // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
    if memo[amount] != -666 {
        return memo[amount]
    }

    res := math.MaxInt32
    for _, coin := range coins {
        // è®¡ç®—å­é—®é¢˜çš„ç»“æœ
        subProblem := dp(coins, amount-coin, memo)
        // å­é—®é¢˜æ— è§£åˆ™è·³è¿‡
        if subProblem == -1 {
            continue
        }
        // åœ¨å­é—®é¢˜ä¸­é€‰æ‹©æœ€ä¼˜è§£ï¼Œç„¶ååŠ ä¸€
        res = min(res, subProblem+1)
    }
    // æŠŠè®¡ç®—ç»“æœå­˜å…¥å¤‡å¿˜å½•
    if res == math.MaxInt32 {
        memo[amount] = -1
    } else {
        memo[amount] = res
    }
    return memo[amount]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    int[] memo;

    public int coinChange(int[] coins, int amount) {
        memo = new int[amount + 1];
        // dp æ•°ç»„å…¨éƒ½åˆå§‹åŒ–ä¸ºç‰¹æ®Šå€¼
        Arrays.fill(memo, -666);
        return dp(coins, amount);
    }

    int dp(int[] coins, int amount) {
        if (amount == 0) return 0;
        if (amount < 0) return -1;
        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[amount] != -666)
            return memo[amount];

        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            // è®¡ç®—å­é—®é¢˜çš„ç»“æœ
            int subProblem = dp(coins, amount - coin);
            /**<extend up -200> 
            ![](../pictures/åŠ¨æ€è§„åˆ’è¯¦è§£è¿›é˜¶/5.jpg)
            */
            // å­é—®é¢˜æ— è§£åˆ™è·³è¿‡
            if (subProblem == -1) continue;
            // åœ¨å­é—®é¢˜ä¸­é€‰æ‹©æœ€ä¼˜è§£ï¼Œç„¶ååŠ ä¸€
            res = Math.min(res, subProblem + 1);
        }
        // æŠŠè®¡ç®—ç»“æœå­˜å…¥å¤‡å¿˜å½•
        memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
        return memo[amount];
    }
}
```

```javascript
// by chatGPT (javascript)
var coinChange = function(coins, amount) {
    let memo = new Array(amount + 1).fill(-666);
    return dp(coins, amount);

    function dp(coins, amount) {
        if (amount == 0) return 0;
        if (amount < 0) return -1;
        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[amount] != -666)
            return memo[amount];

        let res = Number.MAX_SAFE_INTEGER;
        for (let coin of coins) {
            // è®¡ç®—å­é—®é¢˜çš„ç»“æœ
            let subProblem = dp(coins, amount - coin);
            // å­é—®é¢˜æ— è§£åˆ™è·³è¿‡
            if (subProblem == -1) continue;
            // åœ¨å­é—®é¢˜ä¸­é€‰æ‹©æœ€ä¼˜è§£ï¼Œç„¶ååŠ ä¸€
            res = Math.min(res, subProblem + 1);
        }
        // æŠŠè®¡ç®—ç»“æœå­˜å…¥å¤‡å¿˜å½•
        memo[amount] = (res == Number.MAX_SAFE_INTEGER) ? -1 : res;
        return memo[amount];
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.memo = []

    def coinChange(self, coins: List[int], amount: int) -> int:
        self.memo = [-666] * (amount + 1)
        return self.dp(coins, amount)

    def dp(self, coins: List[int], amount: int) -> int:
        if amount == 0:
            return 0
        if amount < 0:
            return -1
        # æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if self.memo[amount] != -666:
            return self.memo[amount]

        res = float("inf")
        for coin in coins:
            # è®¡ç®—å­é—®é¢˜çš„ç»“æœ
            sub_problem = self.dp(coins, amount - coin)
            # å­é—®é¢˜æ— è§£åˆ™è·³è¿‡
            if sub_problem == -1:
                continue
            # åœ¨å­é—®é¢˜ä¸­é€‰æ‹©æœ€ä¼˜è§£ï¼Œç„¶ååŠ ä¸€
            res = min(res, sub_problem + 1)

        # æŠŠè®¡ç®—ç»“æœå­˜å…¥å¤‡å¿˜å½•
        self.memo[amount] = -1 if res == float("inf") else res
        return self.memo[amount]
```

https://leetcode.cn/problems/coin-change çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/coin-change-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();
        vector<vector<int>> dp(n + 1, vector<int>(amount + 1));
        // base case
        for (int i = 0; i <= n; i++)
            dp[i][0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= amount; j++)
                if (j - coins[i-1] >= 0)
                    dp[i][j] = dp[i - 1][j]
                            + dp[i][j - coins[i-1]];
                else
                    dp[i][j] = dp[i - 1][j];
        }
        return dp[n][amount];
    }
};
```

```go
// by chatGPT (go)
func change(amount int, coins []int) int {
    n := len(coins)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, amount+1)
        dp[i][0] = 1
    }

    for i := 1; i <= n; i++ {
        for j := 1; j <= amount; j++ {
            if j-coins[i-1] >= 0 {
                dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]
            } else {
                dp[i][j] = dp[i-1][j]
            }
        }
    }

    return dp[n][amount]
}
```

```java
// by labuladong (java)
class Solution {
    public int change(int amount, int[] coins) {
        int n = coins.length;
        int[][] dp = new int[n + 1][amount + 1];
        // base case
        for (int i = 0; i <= n; i++)
            dp[i][0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= amount; j++)
                if (j - coins[i-1] >= 0)
                    dp[i][j] = dp[i - 1][j]
                            + dp[i][j - coins[i-1]];
                else
                    dp[i][j] = dp[i - 1][j];
        }
        return dp[n][amount];
    }
}
```

```javascript
// by chatGPT (javascript)
var change = function(amount, coins) {
    let n = coins.length;
    let dp = Array.from(Array(n + 1), () => Array(amount + 1).fill(0));
    // base case
    for (let i = 0; i <= n; i++) {
        dp[i][0] = 1;
    }

    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= amount; j++) {
            if (j - coins[i-1] >= 0) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i-1]];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[n][amount];
};
```

```python
# by chatGPT (python)
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        n = len(coins)
        dp = [[0]*(amount + 1) for i in range(n+1)]
        # base case
        for i in range(n+1):
            dp[i][0] = 1

        for i in range(1, n+1):
            for j in range(1, amount+1):
                if j - coins[i-1] >= 0:
                    dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i-1]]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[n][amount]
```

https://leetcode.cn/problems/coin-change-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/combination-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> res;

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        if (candidates.size() == 0) {
            return res;
        }
        backtrack(candidates, 0, target, 0);
        return res;
    }

    // è®°å½•å›æº¯çš„è·¯å¾„
    vector<int> track;

    // å›æº¯ç®—æ³•ä¸»å‡½æ•°
    void backtrack(vector<int>& candidates, int start, int target, int sum) {
        if (sum == target) {
            // æ‰¾åˆ°ç›®æ ‡å’Œ
            res.push_back(track);
            return;
        }

        if (sum > target) {
            // è¶…è¿‡ç›®æ ‡å’Œï¼Œç›´æ¥ç»“æŸ
            return;
        }

        // å›æº¯ç®—æ³•æ¡†æ¶
        for (int i = start; i < candidates.size(); i++) {
            // é€‰æ‹© candidates[i]
            track.push_back(candidates[i]);
            sum += candidates[i];
            // é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
            backtrack(candidates, i, target, sum);
            // æ’¤é”€é€‰æ‹© candidates[i]
            sum -= candidates[i];
            track.pop_back();
        }
    }
};
```

```go
// by chatGPT (go)
func combinationSum(candidates []int, target int) [][]int {
	var res [][]int

	// å®šä¹‰å›æº¯å‡½æ•°
	var backtrack func(start int, target int, sum int, track []int)

	backtrack = func(start int, target int, sum int, track []int) {
		// å¦‚æœå½“å‰ sum ç­‰äº targetï¼Œè¯´æ˜å·²æ‰¾åˆ°ç¬¦åˆè¦æ±‚çš„ç»„åˆ
		if sum == target {
			// ç”±äº track æ•°ç»„ä¸ºå¼•ç”¨ç±»å‹ï¼Œå› æ­¤éœ€è¦é‡æ–°ç”Ÿæˆä¸€ä¸ªæ•°ç»„å¯¹è±¡æ¥ä¿å­˜åˆ°ç»“æœé›†
			res = append(res, append([]int{}, track...))
			return
		}

		// å¦‚æœå½“å‰ sum å·²ç»å¤§äº targetï¼Œå›æº¯ç»“æŸ
		if sum > target {
			return
		}

		// ä»æŒ‡å®šä½ç½®å¼€å§‹éå†å€™é€‰æ•°ç»„
		for i := start; i < len(candidates); i++ {
			// å°†å€™é€‰æ•°ç»„å½“å‰å…ƒç´ åŠ å…¥è·¯å¾„
			track = append(track, candidates[i])
			sum += candidates[i]
			// ç»§ç»­éå†ä¸‹ä¸€ä¸ªå…ƒç´ 
			backtrack(i, target, sum, track)
			// å›æº¯ï¼šå°†å½“å‰å…ƒç´ ä»è·¯å¾„ä¸­ç§»é™¤
			sum -= candidates[i]
			track = track[:len(track)-1]
		}
	}

	backtrack(0, target, 0, []int{})

	return res
}
```

```java
// by labuladong (java)
class Solution {
    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if (candidates.length == 0) {
            return res;
        }
        backtrack(candidates, 0, target, 0);
        return res;
    }

    // è®°å½•å›æº¯çš„è·¯å¾„
    LinkedList<Integer> track = new LinkedList<>();

    // å›æº¯ç®—æ³•ä¸»å‡½æ•°
    void backtrack(int[] candidates, int start, int target, int sum) {
        if (sum == target) {
            // æ‰¾åˆ°ç›®æ ‡å’Œ
            res.add(new LinkedList<>(track));
            return;
        }

        if (sum > target) {
            // è¶…è¿‡ç›®æ ‡å’Œï¼Œç›´æ¥ç»“æŸ
            return;
        }

        // å›æº¯ç®—æ³•æ¡†æ¶
        for (int i = start; i < candidates.length; i++) {
            // é€‰æ‹© candidates[i]
            track.add(candidates[i]);
            sum += candidates[i];
            // é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
            backtrack(candidates, i, target, sum);
            // æ’¤é”€é€‰æ‹© candidates[i]
            sum -= candidates[i];
            track.removeLast();
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var combinationSum = function(candidates, target) {
    let res = [];
    let track = [];
    
    backtrack(candidates, 0, target, 0, track);
    
    return res;
    
    function backtrack(candidates, start, target, sum, track) {
        if (sum === target) {
            // æ‰¾åˆ°ç›®æ ‡å’Œ
            res.push([...track]);
            return;
        }

        if (sum > target) {
            // è¶…è¿‡ç›®æ ‡å’Œï¼Œç›´æ¥ç»“æŸ
            return;
        }

        // å›æº¯ç®—æ³•æ¡†æ¶
        for (let i = start; i < candidates.length; i++) {
            // é€‰æ‹© candidates[i]
            track.push(candidates[i]);
            sum += candidates[i];
            // é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
            backtrack(candidates, i, target, sum, track);
            // æ’¤é”€é€‰æ‹© candidates[i]
            sum -= candidates[i];
            track.pop();
        }
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.res = []

    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        if not candidates:
            return self.res
        self.backtrack(candidates, 0, target, 0)
        return self.res

    # è®°å½•å›æº¯çš„è·¯å¾„
    track = []

    # å›æº¯ç®—æ³•ä¸»å‡½æ•°
    def backtrack(self, candidates, start, target, sum):
        if sum == target:
            # æ‰¾åˆ°ç›®æ ‡å’Œ
            self.res.append(self.track[:])
            return

        if sum > target:
            # è¶…è¿‡ç›®æ ‡å’Œï¼Œç›´æ¥ç»“æŸ
            return

        # å›æº¯ç®—æ³•æ¡†æ¶
        for i in range(start, len(candidates)):
            # é€‰æ‹© candidates[i]
            self.track.append(candidates[i])
            sum += candidates[i]
            # é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
            self.backtrack(candidates, i, target, sum)
            # æ’¤é”€é€‰æ‹© candidates[i]
            sum -= candidates[i]
            self.track.pop()
```

https://leetcode.cn/problems/combination-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/combinations çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:

    vector<vector<int>>res;
    vector<vector<int>> combine(int n, int k) {
        if (k <= 0 || n <= 0) return res;
        vector<int> track;
        backtrack(n, k, 1, track);
        return res;
    }

    void backtrack(int n, int k, int start, vector<int>& track) {
        // åˆ°è¾¾æ ‘çš„åº•éƒ¨
        if (k == track.size()) {
            res.push_back(track);
            return;
        }
        // æ³¨æ„ i ä» start å¼€å§‹é€’å¢
        for (int i = start; i <= n; i++) {
            // åšé€‰æ‹©
            track.push_back(i);
            backtrack(n, k, i + 1, track);
            // æ’¤é”€é€‰æ‹©
            track.pop_back();
        }
    }
};
```

```go
// by chatGPT (go)
func combine(n int, k int) [][]int {
    res := [][]int{}
    if k <= 0 || n <= 0 {
        return res
    }
    track := []int{}
    backtrack := func(n, k, start int, track []int) {}
    backtrack = func(n, k, start int, track []int) {
        // åˆ°è¾¾æ ‘çš„åº•éƒ¨
        if k == len(track) {
            ans := make([]int, k)
            copy(ans, track)
            res = append(res, ans)
            return
        }
        // æ³¨æ„ i ä» start å¼€å§‹é€’å¢
        for i := start; i <= n; i++ {
            // åšé€‰æ‹©
            track = append(track, i)
            backtrack(n, k, i+1, track)
            // æ’¤é”€é€‰æ‹©
            track = track[:len(track)-1]
        }
    }
    backtrack(n, k, 1, track)
    return res
}
```

```java
// by chatGPT (java)
class Solution {
    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> combine(int n, int k) {
        if (k <= 0 || n <= 0) {
            return res;
        }
        List<Integer> track = new LinkedList<>();
        backtrack(n, k, 1, track);
        return res;
    }

    void backtrack(int n, int k, int start, List<Integer> track) {
        // åˆ°è¾¾æ ‘çš„åº•éƒ¨
        if (k == track.size()) {
            res.add(new LinkedList<>(track));
            return;
        }
        // æ³¨æ„ i ä» start å¼€å§‹é€’å¢
        for (int i = start; i <= n; i++) {
            // åšé€‰æ‹©
            track.add(i);
            backtrack(n, k, i + 1, track);
            // æ’¤é”€é€‰æ‹©
            track.remove(track.size() - 1);
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var combine = function(n, k) {
    let res = [];
    if (k <= 0 || n <= 0) return res;
    let track = [];
    backtrack(n, k, 1, track, res);
    return res;
};

var backtrack = function(n, k, start, track, res) {
    // åˆ°è¾¾æ ‘çš„åº•éƒ¨
    if (k === track.length) {
        res.push([...track]);
        return;
    }
    // æ³¨æ„ i ä» start å¼€å§‹é€’å¢
    for (let i = start; i <= n; i++) {
        // åšé€‰æ‹©
        track.push(i);
        backtrack(n, k, i + 1, track, res);
        // æ’¤é”€é€‰æ‹©
        track.pop();
    }
};

// Example usage
console.log(combine(4, 2)); // [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.res = []

    def combine(self, n: int, k: int) -> List[List[int]]:
        if k <= 0 or n <= 0:
            return self.res
        track = []
        self.backtrack(n, k, 1, track)
        return self.res

    def backtrack(self, n: int, k: int, start: int, track: List[int]) -> None:
        # åˆ°è¾¾æ ‘çš„åº•éƒ¨
        if k == len(track):
            self.res.append(track[:])
            return
        # æ³¨æ„ i ä» start å¼€å§‹é€’å¢
        for i in range(start, n + 1):
            # åšé€‰æ‹©
            track.append(i)
            self.backtrack(n, k, i + 1, track)
            # æ’¤é”€é€‰æ‹©
            track.pop()
```

https://leetcode.cn/problems/combinations çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (root == nullptr) {
            return res;
        }

        queue<TreeNode*> q;
        q.push(root);
        // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while (!q.empty()) {
            int sz = q.size();
            // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            vector<int> level;
            // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for (int i = 0; i < sz; i++) {
                TreeNode* cur = q.front();
                q.pop();
                level.push_back(cur->val);
                if (cur->left != nullptr)
                    q.push(cur->left);
                if (cur->right != nullptr)
                    q.push(cur->right);
            }
            res.push_back(level);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func levelOrder(root *TreeNode) [][]int {
    res := [][]int{}
    if root == nil {
        return res
    }

    q := []*TreeNode{root}
    // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
    for len(q) != 0 {
        sz := len(q)
        // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
        level := []int{}
        // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]
            level = append(level, cur.Val)
            if cur.Left != nil {
                q = append(q, cur.Left)
            }
            if cur.Right != nil {
                q = append(q, cur.Right)
            }
        }
        res = append(res, level)
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        if (root == null) {
            return res;
        }

        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while (!q.isEmpty()) {
            int sz = q.size();
            // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            List<Integer> level = new LinkedList<>();
            // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                level.add(cur.val);
                if (cur.left != null)
                    q.offer(cur.left);
                if (cur.right != null)
                    q.offer(cur.right);
            }
            res.add(level);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var levelOrder = function(root) {
    let res = [];
    if (root == null) {
        return res;
    }

    let q = [];
    q.push(root);
    // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
    while (q.length > 0) {
        let sz = q.length;
        // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
        let level = [];
        // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
        for (let i = 0; i < sz; i++) {
            let cur = q.shift();
            level.push(cur.val);
            if (cur.left != null)
                q.push(cur.left);
            if (cur.right != null)
                q.push(cur.right);
        }
        res.push(level);
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []
        if not root:
            return res

        q = collections.deque()
        q.append(root)
        # while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while q:
            sz = len(q)
            # è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            level = []
            # for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for i in range(sz):
                cur = q.popleft()
                level.append(cur.val)
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
            res.append(level)
        return res
```

https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (root == nullptr) {
            return res;
        }

        queue<TreeNode*> q;
        q.push(root);
        // ä¸º true æ—¶å‘å³ï¼Œfalse æ—¶å‘å·¦
        bool flag = true;

        // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while (!q.empty()) {
            int sz = q.size();
            // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            deque<int> level;
            // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for (int i = 0; i < sz; i++) {
                TreeNode* cur = q.front();
                q.pop();
                // å®ç° z å­—å½¢éå†
                if (flag) {
                    level.push_back(cur->val);
                } else {
                    level.push_front(cur->val);
                }
                if (cur->left != nullptr)
                    q.push(cur->left);
                if (cur->right != nullptr)
                    q.push(cur->right);
            }
            // åˆ‡æ¢æ–¹å‘
            flag = !flag;
            res.emplace_back(vector<int>(level.begin(), level.end()));
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func zigzagLevelOrder(root *TreeNode) [][]int {
    res := [][]int{}
    if root == nil {
        return res
    }

    q := []*TreeNode{root}
    // ä¸º true æ—¶å‘å³ï¼Œfalse æ—¶å‘å·¦
    flag := true

    // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
    for len(q) > 0 {
        sz := len(q)
        // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
        level := []int{}
        // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]
            // å®ç° z å­—å½¢éå†
            if flag {
                level = append(level, cur.Val)
            } else {
                level = append([]int{cur.Val}, level...)
            }
            if cur.Left != nil {
                q = append(q, cur.Left)
            }
            if cur.Right != nil {
                q = append(q, cur.Right)
            }
        }
        // åˆ‡æ¢æ–¹å‘
        flag = !flag
        res = append(res, level)
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        if (root == null) {
            return res;
        }

        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        // ä¸º true æ—¶å‘å³ï¼Œfalse æ—¶å‘å·¦
        boolean flag = true;

        // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while (!q.isEmpty()) {
            int sz = q.size();
            // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            LinkedList<Integer> level = new LinkedList<>();
            // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                // å®ç° z å­—å½¢éå†
                if (flag) {
                    level.addLast(cur.val);
                } else {
                    level.addFirst(cur.val);
                }
                if (cur.left != null)
                    q.offer(cur.left);
                if (cur.right != null)
                    q.offer(cur.right);
            }
            // åˆ‡æ¢æ–¹å‘
            flag = !flag;
            res.add(level);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var zigzagLevelOrder = function(root) {
    let res = [];
    if (root === null) {
        return res;
    }

    let q = [];
    q.push(root);
    // ä¸º true æ—¶å‘å³ï¼Œfalse æ—¶å‘å·¦
    let flag = true;

    // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
    while (q.length !== 0) {
        let sz = q.length;
        // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
        let level = [];
        // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
        for (let i = 0; i < sz; i++) {
            let cur = q.shift();
            // å®ç° z å­—å½¢éå†
            if (flag) {
                level.push(cur.val);
            } else {
                level.unshift(cur.val);
            }
            if (cur.left !== null)
                q.push(cur.left);
            if (cur.right !== null)
                q.push(cur.right);
        }
        // åˆ‡æ¢æ–¹å‘
        flag = !flag;
        res.push(level);
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []
        if root is None:
            return res
        
        q = deque([root])
        # ä¸º True æ—¶å‘å³ï¼ŒFalse æ—¶å‘å·¦
        flag = True
        
        # while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while q:
            sz = len(q)
            # è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            level = deque()
            # for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for i in range(sz):
                cur = q.popleft()
                # å®ç° z å­—å½¢éå†
                if flag:
                    level.append(cur.val)
                else:
                    level.appendleft(cur.val)
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
            # åˆ‡æ¢æ–¹å‘
            flag = not flag
            res.append(list(level))
        return res
```

https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (root == nullptr) {
            return res;
        }

        queue<TreeNode*> q;
        q.push(root);
        // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while (!q.empty()) {
            int sz = q.size();
            // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            vector<int> level;
            // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for (int i = 0; i < sz; i++) {
                TreeNode* cur = q.front();
                q.pop();
                level.push_back(cur->val);
                if (cur->left != nullptr)
                    q.push(cur->left);
                if (cur->right != nullptr)
                    q.push(cur->right);
            }
            res.push_back(level);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func levelOrder(root *TreeNode) [][]int {
    res := [][]int{}
    if root == nil {
        return res
    }

    q := []*TreeNode{}
    q = append(q, root)
    // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
    for len(q) > 0 {
        sz := len(q)
        // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
        level := []int{}
        // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]
            level = append(level, cur.Val)
            if cur.Left != nil {
                q = append(q, cur.Left)
            }
            if cur.Right != nil {
                q = append(q, cur.Right)
            }
        }
        res = append(res, level)
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        if (root == null) {
            return res;
        }

        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while (!q.isEmpty()) {
            int sz = q.size();
            // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            List<Integer> level = new LinkedList<>();
            // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                level.add(cur.val);
                if (cur.left != null)
                    q.offer(cur.left);
                if (cur.right != null)
                    q.offer(cur.right);
            }
            res.add(level);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var levelOrder = function(root) {
    let res = [];
    if (!root) {
        return res;
    }

    let q = [];
    q.push(root);
    // while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
    while (q.length > 0) {
        let sz = q.length;
        // è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
        let level = [];
        // for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
        for (let i = 0; i < sz; i++) {
            let cur = q.shift();
            level.push(cur.val);
            if (cur.left !== null) {
                q.push(cur.left);
            }
            if (cur.right !== null) {
                q.push(cur.right);
            }
        }
        res.push(level);
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []
        if root is None:
            return res
        
        q = collections.deque()
        q.append(root)
        # while å¾ªç¯æ§åˆ¶ä»ä¸Šå‘ä¸‹ä¸€å±‚å±‚éå†
        while q:
            sz = len(q)
            # è®°å½•è¿™ä¸€å±‚çš„èŠ‚ç‚¹å€¼
            level = []
            # for å¾ªç¯æ§åˆ¶æ¯ä¸€å±‚ä»å·¦å‘å³éå†
            for i in range(sz):
                cur = q.popleft()
                level.append(cur.val)
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
            res.append(level)
        return res
```

https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        traverse(head);
        return res;
    }

    // è®°å½•é“¾è¡¨é•¿åº¦
    int len = 0;
    // ç»“æœæ•°ç»„
    vector<int> res;
    // ç»“æœæ•°ç»„ä¸­çš„æŒ‡é’ˆ
    int p = 0;

    // é€’å½’éå†å•é“¾è¡¨
    void traverse(ListNode* head) {
        if (head == nullptr) {
            // åˆ°è¾¾é“¾è¡¨å°¾éƒ¨ï¼Œæ­¤æ—¶çŸ¥é“äº†é“¾è¡¨çš„æ€»é•¿åº¦
            // åˆ›å»ºç»“æœæ•°ç»„
            res.resize(len);
            return;
        }
        len++;
        traverse(head->next);
        // ååºä½ç½®ï¼Œå¯ä»¥å€’åºæ“ä½œé“¾è¡¨
        res[p] = head->val;
        p++;
    }

    // ç”¨ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯å†™é€’å½’è§£æ³•
    // å› ä¸º C++ çš„ vector å¯ä»¥æ”¯æŒ push_back æ“ä½œï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸éœ€è¦æ”¹å˜è¿”å›å€¼ç±»å‹
    vector<int> reversePrint2(ListNode* head) {
        // base case
        if (head == nullptr) {
            return {};
        }

        // æŠŠå­é“¾è¡¨ç¿»è½¬çš„ç»“æœç®—å‡ºæ¥ï¼Œç¤ºä¾‹ [3,2]
        vector<int> subProblem = reversePrint2(head->next);
        // æŠŠ head çš„å€¼æ¥åˆ°å­é“¾è¡¨çš„ç¿»è½¬ç»“æœçš„å°¾éƒ¨ï¼Œç¤ºä¾‹ [3,2,1]
        subProblem.push_back(head->val);
        return subProblem;
    }
};
```

```go
// by chatGPT (go)
/*
ç”¨ã€Œéå†ã€çš„æ€è·¯å†™é€’å½’è§£æ³•
*/

func reversePrint(head *ListNode) []int {
    var res []int
    var len int

    // é€’å½’éå†å•é“¾è¡¨
    var traverse func(*ListNode)
    traverse = func(head *ListNode) {
        if head == nil {
            // åˆ°è¾¾é“¾è¡¨å°¾éƒ¨ï¼Œæ­¤æ—¶çŸ¥é“äº†é“¾è¡¨çš„æ€»é•¿åº¦
            // åˆ›å»ºç»“æœæ•°ç»„
            res = make([]int, len)
            return
        }
        len++
        traverse(head.Next)
        // ååºä½ç½®ï¼Œå¯ä»¥å€’åºæ“ä½œé“¾è¡¨
        res[len-p-1] = head.Val
        p++
    }

    traverse(head)
    return res
}

/*
ç”¨ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯å†™é€’å½’è§£æ³•
å› ä¸º Go ä¸æ”¯æŒæ³›å‹ï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠè¿”å›å€¼ä¿®æ”¹æˆ []int
å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªå•é“¾è¡¨ï¼Œè¿”å›è¯¥é“¾è¡¨ç¿»è½¬çš„å€¼ï¼Œç¤ºä¾‹ 1->2->3
*/
func reversePrint2(head *ListNode) []int {
    // base case
    if head == nil {
        return []int{}
    }

    // æŠŠå­é“¾è¡¨ç¿»è½¬çš„ç»“æœç®—å‡ºæ¥ï¼Œç¤ºä¾‹ [3,2]
    subProblem := reversePrint2(head.Next)
    // æŠŠ head çš„å€¼æ¥åˆ°å­é“¾è¡¨çš„ç¿»è½¬ç»“æœçš„å°¾éƒ¨ï¼Œç¤ºä¾‹ [3,2,1]
    return append(subProblem, head.Val)
}
```

```java
// by labuladong (java)
// ç”¨ã€Œéå†ã€çš„æ€è·¯å†™é€’å½’è§£æ³•
class Solution {
    public int[] reversePrint(ListNode head) {
        traverse(head);
        return res;
    }

    // è®°å½•é“¾è¡¨é•¿åº¦
    int len = 0;
    // ç»“æœæ•°ç»„
    int[] res;
    // ç»“æœæ•°ç»„ä¸­çš„æŒ‡é’ˆ
    int p = 0;

    // é€’å½’éå†å•é“¾è¡¨
    void traverse(ListNode head) {
        if (head == null) {
            // åˆ°è¾¾é“¾è¡¨å°¾éƒ¨ï¼Œæ­¤æ—¶çŸ¥é“äº†é“¾è¡¨çš„æ€»é•¿åº¦
            // åˆ›å»ºç»“æœæ•°ç»„
            res = new int[len];
            return;
        }
        len++;
        traverse(head.next);
        // ååºä½ç½®ï¼Œå¯ä»¥å€’åºæ“ä½œé“¾è¡¨
        res[p] = head.val;
        p++;
    }



    // ç”¨ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯å†™é€’å½’è§£æ³•
    // å› ä¸º Java çš„ int[] æ•°ç»„ä¸æ”¯æŒ add ç›¸å…³çš„æ“ä½œï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠè¿”å›å€¼ä¿®æ”¹æˆ List
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªå•é“¾è¡¨ï¼Œè¿”å›è¯¥é“¾è¡¨ç¿»è½¬çš„å€¼ï¼Œç¤ºä¾‹ 1->2->3
    List<Integer> reversePrint2(ListNode head) {
        // base case
        if (head == null) {
            return new LinkedList<>();
        }

        // æŠŠå­é“¾è¡¨ç¿»è½¬çš„ç»“æœç®—å‡ºæ¥ï¼Œç¤ºä¾‹ [3,2]
        List<Integer> subProblem = reversePrint2(head.next);
        // æŠŠ head çš„å€¼æ¥åˆ°å­é“¾è¡¨çš„ç¿»è½¬ç»“æœçš„å°¾éƒ¨ï¼Œç¤ºä¾‹ [3,2,1]
        subProblem.add(head.val);
        return subProblem;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * ç”¨ã€Œéå†ã€çš„æ€è·¯å†™é€’å½’è§£æ³•
 */

var reversePrint = function(head) {
  let len = 0; // è®°å½•é“¾è¡¨é•¿åº¦
  let res = []; // ç»“æœæ•°ç»„
  let p = 0; // ç»“æœæ•°ç»„ä¸­çš„æŒ‡é’ˆ

  // é€’å½’éå†å•é“¾è¡¨
  const traverse = (head) => {
    if (!head) {
      // åˆ°è¾¾é“¾è¡¨å°¾éƒ¨ï¼Œæ­¤æ—¶çŸ¥é“äº†é“¾è¡¨çš„æ€»é•¿åº¦
      // åˆ›å»ºç»“æœæ•°ç»„
      res = new Array(len);
      return;
    }
    len++;
    traverse(head.next);
    // ååºä½ç½®ï¼Œå¯ä»¥å€’åºæ“ä½œé“¾è¡¨
    res[p] = head.val;
    p++;
  };

  traverse(head);
  return res;
};


/**
 * ç”¨ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯å†™é€’å½’è§£æ³•
 * å› ä¸º Java çš„ int[] æ•°ç»„ä¸æ”¯æŒ add ç›¸å…³çš„æ“ä½œï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠè¿”å›å€¼ä¿®æ”¹æˆ List
 * å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªå•é“¾è¡¨ï¼Œè¿”å›è¯¥é“¾è¡¨ç¿»è½¬çš„å€¼ï¼Œç¤ºä¾‹ 1->2->3
 */
var reversePrint2 = function(head) {
  // base case
  if (!head) {
    return new LinkedList();
  }

  // æŠŠå­é“¾è¡¨ç¿»è½¬çš„ç»“æœç®—å‡ºæ¥ï¼Œç¤ºä¾‹ [3,2]
  let subProblem = reversePrint2(head.next);
  // æŠŠ head çš„å€¼æ¥åˆ°å­é“¾è¡¨çš„ç¿»è½¬ç»“æœçš„å°¾éƒ¨ï¼Œç¤ºä¾‹ [3,2,1]
  subProblem.push(head.val);
  return subProblem;
};
```

```python
# by chatGPT (python)
class Solution:
    def reversePrint(self, head: ListNode) -> List[int]:
        # ç”¨ã€Œéå†ã€çš„æ€è·¯å†™é€’å½’è§£æ³•
        def traverse(head):
            nonlocal len_, res, p
            if not head:
                res = [0] * len_
                return
            len_ += 1
            traverse(head.next)
            res[p] = head.val
            p += 1
        
        len_ = 0
        res = []
        p = 0
        traverse(head)
        return res

    def reversePrint2(self, head: ListNode) -> List[int]:
        # ç”¨ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯å†™é€’å½’è§£æ³•
        def sub_problem(head):
            if not head:
                return []
            sub_res = sub_problem(head.next)
            sub_res.append(head.val)
            return sub_res
        
        return sub_problem(head)
```

https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/connecting-cities-with-minimum-cost çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int minimumCost(int n, vector<vector<int>>& connections) {
        // åŸå¸‚ç¼–å·ä¸º 1...nï¼Œæ‰€ä»¥åˆå§‹åŒ–å¤§å°ä¸º n + 1
        UF uf(n + 1);
        // å¯¹æ‰€æœ‰è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
        sort(connections.begin(), connections.end(), [](vector<int>& a, vector<int>& b){
            return a[2] < b[2];
        });
        // è®°å½•æœ€å°ç”Ÿæˆæ ‘çš„æƒé‡ä¹‹å’Œ
        int mst = 0;
        for (auto& edge : connections) {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];
            // è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
            if (uf.connected(u, v)) {
                continue;
            }
            // è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
            mst += weight;
            uf.union_(u, v);
        }
        // ä¿è¯æ‰€æœ‰èŠ‚ç‚¹éƒ½è¢«è¿é€š
        // æŒ‰ç†è¯´ uf.count() == 1 è¯´æ˜æ‰€æœ‰èŠ‚ç‚¹è¢«è¿é€š
        // ä½†å› ä¸ºèŠ‚ç‚¹ 0 æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œæ‰€ä»¥ 0 ä¼šé¢å¤–å ç”¨ä¸€ä¸ªè¿é€šåˆ†é‡
        return uf.count() == 2 ? mst : -1;
    }

private:
    class UF {
    public:
        // è¿é€šåˆ†é‡ä¸ªæ•°
        int count;
        // å­˜å‚¨ä¸€æ£µæ ‘
        vector<int> parent;
        // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
        vector<int> size;

        // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
        UF(int n) : count(n), parent(n), size(n, 1) {
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }

        // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
        void union_(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ)
                return;

            // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
            if (size[rootP] > size[rootQ]) {
                parent[rootQ] = rootP;
                size[rootP] += size[rootQ];
            } else {
                parent[rootP] = rootQ;
                size[rootQ] += size[rootP];
            }
            // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
            count--;
        }

        // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
        bool connected(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            return rootP == rootQ;
        }

        // è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
        int find(int x) {
            while (parent[x] != x) {
                // è¿›è¡Œè·¯å¾„å‹ç¼©
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }
    };
};
```

```go
// by chatGPT (go)
func minimumCost(n int, connections [][]int) int {
    // åŸå¸‚ç¼–å·ä¸º 1...nï¼Œæ‰€ä»¥åˆå§‹åŒ–å¤§å°ä¸º n + 1
    uf := NewUF(n + 1)
    // å¯¹æ‰€æœ‰è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
    sort.Slice(connections, func(i, j int) bool {
        return connections[i][2] < connections[j][2]
    })
    // è®°å½•æœ€å°ç”Ÿæˆæ ‘çš„æƒé‡ä¹‹å’Œ
    mst := 0
    for _, edge := range connections {
        u := edge[0]
        v := edge[1]
        weight := edge[2]
        // è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
        if uf.connected(u, v) {
            continue
        }
        // è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
        mst += weight
        uf.union(u, v)
    }
    // ä¿è¯æ‰€æœ‰èŠ‚ç‚¹éƒ½è¢«è¿é€š
    // æŒ‰ç†è¯´ uf.count() == 1 è¯´æ˜æ‰€æœ‰èŠ‚ç‚¹è¢«è¿é€š
    // ä½†å› ä¸ºèŠ‚ç‚¹ 0 æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œæ‰€ä»¥ 0 ä¼šé¢å¤–å ç”¨ä¸€ä¸ªè¿é€šåˆ†é‡
    if uf.count() == 2 {
        return mst
    }
    return -1
}

type UF struct {
    // è¿é€šåˆ†é‡ä¸ªæ•°
    count int
    // å­˜å‚¨ä¸€æ£µæ ‘
    parent []int
    // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
    size []int
}

// n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
func NewUF(n int) *UF {
    uf := &UF{}
    uf.count = n
    uf.parent = make([]int, n)
    uf.size = make([]int, n)
    for i := 0; i < n; i++ {
        uf.parent[i] = i
        uf.size[i] = 1
    }
    return uf
}

// å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
func (uf *UF) union(p, q int) {
    rootP := uf.find(p)
    rootQ := uf.find(q)
    if rootP == rootQ {
        return
    }

    // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
    if uf.size[rootP] > uf.size[rootQ] {
        uf.parent[rootQ] = rootP
        uf.size[rootP] += uf.size[rootQ]
    } else {
        uf.parent[rootP] = rootQ
        uf.size[rootQ] += uf.size[rootP]
    }
    // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
    uf.count--
}

// åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
func (uf *UF) connected(p, q int) bool {
    rootP := uf.find(p)
    rootQ := uf.find(q)
    return rootP == rootQ
}

// è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
func (uf *UF) find(x int) int {
    for uf.parent[x] != x {
        // è¿›è¡Œè·¯å¾„å‹ç¼©
        uf.parent[x] = uf.parent[uf.parent[x]]
        x = uf.parent[x]
    }
    return x
}

// è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
func (uf *UF) count() int {
    return uf.count
}
```

```java
// by labuladong (java)
class Solution {
    public int minimumCost(int n, int[][] connections) {
        // åŸå¸‚ç¼–å·ä¸º 1...nï¼Œæ‰€ä»¥åˆå§‹åŒ–å¤§å°ä¸º n + 1
        UF uf = new UF(n + 1);
        // å¯¹æ‰€æœ‰è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
        Arrays.sort(connections, (a, b) -> (a[2] - b[2]));
        // è®°å½•æœ€å°ç”Ÿæˆæ ‘çš„æƒé‡ä¹‹å’Œ
        int mst = 0;
        for (int[] edge : connections) {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];
            // è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
            if (uf.connected(u, v)) {
                continue;
            }
            // è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
            mst += weight;
            uf.union(u, v);
        }
        // ä¿è¯æ‰€æœ‰èŠ‚ç‚¹éƒ½è¢«è¿é€š
        // æŒ‰ç†è¯´ uf.count() == 1 è¯´æ˜æ‰€æœ‰èŠ‚ç‚¹è¢«è¿é€š
        // ä½†å› ä¸ºèŠ‚ç‚¹ 0 æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œæ‰€ä»¥ 0 ä¼šé¢å¤–å ç”¨ä¸€ä¸ªè¿é€šåˆ†é‡
        return uf.count() == 2 ? mst : -1;
    }

    class UF {
        // è¿é€šåˆ†é‡ä¸ªæ•°
        private int count;
        // å­˜å‚¨ä¸€æ£µæ ‘
        private int[] parent;
        // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
        private int[] size;

        // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
        public UF(int n) {
            this.count = n;
            parent = new int[n];
            size = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }

        // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
        public void union(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ)
                return;

            // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
            if (size[rootP] > size[rootQ]) {
                parent[rootQ] = rootP;
                size[rootP] += size[rootQ];
            } else {
                parent[rootP] = rootQ;
                size[rootQ] += size[rootP];
            }
            // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
            count--;
        }

        // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
        public boolean connected(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            return rootP == rootQ;
        }

        // è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
        private int find(int x) {
            while (parent[x] != x) {
                // è¿›è¡Œè·¯å¾„å‹ç¼©
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }

        // è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
        public int count() {
            return count;
        }
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @param {number[][]} connections
 * @return {number}
 */
var minimumCost = function(n, connections) {
    // åŸå¸‚ç¼–å·ä¸º 1...nï¼Œæ‰€ä»¥åˆå§‹åŒ–å¤§å°ä¸º n + 1
    const uf = new UF(n + 1);
    // å¯¹æ‰€æœ‰è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
    connections.sort((a, b) => a[2] - b[2]);
    // è®°å½•æœ€å°ç”Ÿæˆæ ‘çš„æƒé‡ä¹‹å’Œ
    let mst = 0;
    for (const edge of connections) {
        const u = edge[0];
        const v = edge[1];
        const weight = edge[2];
        // è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
        if (uf.connected(u, v)) {
            continue;
        }
        // è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
        mst += weight;
        uf.union(u, v);
    }
    // ä¿è¯æ‰€æœ‰èŠ‚ç‚¹éƒ½è¢«è¿é€š
    // æŒ‰ç†è¯´ uf.count() == 1 è¯´æ˜æ‰€æœ‰èŠ‚ç‚¹è¢«è¿é€š
    // ä½†å› ä¸ºèŠ‚ç‚¹ 0 æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œæ‰€ä»¥ 0 ä¼šé¢å¤–å ç”¨ä¸€ä¸ªè¿é€šåˆ†é‡
    return uf.count() == 2 ? mst : -1;
};

class UF {
    // è¿é€šåˆ†é‡ä¸ªæ•°
    #count;
    // å­˜å‚¨ä¸€æ£µæ ‘
    #parent;
    // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
    #size;

    // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
    constructor(n) {
        this.#count = n;
        this.#parent = new Array(n);
        this.#size = new Array(n);
        for (let i = 0; i < n; i++) {
            this.#parent[i] = i;
            this.#size[i] = 1;
        }
    }

    // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    union(p, q) {
        const rootP = this.find(p);
        const rootQ = this.find(q);
        if (rootP === rootQ)
            return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (this.#size[rootP] > this.#size[rootQ]) {
            this.#parent[rootQ] = rootP;
            this.#size[rootP] += this.#size[rootQ];
        } else {
            this.#parent[rootP] = rootQ;
            this.#size[rootQ] += this.#size[rootP];
        }
        // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        this.#count--;
    }

    // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    connected(p, q) {
        const rootP = this.find(p);
        const rootQ = this.find(q);
        return rootP === rootQ;
    }

    // è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
    find(x) {
        while (this.#parent[x] !== x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            this.#parent[x] = this.#parent[this.#parent[x]];
            x = this.#parent[x];
        }
        return x;
    }

    // è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
    count() {
        return this.#count;
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def minimumCost(self, n: int, connections: List[List[int]]) -> int:
        # åŸå¸‚ç¼–å·ä¸º 1...nï¼Œæ‰€ä»¥åˆå§‹åŒ–å¤§å°ä¸º n + 1
        uf = UF(n + 1)
        # å¯¹æ‰€æœ‰è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
        connections.sort(key=lambda x: x[2])
        # è®°å½•æœ€å°ç”Ÿæˆæ ‘çš„æƒé‡ä¹‹å’Œ
        mst = 0
        for edge in connections:
            u, v, weight = edge
            # è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
            if uf.connected(u, v):
                continue
            # è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
            mst += weight
            uf.union(u, v)
        # ä¿è¯æ‰€æœ‰èŠ‚ç‚¹éƒ½è¢«è¿é€š
        # æŒ‰ç†è¯´ uf.count() == 1 è¯´æ˜æ‰€æœ‰èŠ‚ç‚¹è¢«è¿é€š
        # ä½†å› ä¸ºèŠ‚ç‚¹ 0 æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œæ‰€ä»¥ 0 ä¼šé¢å¤–å ç”¨ä¸€ä¸ªè¿é€šåˆ†é‡
        return mst if uf.count() == 2 else -1

class UF:
    # è¿é€šåˆ†é‡ä¸ªæ•°
    def __init__(self, n: int):
        self.count = n
        # å­˜å‚¨ä¸€æ£µæ ‘
        self.parent = list(range(n))
        # è®°å½•æ ‘çš„ã€Œé‡é‡ã€
        self.size = [1] * n

    # å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    def union(self, p: int, q: int):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP == rootQ:
            return

        # å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if self.size[rootP] > self.size[rootQ]:
            self.parent[rootQ] = rootP
            self.size[rootP] += self.size[rootQ]
        else:
            self.parent[rootP] = rootQ
            self.size[rootQ] += self.size[rootP]
        # ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        self.count -= 1

    # åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    def connected(self, p: int, q: int) -> bool:
        rootP = self.find(p)
        rootQ = self.find(q)
        return rootP == rootQ

    # è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
    def find(self, x: int) -> int:
        while self.parent[x] != x:
            # è¿›è¡Œè·¯å¾„å‹ç¼©
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    # è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
    def count(self) -> int:
        return self.count
```

https://leetcode.cn/problems/connecting-cities-with-minimum-cost çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
private:
    // å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    unordered_map<int, int> valToIndex;

public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        for (int i = 0; i < inorder.size(); i++) {
            valToIndex[inorder[i]] = i;
        }
        return build(inorder, 0, inorder.size() - 1,
                     postorder, 0, postorder.size() - 1);
    }

    /*
       å®šä¹‰ï¼š
       ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
       ååºéå†æ•°ç»„ä¸º postorder[postStart..postEnd]ï¼Œ
       æ„é€ è¿™ä¸ªäºŒå‰æ ‘å¹¶è¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    */
    TreeNode* build(vector<int>& inorder, int inStart, int inEnd,
                    vector<int>& postorder, int postStart, int postEnd) {

        if (inStart > inEnd) {
            return nullptr;
        }
        // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯ååºéå†æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ 
        int rootVal = postorder[postEnd];
        // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
        int index = valToIndex[rootVal];
        // å·¦å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°
        int leftSize = index - inStart;
        TreeNode* root = new TreeNode(rootVal);
        /**<extend up -200>
        ![](../pictures/äºŒå‰æ ‘ç³»åˆ—2/6.jpeg)
        */
        // é€’å½’æ„é€ å·¦å³å­æ ‘
        root->left = build(inorder, inStart, index - 1,
                            postorder, postStart, postStart + leftSize - 1);

        root->right = build(inorder, index + 1, inEnd,
                            postorder, postStart + leftSize, postEnd - 1);
        return root;
    }
};
```

```go
// by chatGPT (go)
func buildTree(inorder []int, postorder []int) *TreeNode {
    // å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    valToIndex := make(map[int]int)
    for i, val := range inorder {
        valToIndex[val] = i
    }
    return build(inorder, 0, len(inorder)-1,
                 postorder, 0, len(postorder)-1, valToIndex)
}

/*
   å®šä¹‰ï¼š
   ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
   ååºéå†æ•°ç»„ä¸º postorder[postStart..postEnd]ï¼Œ
   æ„é€ è¿™ä¸ªäºŒå‰æ ‘å¹¶è¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
*/
func build(inorder []int, inStart int, inEnd int,
           postorder []int, postStart int, postEnd int,
           valToIndex map[int]int) *TreeNode {
    if inStart > inEnd {
        return nil
    }
    // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯ååºéå†æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ 
    rootVal := postorder[postEnd]
    // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
    index := valToIndex[rootVal]
    // å·¦å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°
    leftSize := index - inStart
    root := &TreeNode{Val: rootVal}
    // é€’å½’æ„é€ å·¦å³å­æ ‘
    root.Left = build(inorder, inStart, index-1,
                      postorder, postStart, postStart+leftSize-1, valToIndex)
    root.Right = build(inorder, index+1, inEnd,
                       postorder, postStart+leftSize, postEnd-1, valToIndex)
    return root
}
```

```java
// by labuladong (java)
class Solution {
    // å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    HashMap<Integer, Integer> valToIndex = new HashMap<>();

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        for (int i = 0; i < inorder.length; i++) {
            valToIndex.put(inorder[i], i);
        }
        return build(inorder, 0, inorder.length - 1,
                    postorder, 0, postorder.length - 1);
    }

    /*
       å®šä¹‰ï¼š
       ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
       ååºéå†æ•°ç»„ä¸º postorder[postStart..postEnd]ï¼Œ
       æ„é€ è¿™ä¸ªäºŒå‰æ ‘å¹¶è¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    */
    TreeNode build(int[] inorder, int inStart, int inEnd,
                int[] postorder, int postStart, int postEnd) {

        if (inStart > inEnd) {
            return null;
        }
        // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯ååºéå†æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ 
        int rootVal = postorder[postEnd];
        // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
        int index = valToIndex.get(rootVal);
        // å·¦å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°
        int leftSize = index - inStart;
        TreeNode root = new TreeNode(rootVal);
        /**<extend up -200>
        ![](../pictures/äºŒå‰æ ‘ç³»åˆ—2/6.jpeg)
        */
        // é€’å½’æ„é€ å·¦å³å­æ ‘
        root.left = build(inorder, inStart, index - 1,
                         postorder, postStart, postStart + leftSize - 1);
        
        root.right = build(inorder, index + 1, inEnd,
                          postorder, postStart + leftSize, postEnd - 1);
        return root;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {
    // å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    const valToIndex = new Map();
    for (let i = 0; i < inorder.length; i++) {
        valToIndex.set(inorder[i], i);
    }
    return build(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1, valToIndex);
};

/**
* å®šä¹‰ï¼š
* ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
* ååºéå†æ•°ç»„ä¸º postorder[postStart..postEnd]ï¼Œ
* æ„é€ è¿™ä¸ªäºŒå‰æ ‘å¹¶è¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
*/
function build(inorder, inStart, inEnd, postorder, postStart, postEnd, valToIndex) {
    if (inStart > inEnd) {
        return null;
    }
    // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯ååºéå†æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ 
    const rootVal = postorder[postEnd];
    // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
    const index = valToIndex.get(rootVal);
    // å·¦å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°
    const leftSize = index - inStart;
    const root = new TreeNode(rootVal);
    /**<extend up -200>
    ![](../pictures/äºŒå‰æ ‘ç³»åˆ—2/6.jpeg)
    */
    // é€’å½’æ„é€ å·¦å³å­æ ‘
    root.left = build(inorder, inStart, index - 1, postorder, postStart, postStart + leftSize - 1, valToIndex);
    root.right = build(inorder, index + 1, inEnd, postorder, postStart + leftSize, postEnd - 1, valToIndex);
    return root;
}
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        # å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
        self.valToIndex = {}

    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        for i in range(len(inorder)):
            self.valToIndex[inorder[i]] = i
        return self.build(inorder, 0, len(inorder) - 1,
                          postorder, 0, len(postorder) - 1)

    '''
    å®šä¹‰ï¼š
    ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
    ååºéå†æ•°ç»„ä¸º postorder[postStart..postEnd]ï¼Œ
    æ„é€ è¿™ä¸ªäºŒå‰æ ‘å¹¶è¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    '''
    def build(self, inorder: List[int], inStart: int, inEnd: int,
              postorder: List[int], postStart: int, postEnd: int) -> TreeNode:

        if inStart > inEnd:
            return None
        # root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯ååºéå†æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ 
        rootVal = postorder[postEnd]
        # rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
        index = self.valToIndex[rootVal]
        # å·¦å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°
        leftSize = index - inStart
        root = TreeNode(rootVal)
        '''
        <extend up -200>
        ![](../pictures/äºŒå‰æ ‘ç³»åˆ—2/6.jpeg)
        '''
        # é€’å½’æ„é€ å·¦å³å­æ ‘
        root.left = self.build(inorder, inStart, index - 1,
                               postorder, postStart, postStart + leftSize - 1)

        root.right = self.build(inorder, index + 1, inEnd,
                                postorder, postStart + leftSize, postEnd - 1)
        return root
```

https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
private:
    // å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    unordered_map<int, int> valToIndex;

public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for (int i = 0; i < inorder.size(); i++) {
            valToIndex[inorder[i]] = i;
        }
        return build(preorder, 0, preorder.size() - 1,
                     inorder, 0, inorder.size() - 1);
    }

    /*
       å®šä¹‰ï¼šå‰åºéå†æ•°ç»„ä¸º preorder[preStart..preEnd]ï¼Œ
       ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
       æ„é€ è¿™ä¸ªäºŒå‰æ ‘å¹¶è¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    */
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd,
                    vector<int>& inorder, int inStart, int inEnd) {
        if (preStart > preEnd) {
            return nullptr;
        }

        // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        int rootVal = preorder[preStart];
        // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
        int index = valToIndex[rootVal];

        int leftSize = index - inStart;

        // å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
        TreeNode* root = new TreeNode(rootVal);
        // é€’å½’æ„é€ å·¦å³å­æ ‘
        root->left = build(preorder, preStart + 1, preStart + leftSize,
                           inorder, inStart, index - 1);
        root->right = build(preorder, preStart + leftSize + 1, preEnd,
                            inorder, index + 1, inEnd);

        return root;
    }
};
```

```go
// by chatGPT (go)
func buildTree(preorder []int, inorder []int) *TreeNode {
    // å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    valToIndex := make(map[int]int)
    for i, v := range inorder {
        valToIndex[v] = i
    }
    return build(preorder, 0, len(preorder)-1,
                 inorder, 0, len(inorder)-1, valToIndex)
}

/*
   å®šä¹‰ï¼šå‰åºéå†æ•°ç»„ä¸º preorder[preStart..preEnd]ï¼Œ
   ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
   æ„é€ è¿™ä¸ªäºŒå‰æ ‘å¹¶è¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
*/
func build(preorder []int, preStart int, preEnd int,
           inorder []int, inStart int, inEnd int,
           valToIndex map[int]int) *TreeNode {
    if preStart > preEnd {
        return nil
    }

    // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    rootVal := preorder[preStart]
    // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
    index := valToIndex[rootVal]

    leftSize := index - inStart

    // å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
    root := &TreeNode{Val: rootVal}
    // é€’å½’æ„é€ å·¦å³å­æ ‘
    root.Left = build(preorder, preStart+1, preStart+leftSize,
                      inorder, inStart, index-1, valToIndex)

    root.Right = build(preorder, preStart+leftSize+1, preEnd,
                       inorder, index+1, inEnd, valToIndex)
    return root
}
```

```java
// by labuladong (java)
class Solution {
    // å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    HashMap<Integer, Integer> valToIndex = new HashMap<>();

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for (int i = 0; i < inorder.length; i++) {
            valToIndex.put(inorder[i], i);
        }
        return build(preorder, 0, preorder.length - 1,
                    inorder, 0, inorder.length - 1);
    }

    /*
       å®šä¹‰ï¼šå‰åºéå†æ•°ç»„ä¸º preorder[preStart..preEnd]ï¼Œ
       ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
       æ„é€ è¿™ä¸ªäºŒå‰æ ‘å¹¶è¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    */
    TreeNode build(int[] preorder, int preStart, int preEnd,
                   int[] inorder, int inStart, int inEnd) {
        if (preStart > preEnd) {
            return null;
        }

        // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        int rootVal = preorder[preStart];
        // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
        int index = valToIndex.get(rootVal);

        int leftSize = index - inStart;

        // å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
        TreeNode root = new TreeNode(rootVal);
        /**<extend up -200>
        ![](../pictures/äºŒå‰æ ‘ç³»åˆ—2/4.jpeg)
        */
        // é€’å½’æ„é€ å·¦å³å­æ ‘
        root.left = build(preorder, preStart + 1, preStart + leftSize,
                inorder, inStart, index - 1);

        root.right = build(preorder, preStart + leftSize + 1, preEnd,
                inorder, index + 1, inEnd);
        return root;
    }
}
```

```javascript
// by chatGPT (javascript)
var buildTree = function(preorder, inorder) {
    // å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    var valToIndex = new Map();
    for (var i = 0; i < inorder.length; i++) {
        valToIndex.set(inorder[i], i);
    }
    return build(preorder, 0, preorder.length - 1,
                inorder, 0, inorder.length - 1);
};

/*
   å®šä¹‰ï¼šå‰åºéå†æ•°ç»„ä¸º preorder[preStart..preEnd]ï¼Œ
   ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
   æ„é€ è¿™ä¸ªäºŒå‰æ ‘å¹¶è¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
*/
var build = function(preorder, preStart, preEnd,
               inorder, inStart, inEnd) {
    if (preStart > preEnd) {
        return null;
    }
    // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    var rootVal = preorder[preStart];
    // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
    var index = valToIndex.get(rootVal);
    var leftSize = index - inStart;
    // å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
    var root = new TreeNode(rootVal);
    // é€’å½’æ„é€ å·¦å³å­æ ‘
    root.left = build(preorder, preStart + 1, preStart + leftSize,
            inorder, inStart, index - 1);
    root.right = build(preorder, preStart + leftSize + 1, preEnd,
            inorder, index + 1, inEnd);
    return root;
};
```

```python
# by chatGPT (python)
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        # å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
        valToIndex = {}
        for i in range(len(inorder)):
            valToIndex[inorder[i]] = i

        return self.build(preorder, 0, len(preorder) - 1,
                          inorder, 0, len(inorder) - 1, valToIndex)

    def build(self, preorder, preStart, preEnd, inorder, inStart, inEnd, valToIndex):
        if preStart > preEnd:
            return None

        # root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        rootVal = preorder[preStart]
        # rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
        index = valToIndex[rootVal]

        leftSize = index - inStart

        # å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
        root = TreeNode(rootVal)

        # é€’å½’æ„é€ å·¦å³å­æ ‘
        root.left = self.build(preorder, preStart + 1, preStart + leftSize,
                               inorder, inStart, index - 1, valToIndex)

        root.right = self.build(preorder, preStart + leftSize + 1, preEnd,
                                inorder, index + 1, inEnd, valToIndex)
        return root
```

https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    // å­˜å‚¨ postorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    unordered_map<int, int> valToIndex;

public:
    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
        for (int i = 0; i < postorder.size(); i++) {
            valToIndex[postorder[i]] = i;
        }
        return build(preorder, 0, preorder.size() - 1,
                     postorder, 0, postorder.size() - 1);
    }

    // å®šä¹‰ï¼šæ ¹æ® preorder[preStart..preEnd] å’Œ postorder[postStart..postEnd]
    // æ„å»ºäºŒå‰æ ‘ï¼Œå¹¶è¿”å›æ ¹èŠ‚ç‚¹ã€‚
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd,
                    vector<int>& postorder, int postStart, int postEnd) {
        if (preStart > preEnd) {
            return nullptr;
        }
        if (preStart == preEnd) {
            return new TreeNode(preorder[preStart]);
        }

        // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        int rootVal = preorder[preStart];
        // root.left çš„å€¼æ˜¯å‰åºéå†ç¬¬äºŒä¸ªå…ƒç´ 
        // é€šè¿‡å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘çš„å…³é”®åœ¨äºé€šè¿‡å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹
        // ç¡®å®š preorder å’Œ postorder ä¸­å·¦å³å­æ ‘çš„å…ƒç´ åŒºé—´
        int leftRootVal = preorder[preStart + 1];
        // leftRootVal åœ¨ååºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
        int index = valToIndex[leftRootVal];
        // å·¦å­æ ‘çš„å…ƒç´ ä¸ªæ•°
        int leftSize = index - postStart + 1;

        // å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
        TreeNode* root = new TreeNode(rootVal);

        // é€’å½’æ„é€ å·¦å³å­æ ‘
        // æ ¹æ®å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ç´¢å¼•å’Œå…ƒç´ ä¸ªæ•°æ¨å¯¼å·¦å³å­æ ‘çš„ç´¢å¼•è¾¹ç•Œ
        root->left = build(preorder, preStart + 1, preStart + leftSize,
                           postorder, postStart, index);
        root->right = build(preorder, preStart + leftSize + 1, preEnd,
                            postorder, index + 1, postEnd - 1);

        return root;
    }
};
```

```go
// by chatGPT (go)
// Definition for a binary tree node.
// type TreeNode struct {
//     Val int
//     Left *TreeNode
//     Right *TreeNode
// }

func constructFromPrePost(preorder []int, postorder []int) *TreeNode {
    // å­˜å‚¨ postorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    valToIndex := make(map[int]int)
    for i, v := range postorder {
        valToIndex[v] = i
    }
    return build(preorder, 0, len(preorder)-1, postorder, 0, len(postorder)-1, valToIndex)
}

// æ ¹æ® preorder[preStart..preEnd] å’Œ postorder[postStart..postEnd] æ„å»ºäºŒå‰æ ‘ï¼Œå¹¶è¿”å›æ ¹èŠ‚ç‚¹ã€‚
func build(preorder []int, preStart int, preEnd int, postorder []int, postStart int, postEnd int, valToIndex map[int]int) *TreeNode {
    if preStart > preEnd {
        return nil
    }
    if preStart == preEnd {
        return &TreeNode{Val: preorder[preStart]}
    }

    // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    rootVal := preorder[preStart]
    // root.left çš„å€¼æ˜¯å‰åºéå†ç¬¬äºŒä¸ªå…ƒç´ 
    // é€šè¿‡å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘çš„å…³é”®åœ¨äºé€šè¿‡å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹
    // ç¡®å®š preorder å’Œ postorder ä¸­å·¦å³å­æ ‘çš„å…ƒç´ åŒºé—´
    leftRootVal := preorder[preStart+1]
    // leftRootVal åœ¨ååºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
    index := valToIndex[leftRootVal]
    // å·¦å­æ ‘çš„å…ƒç´ ä¸ªæ•°
    leftSize := index - postStart + 1

    // å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
    root := &TreeNode{Val: rootVal}
    // é€’å½’æ„é€ å·¦å³å­æ ‘
    // æ ¹æ®å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ç´¢å¼•å’Œå…ƒç´ ä¸ªæ•°æ¨å¯¼å·¦å³å­æ ‘çš„ç´¢å¼•è¾¹ç•Œ
    root.Left = build(preorder, preStart+1, preStart+leftSize, postorder, postStart, index, valToIndex)
    root.Right = build(preorder, preStart+leftSize+1, preEnd, postorder, index+1, postEnd-1, valToIndex)

    return root
}
```

```java
// by labuladong (java)
class Solution {
    // å­˜å‚¨ postorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    HashMap<Integer, Integer> valToIndex = new HashMap<>();

    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        for (int i = 0; i < postorder.length; i++) {
            valToIndex.put(postorder[i], i);
        }
        return build(preorder, 0, preorder.length - 1,
                    postorder, 0, postorder.length - 1);
    }

    // å®šä¹‰ï¼šæ ¹æ® preorder[preStart..preEnd] å’Œ postorder[postStart..postEnd]
    // æ„å»ºäºŒå‰æ ‘ï¼Œå¹¶è¿”å›æ ¹èŠ‚ç‚¹ã€‚
    TreeNode build(int[] preorder, int preStart, int preEnd,
                   int[] postorder, int postStart, int postEnd) {
        if (preStart > preEnd) {
            return null;
        }
        if (preStart == preEnd) {
            return new TreeNode(preorder[preStart]);
        }

        // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        int rootVal = preorder[preStart];
        // root.left çš„å€¼æ˜¯å‰åºéå†ç¬¬äºŒä¸ªå…ƒç´ 
        // é€šè¿‡å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘çš„å…³é”®åœ¨äºé€šè¿‡å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹
        // ç¡®å®š preorder å’Œ postorder ä¸­å·¦å³å­æ ‘çš„å…ƒç´ åŒºé—´
        int leftRootVal = preorder[preStart + 1];
        // leftRootVal åœ¨ååºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
        int index = valToIndex.get(leftRootVal);
        // å·¦å­æ ‘çš„å…ƒç´ ä¸ªæ•°
        int leftSize = index - postStart + 1;

        // å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
        TreeNode root = new TreeNode(rootVal);
        /**<extend up -200>
        ![](../pictures/äºŒå‰æ ‘ç³»åˆ—2/8.jpeg)
        */
        // é€’å½’æ„é€ å·¦å³å­æ ‘
        // æ ¹æ®å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ç´¢å¼•å’Œå…ƒç´ ä¸ªæ•°æ¨å¯¼å·¦å³å­æ ‘çš„ç´¢å¼•è¾¹ç•Œ
        root.left = build(preorder, preStart + 1, preStart + leftSize,
                postorder, postStart, index);
        root.right = build(preorder, preStart + leftSize + 1, preEnd,
                postorder, index + 1, postEnd - 1);

        return root;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} preorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var constructFromPrePost = function(preorder, postorder) {
    // å­˜å‚¨ postorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    const valToIndex = new Map();
    for (let i = 0; i < postorder.length; i++) {
        valToIndex.set(postorder[i], i);
    }
    return build(preorder, 0, preorder.length - 1,
                postorder, 0, postorder.length - 1, valToIndex);
};

/**
 * @param {number[]} preorder
 * @param {number} preStart
 * @param {number} preEnd
 * @param {number[]} postorder
 * @param {number} postStart
 * @param {number} postEnd
 * @param {Map} valToIndex
 * @return {TreeNode}
 */
function build(preorder, preStart, preEnd, postorder, postStart, postEnd, valToIndex) {
    if (preStart > preEnd) {
        return null;
    }
    if (preStart === preEnd) {
        return new TreeNode(preorder[preStart]);
    }

    // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    const rootVal = preorder[preStart];
    // root.left çš„å€¼æ˜¯å‰åºéå†ç¬¬äºŒä¸ªå…ƒç´ 
    // é€šè¿‡å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘çš„å…³é”®åœ¨äºé€šè¿‡å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹
    // ç¡®å®š preorder å’Œ postorder ä¸­å·¦å³å­æ ‘çš„å…ƒç´ åŒºé—´
    const leftRootVal = preorder[preStart + 1];
    // leftRootVal åœ¨ååºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
    const index = valToIndex.get(leftRootVal);
    // å·¦å­æ ‘çš„å…ƒç´ ä¸ªæ•°
    const leftSize = index - postStart + 1;

    // å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
    const root = new TreeNode(rootVal);

    // é€’å½’æ„é€ å·¦å³å­æ ‘
    // æ ¹æ®å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ç´¢å¼•å’Œå…ƒç´ ä¸ªæ•°æ¨å¯¼å·¦å³å­æ ‘çš„ç´¢å¼•è¾¹ç•Œ
    root.left = build(preorder, preStart + 1, preStart + leftSize,
            postorder, postStart, index, valToIndex);
    root.right = build(preorder, preStart + leftSize + 1, preEnd,
            postorder, index + 1, postEnd - 1, valToIndex);

    return root;
}
```

```python
# by chatGPT (python)
class Solution:
    # å­˜å‚¨ postorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    valToIndex = {}

    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> TreeNode:
        for i in range(len(postorder)):
            self.valToIndex[postorder[i]] = i
        return self.build(preorder, 0, len(preorder) - 1,
                           postorder, 0, len(postorder) - 1)

    # å®šä¹‰ï¼šæ ¹æ® preorder[preStart..preEnd] å’Œ postorder[postStart..postEnd]
    # æ„å»ºäºŒå‰æ ‘ï¼Œå¹¶è¿”å›æ ¹èŠ‚ç‚¹ã€‚
    def build(self, preorder, preStart, preEnd, postorder, postStart, postEnd):
        if preStart > preEnd:
            return None
        if preStart == preEnd:
            return TreeNode(preorder[preStart])

        # root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        rootVal = preorder[preStart]
        # root.left çš„å€¼æ˜¯å‰åºéå†ç¬¬äºŒä¸ªå…ƒç´ 
        # é€šè¿‡å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘çš„å…³é”®åœ¨äºé€šè¿‡å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹
        # ç¡®å®š preorder å’Œ postorder ä¸­å·¦å³å­æ ‘çš„å…ƒç´ åŒºé—´
        leftRootVal = preorder[preStart + 1]
        # leftRootVal åœ¨ååºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
        index = self.valToIndex[leftRootVal]
        # å·¦å­æ ‘çš„å…ƒç´ ä¸ªæ•°
        leftSize = index - postStart + 1

        # å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
        root = TreeNode(rootVal)
        # é€’å½’æ„é€ å·¦å³å­æ ‘
        # æ ¹æ®å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ç´¢å¼•å’Œå…ƒç´ ä¸ªæ•°æ¨å¯¼å·¦å³å­æ ‘çš„ç´¢å¼•è¾¹ç•Œ
        root.left = self.build(preorder, preStart + 1, preStart + leftSize,
                               postorder, postStart, index)
        root.right = self.build(preorder, preStart + leftSize + 1, preEnd,
                                postorder, index + 1, postEnd - 1)

        return root
```

https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/container-with-most-water çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int res = 0;
        while (left < right) {
            // [left, right] ä¹‹é—´çš„çŸ©å½¢é¢ç§¯
            int cur_area = min(height[left], height[right]) * (right - left);
            res = max(res, cur_area);
            // åŒæŒ‡é’ˆæŠ€å·§ï¼Œç§»åŠ¨è¾ƒä½çš„ä¸€è¾¹
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func maxArea(height []int) int {
    left, right := 0, len(height)-1
    res := 0
    for left < right {
        // [left, right] ä¹‹é—´çš„çŸ©å½¢é¢ç§¯
        curArea := func() int {
            if height[left] < height[right] {
                return height[left] * (right - left)
            }
            return height[right] * (right - left)
        }()
        res = func() int {
            if curArea > res {
                return curArea
            }
            return res
        }()
        // åŒæŒ‡é’ˆæŠ€å·§ï¼Œç§»åŠ¨è¾ƒä½çš„ä¸€è¾¹
        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int res = 0;
        while (left < right) {
            // [left, right] ä¹‹é—´çš„çŸ©å½¢é¢ç§¯
            int cur_area = Math.min(height[left], height[right]) * (right - left);
            res = Math.max(res, cur_area);
            // åŒæŒ‡é’ˆæŠ€å·§ï¼Œç§»åŠ¨è¾ƒä½çš„ä¸€è¾¹
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    let left = 0, right = height.length - 1;
    let res = 0;
    while (left < right) {
        // [left, right] ä¹‹é—´çš„çŸ©å½¢é¢ç§¯
        const cur_area = Math.min(height[left], height[right]) * (right - left);
        res = Math.max(res, cur_area);
        // åŒæŒ‡é’ˆæŠ€å·§ï¼Œç§»åŠ¨è¾ƒä½çš„ä¸€è¾¹
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left, right = 0, len(height)-1
        res = 0
        while left < right:
            # [left, right] ä¹‹é—´çš„çŸ©å½¢é¢ç§¯
            cur_area = min(height[left], height[right]) * (right - left)
            res = max(res, cur_area)
            # åŒæŒ‡é’ˆæŠ€å·§ï¼Œç§»åŠ¨è¾ƒä½çš„ä¸€è¾¹
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        return res
```

https://leetcode.cn/problems/container-with-most-water çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/convert-bst-to-greater-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        traverse(root);
        return root;
    }

    // è®°å½•ç´¯åŠ å’Œ
    int sum = 0;
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        traverse(root->right);
        // ç»´æŠ¤ç´¯åŠ å’Œ
        sum += root->val;
        // å°† BST è½¬åŒ–æˆç´¯åŠ æ ‘
        root->val = sum;
        traverse(root->left);
    }
};
```

```go
// by chatGPT (go)
func convertBST(root *TreeNode) *TreeNode {
    // è®°å½•ç´¯åŠ å’Œ
    var sum int
    var traverse func(node *TreeNode)
    traverse = func(node *TreeNode) {
        if node == nil {
            return
        }
        traverse(node.Right)
        // ç»´æŠ¤ç´¯åŠ å’Œ
        sum += node.Val
        // å°† BST è½¬åŒ–æˆç´¯åŠ æ ‘
        node.Val = sum
        traverse(node.Left)
    }
    traverse(root)
    return root
}
```

```java
// by labuladong (java)
class Solution {
    public TreeNode convertBST(TreeNode root) {
        traverse(root);
        return root;
    }

    // è®°å½•ç´¯åŠ å’Œ
    int sum = 0;
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        traverse(root.right);
        // ç»´æŠ¤ç´¯åŠ å’Œ
        sum += root.val;
        // å°† BST è½¬åŒ–æˆç´¯åŠ æ ‘
        root.val = sum;
        traverse(root.left);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var convertBST = function(root) {
    // è®°å½•ç´¯åŠ å’Œ
    let sum = 0;
    // ä¸­åºéå†èŠ‚ç‚¹
    const traverse = function(node) {
        if (!node) {
            return;
        }
        traverse(node.right);  // å…ˆéå†å³å­æ ‘
        sum += node.val;  // ç»´æŠ¤ç´¯åŠ å’Œ
        node.val = sum;  // å°† BST èŠ‚ç‚¹çš„å€¼æ›´æ–°ä¸ºç´¯åŠ å’Œ
        traverse(node.left);  // éå†å·¦å­æ ‘
    }
    traverse(root);
    return root;
};
```

```python
# by chatGPT (python)
class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        self.sum = 0
        self.traverse(root)
        return root

    def traverse(self, root: TreeNode) -> None:
        if not root:
            return
        self.traverse(root.right)
        # ç»´æŠ¤ç´¯åŠ å’Œ
        self.sum += root.val
        # å°† BST è½¬åŒ–æˆç´¯åŠ æ ‘
        root.val = self.sum
        self.traverse(root.left)
```

https://leetcode.cn/problems/convert-bst-to-greater-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/copy-list-with-random-pointer çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map<Node*, Node*> originToClone;
        // ç¬¬ä¸€æ¬¡éå†ï¼Œå…ˆæŠŠæ‰€æœ‰èŠ‚ç‚¹å…‹éš†å‡ºæ¥
        for (Node* p = head; p != nullptr; p = p->next) {
            if (originToClone.count(p) == 0) {
                originToClone[p] = new Node(p->val);
            }
        }
        // ç¬¬äºŒæ¬¡éå†ï¼ŒæŠŠå…‹éš†èŠ‚ç‚¹çš„ç»“æ„è¿æ¥å¥½
        for (Node* p = head; p != nullptr; p = p->next) {
            if (p->next != nullptr) {
                originToClone[p]->next = originToClone[p->next];
            }
            if (p->random != nullptr) {
                originToClone[p]->random = originToClone[p->random];
            }
        }
        // è¿”å›å…‹éš†ä¹‹åçš„å¤´ç»“ç‚¹
        return originToClone[head];
    }
};

// ç”¨é€’å½’çš„æ–¹å¼è¿›è¡Œéå†
class Solution2 {
public:
    Node* copyRandomList(Node* head) {
        traverse(head);
        return originToClone[head];
    }

private:
    // è®°å½• DFS éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
    unordered_set<Node*> visited;
    // è®°å½•åŸèŠ‚ç‚¹åˆ°å…‹éš†èŠ‚ç‚¹çš„æ˜ å°„
    unordered_map<Node*, Node*> originToClone;

    // DFS å›¾éå†æ¡†æ¶
    void traverse(Node* node) {
        if (node == nullptr) {
            return;
        }
        if (visited.count(node) > 0) {
            return;
        }
        // å‰åºä½ç½®ï¼Œæ ‡è®°ä¸ºå·²è®¿é—®
        visited.insert(node);
        // å‰åºä½ç½®ï¼Œå…‹éš†èŠ‚ç‚¹
        if (originToClone.count(node) == 0) {
            originToClone[node] = new Node(node->val);
        }
        Node* cloneNode = originToClone[node];

        // é€’å½’éå†é‚»å±…èŠ‚ç‚¹ï¼Œå¹¶æ„å»ºå…‹éš†å›¾
        // é€’å½’ä¹‹åï¼Œé‚»å±…èŠ‚ç‚¹ä¸€å®šå­˜åœ¨ originToClone ä¸­
        traverse(node->next);
        cloneNode->next = originToClone[node->next];

        traverse(node->random);
        cloneNode->random = originToClone[node->random];
    }
};
```

```go
// by chatGPT (go)
func copyRandomList(head *Node) *Node {
    originToClone := make(map[*Node]*Node)
    // ç¬¬ä¸€æ¬¡éå†ï¼Œå…ˆæŠŠæ‰€æœ‰èŠ‚ç‚¹å…‹éš†å‡ºæ¥
    for p := head; p != nil; p = p.Next {
        if _, ok := originToClone[p]; !ok {
            originToClone[p] = &Node{
                Val: p.Val,
            }
        }
    }
    // ç¬¬äºŒæ¬¡éå†ï¼ŒæŠŠå…‹éš†èŠ‚ç‚¹çš„ç»“æ„è¿æ¥å¥½
    for p := head; p != nil; p = p.Next {
        if p.Next != nil {
            originToClone[p].Next = originToClone[p.Next]
        }
        if p.Random != nil {
            originToClone[p].Random = originToClone[p.Random]
        }
    }
    // è¿”å›å…‹éš†ä¹‹åçš„å¤´ç»“ç‚¹
    return originToClone[head]
}

// ç”¨é€’å½’çš„æ–¹å¼è¿›è¡Œéå†
func copyRandomList2(head *Node) *Node {
    visited := make(map[*Node]bool)
    originToClone := make(map[*Node]*Node)
    traverse(head, visited, originToClone)
    return originToClone[head]
}

// DFS å›¾éå†æ¡†æ¶
func traverse(node *Node, visited map[*Node]bool, originToClone map[*Node]*Node) {
    if node == nil {
        return
    }
    if visited[node] {
        return
    }
    // å‰åºä½ç½®ï¼Œæ ‡è®°ä¸ºå·²è®¿é—®
    visited[node] = true
    // å‰åºä½ç½®ï¼Œå…‹éš†èŠ‚ç‚¹
    if _, ok := originToClone[node]; !ok {
        originToClone[node] = &Node{
            Val: node.Val,
        }
    }
    cloneNode := originToClone[node]

    // é€’å½’éå†é‚»å±…èŠ‚ç‚¹ï¼Œå¹¶æ„å»ºå…‹éš†å›¾
    // é€’å½’ä¹‹åï¼Œé‚»å±…èŠ‚ç‚¹ä¸€å®šå­˜åœ¨ originToClone ä¸­

    traverse(node.Next, visited, originToClone)
    cloneNode.Next = originToClone[node.Next]

    traverse(node.Random, visited, originToClone)
    cloneNode.Random = originToClone[node.Random]
}
```

```java
// by labuladong (java)
class Solution {
    public Node copyRandomList(Node head) {
        HashMap<Node, Node> originToClone = new HashMap<>();
        // ç¬¬ä¸€æ¬¡éå†ï¼Œå…ˆæŠŠæ‰€æœ‰èŠ‚ç‚¹å…‹éš†å‡ºæ¥
        for (Node p = head; p != null; p = p.next) {
            if (!originToClone.containsKey(p)) {
                originToClone.put(p, new Node(p.val));
            }
        }
        // ç¬¬äºŒæ¬¡éå†ï¼ŒæŠŠå…‹éš†èŠ‚ç‚¹çš„ç»“æ„è¿æ¥å¥½
        for (Node p = head; p != null; p = p.next) {
            if (p.next != null) {
                originToClone.get(p).next = originToClone.get(p.next);
            }
            if (p.random != null) {
                originToClone.get(p).random = originToClone.get(p.random);
            }
        }
        // è¿”å›å…‹éš†ä¹‹åçš„å¤´ç»“ç‚¹
        return originToClone.get(head);
    }
}

// ç”¨é€’å½’çš„æ–¹å¼è¿›è¡Œéå†
class Solution2 {
    public Node copyRandomList(Node head) {
        traverse(head);
        return originToClone.get(head);
    }

    // è®°å½• DFS éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
    HashSet<Node> visited = new HashSet<>();
    // è®°å½•åŸèŠ‚ç‚¹åˆ°å…‹éš†èŠ‚ç‚¹çš„æ˜ å°„
    HashMap<Node, Node> originToClone = new HashMap<>();

    // DFS å›¾éå†æ¡†æ¶
    void traverse(Node node) {
        if (node == null) {
            return;
        }
        if (visited.contains(node)) {
            return;
        }
        // å‰åºä½ç½®ï¼Œæ ‡è®°ä¸ºå·²è®¿é—®
        visited.add(node);
        // å‰åºä½ç½®ï¼Œå…‹éš†èŠ‚ç‚¹
        if (!originToClone.containsKey(node)) {
            originToClone.put(node, new Node(node.val));
        }
        Node cloneNode = originToClone.get(node);

        // é€’å½’éå†é‚»å±…èŠ‚ç‚¹ï¼Œå¹¶æ„å»ºå…‹éš†å›¾
        // é€’å½’ä¹‹åï¼Œé‚»å±…èŠ‚ç‚¹ä¸€å®šå­˜åœ¨ originToClone ä¸­

        traverse(node.next);
        cloneNode.next = originToClone.get(node.next);

        traverse(node.random);
        cloneNode.random = originToClone.get(node.random);
    }
}
```

```javascript
// by chatGPT (javascript)
var copyRandomList = function(head) {
    const originToClone = new Map();

    // ç¬¬ä¸€æ¬¡éå†ï¼Œå…ˆæŠŠæ‰€æœ‰èŠ‚ç‚¹å…‹éš†å‡ºæ¥
    for (let p = head; p !== null; p = p.next) {
        if (!originToClone.has(p)) {
            originToClone.set(p, new Node(p.val));
        }
    }

    // ç¬¬äºŒæ¬¡éå†ï¼ŒæŠŠå…‹éš†èŠ‚ç‚¹çš„ç»“æ„è¿æ¥å¥½
    for (let p = head; p !== null; p = p.next) {
        if (p.next !== null) {
            originToClone.get(p).next = originToClone.get(p.next);
        }
        if (p.random !== null) {
            originToClone.get(p).random = originToClone.get(p.random);
        }
    }

    // è¿”å›å…‹éš†ä¹‹åçš„å¤´ç»“ç‚¹
    return originToClone.get(head);
};

// ç”¨é€’å½’çš„æ–¹å¼è¿›è¡Œéå†
var copyRandomList2 = function(head) {
    const visited = new Set();
    const originToClone = new Map();

    const traverse = (node) => {
        if (node === null) {
            return;
        }
        if (visited.has(node)) {
            return;
        }
        // å‰åºä½ç½®ï¼Œæ ‡è®°ä¸ºå·²è®¿é—®
        visited.add(node);
        // å‰åºä½ç½®ï¼Œå…‹éš†èŠ‚ç‚¹
        if (!originToClone.has(node)) {
            originToClone.set(node, new Node(node.val));
        }
        const cloneNode = originToClone.get(node);

        // é€’å½’éå†é‚»å±…èŠ‚ç‚¹ï¼Œå¹¶æ„å»ºå…‹éš†å›¾
        // é€’å½’ä¹‹åï¼Œé‚»å±…èŠ‚ç‚¹ä¸€å®šå­˜åœ¨ originToClone ä¸­
        traverse(node.next);
        cloneNode.next = originToClone.get(node.next);

        traverse(node.random);
        cloneNode.random = originToClone.get(node.random);
    };

    traverse(head);
    return originToClone.get(head);
};
```

```python
# by chatGPT (python)
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        originToClone = {}
        # ç¬¬ä¸€æ¬¡éå†ï¼Œå…ˆæŠŠæ‰€æœ‰èŠ‚ç‚¹å…‹éš†å‡ºæ¥
        p = head
        while p:
            if p not in originToClone:
                originToClone[p] = Node(p.val)
            p = p.next
        # ç¬¬äºŒæ¬¡éå†ï¼ŒæŠŠå…‹éš†èŠ‚ç‚¹çš„ç»“æ„è¿æ¥å¥½
        p = head
        while p:
            if p.next:
                originToClone[p].next = originToClone[p.next]
            if p.random:
                originToClone[p].random = originToClone[p.random]
            p = p.next
        # è¿”å›å…‹éš†ä¹‹åçš„å¤´ç»“ç‚¹
        return originToClone.get(head)

# ç”¨é€’å½’çš„æ–¹å¼è¿›è¡Œéå†
class Solution2:
    def copyRandomList(self, head: 'Node') -> 'Node':
        self.visited = set()
        self.originToClone = {}
        self.traverse(head)
        return self.originToClone.get(head)

    # DFS å›¾éå†æ¡†æ¶
    def traverse(self, node):
        if not node:
            return
        if node in self.visited:
            return
        # å‰åºä½ç½®ï¼Œæ ‡è®°ä¸ºå·²è®¿é—®
        self.visited.add(node)
        # å‰åºä½ç½®ï¼Œå…‹éš†èŠ‚ç‚¹
        if node not in self.originToClone:
            self.originToClone[node] = Node(node.val)
        cloneNode = self.originToClone[node]

        # é€’å½’éå†é‚»å±…èŠ‚ç‚¹ï¼Œå¹¶æ„å»ºå…‹éš†å›¾
        # é€’å½’ä¹‹åï¼Œé‚»å±…èŠ‚ç‚¹ä¸€å®šå­˜åœ¨ originToClone ä¸­
        self.traverse(node.next)
        cloneNode.next = self.originToClone.get(node.next)

        self.traverse(node.random)
        cloneNode.random = self.originToClone.get(node.random)
```

https://leetcode.cn/problems/copy-list-with-random-pointer çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/corporate-flight-bookings çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
        // nums åˆå§‹åŒ–ä¸ºå…¨ 0
        vector<int> nums(n);
        // æ„é€ å·®åˆ†è§£æ³•
        Difference df(nums);

        for (auto& booking : bookings) {
            // æ³¨æ„è½¬æˆæ•°ç»„ç´¢å¼•è¦å‡ä¸€å“¦
            int i = booking[0] - 1;
            int j = booking[1] - 1;
            int val = booking[2];
            // å¯¹åŒºé—´ nums[i..j] å¢åŠ  val
            df.increment(i, j, val);
        }
        // è¿”å›æœ€ç»ˆçš„ç»“æœæ•°ç»„
        return df.result();
    }

private:
    class Difference {
        // å·®åˆ†æ•°ç»„
        vector<int> diff;

    public:
        Difference(vector<int>& nums) {
            assert(nums.size() > 0);
            diff = vector<int>(nums.size());
            // æ„é€ å·®åˆ†æ•°ç»„
            diff[0] = nums[0];
            for (int i = 1; i < nums.size(); i++) {
                diff[i] = nums[i] - nums[i - 1];
            }
        }

        /* ç»™é—­åŒºé—´ [i, j] å¢åŠ  valï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰*/
        void increment(int i, int j, int val) {
            diff[i] += val;
            if (j + 1 < diff.size()) {
                diff[j + 1] -= val;
            }
        }

        vector<int> result() {
            vector<int> res(diff.size());
            // æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
            res[0] = diff[0];
            for (int i = 1; i < diff.size(); i++) {
                res[i] = res[i - 1] + diff[i];
            }
            return res;
        }
    };
};
```

```go
// by chatGPT (go)
func corpFlightBookings(bookings [][]int, n int) []int {
    // nums åˆå§‹åŒ–ä¸ºå…¨ 0
    nums := make([]int, n)
    // æ„é€ å·®åˆ†è§£æ³•
    df := Difference{nums}

    for _, booking := range bookings {
        // æ³¨æ„è½¬æˆæ•°ç»„ç´¢å¼•è¦å‡ä¸€å“¦
        i := booking[0] - 1
        j := booking[1] - 1
        val := booking[2]
        // å¯¹åŒºé—´ nums[i..j] å¢åŠ  val
        df.increment(i, j, val)
    }
    // è¿”å›æœ€ç»ˆçš„ç»“æœæ•°ç»„
    return df.result()
}

type Difference struct {
    // å·®åˆ†æ•°ç»„
    diff []int
}

func (df *Difference) increment(i, j, val int) {
    df.diff[i] += val
    if j+1 < len(df.diff) {
        df.diff[j+1] -= val
    }
}

func (df *Difference) result() []int {
    res := make([]int, len(df.diff))
    // æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
    res[0] = df.diff[0]
    for i := 1; i < len(df.diff); i++ {
        res[i] = res[i-1] + df.diff[i]
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        // nums åˆå§‹åŒ–ä¸ºå…¨ 0
        int[] nums = new int[n];
        // æ„é€ å·®åˆ†è§£æ³•
        Difference df = new Difference(nums);

        for (int[] booking : bookings) {
            // æ³¨æ„è½¬æˆæ•°ç»„ç´¢å¼•è¦å‡ä¸€å“¦
            int i = booking[0] - 1;
            int j = booking[1] - 1;
            int val = booking[2];
            // å¯¹åŒºé—´ nums[i..j] å¢åŠ  val
            df.increment(i, j, val);
        }
        // è¿”å›æœ€ç»ˆçš„ç»“æœæ•°ç»„
        return df.result();
    }

    class Difference {
        // å·®åˆ†æ•°ç»„
        private int[] diff;

        public Difference(int[] nums) {
            assert nums.length > 0;
            diff = new int[nums.length];
            // æ„é€ å·®åˆ†æ•°ç»„
            diff[0] = nums[0];
            for (int i = 1; i < nums.length; i++) {
                diff[i] = nums[i] - nums[i - 1];
            }
        }

        /* ç»™é—­åŒºé—´ [i, j] å¢åŠ  valï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰*/
        public void increment(int i, int j, int val) {
            diff[i] += val;
            if (j + 1 < diff.length) {
                diff[j + 1] -= val;
            }
        }

        public int[] result() {
            int[] res = new int[diff.length];
            // æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
            res[0] = diff[0];
            for (int i = 1; i < diff.length; i++) {
                res[i] = res[i - 1] + diff[i];
            }
            return res;
        }
    }

}
```

```javascript
// by chatGPT (javascript)
var corpFlightBookings = function(bookings, n) {
    // nums åˆå§‹åŒ–ä¸ºå…¨ 0
    let nums = new Array(n).fill(0);
    // æ„é€ å·®åˆ†è§£æ³•
    let df = new Difference(nums);

    for (let booking of bookings) {
        // æ³¨æ„è½¬æˆæ•°ç»„ç´¢å¼•è¦å‡ä¸€å“¦
        let i = booking[0] - 1;
        let j = booking[1] - 1;
        let val = booking[2];
        // å¯¹åŒºé—´ nums[i..j] å¢åŠ  val
        df.increment(i, j, val);
    }
    // è¿”å›æœ€ç»ˆçš„ç»“æœæ•°ç»„
    return df.result();
}

class Difference {
    // å·®åˆ†æ•°ç»„
    constructor(nums) {
        if (nums.length <= 0) {
            throw new Error('nums array should not be empty');
        }
        this.diff = new Array(nums.length).fill(0);
        // æ„é€ å·®åˆ†æ•°ç»„
        this.diff[0] = nums[0];
        for (let i = 1; i < nums.length; i++) {
            this.diff[i] = nums[i] - nums[i - 1];
        }
    }

    /* ç»™é—­åŒºé—´ [i, j] å¢åŠ  valï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰*/
    increment(i, j, val) {
        this.diff[i] += val;
        if (j + 1 < this.diff.length) {
            this.diff[j + 1] -= val;
        }
    }

    result() {
        let res = new Array(this.diff.length).fill(0);
        // æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
        res[0] = this.diff[0];
        for (let i = 1; i < this.diff.length; i++) {
            res[i] = res[i - 1] + this.diff[i];
        }
        return res;
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        # nums åˆå§‹åŒ–ä¸ºå…¨ 0
        nums = [0] * n
        # æ„é€ å·®åˆ†è§£æ³•
        df = Difference(nums)

        for booking in bookings:
            # æ³¨æ„è½¬æˆæ•°ç»„ç´¢å¼•è¦å‡ä¸€å“¦
            i, j, val = booking[0] - 1, booking[1] - 1, booking[2]
            # å¯¹åŒºé—´ nums[i..j] å¢åŠ  val
            df.increment(i, j, val)
        # è¿”å›æœ€ç»ˆçš„ç»“æœæ•°ç»„
        return df.result()

    class Difference:
        # å·®åˆ†æ•°ç»„
        def __init__(self, nums: List[int]):
            assert len(nums) > 0
            self.diff = [0] * len(nums)
            # æ„é€ å·®åˆ†æ•°ç»„
            self.diff[0] = nums[0]
            for i in range(1, len(nums)):
                self.diff[i] = nums[i] - nums[i - 1]

        # ç»™é—­åŒºé—´ [i, j] å¢åŠ  valï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰
        def increment(self, i: int, j: int, val: int) -> None:
            self.diff[i] += val
            if j + 1 < len(self.diff):
                self.diff[j + 1] -= val

        def result(self) -> List[int]:
            res = [0] * len(self.diff)
            # æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
            res[0] = self.diff[0]
            for i in range(1, len(self.diff)):
                res[i] = res[i - 1] + self.diff[i]
            return res
```

https://leetcode.cn/problems/corporate-flight-bookings çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/count-complete-tree-nodes çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int countNodes(TreeNode* root) {
        TreeNode* l = root;
        TreeNode* r = root;
        // è®°å½•å·¦ã€å³å­æ ‘çš„é«˜åº¦
        int hl = 0, hr = 0;
        while (l != nullptr) {
            l = l->left;
            hl++;
        }
        while (r != nullptr) {
            r = r->right;
            hr++;
        }
        // å¦‚æœå·¦å³å­æ ‘çš„é«˜åº¦ç›¸åŒï¼Œåˆ™æ˜¯ä¸€æ£µæ»¡äºŒå‰æ ‘
        if (hl == hr) {
            return pow(2, hl) - 1;
        }
        // å¦‚æœå·¦å³é«˜åº¦ä¸åŒï¼Œåˆ™æŒ‰ç…§æ™®é€šäºŒå‰æ ‘çš„é€»è¾‘è®¡ç®—
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
};
```

```go
// by chatGPT (go)
func countNodes(root *TreeNode) int {
    // è®°å½•å·¦ã€å³å­æ ‘çš„é«˜åº¦
    hl, hr := 0, 0
    l, r := root, root
    for l != nil {
        l = l.Left
        hl++
    }
    for r != nil {
        r = r.Right
        hr++
    }
    // å¦‚æœå·¦å³å­æ ‘çš„é«˜åº¦ç›¸åŒï¼Œåˆ™æ˜¯ä¸€æ£µæ»¡äºŒå‰æ ‘
    if hl == hr {
        return int(math.Pow(2, float64(hl))) - 1
    }
    // å¦‚æœå·¦å³é«˜åº¦ä¸åŒï¼Œåˆ™æŒ‰ç…§æ™®é€šäºŒå‰æ ‘çš„é€»è¾‘è®¡ç®—
    return 1 + countNodes(root.Left) + countNodes(root.Right)
}
```

```java
// by labuladong (java)
class Solution {
    public int countNodes(TreeNode root) {
        TreeNode l = root, r = root;
        // è®°å½•å·¦ã€å³å­æ ‘çš„é«˜åº¦
        int hl = 0, hr = 0;
        while (l != null) {
            l = l.left;
            hl++;
        }
        while (r != null) {
            r = r.right;
            hr++;
        }
        // å¦‚æœå·¦å³å­æ ‘çš„é«˜åº¦ç›¸åŒï¼Œåˆ™æ˜¯ä¸€æ£µæ»¡äºŒå‰æ ‘
        if (hl == hr) {
            return (int) Math.pow(2, hl) - 1;
        }
        // å¦‚æœå·¦å³é«˜åº¦ä¸åŒï¼Œåˆ™æŒ‰ç…§æ™®é€šäºŒå‰æ ‘çš„é€»è¾‘è®¡ç®—
        return 1 + countNodes(root.left) + countNodes(root.right);
    }
}
```

```javascript
// by chatGPT (javascript)
var countNodes = function(root) {
    let l = root, r = root;
    // è®°å½•å·¦ã€å³å­æ ‘çš„é«˜åº¦
    let hl = 0, hr = 0;

    while (l !== null) {
        l = l.left;
        hl++;
    }

    while (r !== null) {
        r = r.right;
        hr++;
    }

    // å¦‚æœå·¦å³å­æ ‘çš„é«˜åº¦ç›¸åŒï¼Œåˆ™æ˜¯ä¸€æ£µæ»¡äºŒå‰æ ‘
    if (hl === hr) {
        return Math.pow(2, hl) - 1;
    }

    // å¦‚æœå·¦å³é«˜åº¦ä¸åŒï¼Œåˆ™æŒ‰ç…§æ™®é€šäºŒå‰æ ‘çš„é€»è¾‘è®¡ç®—
    return 1 + countNodes(root.left) + countNodes(root.right);
};
```

```python
# by chatGPT (python)
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        l, r = root, root
        hl, hr = 0, 0
        # è®°å½•å·¦ã€å³å­æ ‘çš„é«˜åº¦
        while l:
            l = l.left
            hl += 1
        while r:
            r = r.right
            hr += 1
        # å¦‚æœå·¦å³å­æ ‘çš„é«˜åº¦ç›¸åŒï¼Œåˆ™æ˜¯ä¸€æ£µæ»¡äºŒå‰æ ‘
        if hl == hr:
            return 2 ** hl - 1
        # å¦‚æœå·¦å³é«˜åº¦ä¸åŒï¼Œåˆ™æŒ‰ç…§æ™®é€šäºŒå‰æ ‘çš„é€»è¾‘è®¡ç®—
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)
```

https://leetcode.cn/problems/count-complete-tree-nodes çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/count-numbers-with-unique-digits çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int countNumbersWithUniqueDigits(int n) {
        if (n == 0) return 1;
        if (n == 1) return 10;
        int res = 9;
        // è®¡ç®— n ä½æ•°çš„é˜¶ä¹˜ï¼Œå…±æœ‰å‡ ç§ä¸åŒæ•°å­—çš„æ’åˆ—ç»„åˆ
        for (int i = 1; i < n; i++) {
            res *= (10 - i);
        }
        // æœ€åè¦åŠ ä¸Š n - 1 ä½æ•°çš„æ’åˆ—ç»„åˆ
        return res + countNumbersWithUniqueDigits(n - 1);
    }
};
```

```go
// by chatGPT (go)
// Solution function 
func countNumbersWithUniqueDigits(n int) int {
    if n == 0 { 
        return 1
    }
    if n == 1 { 
        return 10
    }
    res := 9
    
    // è®¡ç®— n ä½æ•°çš„é˜¶ä¹˜ï¼Œå…±æœ‰å‡ ç§ä¸åŒæ•°å­—çš„æ’åˆ—ç»„åˆ
    for i := 1; i < n; i++ {
        res *= (10 - i)
    }
    // æœ€åè¦åŠ ä¸Š n - 1 ä½æ•°çš„æ’åˆ—ç»„åˆ
    return res + countNumbersWithUniqueDigits(n - 1)
}
```

```java
// by labuladong (java)
class Solution {
    public int countNumbersWithUniqueDigits(int n) {
        if (n == 0) return 1;
        if (n == 1) return 10;
        int res = 9;
        // è®¡ç®— n ä½æ•°çš„é˜¶ä¹˜ï¼Œå…±æœ‰å‡ ç§ä¸åŒæ•°å­—çš„æ’åˆ—ç»„åˆ
        for (int i = 1; i < n; i++) {
            res *= (10 - i);
        }
        // æœ€åè¦åŠ ä¸Š n - 1 ä½æ•°çš„æ’åˆ—ç»„åˆ
        return res + countNumbersWithUniqueDigits(n - 1);
    }
}
```

```javascript
// by chatGPT (javascript)
var countNumbersWithUniqueDigits = function(n) {
    if (n == 0) return 1;
    if (n == 1) return 10;
    var res = 9;
    // è®¡ç®— n ä½æ•°çš„é˜¶ä¹˜ï¼Œå…±æœ‰å‡ ç§ä¸åŒæ•°å­—çš„æ’åˆ—ç»„åˆ
    for (var i = 1; i < n; i++) {
        res *= (10 - i);
    }
    // æœ€åè¦åŠ ä¸Š n - 1 ä½æ•°çš„æ’åˆ—ç»„åˆ
    return res + countNumbersWithUniqueDigits(n - 1);
};
```

```python
# by chatGPT (python)
class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -> int:
        if n == 0:
            return 1
        if n == 1:
            return 10
        res = 9
        # è®¡ç®— n ä½æ•°çš„é˜¶ä¹˜ï¼Œå…±æœ‰å‡ ç§ä¸åŒæ•°å­—çš„æ’åˆ—ç»„åˆ
        for i in range(1, n):
            res *= (10 - i)
        # æœ€åè¦åŠ ä¸Š n - 1 ä½æ•°çš„æ’åˆ—ç»„åˆ
        return res + self.countNumbersWithUniqueDigits(n - 1)
```

https://leetcode.cn/problems/count-numbers-with-unique-digits çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/count-of-range-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
private:
    int lower, upper;
    int count = 0;
    vector<long long> temp;
public:
    int countRangeSum(vector<int>& nums, int lower, int upper) {
        this->lower = lower;
        this->upper = upper;
        vector<long long> preSum(nums.size() + 1);
        for (int i = 0; i < nums.size(); i++) {
            preSum[i + 1] = nums[i] + preSum[i];
        }
        sort(preSum, 0, preSum.size()- 1);
        return count;
    }

    // å½’å¹¶æ’åº
    void sort(vector<long long>& nums, int lo, int hi) {
        if (lo == hi) {
            // å•ä¸ªå…ƒç´ ä¸ç”¨æ’åº
            return;
        }
        int mid = lo + (hi - lo) / 2;
        // å…ˆå¯¹å·¦åŠéƒ¨åˆ†æ•°ç»„ nums[lo..mid] æ’åº
        sort(nums, lo, mid);
        // å†å¯¹å³åŠéƒ¨åˆ†æ•°ç»„ nums[mid+1..hi] æ’åº
        sort(nums, mid + 1, hi);
        // å°†ä¸¤éƒ¨åˆ†æœ‰åºæ•°ç»„åˆå¹¶æˆä¸€ä¸ªæœ‰åºæ•°ç»„
        merge(nums, lo, mid, hi);
    }

    // å½’å¹¶æ“ä½œ
    void merge(vector<long long>& nums, int lo, int mid, int hi) {
        temp.assign(mid - lo + 1 + hi - mid, 0);
        int i = lo, j = mid + 1, k = 0, start = mid + 1, end = mid + 1;
        while (i <= mid) {
            while (start <= hi && nums[start] - nums[i] < lower) {
                start++;
            }
            while (end <= hi && nums[end] - nums[i] <= upper) {
                end++;
            }
            count += end - start;
            while (j <= hi && nums[j] < nums[i]) {
                temp[k++] = nums[j++];
            }
            temp[k++] = nums[i++];
        }
        while (j <= hi) {
            temp[k++] = nums[j++];
        }
        for (int p = 0; p < k; p++) {
            nums[lo + p] = temp[p];
        }
    }
};
```

```go
// by chatGPT (go)
// è§£æ³•ï¼šå½’å¹¶æ’åº
// æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)
// ç©ºé—´å¤æ‚åº¦ï¼šO(n)
func countRangeSum(nums []int, lower int, upper int) int {
    // å‰ç¼€å’Œæ•°ç»„
    presum := make([]int64, len(nums)+1)
    for i := 0; i < len(nums); i++ {
        presum[i+1] = int64(nums[i]) + presum[i]
    }

    // å½’å¹¶æ’åº
    temp := make([]int64, len(nums)+1)
    return mergeSort(presum, temp, 0, len(presum)-1, lower, upper)
}

// å°† nums[lo..hi] åˆ†åˆ«æ’åºï¼Œç„¶ååˆå¹¶æˆä¸€ä¸ªæœ‰åºæ•°ç»„
func mergeSort(nums, temp []int64, lo, hi, lower, upper int) int {
    if lo == hi {
        return 0
    }
    mid := lo + (hi-lo)/2
    count := mergeSort(nums, temp, lo, mid, lower, upper) + mergeSort(nums, temp, mid+1, hi, lower, upper)

    // ç»Ÿè®¡å·¦é—­å³å¼€åŒºé—´ [start, end) ä¸­çš„å…ƒç´ è½åœ¨ [lower, upper] ä¸­
    start, end := mid+1, mid+1
    for i := lo; i <= mid; i++ {
        for start <= hi && nums[start]-nums[i] < int64(lower) {
            start++
        }
        for end <= hi && nums[end]-nums[i] <= int64(upper) {
            end++
        }
        count += end - start
    }

    // åˆå¹¶æœ‰åºæ•°ç»„
    copy(temp[lo:hi+1], nums[lo:hi+1])
    i, j := lo, mid+1
    for k := lo; k <= hi; k++ {
        if i == mid+1 {
            nums[k] = temp[j]
            j++
        } else if j == hi+1 || temp[i] <= temp[j] {
            nums[k] = temp[i]
            i++
        } else {
            nums[k] = temp[j]
            j++
        }
    }

    return count
}
```

```java
// by labuladong (java)
class Solution {
    int lower, upper;

    public int countRangeSum(int[] nums, int lower, int upper) {
        this.lower = lower;
        this.upper = upper;
        long[] preSum = new long[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            preSum[i + 1] = (long) nums[i] + preSum[i];
        }
        sort(preSum);
        return count;
    }

    // ç”¨äºè¾…åŠ©åˆå¹¶æœ‰åºæ•°ç»„
    private long[] temp;
    private int count = 0;

    public void sort(long[] nums) {
        // å…ˆç»™è¾…åŠ©æ•°ç»„å¼€è¾Ÿå†…å­˜ç©ºé—´
        temp = new long[nums.length];
        // æ’åºæ•´ä¸ªæ•°ç»„ï¼ˆåŸåœ°ä¿®æ”¹ï¼‰
        sort(nums, 0, nums.length - 1);
    }

    // å®šä¹‰ï¼šå°†å­æ•°ç»„ nums[lo..hi] è¿›è¡Œæ’åº
    private void sort(long[] nums, int lo, int hi) {
        if (lo == hi) {
            // å•ä¸ªå…ƒç´ ä¸ç”¨æ’åº
            return;
        }
        // è¿™æ ·å†™æ˜¯ä¸ºäº†é˜²æ­¢æº¢å‡ºï¼Œæ•ˆæœç­‰åŒäº (hi + lo) / 2
        int mid = lo + (hi - lo) / 2;
        // å…ˆå¯¹å·¦åŠéƒ¨åˆ†æ•°ç»„ nums[lo..mid] æ’åº
        sort(nums, lo, mid);
        // å†å¯¹å³åŠéƒ¨åˆ†æ•°ç»„ nums[mid+1..hi] æ’åº
        sort(nums, mid + 1, hi);
        // å°†ä¸¤éƒ¨åˆ†æœ‰åºæ•°ç»„åˆå¹¶æˆä¸€ä¸ªæœ‰åºæ•°ç»„
        merge(nums, lo, mid, hi);
    }

    // å°† nums[lo..mid] å’Œ nums[mid+1..hi] è¿™ä¸¤ä¸ªæœ‰åºæ•°ç»„åˆå¹¶æˆä¸€ä¸ªæœ‰åºæ•°ç»„
    private void merge(long[] nums, int lo, int mid, int hi) {
        // å…ˆæŠŠ nums[lo..hi] å¤åˆ¶åˆ°è¾…åŠ©æ•°ç»„ä¸­
        // ä»¥ä¾¿åˆå¹¶åçš„ç»“æœèƒ½å¤Ÿç›´æ¥å­˜å…¥ nums
        for (int i = lo; i <= hi; i++) {
            temp[i] = nums[i];
        }

        // è¿™æ®µä»£ç ä¼šè¶…æ—¶
        // for (int i = lo; i <= mid; i++) {
        //     // åœ¨åŒºé—´ [mid + 1, hi] ä¸­å¯»æ‰¾ lower <= delta <= upper çš„å…ƒç´ 
        //     for (int k = mid + 1; k <= hi; k++) {
        //         long delta = nums[k] - nums[i];
        //         if (delta <= upper && delta >= lower) {
        //             count++;
        //         }
        //     }
        // }

        // è¿›è¡Œæ•ˆç‡ä¼˜åŒ–
        // ç»´æŠ¤å·¦é—­å³å¼€åŒºé—´ [start, end) ä¸­çš„å…ƒç´ è½åœ¨ [lower, upper] ä¸­
        int start = mid + 1, end = mid + 1;
        for (int i = lo; i <= mid; i++) {
            while (start <= hi && nums[start] - nums[i] < lower) {
                start++;
            }
            while (end <= hi && nums[end] - nums[i] <= upper) {
                end++;
            }
            count += end - start;
        }

        // æ•°ç»„åŒæŒ‡é’ˆæŠ€å·§ï¼Œåˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„
        int i = lo, j = mid + 1;
        for (int p = lo; p <= hi; p++) {
            if (i == mid + 1) {
                // å·¦åŠè¾¹æ•°ç»„å·²å…¨éƒ¨è¢«åˆå¹¶
                nums[p] = temp[j++];
            } else if (j == hi + 1) {
                // å³åŠè¾¹æ•°ç»„å·²å…¨éƒ¨è¢«åˆå¹¶
                nums[p] = temp[i++];
            } else if (temp[i] > temp[j]) {
                nums[p] = temp[j++];
            } else {
                nums[p] = temp[i++];
            }
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var countRangeSum = function(nums, lower, upper) {
    let count = 0;
    const n = nums.length;
    const preSum = new Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        preSum[i + 1] = nums[i] + preSum[i];
    }

    mergeSort(preSum, 0, n);

    return count;

    function mergeSort(nums, left, right) {
        if (left >= right) {
            return;
        }
        const mid = left + Math.floor((right - left) / 2);
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);

        let i = left;
        let j = mid + 1;
        let k = 0;
        let t = 0;
        const temp = new Array(right - left + 1);

        while (i <= mid && j <= right) {
            if (nums[i] <= nums[j]) {
                // ç»Ÿè®¡åŒºé—´å’Œ count
                while (t <= right && nums[t] - nums[i] < lower) {
                    t++;
                }
                while (k <= right && nums[k] - nums[i] <= upper) {
                    k++;
                }
                count += k - t;
                temp[i - left] = nums[i++];
            } else {
                temp[i - left] = nums[j++];
            }
        }
        while (i <= mid) {
            temp[i - left] = nums[i++];
        }
        while (j <= right) {
            temp[i - left] = nums[j++];
        }
        for (let p = left; p <= right; p++) {
            nums[p] = temp[p - left];
        }
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.lower, self.upper = 0, 0

    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        # å®šä¹‰å…¨å±€å˜é‡
        self.lower, self.upper = lower, upper
        # å‰ç¼€å’Œæ•°ç»„
        preSum = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            preSum[i + 1] = nums[i] + preSum[i]
        # æ’åº
        self.sort(preSum)
        return self.count

    def sort(self, nums):
        # å®šä¹‰è¾…åŠ©åˆå¹¶æ•°ç»„
        self.temp = [0] * len(nums)
        # å®šä¹‰è®¡æ•°å™¨
        self.count = 0
        # è°ƒç”¨é€’å½’æ’åºæ–¹æ³•
        self._sort(nums, 0, len(nums) - 1)

    def _sort(self, nums, lo, hi):
        # æ’åºå­æ•°ç»„nums[lo..hi]
        if lo == hi:
            return
        mid = lo + (hi - lo) // 2
        self._sort(nums, lo, mid)
        self._sort(nums, mid + 1, hi)
        self._merge(nums, lo, mid, hi)

    def _merge(self, nums, lo, mid, hi):
        # åˆå¹¶ä¸¤ä¸ªæœ‰åºå­æ•°ç»„ nums[lo..mid] å’Œ nums[mid+1..hi]
        
        # å…ˆå°† nums[lo..hi] å¤åˆ¶åˆ°ä¸´æ—¶æ•°ç»„ temp ä¸­
        for i in range(lo, hi + 1):
            self.temp[i] = nums[i]

        # å·¦å³ä¸¤éƒ¨åˆ†è®¡æ•°å™¨ start å’Œ end
        start, end = mid + 1, mid + 1
        for i in range(lo, mid + 1):
            while start <= hi and nums[start] - nums[i] < self.lower:
                start += 1
            while end <= hi and nums[end] - nums[i] <= self.upper:
                end += 1
            # æ›´æ–°è®¡æ•°å™¨
            self.count += end - start

        # æ•°ç»„åˆå¹¶ï¼ŒåŒæŒ‡é’ˆæŠ€å·§
        i, j = lo, mid + 1
        for p in range(lo, hi + 1):
            if i > mid:
                nums[p] = self.temp[j]
                j += 1
            elif j > hi:
                nums[p] = self.temp[i]
                i += 1
            elif self.temp[i] < self.temp[j]:
                nums[p] = self.temp[i]
                i += 1
            else:
                nums[p] = self.temp[j]
                j += 1
```

https://leetcode.cn/problems/count-of-range-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/count-primes çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int countPrimes(int n) {
        vector<bool> isPrime(n, true); // vector instead of array
        for (int i = 2; i * i < n; i++)
            if (isPrime[i])
                for (int j = i * i; j < n; j += i)
                    isPrime[j] = false;

        int count = 0;
        for (int i = 2; i < n; i++)
            if (isPrime[i]) count++;

        return count;
    }
};
```

```go
// by chatGPT (go)
func countPrimes(n int) int {
    // create boolean array with default value true
    isPrime := make([]bool, n)
    for i := range isPrime {
        isPrime[i] = true
    }

    // loop through all numbers up to the square root of n
    for i := 2; i*i < n; i++ {
        if isPrime[i] {
            // loop through multiples of i and mark them as not prime
            for j := i * i; j < n; j += i {
                isPrime[j] = false
            }
        }
    }

    // count number of primes
    count := 0
    for i := 2; i < n; i++ {
        if isPrime[i] {
            count++
        }
    }

    return count
}
```

```java
// by labuladong (java)
class Solution {
    public int countPrimes(int n) {
        boolean[] isPrime = new boolean[n];
        Arrays.fill(isPrime, true);
        for (int i = 2; i * i < n; i++)
            if (isPrime[i])
                for (int j = i * i; j < n; j += i)
                    isPrime[j] = false;

        int count = 0;
        for (int i = 2; i < n; i++)
            if (isPrime[i]) count++;

        return count;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
    const isPrime = new Array(n).fill(true);
    for (let i = 2; i * i < n; i++) {
        if (isPrime[i]) {
            for (let j = i * i; j < n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    let count = 0;
    for (let i = 2; i < n; i++) {
        if (isPrime[i]) count++;
    }
    return count;
};
```

```python
# by chatGPT (python)
class Solution:
    def countPrimes(self, n: int) -> int:
        isPrime = [True]*n
        for i in range(2, int(n**0.5)+1):
            if isPrime[i]:
                for j in range(i*i, n, i):
                    isPrime[j] = False

        count = 0
        for i in range(2, n):
            if isPrime[i]:
                count += 1

        return count
```

https://leetcode.cn/problems/count-primes çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/count-sub-islands çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {
        int m = grid1.size(), n = grid1[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid1[i][j] == 0 && grid2[i][j] == 1) {
                    // è¿™ä¸ªå²›å±¿è‚¯å®šä¸æ˜¯å­å²›ï¼Œæ·¹æ‰
                    dfs(grid2, i, j);
                }
            }
        }
        // ç°åœ¨ grid2 ä¸­å‰©ä¸‹çš„å²›å±¿éƒ½æ˜¯å­å²›ï¼Œè®¡ç®—å²›å±¿æ•°é‡
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid2[i][j] == 1) {
                    res++;
                    dfs(grid2, i, j);
                }
            }
        }
        return res;
    }

    // ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
    void dfs(vector<vector<int>>& grid, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return;
        }
        if (grid[i][j] == 0) {
            return;
        }

        grid[i][j] = 0;
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func countSubIslands(grid1 [][]int, grid2 [][]int) int {
    m, n := len(grid1), len(grid1[0])
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if grid1[i][j] == 0 && grid2[i][j] == 1 {
                // è¿™ä¸ªå²›å±¿è‚¯å®šä¸æ˜¯å­å²›ï¼Œæ·¹æ‰
                dfs(grid2, i, j)
            }
        }
    }
    // ç°åœ¨ grid2 ä¸­å‰©ä¸‹çš„å²›å±¿éƒ½æ˜¯å­å²›ï¼Œè®¡ç®—å²›å±¿æ•°é‡
    res := 0
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if grid2[i][j] == 1 {
                res++
                dfs(grid2, i, j)
            }
        }
    }
    return res
}

// ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
func dfs(grid [][]int, i, j int) {
    m, n := len(grid), len(grid[0])
    if i < 0 || j < 0 || i >= m || j >= n {
        return
    }
    if grid[i][j] == 0 {
        return
    }

    grid[i][j] = 0
    dfs(grid, i+1, j)
    dfs(grid, i, j+1)
    dfs(grid, i-1, j)
    dfs(grid, i, j-1)
}
```

```java
// by labuladong (java)
class Solution {
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int m = grid1.length, n = grid1[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid1[i][j] == 0 && grid2[i][j] == 1) {
                    // è¿™ä¸ªå²›å±¿è‚¯å®šä¸æ˜¯å­å²›ï¼Œæ·¹æ‰
                    dfs(grid2, i, j);
                }
            }
        }
        // ç°åœ¨ grid2 ä¸­å‰©ä¸‹çš„å²›å±¿éƒ½æ˜¯å­å²›ï¼Œè®¡ç®—å²›å±¿æ•°é‡
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid2[i][j] == 1) {
                    res++;
                    dfs(grid2, i, j);
                }
            }
        }
        return res;
    }

    // ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
    void dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return;
        }
        if (grid[i][j] == 0) {
            return;
        }

        grid[i][j] = 0;
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} grid1
 * @param {number[][]} grid2
 * @return {number}
 */
var countSubIslands = function(grid1, grid2) {
    const m = grid1.length, n = grid1[0].length;

    // æ·¹æ²¡éå­å²›å±¿
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid1[i][j] == 0 && grid2[i][j] == 1) {
                dfs(grid2, i, j);
            }
        }
    }

    // è®¡ç®—å­å²›å±¿æ•°é‡
    let res = 0;
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid2[i][j] == 1) {
                res++;
                dfs(grid2, i, j);
            }
        }
    }
    return res;
};

// æ·±åº¦ä¼˜å…ˆéå†
function dfs(grid, i, j) {
    const m = grid.length, n = grid[0].length;
    if (i < 0 || j < 0 || i >= m || j >= n) {
        return;
    }
    if (grid[i][j] == 0) {
        return;
    }

    grid[i][j] = 0;
    dfs(grid, i + 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i - 1, j);
    dfs(grid, i, j - 1);
}
```

```python
# by chatGPT (python)
class Solution:
    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:
        m, n = len(grid1), len(grid1[0])

        # éå† grid2ï¼Œå°†éå­å²›çš„å²›å±¿æ·¹æ‰
        for i in range(m):
            for j in range(n):
                if grid1[i][j] == 0 and grid2[i][j] == 1:
                    self.dfs(grid2, i, j)

        # ç°åœ¨ grid2 ä¸­å‰©ä¸‹çš„å²›å±¿éƒ½æ˜¯å­å²›ï¼Œè®¡ç®—å²›å±¿æ•°é‡
        res = 0
        for i in range(m):
            for j in range(n):
                if grid2[i][j] == 1:
                    res += 1
                    self.dfs(grid2, i, j)

        return res

    # ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
    def dfs(self, grid: List[List[int]], i: int, j: int) -> None:
        m, n = len(grid), len(grid[0])
        if i < 0 or j < 0 or i >= m or j >= n:
            return
        if grid[i][j] == 0:
            return

        grid[i][j] = 0
        self.dfs(grid, i + 1, j)
        self.dfs(grid, i, j + 1)
        self.dfs(grid, i - 1, j)
        self.dfs(grid, i, j - 1)
```

https://leetcode.cn/problems/count-sub-islands çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/couples-holding-hands çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int minSwapsCouples(vector<int>& row) {
        int n = row.size();
        UF uf(n);
        for (int i = 0; i < n; i += 2) {
            // å°†ä¸¤äººçš„ couple_id è¿›è¡Œè¿æ¥
            uf.Union(row[i] / 2, row[i + 1] / 2);
        }
        // å’Œè¿é€šåˆ†é‡çš„å·®å³ä¸ºéœ€è¦äº¤æ¢çš„æ¬¡æ•°
        return n - uf.Count();
    }
};

// å¹¶æŸ¥é›†ç®—æ³•æ¨¡æ¿
class UF {
private:
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    int count;
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    vector<int> parent;
public:
    UF(int n) {
        this->count = n;
        parent = vector<int>(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    /* å°† p å’Œ q è¿é€š */
    void Union(int p, int q) {
        int rootP = Find(p);
        int rootQ = Find(q);
        if (rootP == rootQ)
            return;

        parent[rootQ] = rootP;
        count--;
    }

    /* åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š */
    bool Connected(int p, int q) {
        int rootP = Find(p);
        int rootQ = Find(q);
        // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP == rootQ;
    }

    /* è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹ */
    int Find(int x) {
        while (parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    int Count() {
        return count;
    }
};
```

```go
// by chatGPT (go)
func minSwapsCouples(row []int) int {
    n := len(row)
    uf := NewUF(n)
    for i := 0; i < n; i += 2 {
        // å°†ä¸¤äººçš„ couple_id è¿›è¡Œè¿æ¥
        uf.Union(row[i]/2, row[i+1]/2)
    }
    // å’Œè¿é€šåˆ†é‡çš„å·®å³ä¸ºéœ€è¦äº¤æ¢çš„æ¬¡æ•°
    return n - uf.Count()
}

type UF struct {
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    count int
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    parent []int
}

func NewUF(n int) *UF {
    uf := &UF{}
    uf.count = n
    uf.parent = make([]int, n)
    for i := 0; i < n; i++ {
        uf.parent[i] = i
    }
    return uf
}

/* å°† p å’Œ q è¿é€š */
func (uf *UF) Union(p, q int) {
    rootP := uf.find(p)
    rootQ := uf.find(q)
    if rootP == rootQ {
        return
    }
    uf.parent[rootQ] = rootP
    uf.count--
}

/* åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š */
func (uf *UF) Connected(p, q int) bool {
    rootP := uf.find(p)
    rootQ := uf.find(q)
    // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
    return rootP == rootQ
}

/* è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹ */
func (uf *UF) find(x int) int {
    for uf.parent[x] != x {
        // è¿›è¡Œè·¯å¾„å‹ç¼©
        uf.parent[x] = uf.parent[uf.parent[x]]
        x = uf.parent[x]
    }
    return x
}

func (uf *UF) Count() int {
    return uf.count
}
```

```java
// by labuladong (java)
class Solution {
    public int minSwapsCouples(int[] row) {
        int n = row.length;
        UF uf = new UF(n);
        for (int i = 0; i < n; i += 2) {
            // å°†ä¸¤äººçš„ couple_id è¿›è¡Œè¿æ¥
            uf.union(row[i] / 2, row[i + 1] / 2);
        }
        // å’Œè¿é€šåˆ†é‡çš„å·®å³ä¸ºéœ€è¦äº¤æ¢çš„æ¬¡æ•°
        return n - uf.count();
    }
}

// å¹¶æŸ¥é›†ç®—æ³•æ¨¡æ¿
class UF {
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    private int count;
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    private int[] parent;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    /* å°† p å’Œ q è¿é€š */
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        parent[rootQ] = rootP;
        count--;
    }

    /* åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š */
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP == rootQ;
    }

    /* è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹ */
    private int find(int x) {
        while (parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public int count() {
        return count;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} row
 * @return {number}
 */
var minSwapsCouples = function(row) {
    const n = row.length;
    const uf = new UF(n);
    for (let i = 0; i < n; i += 2) {
        // å°†ä¸¤äººçš„ couple_id è¿›è¡Œè¿æ¥
        uf.union(Math.floor(row[i] / 2), Math.floor(row[i + 1] / 2));
    }
    // å’Œè¿é€šåˆ†é‡çš„å·®å³ä¸ºéœ€è¦äº¤æ¢çš„æ¬¡æ•°
    return n - uf.count();
};

// å¹¶æŸ¥é›†ç®—æ³•æ¨¡æ¿
class UF {
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    #count;
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    #parent;

    constructor(n) {
        this.#count = n;
        this.#parent = new Array(n).fill().map((_, i) => i);
    }

    /* å°† p å’Œ q è¿é€š */
    union(p, q) {
        const rootP = this.find(p);
        const rootQ = this.find(q);
        if (rootP === rootQ) {
            return;
        }

        this.#parent[rootQ] = rootP;
        this.#count--;
    }

    /* åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š */
    connected(p, q) {
        const rootP = this.find(p);
        const rootQ = this.find(q);
        // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP === rootQ;
    }

    /* è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹ */
    find(x) {
        while (this.#parent[x] !== x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            this.#parent[x] = this.#parent[this.#parent[x]];
            x = this.#parent[x];
        }
        return x;
    }

    count() {
        return this.#count;
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        n = len(row)
        uf = UF(n)
        for i in range(0, n, 2):
            # å°†ä¸¤äººçš„ couple_id è¿›è¡Œè¿æ¥
            uf.union(row[i] // 2, row[i + 1] // 2)
        # å’Œè¿é€šåˆ†é‡çš„å·®å³ä¸ºéœ€è¦äº¤æ¢çš„æ¬¡æ•°
        return n - uf.count()

class UF:
    def __init__(self, n: int):
        self.count = n
        self.parent = [i for i in range(n)]

    def union(self, p: int, q: int) -> None:
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP == rootQ:
            return

        self.parent[rootQ] = rootP
        self.count -= 1

    def connected(self, p: int, q: int) -> bool:
        rootP = self.find(p)
        rootQ = self.find(q)
        # å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP == rootQ

    def find(self, x: int) -> int:
        while self.parent[x] != x:
            # è¿›è¡Œè·¯å¾„å‹ç¼©
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def count(self) -> int:
        return self.count
```

https://leetcode.cn/problems/couples-holding-hands çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/course-schedule çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    // è®°å½•ä¸€æ¬¡ traverse é€’å½’ç»è¿‡çš„èŠ‚ç‚¹
    vector<bool> onPath;
    // è®°å½•éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
    vector<bool> visited;
    // è®°å½•å›¾ä¸­æ˜¯å¦æœ‰ç¯
    bool hasCycle = false;

public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> graph = buildGraph(numCourses, prerequisites);

        visited.resize(numCourses, false);
        onPath.resize(numCourses, false);

        for (int i = 0; i < numCourses; i++) {
            // éå†å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
            traverse(graph, i);
        }
        // åªè¦æ²¡æœ‰å¾ªç¯ä¾èµ–å¯ä»¥å®Œæˆæ‰€æœ‰è¯¾ç¨‹
        return !hasCycle;
    }

    void traverse(vector<vector<int>>& graph, int s) {
        if (onPath[s]) {
            // å‡ºç°ç¯
            hasCycle = true;
            /**<extend up -150>
            ![](../pictures/æ‹“æ‰‘æ’åº/4.jpeg)
            */
        }

        if (visited[s] || hasCycle) {
            // å¦‚æœå·²ç»æ‰¾åˆ°äº†ç¯ï¼Œä¹Ÿä¸ç”¨å†éå†äº†
            return;
        }
        // å‰åºéå†ä»£ç ä½ç½®
        visited[s] = true;
        onPath[s] = true;
        for (int t : graph[s]) {
            traverse(graph, t);
        }
        // ååºéå†ä»£ç ä½ç½®
        onPath[s] = false;
    }

    vector<vector<int>> buildGraph(int numCourses, vector<vector<int>>& prerequisites) {
        // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
        vector<vector<int>> graph(numCourses);
        for (auto edge : prerequisites) {
            int from = edge[1];
            int to = edge[0];
            // ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
            // åœ¨å›¾ä¸­æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
            graph[from].push_back(to);
        }
        return graph;
    }
};
```

```go
// by chatGPT (go)
func canFinish(numCourses int, prerequisites [][]int) bool {
    // è®°å½•ä¸€æ¬¡ traverse é€’å½’ç»è¿‡çš„èŠ‚ç‚¹
    onPath := make([]bool, numCourses)
    // è®°å½•éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
    visited := make([]bool, numCourses)
    // è®°å½•å›¾ä¸­æ˜¯å¦æœ‰ç¯
    hasCycle := false

    graph := buildGraph(numCourses, prerequisites)

    for i := 0; i < numCourses; i++ {
        // éå†å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
        traverse(graph, i, &hasCycle, visited, onPath)
    }
    // åªè¦æ²¡æœ‰å¾ªç¯ä¾èµ–å¯ä»¥å®Œæˆæ‰€æœ‰è¯¾ç¨‹
    return !hasCycle
}

func traverse(graph []LinkedList, s int, hasCycle *bool, visited, onPath []bool) {
    if onPath[s] {
        // å‡ºç°ç¯
        *hasCycle = true
        /**<extend up -150>
        ![](../pictures/æ‹“æ‰‘æ’åº/4.jpeg)
        */
    }

    if visited[s] || *hasCycle {
        // å¦‚æœå·²ç»æ‰¾åˆ°äº†ç¯ï¼Œä¹Ÿä¸ç”¨å†éå†äº†
        return
    }
    // å‰åºéå†ä»£ç ä½ç½®
    visited[s] = true
    onPath[s] = true
    for _, t := range graph[s].list {
        traverse(graph, t, hasCycle, visited, onPath)
    }
    // ååºéå†ä»£ç ä½ç½®
    onPath[s] = false
}

type LinkedList struct {
    list []int
}

func buildGraph(numCourses int, prerequisites [][]int) []LinkedList {
    // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
    graph := make([]LinkedList, numCourses)
    for i := 0; i < numCourses; i++ {
        graph[i] = LinkedList{list: []int{}}
    }
    for _, edge := range prerequisites {
        from := edge[1]
        to := edge[0]
        // ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
        // åœ¨å›¾ä¸­æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
        graph[from].list = append(graph[from].list, to)
    }
    return graph
}
```

```java
// by labuladong (java)
class Solution {
    // è®°å½•ä¸€æ¬¡ traverse é€’å½’ç»è¿‡çš„èŠ‚ç‚¹
    boolean[] onPath;
    // è®°å½•éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
    boolean[] visited;
    // è®°å½•å›¾ä¸­æ˜¯å¦æœ‰ç¯
    boolean hasCycle = false;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);

        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];

        for (int i = 0; i < numCourses; i++) {
            // éå†å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
            traverse(graph, i);
        }
        // åªè¦æ²¡æœ‰å¾ªç¯ä¾èµ–å¯ä»¥å®Œæˆæ‰€æœ‰è¯¾ç¨‹
        return !hasCycle;
    }

    void traverse(List<Integer>[] graph, int s) {
        if (onPath[s]) {
            // å‡ºç°ç¯
            hasCycle = true;
            /**<extend up -150>
            ![](../pictures/æ‹“æ‰‘æ’åº/4.jpeg)
            */
        }

        if (visited[s] || hasCycle) {
            // å¦‚æœå·²ç»æ‰¾åˆ°äº†ç¯ï¼Œä¹Ÿä¸ç”¨å†éå†äº†
            return;
        }
        // å‰åºéå†ä»£ç ä½ç½®
        visited[s] = true;
        onPath[s] = true;
        for (int t : graph[s]) {
            traverse(graph, t);
        }
        // ååºéå†ä»£ç ä½ç½®
        onPath[s] = false;
    }

    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
        List<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : prerequisites) {
            int from = edge[1];
            int to = edge[0];
            // ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
            // åœ¨å›¾ä¸­æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
            graph[from].add(to);
        }
        return graph;
    }
}
```

```javascript
// by chatGPT (javascript)
var canFinish = function(numCourses, prerequisites) {
    // è®°å½•ä¸€æ¬¡ traverse é€’å½’ç»è¿‡çš„èŠ‚ç‚¹
    const onPath = new Array(numCourses).fill(false);
    // è®°å½•éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
    const visited = new Array(numCourses).fill(false);
    // è®°å½•å›¾ä¸­æ˜¯å¦æœ‰ç¯
    let hasCycle = false;

    const graph = buildGraph(numCourses, prerequisites);

    for (let i = 0; i < numCourses; i++) {
        // éå†å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
        traverse(graph, i);
    }

    // åªè¦æ²¡æœ‰å¾ªç¯ä¾èµ–å¯ä»¥å®Œæˆæ‰€æœ‰è¯¾ç¨‹
    return !hasCycle;

    function traverse(graph, s) {
        if (onPath[s]) {
            // å‡ºç°ç¯
            hasCycle = true;
            /**<extend up -150>
            ![](../pictures/æ‹“æ‰‘æ’åº/4.jpeg)
            */
            return;
        }

        if (visited[s] || hasCycle) {
            // å¦‚æœå·²ç»æ‰¾åˆ°äº†ç¯ï¼Œä¹Ÿä¸ç”¨å†éå†äº†
            return;
        }
        // å‰åºéå†ä»£ç ä½ç½®
        visited[s] = true;
        onPath[s] = true;
        for (let t of graph[s]) {
            traverse(graph, t);
        }
        // ååºéå†ä»£ç ä½ç½®
        onPath[s] = false;
    }

    function buildGraph(numCourses, prerequisites) {
        // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
        const graph = new Array(numCourses).map(() => []);
        for (let edge of prerequisites) {
            const from = edge[1];
            const to = edge[0];
            // ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
            // åœ¨å›¾ä¸­æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
            graph[from].push(to);
        }
        return graph;
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        # è®°å½•ä¸€æ¬¡ traverse é€’å½’ç»è¿‡çš„èŠ‚ç‚¹
        onPath = [False] * numCourses
        # è®°å½•éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
        visited = [False] * numCourses
        # è®°å½•å›¾ä¸­æ˜¯å¦æœ‰ç¯
        hasCycle = [False]

        graph = self.buildGraph(numCourses, prerequisites)

        def traverse(s):
            if onPath[s]:
                # å‡ºç°ç¯
                hasCycle[0] = True
                """
                <extend up -150>
                ![](../pictures/æ‹“æ‰‘æ’åº/4.jpeg)
                """
            if visited[s] or hasCycle[0]:
                # å¦‚æœå·²ç»æ‰¾åˆ°äº†ç¯ï¼Œä¹Ÿä¸ç”¨å†éå†äº†
                return
            # å‰åºéå†ä»£ç ä½ç½®
            visited[s] = True
            onPath[s] = True
            for t in graph[s]:
                traverse(t)
            # ååºéå†ä»£ç ä½ç½®
            onPath[s] = False
        
        for i in range(numCourses):
            # éå†å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
            traverse(i)
        
        # åªè¦æ²¡æœ‰å¾ªç¯ä¾èµ–å¯ä»¥å®Œæˆæ‰€æœ‰è¯¾ç¨‹
        return not hasCycle[0]
    
    def buildGraph(self, numCourses, prerequisites):
        # å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
        graph = [[] for _ in range(numCourses)]
        for from_, to in prerequisites:
            # ä¿®å®Œè¯¾ç¨‹ from_ æ‰èƒ½ä¿®è¯¾ç¨‹ to
            # åœ¨å›¾ä¸­æ·»åŠ ä¸€æ¡ä» from_ æŒ‡å‘ to çš„æœ‰å‘è¾¹
            graph[from_].append(to)
        return graph
```

https://leetcode.cn/problems/course-schedule çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/course-schedule-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        // å»ºå›¾ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        vector<vector<int>> graph(numCourses);
        // è®¡ç®—å…¥åº¦ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        vector<int> indegree(numCourses, 0);
        for (auto& edge : prerequisites) {
            int from = edge[1], to = edge[0];
            graph[from].push_back(to);
            indegree[to]++;
        }

        // æ ¹æ®å…¥åº¦åˆå§‹åŒ–é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        queue<int> q;
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) {
                q.push(i);
            }
        }

        // è®°å½•æ‹“æ‰‘æ’åºç»“æœ
        vector<int> res;
        // å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            // å¼¹å‡ºèŠ‚ç‚¹çš„é¡ºåºå³ä¸ºæ‹“æ‰‘æ’åºç»“æœ
            res.push_back(cur);
            for (int next : graph[cur]) {
                indegree[next]--;
                if (indegree[next] == 0) {
                    q.push(next);
                }
            }
        }

        if (res.size() != numCourses) {
            // å­˜åœ¨ç¯ï¼Œæ‹“æ‰‘æ’åºä¸å­˜åœ¨
            return {};
        }

        return res;
    }
};
```

```go
// by chatGPT (go)
func findOrder(numCourses int, prerequisites [][]int) []int {
    // å»ºå›¾ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
    graph := buildGraph(numCourses, prerequisites)
    // è®¡ç®—å…¥åº¦ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
    indegree := make([]int, numCourses)
    for _, edge := range prerequisites {
        _, to := edge[1], edge[0]
        from, to := edge[1], edge[0]
        _, to := edge[1], edge[0]
        from, to := edge[1], edge[0]
        _, to := edge[1], edge[0]
        from, to := edge[1], edge[0]
        _, to := edge[1], edge[0]
        from, to := edge[1], edge[0]
        _, to := edge[1], edge[0]
        from, to := edge[1], edge[0]
        _, to := edge[1], edge[0]
        from, to := edge[1], edge[0]
        _, to := edge[1], edge[0]
        from, to := edge[1], edge[0]
        _, to := edge[1], edge[0]
        from, to := edge[1], edge[0]
        _, to := edge[1], edge[0]
        from, to := edge[1], edge[0]
        _, to := edge[1], edge[0]
        indegree[to]++
    }

    // æ ¹æ®å…¥åº¦åˆå§‹åŒ–é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
    q := make([]int, 0)
    for i := 0; i < numCourses; i++ {
        if indegree[i] == 0 {
            q = append(q, i)
        }
    }

    // è®°å½•æ‹“æ‰‘æ’åºç»“æœ
    res := make([]int, numCourses)
    // è®°å½•éå†èŠ‚ç‚¹çš„é¡ºåºï¼ˆç´¢å¼•ï¼‰
    count := 0
    // å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•
    for len(q) > 0 {
        cur := q[0]
        q = q[1:]
        // å¼¹å‡ºèŠ‚ç‚¹çš„é¡ºåºå³ä¸ºæ‹“æ‰‘æ’åºç»“æœ
        res[count] = cur
        count++
        for _, next := range graph[cur] {
            indegree[next]--
            if indegree[next] == 0 {
                q = append(q, next)
            }
        }
    }

    if count != numCourses {
        // å­˜åœ¨ç¯ï¼Œæ‹“æ‰‘æ’åºä¸å­˜åœ¨
        return []int{}
    }

    return res
}

// å»ºå›¾å‡½æ•°
func buildGraph(numCourses int, prerequisites [][]int) []([]int) {
    // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
    graph := make([]([]int), numCourses)
    for i := 0; i < numCourses; i++ {
        graph[i] = make([]int, 0)
    }
    for _, edge := range prerequisites {
        from, to := edge[1], edge[0]
        // ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
        // åœ¨å›¾ä¸­æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
        graph[from] = append(graph[from], to)
    }
    return graph
}
```

```java
// by labuladong (java)
class Solution {
    // ä¸»å‡½æ•°
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // å»ºå›¾ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
        // è®¡ç®—å…¥åº¦ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        int[] indegree = new int[numCourses];
        for (int[] edge : prerequisites) {
            int from = edge[1], to = edge[0];
            indegree[to]++;
        }

        // æ ¹æ®å…¥åº¦åˆå§‹åŒ–é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) {
                q.offer(i);
                /**<extend up -200>
                ![](../pictures/æ‹“æ‰‘æ’åº/6.jpeg)
                */
            }
        }

        // è®°å½•æ‹“æ‰‘æ’åºç»“æœ
        int[] res = new int[numCourses];
        // è®°å½•éå†èŠ‚ç‚¹çš„é¡ºåºï¼ˆç´¢å¼•ï¼‰
        int count = 0;
        // å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•
        while (!q.isEmpty()) {
            int cur = q.poll();
            // å¼¹å‡ºèŠ‚ç‚¹çš„é¡ºåºå³ä¸ºæ‹“æ‰‘æ’åºç»“æœ
            res[count] = cur;
            count++;
            for (int next : graph[cur]) {
                /**<extend up -200>
                ![](../pictures/æ‹“æ‰‘æ’åº/7.jpeg)
                */
                indegree[next]--;
                if (indegree[next] == 0) {
                    q.offer(next);
                }
            }
        }

        if (count != numCourses) {
            // å­˜åœ¨ç¯ï¼Œæ‹“æ‰‘æ’åºä¸å­˜åœ¨
            return new int[]{};
        }
        
        return res;
    }

    // å»ºå›¾å‡½æ•°
    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
        List<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : prerequisites) {
            int from = edge[1], to = edge[0];
            // ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
            // åœ¨å›¾ä¸­æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
            graph[from].add(to);
        }
        return graph;
    }
}
```

```javascript
// by chatGPT (javascript)
var findOrder = function(numCourses, prerequisites) {
    // å»ºå›¾ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
    const graph = buildGraph(numCourses, prerequisites);
    // è®¡ç®—å…¥åº¦ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
    const indegree = new Array(numCourses).fill(0);
    for (const [from, to] of prerequisites) {
        indegree[to]++;
    }

    // æ ¹æ®å…¥åº¦åˆå§‹åŒ–é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
    const q = [];
    for (let i = 0; i < numCourses; i++) {
        if (indegree[i] === 0) {
            q.push(i);
            /**<extend up -200>
            ![](../pictures/æ‹“æ‰‘æ’åº/6.jpeg)
            */
        }
    }

    // è®°å½•æ‹“æ‰‘æ’åºç»“æœ
    const res = new Array(numCourses);
    // è®°å½•éå†èŠ‚ç‚¹çš„é¡ºåºï¼ˆç´¢å¼•ï¼‰
    let count = 0;
    // å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•
    while (q.length > 0) {
        const cur = q.shift();
        // å¼¹å‡ºèŠ‚ç‚¹çš„é¡ºåºå³ä¸ºæ‹“æ‰‘æ’åºç»“æœ
        res[count] = cur;
        count++;
        for (const next of graph[cur]) {
            /**<extend up -200>
            ![](../pictures/æ‹“æ‰‘æ’åº/7.jpeg)
            */
            indegree[next]--;
            if (indegree[next] === 0) {
                q.push(next);
            }
        }
    }

    if (count !== numCourses) {
        // å­˜åœ¨ç¯ï¼Œæ‹“æ‰‘æ’åºä¸å­˜åœ¨
        return [];
    }

    return res;
}

// å»ºå›¾å‡½æ•°
function buildGraph(numCourses, prerequisites) {
    // å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
    const graph = new Array(numCourses).fill().map(() => []);
    for (const [from, to] of prerequisites) {
        // ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
        // åœ¨å›¾ä¸­æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
        graph[from].push(to);
    }
    return graph;
}
```

```python
# by chatGPT (python)
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        # å»ºå›¾ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        graph = self.buildGraph(numCourses, prerequisites)
        # è®¡ç®—å…¥åº¦ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        indegree = [0] * numCourses
        for edge in prerequisites:
            from_course, to_course = edge[1], edge[0]
            indegree[to_course] += 1

        # æ ¹æ®å…¥åº¦åˆå§‹åŒ–é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼Œå’Œç¯æ£€æµ‹ç®—æ³•ç›¸åŒ
        q = []
        for i in range(numCourses):
            if indegree[i] == 0:
                q.append(i)

        # è®°å½•æ‹“æ‰‘æ’åºç»“æœ
        res = []
        # è®°å½•éå†èŠ‚ç‚¹çš„é¡ºåºï¼ˆç´¢å¼•ï¼‰
        count = 0
        # å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•
        while q:
            cur = q.pop(0)
            # å¼¹å‡ºèŠ‚ç‚¹çš„é¡ºåºå³ä¸ºæ‹“æ‰‘æ’åºç»“æœ
            res.append(cur)
            count += 1
            for next_course in graph[cur]:
                indegree[next_course] -= 1
                if indegree[next_course] == 0:
                    q.append(next_course)

        if count != numCourses:
            # å­˜åœ¨ç¯ï¼Œæ‹“æ‰‘æ’åºä¸å­˜åœ¨
            return []

        return res

    # å»ºå›¾å‡½æ•°
    def buildGraph(self, numCourses: int, prerequisites: List[List[int]]) -> List[List[int]]:
        # å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹
        graph = [[] for _ in range(numCourses)]
        for edge in prerequisites:
            from_course, to_course = edge[1], edge[0]
            # ä¿®å®Œè¯¾ç¨‹ from æ‰èƒ½ä¿®è¯¾ç¨‹ to
            # åœ¨å›¾ä¸­æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹
            graph[from_course].append(to_course)
        return graph
```

https://leetcode.cn/problems/course-schedule-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> printNumbers(int n) {
        // å…ˆç”Ÿæˆ n ä½ 9
        int max = 0;
        for (int i = 0; i < n; i++) {
            max = 10 * max + 9;
        }
        // å¡«å…¥ç»“æœæ•°ç»„
        vector<int> res(max);
        for (int i = 1; i <= max; i++) {
            res[i - 1] = i;
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func printNumbers(n int) []int {
    // å…ˆç”Ÿæˆ n ä½ 9
    max := 0
    for i := 0; i < n; i++ {
        max = 10 * max + 9
    }
    // å¡«å…¥ç»“æœæ•°ç»„
    res := make([]int, max)
    for i := 1; i <= max; i++ {
        res[i-1] = i
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int[] printNumbers(int n) {
        // å…ˆç”Ÿæˆ n ä½ 9
        int max = 0;
        for (int i = 0; i < n; i++) {
            max = 10 * max + 9;
        }
        // å¡«å…¥ç»“æœæ•°ç»„
        int[] res = new int[max];
        for (int i = 1; i <= max; i++) {
            res[i - 1] = i;
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @return {number[]}
 */
var printNumbers = function(n) {
    // å…ˆç”Ÿæˆ n ä½ 9
    let max = 0;
    for (let i = 0; i < n; i++) {
        max = 10 * max + 9;
    }
    // å¡«å…¥ç»“æœæ•°ç»„
    let res = new Array(max);
    for (let i = 1; i <= max; i++) {
        res[i - 1] = i;
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def printNumbers(self, n: int) -> List[int]:
        # å…ˆç”Ÿæˆ n ä½ 9
        max_num = 0
        for i in range(n):
            max_num = max_num * 10 + 9
            
        # å¡«å…¥ç»“æœæ•°ç»„
        res = []
        for i in range(1, max_num + 1):
            res.append(i)
        
        return res
```

https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/delete-node-in-a-bst çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) {
            return nullptr;
        }
        if (root->val == key) {
            // è¿™ä¸¤ä¸ª if æŠŠæƒ…å†µ 1 å’Œ 2 éƒ½æ­£ç¡®å¤„ç†äº†
            if (root->left == nullptr) {
                return root->right;
            }
            if (root->right == nullptr) {
                return root->left;
            }
            // å¤„ç†æƒ…å†µ 3
            // è·å¾—å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹
            TreeNode* minNode = getMin(root->right);
            // åˆ é™¤å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹
            root->right = deleteNode(root->right, minNode->val);
            // ç”¨å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹æ›¿æ¢ root èŠ‚ç‚¹
            minNode->left = root->left;
            minNode->right = root->right;
            root = minNode;
        } else if (root->val > key) {
            root->left = deleteNode(root->left, key);
        } else if (root->val < key) {
            root->right = deleteNode(root->right, key);
        }
        return root;
    }

    TreeNode* getMin(TreeNode* node) {
        // BST æœ€å·¦è¾¹çš„å°±æ˜¯æœ€å°çš„
        while (node->left != nullptr) {
            node = node->left;
        }
        return node;
    }
};
```

```go
// by chatGPT (go)
func deleteNode(root *TreeNode, key int) *TreeNode {
    if root == nil {
        return nil
    }
    if root.Val == key {
        // è¿™ä¸¤ä¸ª if æŠŠæƒ…å†µ 1 å’Œ 2 éƒ½æ­£ç¡®å¤„ç†äº†
        if root.Left == nil {
            return root.Right
        }
        if root.Right == nil {
            return root.Left
        }
        // å¤„ç†æƒ…å†µ 3
        // è·å¾—å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹
        minNode := getMin(root.Right)
        // åˆ é™¤å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹
        root.Right = deleteNode(root.Right, minNode.Val)
        // ç”¨å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹æ›¿æ¢ root èŠ‚ç‚¹
        minNode.Left = root.Left
        minNode.Right = root.Right
        root = minNode
    } else if root.Val > key {
        root.Left = deleteNode(root.Left, key)
    } else if root.Val < key {
        root.Right = deleteNode(root.Right, key)
    }
    return root
}

func getMin(node *TreeNode) *TreeNode {
    // BST æœ€å·¦è¾¹çš„å°±æ˜¯æœ€å°çš„
    for node.Left != nil {
        node = node.Left
    }
    return node
}
```

```java
// by labuladong (java)
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;
        if (root.val == key) {
            // è¿™ä¸¤ä¸ª if æŠŠæƒ…å†µ 1 å’Œ 2 éƒ½æ­£ç¡®å¤„ç†äº†
            if (root.left == null) return root.right;
            if (root.right == null) return root.left;
            // å¤„ç†æƒ…å†µ 3
            // è·å¾—å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹
            TreeNode minNode = getMin(root.right);
            // åˆ é™¤å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹
            root.right = deleteNode(root.right, minNode.val);
            // ç”¨å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹æ›¿æ¢ root èŠ‚ç‚¹
            minNode.left = root.left;
            minNode.right = root.right;
            root = minNode;
        } else if (root.val > key) {
            root.left = deleteNode(root.left, key);
        } else if (root.val < key) {
            root.right = deleteNode(root.right, key);
        }
        return root;
    }

    TreeNode getMin(TreeNode node) {
        // BST æœ€å·¦è¾¹çš„å°±æ˜¯æœ€å°çš„
        while (node.left != null) node = node.left;
        return node;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {TreeNode} root
 * @param {number} key
 * @return {TreeNode}
 */
var deleteNode = function(root, key) {
    if (root == null) return null;
    if (root.val == key) {
        // è¿™ä¸¤ä¸ª if æŠŠæƒ…å†µ 1 å’Œ 2 éƒ½æ­£ç¡®å¤„ç†äº†
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        // å¤„ç†æƒ…å†µ 3
        // è·å¾—å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹
        let minNode = getMin(root.right);
        // åˆ é™¤å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹
        root.right = deleteNode(root.right, minNode.val);
        // ç”¨å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹æ›¿æ¢ root èŠ‚ç‚¹
        minNode.left = root.left;
        minNode.right = root.right;
        root = minNode;
    } else if (root.val > key) {
        root.left = deleteNode(root.left, key);
    } else if (root.val < key) {
        root.right = deleteNode(root.right, key);
    }
    return root;
};

var getMin = function(node) {
    // BST æœ€å·¦è¾¹çš„å°±æ˜¯æœ€å°çš„
    while (node.left != null) node = node.left;
    return node;
};
```

```python
# by chatGPT (python)
class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if not root:
            return None
        if root.val == key:
            # è¿™ä¸¤ä¸ª if æŠŠæƒ…å†µ 1 å’Œ 2 éƒ½æ­£ç¡®å¤„ç†äº†
            if not root.left:
                return root.right
            if not root.right:
                return root.left
            # å¤„ç†æƒ…å†µ 3
            # è·å¾—å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹
            min_node = self.getMin(root.right)
            # åˆ é™¤å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹
            root.right = self.deleteNode(root.right, min_node.val)
            # ç”¨å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹æ›¿æ¢ root èŠ‚ç‚¹
            min_node.left = root.left
            min_node.right = root.right
            root = min_node
        elif root.val > key:
            root.left = self.deleteNode(root.left, key)
        elif root.val < key:
            root.right = self.deleteNode(root.right, key)
        return root

    def getMin(self, node: TreeNode) -> TreeNode:
        # BST æœ€å·¦è¾¹çš„å°±æ˜¯æœ€å°çš„
        while node.left:
            node = node.left
        return node
```

https://leetcode.cn/problems/delete-node-in-a-bst çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/delete-operation-for-two-strings çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int minDistance(string s1, string s2) {
        int m = s1.length(), n = s2.length();
        // å¤ç”¨å‰æ–‡è®¡ç®— lcs é•¿åº¦çš„å‡½æ•°
        int lcs = longestCommonSubsequence(s1, s2);
        return m - lcs + n - lcs;
    }

    // è®¡ç®—æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦
    int longestCommonSubsequence(string s1, string s2) {
        int m = s1.length(), n = s2.length();
        // å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
                if (s1[i - 1] == s2[j - 1]) {
                    // s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    // s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }
        return dp[m][n];
    }
};
```

```go
// by chatGPT (go)
func minDistance(s1 string, s2 string) int {
    m, n := len(s1), len(s2)
    // å¤ç”¨å‰æ–‡è®¡ç®— lcs é•¿åº¦çš„å‡½æ•°
    lcs := longestCommonSubsequence(s1, s2)
    return m - lcs + n - lcs
}

// è®¡ç®—æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦
func longestCommonSubsequence(s1 string, s2 string) int {
    m, n := len(s1), len(s2)
    // å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
    dp := make([][]int, m+1)
    for i := 0; i <= m; i++ {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            // ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
            if s1[i-1] == s2[j-1] {
                // s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                dp[i][j] = 1 + dp[i-1][j-1]
            } else {
                // s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                dp[i][j] = max(dp[i][j-1], dp[i-1][j])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int minDistance(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // å¤ç”¨å‰æ–‡è®¡ç®— lcs é•¿åº¦çš„å‡½æ•°
        int lcs = longestCommonSubsequence(s1, s2);
        return m - lcs + n - lcs;
    }

    // è®¡ç®—æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦
    int longestCommonSubsequence(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    // s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    // s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }
        return dp[m][n];
    }
}
```

```javascript
// by chatGPT (javascript)
var minDistance = function(s1, s2) {
    const m = s1.length, n = s2.length;
    // å¤ç”¨å‰æ–‡è®¡ç®— lcs é•¿åº¦çš„å‡½æ•°
    const lcs = longestCommonSubsequence(s1, s2);
    return m - lcs + n - lcs;
};

// è®¡ç®—æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦
function longestCommonSubsequence(s1, s2) {
    const m = s1.length, n = s2.length;
    // å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
    const dp = Array.from(Array(m + 1), () => new Array(n + 1).fill(0));

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            // ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                // s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                // s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
            }
        }
    }
    return dp[m][n];
};
```

```python
# by chatGPT (python)
class Solution:
    def minDistance(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
        # å¤ç”¨å‰æ–‡è®¡ç®— lcs é•¿åº¦çš„å‡½æ•°
        lcs = self.longestCommonSubsequence(s1, s2)
        return m - lcs + n - lcs

    # è®¡ç®—æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦
    def longestCommonSubsequence(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
        # å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
                if s1[i - 1] == s2[j - 1]:
                    # s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                    dp[i][j] = 1 + dp[i - 1][j - 1]
                else:
                    # s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])
        return dp[m][n]
```

https://leetcode.cn/problems/delete-operation-for-two-strings çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/design-twitter çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Twitter {
private:
    // Tweet ç±»
    class Tweet {
    private:
        int id;
        // æ—¶é—´æˆ³ç”¨äºå¯¹ä¿¡æ¯æµæŒ‰ç…§æ—¶é—´æ’åº
        int timestamp;
        // æŒ‡å‘ä¸‹ä¸€æ¡ tweetï¼Œç±»ä¼¼å•é“¾è¡¨ç»“æ„
        Tweet *next;

    public:
        Tweet(int id) {
            this->id = id;
            // æ–°å»ºä¸€æ¡ tweet æ—¶è®°å½•å¹¶æ›´æ–°æ—¶é—´æˆ³ 
            this->timestamp = globalTime++;
        }

        int getId() {
            return id;
        }

        int getTimestamp() {
            return timestamp;
        }

        Tweet* getNext() {
            return next;
        }

        void setNext(Tweet *next) {
            this->next = next;
        }
    };

    // ç”¨æˆ·ç±»
    class User {
    private:
        // è®°å½•è¯¥ç”¨æˆ·çš„ id ä»¥åŠå‘å¸ƒçš„ tweet
        int id;
        Tweet *tweetHead;
        // è®°å½•è¯¥ç”¨æˆ·çš„å…³æ³¨è€…
        unordered_set<User*> followedUserSet;

    public:
        User(int id) {
            this->id = id;
            this->tweetHead = nullptr;
            this->followedUserSet = unordered_set<User*>();
        }

        int getId() {
            return id;
        }

        Tweet* getTweetHead() {
            return tweetHead;
        }

        unordered_set<User*> getFollowedUserSet() {
            return followedUserSet;
        }

        bool equals(User* other) {
            return this->id == other->id;
        }

        // å…³æ³¨å…¶ä»–äºº
        void follow(User *other) {
            followedUserSet.insert(other);
        }

        // å–å…³å…¶ä»–äºº
        void unfollow(User *other) {
            followedUserSet.erase(other);
        }

        // å‘å¸ƒä¸€æ¡ tweet
        void post(Tweet *tweet) {
            // æŠŠæ–°å‘å¸ƒçš„ tweet ä½œä¸ºé“¾è¡¨å¤´èŠ‚ç‚¹
            tweet->setNext(tweetHead);
            tweetHead = tweet;
        }
    };

    // å…¨å±€æ—¶é—´æˆ³
    int globalTime = 0;
    // è®°å½•ç”¨æˆ· ID åˆ°ç”¨æˆ·ç¤ºä¾‹çš„æ˜ å°„
    unordered_map<int, User*> idToUser;

public:
    void postTweet(int userId, int tweetId) {
        // å¦‚æœè¿™ä¸ªç”¨æˆ·è¿˜ä¸å­˜åœ¨ï¼Œæ–°å»ºç”¨æˆ·
        if (idToUser.find(userId) == idToUser.end()) {
            idToUser[userId] = new User(userId);
        }
        User* user = idToUser[userId];
        user->post(new Tweet(tweetId));
    }

    vector<int> getNewsFeed(int userId) {
        vector<int> res = vector<int>();
        if (idToUser.find(userId) == idToUser.end()) {
            return res;
        }
        // è·å–è¯¥ç”¨æˆ·å…³æ³¨çš„ç”¨æˆ·åˆ—è¡¨
        User* user = idToUser[userId];
        unordered_set<User*> followedUserSet = user->getFollowedUserSet();
        // æ¯ä¸ªç”¨æˆ·çš„ tweet æ˜¯ä¸€æ¡æŒ‰æ—¶é—´æ’åºçš„é“¾è¡¨
        // ç°åœ¨æ‰§è¡Œåˆå¹¶å¤šæ¡æœ‰åºé“¾è¡¨çš„é€»è¾‘ï¼Œæ‰¾å‡ºæ—¶é—´çº¿ä¸­çš„æœ€è¿‘ 10 æ¡åŠ¨æ€
        auto cmp = [](Tweet* a, Tweet* b) -> bool {
            // æŒ‰ç…§æ¯æ¡ tweet çš„å‘å¸ƒæ—¶é—´é™åºæ’åºï¼ˆæœ€è¿‘å‘å¸ƒçš„æ’åœ¨äº‹ä»¶æµå‰é¢ï¼‰
            return b->getTimestamp() < a->getTimestamp();
        };
        priority_queue<Tweet*, vector<Tweet*>, decltype(cmp)> pq(cmp);
        // è¯¥ç”¨æˆ·è‡ªå·±çš„ tweet ä¹Ÿåœ¨æ—¶é—´çº¿å†…
        if (user->getTweetHead() != nullptr) {
            pq.push(user->getTweetHead());
        }
        for (User* other : followedUserSet) {
            if (other->getTweetHead() != nullptr) {
                pq.push(other->getTweetHead());
            }
        }
        // åˆå¹¶å¤šæ¡æœ‰åºé“¾è¡¨
        int count = 0;
        while (!pq.empty() && count < 10) {
            Tweet* tweet = pq.top();
            pq.pop();
            res.push_back(tweet->getId());
            if (tweet->getNext() != nullptr) {
                pq.push(tweet->getNext());
            }
            count++;
        }
        return res;
    }

    void follow(int followerId, int followeeId) {
        // å¦‚æœç”¨æˆ·è¿˜ä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºç”¨æˆ·
        if (idToUser.find(followerId) == idToUser.end()) {
            idToUser[followerId] = new User(followerId);
        }
        if (idToUser.find(followeeId) == idToUser.end()) {
            idToUser[followeeId] = new User(followeeId);
        }

        User* follower = idToUser[followerId];
        User* followee = idToUser[followeeId];
        // å…³æ³¨è€…å…³æ³¨è¢«å…³æ³¨è€…
        follower->follow(followee);
    }

    void unfollow(int followerId, int followeeId) {
        if (idToUser.find(followerId) == idToUser.end() || idToUser.find(followeeId) == idToUser.end()) {
            return;
        }
        User* follower = idToUser[followerId];
        User* followee = idToUser[followeeId];
        // å…³æ³¨è€…å–å…³è¢«å…³æ³¨è€…
        follower->unfollow(followee);
    }
};
```

```go
// by chatGPT (go)
type Twitter struct {
    // å…¨å±€æ—¶é—´æˆ³
    globalTime int
    // è®°å½•ç”¨æˆ· ID åˆ°ç”¨æˆ·ç¤ºä¾‹çš„æ˜ å°„
    idToUser map[int]*User
}

// Tweet ç±»
type Tweet struct {
    id        int
    // æ—¶é—´æˆ³ç”¨äºå¯¹ä¿¡æ¯æµæŒ‰ç…§æ—¶é—´æ’åº
    timestamp int
    // æŒ‡å‘ä¸‹ä¸€æ¡ tweetï¼Œç±»ä¼¼å•é“¾è¡¨ç»“æ„
    next      *Tweet
}

func NewTweet(id int) *Tweet {
    return &Tweet{
        id:        id,
        timestamp: globalTime,
    }
}

// User ç±»
type User struct {
    // è®°å½•è¯¥ç”¨æˆ·çš„ id ä»¥åŠå‘å¸ƒçš„ tweet
    id            int
    tweetHead     *Tweet
    // è®°å½•è¯¥ç”¨æˆ·çš„å…³æ³¨è€…
    followedUsers map[int]*User
}

func NewUser(id int) *User {
    return &User{
        id:            id,
        followedUsers: make(map[int]*User),
    }
}

func (u *User) Post(tweet *Tweet) {
    // æŠŠæ–°å‘å¸ƒçš„ tweet ä½œä¸ºé“¾è¡¨å¤´èŠ‚ç‚¹
    tweet.next = u.tweetHead
    u.tweetHead = tweet
}

func (u *User) Follow(other *User) {
    u.followedUsers[other.id] = other
}

func (u *User) Unfollow(other *User) {
    delete(u.followedUsers, other.id)
}

func (u *User) Eq(other *User) bool {
    return u.id == other.id
}

func (t *Twitter) PostTweet(userId int, tweetId int) {
    // å¦‚æœè¿™ä¸ªç”¨æˆ·è¿˜ä¸å­˜åœ¨ï¼Œæ–°å»ºç”¨æˆ·
    if _, ok := t.idToUser[userId]; !ok {
        t.idToUser[userId] = NewUser(userId)
    }
    user := t.idToUser[userId]
    user.Post(NewTweet(tweetId))
}

func (t *Twitter) GetNewsFeed(userId int) []int {
    res := make([]int, 0)
    if _, ok := t.idToUser[userId]; !ok {
        return res
    }
    // è·å–è¯¥ç”¨æˆ·å…³æ³¨çš„ç”¨æˆ·åˆ—è¡¨
    user := t.idToUser[userId]
    followedUserSet := user.followedUsers
    // æ¯ä¸ªç”¨æˆ·çš„ tweet æ˜¯ä¸€æ¡æŒ‰æ—¶é—´æ’åºçš„é“¾è¡¨
    // ç°åœ¨æ‰§è¡Œåˆå¹¶å¤šæ¡æœ‰åºé“¾è¡¨çš„é€»è¾‘ï¼Œæ‰¾å‡ºæ—¶é—´çº¿ä¸­çš„æœ€è¿‘ 10 æ¡åŠ¨æ€
    pq := make(PriorityQueue, 0)
    // æŒ‰ç…§æ¯æ¡ tweet çš„å‘å¸ƒæ—¶é—´é™åºæ’åºï¼ˆæœ€è¿‘å‘å¸ƒçš„æ’åœ¨äº‹ä»¶æµå‰é¢ï¼‰
    heap.Init(&pq)
    // è¯¥ç”¨æˆ·è‡ªå·±çš„ tweet ä¹Ÿåœ¨æ—¶é—´çº¿å†…
    if user.tweetHead != nil {
        heap.Push(&pq, user.tweetHead)
    }
    for _, other := range followedUserSet {
        if other.tweetHead != nil {
            heap.Push(&pq, other.tweetHead)
        }
    }
    // åˆå¹¶å¤šæ¡æœ‰åºé“¾è¡¨
    count := 0
    for pq.Len() > 0 && count < 10 {
        tweet := heap.Pop(&pq).(*Tweet)
        res = append(res, tweet.id)
        if tweet.next != nil {
            heap.Push(&pq, tweet.next)
        }
        count++
    }
    return res
}

func (t *Twitter) Follow(followerId int, followeeId int) {
    // å¦‚æœç”¨æˆ·è¿˜ä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºç”¨æˆ·
    if _, ok := t.idToUser[followerId]; !ok {
        t.idToUser[followerId] = NewUser(followerId)
    }
    if _, ok := t.idToUser[followeeId]; !ok {
        t.idToUser[followeeId] = NewUser(followeeId)
    }

    follower := t.idToUser[followerId]
    followee := t.idToUser[followeeId]
    // å…³æ³¨è€…å…³æ³¨è¢«å…³æ³¨è€…
    follower.Follow(followee)
}

func (t *Twitter) Unfollow(followerId int, followeeId int) {
    if _, ok := t.idToUser[followerId]; !ok || _, ok := t.idToUser[followeeId]; !ok {
        return
    }
    follower := t.idToUser[followerId]
    followee := t.idToUser[followeeId]
    // å…³æ³¨è€…å–å…³è¢«å…³æ³¨è€…
    follower.Unfollow(followee)
}

type PriorityQueue []*Tweet

func (pq PriorityQueue) Len() int {
    return len(pq)
}

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i].timestamp > pq[j].timestamp
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Pop() interface{} {
    n := len(*pq)
    item := (*pq)[n-1]
    *pq = (*pq)[:n-1]
    return item
}

func (pq *PriorityQueue) Push(item interface{}) {
    *pq = append(*pq, item.(*Tweet))
}
```

```java
// by labuladong (java)
class Twitter {
    // å…¨å±€æ—¶é—´æˆ³
    int globalTime = 0;
    // è®°å½•ç”¨æˆ· ID åˆ°ç”¨æˆ·ç¤ºä¾‹çš„æ˜ å°„
    HashMap<Integer, User> idToUser = new HashMap<>();

    // Tweet ç±»
    class Tweet {
        private int id;
        // æ—¶é—´æˆ³ç”¨äºå¯¹ä¿¡æ¯æµæŒ‰ç…§æ—¶é—´æ’åº
        private int timestamp;
        // æŒ‡å‘ä¸‹ä¸€æ¡ tweetï¼Œç±»ä¼¼å•é“¾è¡¨ç»“æ„
        private Tweet next;

        public Tweet(int id) {
            this.id = id;
            // æ–°å»ºä¸€æ¡ tweet æ—¶è®°å½•å¹¶æ›´æ–°æ—¶é—´æˆ³ 
            this.timestamp = globalTime++;
        }

        public int getId() {
            return id;
        }

        public int getTimestamp() {
            return timestamp;
        }

        public Tweet getNext() {
            return next;
        }

        public void setNext(Tweet next) {
            this.next = next;
        }
    }

    // ç”¨æˆ·ç±»
    class User {
        // è®°å½•è¯¥ç”¨æˆ·çš„ id ä»¥åŠå‘å¸ƒçš„ tweet
        private int id;
        private Tweet tweetHead;
        // è®°å½•è¯¥ç”¨æˆ·çš„å…³æ³¨è€…
        private HashSet<User> followedUserSet;

        public User(int id) {
            this.id = id;
            this.tweetHead = null;
            this.followedUserSet = new HashSet<>();
        }

        public int getId() {
            return id;
        }

        public Tweet getTweetHead() {
            return tweetHead;
        }

        public HashSet<User> getFollowedUserSet() {
            return followedUserSet;
        }

        public boolean equals(User other) {
            return this.id == other.id;
        }

        // å…³æ³¨å…¶ä»–äºº
        public void follow(User other) {
            followedUserSet.add(other);
        }

        // å–å…³å…¶ä»–äºº
        public void unfollow(User other) {
            followedUserSet.remove(other);
        }

        // å‘å¸ƒä¸€æ¡ tweet
        public void post(Tweet tweet) {
            // æŠŠæ–°å‘å¸ƒçš„ tweet ä½œä¸ºé“¾è¡¨å¤´èŠ‚ç‚¹
            tweet.setNext(tweetHead);
            tweetHead = tweet;
        }
    }

    public void postTweet(int userId, int tweetId) {
        // å¦‚æœè¿™ä¸ªç”¨æˆ·è¿˜ä¸å­˜åœ¨ï¼Œæ–°å»ºç”¨æˆ·
        if (!idToUser.containsKey(userId)) {
            idToUser.put(userId, new User(userId));
        }
        User user = idToUser.get(userId);
        user.post(new Tweet(tweetId));
    }

    public List<Integer> getNewsFeed(int userId) {
        List<Integer> res = new LinkedList<>();
        if (!idToUser.containsKey(userId)) {
            return res;
        }
        // è·å–è¯¥ç”¨æˆ·å…³æ³¨çš„ç”¨æˆ·åˆ—è¡¨
        User user = idToUser.get(userId);
        Set<User> followedUserSet = user.getFollowedUserSet();
        // æ¯ä¸ªç”¨æˆ·çš„ tweet æ˜¯ä¸€æ¡æŒ‰æ—¶é—´æ’åºçš„é“¾è¡¨
        // ç°åœ¨æ‰§è¡Œåˆå¹¶å¤šæ¡æœ‰åºé“¾è¡¨çš„é€»è¾‘ï¼Œæ‰¾å‡ºæ—¶é—´çº¿ä¸­çš„æœ€è¿‘ 10 æ¡åŠ¨æ€
        PriorityQueue<Tweet> pq = new PriorityQueue<>((a, b) -> {
            // æŒ‰ç…§æ¯æ¡ tweet çš„å‘å¸ƒæ—¶é—´é™åºæ’åºï¼ˆæœ€è¿‘å‘å¸ƒçš„æ’åœ¨äº‹ä»¶æµå‰é¢ï¼‰
            return b.timestamp - a.timestamp;
        });
        // è¯¥ç”¨æˆ·è‡ªå·±çš„ tweet ä¹Ÿåœ¨æ—¶é—´çº¿å†…
        if (user.getTweetHead() != null) {
            pq.offer(user.getTweetHead());
        }
        for (User other : followedUserSet) {
            if (other.getTweetHead() != null) {
                pq.offer(other.tweetHead);
            }
        }
        // åˆå¹¶å¤šæ¡æœ‰åºé“¾è¡¨
        int count = 0;
        while (!pq.isEmpty() && count < 10) {
            Tweet tweet = pq.poll();
            res.add(tweet.getId());
            if (tweet.getNext() != null) {
                pq.offer(tweet.getNext());
            }
            count++;
        }
        return res;
    }

    public void follow(int followerId, int followeeId) {
        // å¦‚æœç”¨æˆ·è¿˜ä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºç”¨æˆ·
        if (!idToUser.containsKey(followerId)) {
            idToUser.put(followerId, new User(followerId));
        }
        if (!idToUser.containsKey(followeeId)) {
            idToUser.put(followeeId, new User(followeeId));
        }

        User follower = idToUser.get(followerId);
        User followee = idToUser.get(followeeId);
        // å…³æ³¨è€…å…³æ³¨è¢«å…³æ³¨è€…
        follower.follow(followee);
    }

    public void unfollow(int followerId, int followeeId) {
        if (!idToUser.containsKey(followerId) || !idToUser.containsKey(followeeId)) {
            return;
        }
        User follower = idToUser.get(followerId);
        User followee = idToUser.get(followeeId);
        // å…³æ³¨è€…å–å…³è¢«å…³æ³¨è€…
        follower.unfollow(followee);
    }
}
```

```javascript
// by chatGPT (javascript)
var Twitter = function() {
    // å…¨å±€æ—¶é—´æˆ³
    let globalTime = 0;
    // è®°å½•ç”¨æˆ· ID åˆ°ç”¨æˆ·ç¤ºä¾‹çš„æ˜ å°„
    const idToUser = new Map();

    // Tweet ç±»
    function Tweet(id) {
        this.id = id;
        // æ—¶é—´æˆ³ç”¨äºå¯¹ä¿¡æ¯æµæŒ‰ç…§æ—¶é—´æ’åº
        this.timestamp = globalTime++;
        // æŒ‡å‘ä¸‹ä¸€æ¡ tweetï¼Œç±»ä¼¼å•é“¾è¡¨ç»“æ„
        this.next = null;
    }

    // ç”¨æˆ·ç±»
    function User(id) {
        // è®°å½•è¯¥ç”¨æˆ·çš„ id ä»¥åŠå‘å¸ƒçš„ tweet
        this.id = id;
        this.tweetHead = null;
        // è®°å½•è¯¥ç”¨æˆ·çš„å…³æ³¨è€…
        this.followedUserSet = new Set();
    }

    User.prototype.equals = function(other) {
        return this.id === other.id;
    }

    // å…³æ³¨å…¶ä»–äºº
    User.prototype.follow = function(other) {
        this.followedUserSet.add(other);
    }

    // å–å…³å…¶ä»–äºº
    User.prototype.unfollow = function(other) {
        this.followedUserSet.delete(other);
    }

    // å‘å¸ƒä¸€æ¡ tweet
    User.prototype.post = function(tweet) {
        // æŠŠæ–°å‘å¸ƒçš„ tweet ä½œä¸ºé“¾è¡¨å¤´èŠ‚ç‚¹
        tweet.next = this.tweetHead;
        this.tweetHead = tweet;
    }

    this.postTweet = function(userId, tweetId) {
        // å¦‚æœè¿™ä¸ªç”¨æˆ·è¿˜ä¸å­˜åœ¨ï¼Œæ–°å»ºç”¨æˆ·
        if (!idToUser.has(userId)) {
            idToUser.set(userId, new User(userId));
        }
        const user = idToUser.get(userId);
        user.post(new Tweet(tweetId));
    };

    this.getNewsFeed = function(userId) {
        const res = [];
        if (!idToUser.has(userId)) {
            return res;
        }
        // è·å–è¯¥ç”¨æˆ·å…³æ³¨çš„ç”¨æˆ·åˆ—è¡¨
        const user = idToUser.get(userId);
        const followedUserSet = user.followedUserSet;
        // æ¯ä¸ªç”¨æˆ·çš„ tweet æ˜¯ä¸€æ¡æŒ‰æ—¶é—´æ’åºçš„é“¾è¡¨
        // ç°åœ¨æ‰§è¡Œåˆå¹¶å¤šæ¡æœ‰åºé“¾è¡¨çš„é€»è¾‘ï¼Œæ‰¾å‡ºæ—¶é—´çº¿ä¸­çš„æœ€è¿‘ 10 æ¡åŠ¨æ€
        const pq = new PriorityQueue((a, b) => {
            // æŒ‰ç…§æ¯æ¡ tweet çš„å‘å¸ƒæ—¶é—´é™åºæ’åºï¼ˆæœ€è¿‘å‘å¸ƒçš„æ’åœ¨äº‹ä»¶æµå‰é¢ï¼‰
            return b.timestamp - a.timestamp;
        });
        // è¯¥ç”¨æˆ·è‡ªå·±çš„ tweet ä¹Ÿåœ¨æ—¶é—´çº¿å†…
        if (user.tweetHead !== null) {
            pq.offer(user.tweetHead);
        }
        for (const other of followedUserSet) {
            if (other.tweetHead !== null) {
                pq.offer(other.tweetHead);
            }
        }
        // åˆå¹¶å¤šæ¡æœ‰åºé“¾è¡¨
        let count = 0;
        while (!pq.isEmpty() && count < 10) {
            const tweet = pq.poll();
            res.push(tweet.id);
            if (tweet.next !== null) {
                pq.offer(tweet.next);
            }
            count++;
        }
        return res;
    };

    this.follow = function(followerId, followeeId) {
        // å¦‚æœç”¨æˆ·è¿˜ä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºç”¨æˆ·
        if (!idToUser.has(followerId)) {
            idToUser.set(followerId, new User(followerId));
        }
        if (!idToUser.has(followeeId)) {
            idToUser.set(followeeId, new User(followeeId));
        }

        const follower = idToUser.get(followerId);
        const followee = idToUser.get(followeeId);
        // å…³æ³¨è€…å…³æ³¨è¢«å…³æ³¨è€…
        follower.follow(followee);
    };

    this.unfollow = function(followerId, followeeId) {
        if (!idToUser.has(followerId) || !idToUser.has(followeeId)) {
            return;
        }
        const follower = idToUser.get(followerId);
        const followee = idToUser.get(followeeId);
        // å…³æ³¨è€…å–å…³è¢«å…³æ³¨è€…
        follower.unfollow(followee);
    };
};

// ä¼˜å…ˆé˜Ÿåˆ—å®ç°
class PriorityQueue {
    constructor(comparator) {
        this.heap = [];
        this.comparator = comparator;
    }

    /**
     * ä¸Šæµ®æ“ä½œ
     * @param {number} index - ä¸Šæµ®èŠ‚ç‚¹çš„ä¸‹æ ‡
     */
    swim(index) {
        let currentIndex = index;
        while (currentIndex > 0) {
            const parentIndex = Math.floor((currentIndex - 1) / 2);
            if (this.comparator(this.heap[currentIndex], this.heap[parentIndex]) >= 0) {
                break;
            }
            [this.heap[currentIndex], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[currentIndex]];
            currentIndex = parentIndex;
        }
    }

    /**
     * ä¸‹æ²‰æ“ä½œ
     * @param {number} index - ä¸‹æ²‰èŠ‚ç‚¹çš„ä¸‹æ ‡
     */
    sink(index) {
        let currentIndex = index;
        while (currentIndex * 2 + 1 < this.heap.length) {
            const leftIndex = currentIndex * 2 + 1;
            const rightIndex = currentIndex * 2 + 2 < this.heap.length ? currentIndex * 2 + 2 : leftIndex;
            const smallerIndex = this.comparator(this.heap[leftIndex], this.heap[rightIndex]) <= 0 ? leftIndex : rightIndex;
            if (this.comparator(this.heap[currentIndex], this.heap[smallerIndex]) <= 0) {
                break;
            }
            [this.heap[currentIndex], this.heap[smallerIndex]] = [this.heap[smallerIndex], this.heap[currentIndex]];
            currentIndex = smallerIndex;
        }
    }

    /**
     * æ’å…¥å…ƒç´ 
     * @param {*} value - æ’å…¥çš„å€¼
     */
    offer(value) {
        this.heap.push(value);
        this.swim(this.heap.length - 1);
    }

    /**
     * å¼¹å‡ºå †é¡¶å…ƒç´ 
     * @return {*} å †é¡¶å…ƒç´ 
     */
    poll() {
        if (this.size() === 0) {
            return null;
        }
        if (this.size() === 1) {
            return this.heap.pop();
        }
        const top = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.sink(0);
        return top;
    }

    /**
     * è·å–å †å¤§å°
     * @return {number} å †å¤§å°
     */
    size() {
        return this.heap.length;
    }
}
```

```python
# by chatGPT (python)
class Twitter:
    def __init__(self):
        # å…¨å±€æ—¶é—´æˆ³
        self.globalTime = 0
        # è®°å½•ç”¨æˆ· ID åˆ°ç”¨æˆ·ç¤ºä¾‹çš„æ˜ å°„
        self.idToUser = {}

    # Tweet ç±»
    class Tweet:
        def __init__(self, id: int):
            self.id = id
            # æ—¶é—´æˆ³ç”¨äºå¯¹ä¿¡æ¯æµæŒ‰ç…§æ—¶é—´æ’åº
            self.timestamp = Twitter.globalTime
            Twitter.globalTime += 1
            # æŒ‡å‘ä¸‹ä¸€æ¡ tweetï¼Œç±»ä¼¼å•é“¾è¡¨ç»“æ„
            self.next = None

        def get_id(self) -> int:
            return self.id

        def get_timestamp(self) -> int:
            return self.timestamp

        def get_next(self):
            return self.next

        def set_next(self, next_tweet):
            self.next = next_tweet

    # ç”¨æˆ·ç±»
    class User:
        def __init__(self, id: int):
            # è®°å½•è¯¥ç”¨æˆ·çš„ id ä»¥åŠå‘å¸ƒçš„ tweet
            self.id = id
            self.tweet_head = None
            # è®°å½•è¯¥ç”¨æˆ·çš„å…³æ³¨è€…
            self.followed_user_set = set()

        def get_id(self):
            return self.id

        def get_tweet_head(self) -> Tweet:
            return self.tweet_head

        def get_followed_user_set(self):
            return self.followed_user_set

        def __eq__(self, other):
            return self.id == other.id

        # å…³æ³¨å…¶ä»–äºº
        def follow(self, other):
            self.followed_user_set.add(other)

        # å–å…³å…¶ä»–äºº
        def unfollow(self, other):
            self.followed_user_set.discard(other)

        # å‘å¸ƒä¸€æ¡ tweet
        def post(self, tweet: Tweet):
            # æŠŠæ–°å‘å¸ƒçš„ tweet ä½œä¸ºé“¾è¡¨å¤´èŠ‚ç‚¹
            tweet.set_next(self.tweet_head)
            self.tweet_head = tweet

    def postTweet(self, userId: int, tweetId: int) -> None:
        # å¦‚æœè¿™ä¸ªç”¨æˆ·è¿˜ä¸å­˜åœ¨ï¼Œæ–°å»ºç”¨æˆ·
        if userId not in self.idToUser:
            self.idToUser[userId] = Twitter.User(userId)
        user = self.idToUser[userId]
        user.post(Twitter.Tweet(tweetId))

    def getNewsFeed(self, userId: int) -> List[int]:
        res = []
        if userId not in self.idToUser:
            return res
        # è·å–è¯¥ç”¨æˆ·å…³æ³¨çš„ç”¨æˆ·åˆ—è¡¨
        user = self.idToUser[userId]
        followed_user_set = user.get_followed_user_set()
        # æ¯ä¸ªç”¨æˆ·çš„ tweet æ˜¯ä¸€æ¡æŒ‰æ—¶é—´æ’åºçš„é“¾è¡¨
        # ç°åœ¨æ‰§è¡Œåˆå¹¶å¤šæ¡æœ‰åºé“¾è¡¨çš„é€»è¾‘ï¼Œæ‰¾å‡ºæ—¶é—´çº¿ä¸­çš„æœ€è¿‘ 10 æ¡åŠ¨æ€
        pq = []
        # è¯¥ç”¨æˆ·è‡ªå·±çš„ tweet ä¹Ÿåœ¨æ—¶é—´çº¿å†…
        if user.get_tweet_head():
            heappush(pq, (-user.tweet_head.timestamp, user.get_tweet_head())) # æŒ‰ç…§æ¯æ¡ tweet çš„å‘å¸ƒæ—¶é—´é™åºæ’åºï¼ˆæœ€è¿‘å‘å¸ƒçš„æ’åœ¨äº‹ä»¶æµå‰é¢ï¼‰
        for other in followed_user_set:
            if other.get_tweet_head():
                heappush(pq, (-other.tweet_head.timestamp, other.get_tweet_head()))
        # åˆå¹¶å¤šæ¡æœ‰åºé“¾è¡¨
        count = 0
        while pq and count < 10:
            _, tweet = heappop(pq)
            res.append(tweet.get_id())
            if tweet.get_next():
                heappush(pq, (-tweet.get_next().timestamp, tweet.get_next()))
            count += 1
        return res

    def follow(self, followerId: int, followeeId: int) -> None:
        # å¦‚æœç”¨æˆ·è¿˜ä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºç”¨æˆ·
        if followerId not in self.idToUser:
            self.idToUser[followerId] = Twitter.User(followerId)
        if followeeId not in self.idToUser:
            self.idToUser[followeeId] = Twitter.User(followeeId)

        follower = self.idToUser[followerId]
        followee = self.idToUser[followeeId]
        # å…³æ³¨è€…å…³æ³¨è¢«å…³æ³¨è€…
        follower.follow(followee)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        if followerId not in self.idToUser or followeeId not in self.idToUser:
            return
        follower = self.idToUser[followerId]
        followee = self.idToUser[followeeId]
        # å…³æ³¨è€…å–å…³è¢«å…³æ³¨è€…
        follower.unfollow(followee)
```

https://leetcode.cn/problems/design-twitter çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    char firstUniqChar(string s) {
        int count[26] = {0};
        for (char c : s) {
            // å°†å­—ç¬¦è½¬åŒ–æˆæ•°å­—
            count[c - 'a']++;
        }
        for (int i = 0; i < s.length(); i++) {
            char c = s[i];
            if (count[c - 'a'] == 1) {
                // ç¬¬ä¸€ä¸ªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦
                return c;
            }
        }
        return ' ';
    }
};
```

```go
// by chatGPT (go)
func firstUniqChar(s string) byte {
    count := make([]int, 26)
    for _, c := range s {
        // å°†å­—ç¬¦è½¬åŒ–æˆæ•°å­—
        count[c-'a']++
    }
    for _, c := range s {
        if count[c-'a'] == 1 {
            // ç¬¬ä¸€ä¸ªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦
            return byte(c)
        }
    }
    return ' '
}
```

```java
// by labuladong (java)
class Solution {
    public char firstUniqChar(String s) {
        int[] count = new int[26];
        for (char c : s.toCharArray()) {
            // å°†å­—ç¬¦è½¬åŒ–æˆæ•°å­—
            count[c - 'a']++;
        }
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (count[c - 'a'] == 1) {
                // ç¬¬ä¸€ä¸ªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦
                return c;
            }
        }
        return ' ';
    }
}
```

```javascript
// by chatGPT (javascript)
var firstUniqChar = function(s) {
    var count = new Array(26).fill(0);
    for (var i = 0; i < s.length; i++) {
        // å°†å­—ç¬¦è½¬åŒ–æˆæ•°å­—
        count[s.charCodeAt(i) - 97]++;
    }
    for (var i = 0; i < s.length; i++) {
        var c = s.charAt(i);
        if (count[c.charCodeAt(0) - 97] == 1) {
            // ç¬¬ä¸€ä¸ªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦
            return c;
        }
    }
    return ' ';
};
```

```python
# by chatGPT (python)
class Solution:
    def firstUniqChar(self, s: str) -> str:
        count = [0] * 26
        for c in s:
            # å°†å­—ç¬¦è½¬åŒ–æˆæ•°å­—
            count[ord(c) - ord('a')] += 1
        for c in s:
            if count[ord(c) - ord('a')] == 1:
                # ç¬¬ä¸€ä¸ªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦
                return c
        return ' '
```

https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/diameter-of-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    int maxDiameter = 0;

public:
    int diameterOfBinaryTree(TreeNode* root) {
        maxDepth(root);
        return maxDiameter;
    }

    int maxDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        // ååºéå†ä½ç½®é¡ºä¾¿è®¡ç®—æœ€å¤§ç›´å¾„
        maxDiameter = max(maxDiameter, leftMax + rightMax);
        return 1 + max(leftMax, rightMax);
    }
};

// è¿™æ˜¯ä¸€ç§ç®€å•ç²—æš´ï¼Œä½†æ˜¯æ•ˆç‡ä¸é«˜çš„è§£æ³•
class BadSolution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        // è®¡ç®—å‡ºå·¦å³å­æ ‘çš„æœ€å¤§é«˜åº¦
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        // root è¿™ä¸ªèŠ‚ç‚¹çš„ç›´å¾„
        int res = leftMax + rightMax;
        // é€’å½’éå† root->left å’Œ root->right ä¸¤ä¸ªå­æ ‘
        return max(res,
                max(diameterOfBinaryTree(root->left),
                    diameterOfBinaryTree(root->right)));
    }

    int maxDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        return 1 + max(leftMax, rightMax);
    }
};
```

```go
// by mario_huang (go)
var maxDiameter int

func diameterOfBinaryTree(root *TreeNode) int {
    // è®°å½•æœ€å¤§ç›´å¾„çš„é•¿åº¦
    maxDiameter = 0
    maxDepth(root)
    return maxDiameter
}

func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    leftMax := maxDepth(root.Left)
    rightMax := maxDepth(root.Right)
    // ååºä½ç½®ï¼Œé¡ºä¾¿è®¡ç®—æœ€å¤§ç›´å¾„
    myDiameter := leftMax + rightMax
    maxDiameter = max(maxDiameter, myDiameter)
    return max(leftMax, rightMax) + 1
}

// è¿™æ˜¯ä¸€ç§ç®€å•ç²—æš´ï¼Œä½†æ˜¯æ•ˆç‡ä¸é«˜çš„è§£æ³•
func diameterOfBinaryTree(root *TreeNode) int {
    if root == nil {
        return 0
    }
    // è®¡ç®—å‡ºå·¦å³å­æ ‘çš„æœ€å¤§é«˜åº¦
    maxDepth := func(root *TreeNode) int {
        if root == nil {
            return 0
        }
        leftMax := maxDepth(root.Left)
        rightMax := maxDepth(root.Right)
        return 1 + max(leftMax, rightMax)
    }
    leftMax := maxDepth(root.Left)
    rightMax := maxDepth(root.Right)
    // root è¿™ä¸ªèŠ‚ç‚¹çš„ç›´å¾„
    res := leftMax + rightMax
    // é€’å½’éå† root.Left å’Œ root.Right ä¸¤ä¸ªå­æ ‘
    return max(res,
        max(diameterOfBinaryTree(root.Left),
            diameterOfBinaryTree(root.Right)))
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    int maxDiameter = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return maxDiameter;
    }

    int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftMax = maxDepth(root.left);
        int rightMax = maxDepth(root.right);
        // ååºéå†ä½ç½®é¡ºä¾¿è®¡ç®—æœ€å¤§ç›´å¾„
        maxDiameter = Math.max(maxDiameter, leftMax + rightMax);
        return 1 + Math.max(leftMax, rightMax);
    }
}

// è¿™æ˜¯ä¸€ç§ç®€å•ç²—æš´ï¼Œä½†æ˜¯æ•ˆç‡ä¸é«˜çš„è§£æ³•
class BadSolution {
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        // è®¡ç®—å‡ºå·¦å³å­æ ‘çš„æœ€å¤§é«˜åº¦
        int leftMax = maxDepth(root.left);
        int rightMax = maxDepth(root.right);
        // root è¿™ä¸ªèŠ‚ç‚¹çš„ç›´å¾„
        int res = leftMax + rightMax;
        // é€’å½’éå† root.left å’Œ root.right ä¸¤ä¸ªå­æ ‘
        return Math.max(res,
                Math.max(diameterOfBinaryTree(root.left),
                        diameterOfBinaryTree(root.right)));
    }

    int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftMax = maxDepth(root.left);
        int rightMax = maxDepth(root.right);
        return 1 + Math.max(leftMax, rightMax);
    }
}
```

```javascript
// by chatGPT (javascript)
var diameterOfBinaryTree = function(root) {
    let maxDiameter = 0;

    const maxDepth = (root) => {
        if (root == null) {
            return 0;
        }
        let leftMax = maxDepth(root.left);
        let rightMax = maxDepth(root.right);
        // ååºéå†ä½ç½®é¡ºä¾¿è®¡ç®—æœ€å¤§ç›´å¾„
        maxDiameter = Math.max(maxDiameter, leftMax + rightMax);
        return 1 + Math.max(leftMax, rightMax);
    };

    maxDepth(root);
    return maxDiameter;
}

// è¿™æ˜¯ä¸€ç§ç®€å•ç²—æš´ï¼Œä½†æ˜¯æ•ˆç‡ä¸é«˜çš„è§£æ³•
var BadSolution = function() {};

BadSolution.prototype.diameterOfBinaryTree = function(root) {
    if (root == null) {
        return 0;
    }
    // è®¡ç®—å‡ºå·¦å³å­æ ‘çš„æœ€å¤§é«˜åº¦
    let leftMax = this.maxDepth(root.left);
    let rightMax = this.maxDepth(root.right);
    // root è¿™ä¸ªèŠ‚ç‚¹çš„ç›´å¾„
    let res = leftMax + rightMax;
    // é€’å½’éå† root.left å’Œ root.right ä¸¤ä¸ªå­æ ‘
    return Math.max(res,
            Math.max(this.diameterOfBinaryTree(root.left),
                    this.diameterOfBinaryTree(root.right)));
};

BadSolution.prototype.maxDepth = function(root) {
    if (root == null) {
        return 0;
    }
    let leftMax = this.maxDepth(root.left);
    let rightMax = this.maxDepth(root.right);
    return 1 + Math.max(leftMax, rightMax);
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.maxDiameter = 0
        
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.maxDepth(root)
        return self.maxDiameter
    
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        leftMax = self.maxDepth(root.left)
        rightMax = self.maxDepth(root.right)
        # ååºéå†ä½ç½®é¡ºä¾¿è®¡ç®—æœ€å¤§ç›´å¾„
        self.maxDiameter = max(self.maxDiameter, leftMax + rightMax)
        return 1 + max(leftMax, rightMax)
 
# è¿™æ˜¯ä¸€ç§ç®€å•ç²—æš´ï¼Œä½†æ˜¯æ•ˆç‡ä¸é«˜çš„è§£æ³•
class BadSolution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        if not root:
            return 0
        # è®¡ç®—å‡ºå·¦å³å­æ ‘çš„æœ€å¤§é«˜åº¦
        leftMax = self.maxDepth(root.left)
        rightMax = self.maxDepth(root.right)
        # root è¿™ä¸ªèŠ‚ç‚¹çš„ç›´å¾„
        res = leftMax + rightMax
        # é€’å½’éå† root.left å’Œ root.right ä¸¤ä¸ªå­æ ‘
        return max(res, max(self.diameterOfBinaryTree(root.left), self.diameterOfBinaryTree(root.right)))

    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        leftMax = self.maxDepth(root.left)
        rightMax = self.maxDepth(root.right)
        return 1 + max(leftMax, rightMax)
```

https://leetcode.cn/problems/diameter-of-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        // ç»´æŠ¤ nums[0..slow) éƒ½æ˜¯å¥‡æ•°
        int fast = 0, slow = 0;
        while (fast < nums.size()) {
            if (nums[fast] % 2 == 1) {
                // fast é‡åˆ°å¥‡æ•°ï¼ŒæŠŠ nums[fast] æ¢åˆ° nums[slow]
                int temp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = temp;
                slow++;
            }
            fast++;
        }
        return nums;
    }
};
```

```go
// by chatGPT (go)
func exchange(nums []int) []int {
    // ç»´æŠ¤ nums[0..slow) éƒ½æ˜¯å¥‡æ•°
    fast, slow := 0, 0
    for fast < len(nums) {
        if nums[fast]%2 == 1 {
            // fast é‡åˆ°å¥‡æ•°ï¼ŒæŠŠ nums[fast] æ¢åˆ° nums[slow]
            temp := nums[slow]
            nums[slow] = nums[fast]
            nums[fast] = temp
            slow++
        }
        fast++
    }
    return nums
}
```

```java
// by labuladong (java)
class Solution {
    public int[] exchange(int[] nums) {
        // ç»´æŠ¤ nums[0..slow) éƒ½æ˜¯å¥‡æ•°
        int fast = 0, slow = 0;
        while (fast < nums.length) {
            if (nums[fast] % 2 == 1) {
                // fast é‡åˆ°å¥‡æ•°ï¼ŒæŠŠ nums[fast] æ¢åˆ° nums[slow]
                int temp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = temp;
                slow++;
            }
            fast++;
        }
        return nums;
    }
}
```

```javascript
// by chatGPT (javascript)
var exchange = function(nums) {
    // ç»´æŠ¤ nums[0..slow) éƒ½æ˜¯å¥‡æ•°
    let fast = 0, slow = 0;
    while (fast < nums.length) {
        if (nums[fast] % 2 === 1) {
            // fast é‡åˆ°å¥‡æ•°ï¼ŒæŠŠ nums[fast] æ¢åˆ° nums[slow]
            let temp = nums[slow];
            nums[slow] = nums[fast];
            nums[fast] = temp;
            slow++;
        }
        fast++;
    }
    return nums;
};
```

```python
# by chatGPT (python)
class Solution:
    def exchange(self, nums: List[int]) -> List[int]:
        # ç»´æŠ¤ nums[0..slow) éƒ½æ˜¯å¥‡æ•°
        fast, slow = 0, 0
        while fast < len(nums):
            if nums[fast] % 2 == 1:
                # fast é‡åˆ°å¥‡æ•°ï¼ŒæŠŠ nums[fast] æ¢åˆ° nums[slow]
                nums[slow], nums[fast] = nums[fast], nums[slow]
                slow += 1
            fast += 1
        return nums
```

https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/different-ways-to-add-parentheses çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
private:
    unordered_map<string, vector<int>> memo;
public:
    vector<int> diffWaysToCompute(string input) {
        // é¿å…é‡å¤è®¡ç®—
        if (memo.count(input)) {
            return memo[input];
        }
        vector<int> res;
        for (int i = 0; i < input.length(); i++) {
            char c = input[i];
            // æ‰«æç®—å¼ input ä¸­çš„è¿ç®—ç¬¦
            if (c == '-' || c == '*' || c == '+') {
                /******åˆ†******/
                // ä»¥è¿ç®—ç¬¦ä¸ºä¸­å¿ƒï¼Œåˆ†å‰²æˆä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œåˆ†åˆ«é€’å½’è®¡ç®—
                vector<int> left = diffWaysToCompute(input.substr(0, i));
                vector<int> right = diffWaysToCompute(input.substr(i + 1));
                /******æ²»******/
                // é€šè¿‡å­é—®é¢˜çš„ç»“æœï¼ŒåˆæˆåŸé—®é¢˜çš„ç»“æœ
                for (int a : left)
                    for (int b : right)
                        if (c == '+')
                            res.push_back(a + b);
                        else if (c == '-')
                            res.push_back(a - b);
                        else if (c == '*')
                            res.push_back(a * b);
            }
        }
        // base case
        // å¦‚æœ res ä¸ºç©ºï¼Œè¯´æ˜ç®—å¼æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œæ²¡æœ‰è¿ç®—ç¬¦
        if (res.empty()) {
            res.push_back(stoi(input));
        }
        // å°†ç»“æœæ·»åŠ è¿›å¤‡å¿˜å½•
        memo[input] = res;
        return res;
    }
};
```

```go
// by chatGPT (go)
func diffWaysToCompute(input string) []int {
    memo := make(map[string][]int)
    return compute(input, memo)
}

func compute(input string, memo map[string][]int) []int {
    // é¿å…é‡å¤è®¡ç®—
    if val, ok := memo[input]; ok {
        return val
    }
    res := make([]int, 0)
    for i := 0; i < len(input); i++ {
        c := input[i]
        // æ‰«æç®—å¼ input ä¸­çš„è¿ç®—ç¬¦
        if c == '-' || c == '*' || c == '+' {
            /******åˆ†******/
            // ä»¥è¿ç®—ç¬¦ä¸ºä¸­å¿ƒï¼Œåˆ†å‰²æˆä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œåˆ†åˆ«é€’å½’è®¡ç®—
            left := compute(input[0:i], memo)
            right := compute(input[i+1:], memo)
            /******æ²»******/
            // é€šè¿‡å­é—®é¢˜çš„ç»“æœï¼ŒåˆæˆåŸé—®é¢˜çš„ç»“æœ
            for _, a := range left {
                for _, b := range right {
                    if c == '+' {
                        res = append(res, a+b)
                    } else if c == '-' {
                        res = append(res, a-b)
                    } else if c == '*' {
                        res = append(res, a*b)
                    }
                }
            }
        }
    }
    // base case
    // å¦‚æœ res ä¸ºç©ºï¼Œè¯´æ˜ç®—å¼æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œæ²¡æœ‰è¿ç®—ç¬¦
    if len(res) == 0 {
        n, _ := strconv.Atoi(input)
        res = append(res, n)
    }
    // å°†ç»“æœæ·»åŠ è¿›å¤‡å¿˜å½•
    memo[input] = res
    return res
}
```

```java
// by labuladong (java)
class Solution {

    HashMap<String, List<Integer>> memo = new HashMap<>();

    public List<Integer> diffWaysToCompute(String input) {
        // é¿å…é‡å¤è®¡ç®—
        if (memo.containsKey(input)) {
            return memo.get(input);
        }
        List<Integer> res = new LinkedList<>();
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            // æ‰«æç®—å¼ input ä¸­çš„è¿ç®—ç¬¦
            if (c == '-' || c == '*' || c == '+') {
                /******åˆ†******/
                // ä»¥è¿ç®—ç¬¦ä¸ºä¸­å¿ƒï¼Œåˆ†å‰²æˆä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œåˆ†åˆ«é€’å½’è®¡ç®—
                List<Integer>
                        left = diffWaysToCompute(input.substring(0, i));
                List<Integer>
                        right = diffWaysToCompute(input.substring(i + 1));
                /******æ²»******/
                // é€šè¿‡å­é—®é¢˜çš„ç»“æœï¼ŒåˆæˆåŸé—®é¢˜çš„ç»“æœ
                for (int a : left)
                    for (int b : right)
                        if (c == '+')
                            res.add(a + b);
                        else if (c == '-')
                            res.add(a - b);
                        else if (c == '*')
                            res.add(a * b);
            }
        }
        // base case
        // å¦‚æœ res ä¸ºç©ºï¼Œè¯´æ˜ç®—å¼æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œæ²¡æœ‰è¿ç®—ç¬¦
        if (res.isEmpty()) {
            res.add(Integer.parseInt(input));
        }
        // å°†ç»“æœæ·»åŠ è¿›å¤‡å¿˜å½•
        memo.put(input, res);
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var diffWaysToCompute = function(input) {
    let memo = new Map();
    const compute = (input) => {
        if (memo.has(input)) {
            return memo.get(input);
        }
        let res = [];
        for (let i = 0; i < input.length; i++) {
            let c = input.charAt(i);
            // æ‰«æç®—å¼ input ä¸­çš„è¿ç®—ç¬¦
            if (c == '-' || c == '*' || c == '+') {
                /******åˆ†******/
                // ä»¥è¿ç®—ç¬¦ä¸ºä¸­å¿ƒï¼Œåˆ†å‰²æˆä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œåˆ†åˆ«é€’å½’è®¡ç®—
                let left = compute(input.substring(0, i));
                let right = compute(input.substring(i + 1));
                /******æ²»******/
                // é€šè¿‡å­é—®é¢˜çš„ç»“æœï¼ŒåˆæˆåŸé—®é¢˜çš„ç»“æœ
                for (let a of left) {
                    for (let b of right) {
                        if (c == '+') {
                            res.push(a + b);
                        } else if (c == '-') {
                            res.push(a - b);
                        } else if (c == '*') {
                            res.push(a * b);
                        }
                    }
                }
            }
        }
        // base case
        // å¦‚æœ res ä¸ºç©ºï¼Œè¯´æ˜ç®—å¼æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œæ²¡æœ‰è¿ç®—ç¬¦
        if (res.length == 0) {
            res.push(parseInt(input));
        }
        // å°†ç»“æœæ·»åŠ è¿›å¤‡å¿˜å½•
        memo.set(input, res);
        return res;
    };
    return compute(input);
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.memo = {}

    def diffWaysToCompute(self, input: str) -> List[int]:
        # é¿å…é‡å¤è®¡ç®—
        if input in self.memo:
            return self.memo[input]
        res = []
        for i in range(len(input)):
            c = input[i]
            # æ‰«æç®—å¼ input ä¸­çš„è¿ç®—ç¬¦
            if c in ['-', '*', '+']:
                # ä»¥è¿ç®—ç¬¦ä¸ºä¸­å¿ƒï¼Œåˆ†å‰²æˆä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œåˆ†åˆ«é€’å½’è®¡ç®—
                left = self.diffWaysToCompute(input[:i])
                right = self.diffWaysToCompute(input[i+1:])
                # é€šè¿‡å­é—®é¢˜çš„ç»“æœï¼ŒåˆæˆåŸé—®é¢˜çš„ç»“æœ
                for a in left:
                    for b in right:
                        if c == '+':
                            res.append(a + b)
                        elif c == '-':
                            res.append(a - b)
                        elif c == '*':
                            res.append(a * b)
        # base case
        # å¦‚æœ res ä¸ºç©ºï¼Œè¯´æ˜ç®—å¼æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œæ²¡æœ‰è¿ç®—ç¬¦
        if not res:
            res.append(int(input))
        # å°†ç»“æœæ·»åŠ è¿›å¤‡å¿˜å½•
        self.memo[input] = res
        return res
```

https://leetcode.cn/problems/different-ways-to-add-parentheses çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/dungeon-game çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        // å¤‡å¿˜å½•ä¸­éƒ½åˆå§‹åŒ–ä¸º -1
        memo = vector<vector<int>>(m, vector<int>(n, -1));

        return dp(grid, 0, 0);
    }

    // å¤‡å¿˜å½•ï¼Œæ¶ˆé™¤é‡å å­é—®é¢˜
    vector<vector<int>> memo;

    /* å®šä¹‰ï¼šä» (i, j) åˆ°è¾¾å³ä¸‹è§’ï¼Œéœ€è¦çš„åˆå§‹è¡€é‡è‡³å°‘æ˜¯å¤šå°‘ */
    int dp(vector<vector<int>>& grid, int i, int j) {
        int m = grid.size();
        int n = grid[0].size();
        // base case
        if (i == m - 1 && j == n - 1) {
            return grid[i][j] >= 0 ? 1 : -grid[i][j] + 1;
        }
        if (i == m || j == n) {
            return INT_MAX;
        }
        // é¿å…é‡å¤è®¡ç®—
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // çŠ¶æ€è½¬ç§»é€»è¾‘
        int res = min(
                dp(grid, i, j + 1),
                dp(grid, i + 1, j)
        ) - grid[i][j];
        // éª‘å£«çš„ç”Ÿå‘½å€¼è‡³å°‘ä¸º 1
        memo[i][j] = res <= 0 ? 1 : res;

        return memo[i][j];
    }
};
```

```go
// by chatGPT (go)
import "math"

func calculateMinimumHP(grid [][]int) int {
    m := len(grid)
    n := len(grid[0])
    // å¤‡å¿˜å½•ä¸­éƒ½åˆå§‹åŒ–ä¸º -1
    memo := make([][]int, m)
    for i := range memo {
        memo[i] = make([]int, n)
        for j := range memo[i] {
            memo[i][j] = -1
        }
    }

    return dp(grid, 0, 0, memo)
}

/* å®šä¹‰ï¼šä» (i, j) åˆ°è¾¾å³ä¸‹è§’ï¼Œéœ€è¦çš„åˆå§‹è¡€é‡è‡³å°‘æ˜¯å¤šå°‘ */
func dp(grid [][]int, i, j int, memo [][]int) int {
    m := len(grid)
    n := len(grid[0])
    // base case
    if i == m-1 && j == n-1 {
        if grid[i][j] >= 0 {
            return 1
        } else {
            return -grid[i][j] + 1
        }
    }
    if i == m || j == n {
        return math.MaxInt32
    }
    // é¿å…é‡å¤è®¡ç®—
    if memo[i][j] != -1 {
        return memo[i][j]
    }
    // çŠ¶æ€è½¬ç§»é€»è¾‘
    res := int(math.Min(
        float64(dp(grid, i, j+1, memo)),
        float64(dp(grid, i+1, j, memo)),
    )) - grid[i][j]
    // éª‘å£«çš„ç”Ÿå‘½å€¼è‡³å°‘ä¸º 1
    if res <= 0 {
        memo[i][j] = 1
    } else {
        memo[i][j] = res
    }

    return memo[i][j]
}
```

```java
// by labuladong (java)
class Solution {

    public int calculateMinimumHP(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        // å¤‡å¿˜å½•ä¸­éƒ½åˆå§‹åŒ–ä¸º -1
        memo = new int[m][n];
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }

        return dp(grid, 0, 0);
    }

    // å¤‡å¿˜å½•ï¼Œæ¶ˆé™¤é‡å å­é—®é¢˜
    int[][] memo;

    /* å®šä¹‰ï¼šä» (i, j) åˆ°è¾¾å³ä¸‹è§’ï¼Œéœ€è¦çš„åˆå§‹è¡€é‡è‡³å°‘æ˜¯å¤šå°‘ */
    int dp(int[][] grid, int i, int j) {
        int m = grid.length;
        int n = grid[0].length;
        // base case
        if (i == m - 1 && j == n - 1) {
            return grid[i][j] >= 0 ? 1 : -grid[i][j] + 1;
        }
        if (i == m || j == n) {
            return Integer.MAX_VALUE;
        }
        // é¿å…é‡å¤è®¡ç®—
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // çŠ¶æ€è½¬ç§»é€»è¾‘
        int res = Math.min(
                dp(grid, i, j + 1),
                dp(grid, i + 1, j)
        ) - grid[i][j];
        // éª‘å£«çš„ç”Ÿå‘½å€¼è‡³å°‘ä¸º 1
        memo[i][j] = res <= 0 ? 1 : res;

        return memo[i][j];
    }
}
```

```javascript
// by chatGPT (javascript)
var calculateMinimumHP = function(grid) {
    const m = grid.length;
    const n = grid[0].length;
    // å¤‡å¿˜å½•ä¸­éƒ½åˆå§‹åŒ–ä¸º -1
    const memo = new Array(m).fill().map(() => new Array(n).fill(-1));

    function dp(i, j) {
        // base case
        if (i === m - 1 && j === n - 1) {
            return grid[i][j] >= 0 ? 1 : -grid[i][j] + 1;
        }
        if (i === m || j === n) {
            return Number.MAX_VALUE;
        }
        // é¿å…é‡å¤è®¡ç®—
        if (memo[i][j] !== -1) {
            return memo[i][j];
        }
        // çŠ¶æ€è½¬ç§»é€»è¾‘
        const res = Math.min(dp(i, j + 1), dp(i + 1, j)) - grid[i][j];
        // éª‘å£«çš„ç”Ÿå‘½å€¼è‡³å°‘ä¸º 1
        memo[i][j] = res <= 0 ? 1 : res;

        return memo[i][j];
    }

    return dp(0, 0);
};
```

```python
# by chatGPT (python)
class Solution:
    def calculateMinimumHP(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        # å¤‡å¿˜å½•ä¸­éƒ½åˆå§‹åŒ–ä¸º -1
        memo = [[-1 for _ in range(n)] for _ in range(m)]

        return self.dp(grid, 0, 0, memo)

    def dp(self, grid: List[List[int]], i: int, j: int, memo: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        # base case
        if i == m - 1 and j == n - 1:
            return 1 if grid[i][j] >= 0 else -grid[i][j] + 1
        if i == m or j == n:
            return float('inf')
        # é¿å…é‡å¤è®¡ç®—
        if memo[i][j] != -1:
            return memo[i][j]
        # çŠ¶æ€è½¬ç§»é€»è¾‘
        res = min(
                self.dp(grid, i, j + 1, memo),
                self.dp(grid, i + 1, j, memo)
        ) - grid[i][j]
        # éª‘å£«çš„ç”Ÿå‘½å€¼è‡³å°‘ä¸º 1
        memo[i][j] = 1 if res <= 0 else res

        return memo[i][j]
```

https://leetcode.cn/problems/dungeon-game çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/edit-distance çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.length(), n = word2.length();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        // base case
        for (int i = 1; i <= m; i++)
            dp[i][0] = i;
        for (int j = 1; j <= n; j++)
            dp[0][j] = j;
        // è‡ªåº•å‘ä¸Šæ±‚è§£
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1[i - 1] == word2[j - 1])
                    dp[i][j] = dp[i - 1][j - 1];
                else
                    dp[i][j] = min(
                        dp[i - 1][j] + 1,
                        /**<extend up -300>
                        ![](../pictures/editDistance/delete.gif)
                        */
                        dp[i][j - 1] + 1,
                        /**<extend up -300>
                        ![](../pictures/editDistance/insert.gif)
                        */
                        dp[i - 1][j - 1] + 1
                        /**<extend up -300>
                        ![](../pictures/editDistance/replace.gif)
                        */
                    );
            }
        }
        // å‚¨å­˜ç€æ•´ä¸ª s1 å’Œ s2 çš„æœ€å°ç¼–è¾‘è·ç¦»
        return dp[m][n];
    }

    int min(int a, int b, int c) {
        return std::min(a, std::min(b, c));
    }
};
```

```go
// by chatGPT (go)
func minDistance(s1 string, s2 string) int {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    // base case
    for i := 1; i <= m; i++ {
        dp[i][0] = i
    }
    for j := 1; j <= n; j++ {
        dp[0][j] = j
    }
    // è‡ªåº•å‘ä¸Šæ±‚è§£
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = min(
                    dp[i-1][j]+1,
                    /**<extend up -300>
                    ![](../pictures/editDistance/delete.gif)
                    */
                    dp[i][j-1]+1,
                    /**<extend up -300>
                    ![](../pictures/editDistance/insert.gif)
                    */
                    dp[i-1][j-1]+1,
                    /**<extend up -300>
                    ![](../pictures/editDistance/replace.gif)
                    */
                )
            }
        }
    }
    // å‚¨å­˜ç€æ•´ä¸ª s1 å’Œ s2 çš„æœ€å°ç¼–è¾‘è·ç¦»
    return dp[m][n]
}

func min(a, b, c int) int {
    if a < b {
        if a < c {
            return a
        }
        return c
    } else if b < c {
        return b
    }
    return c
}
```

```java
// by labuladong (java)
class Solution {
    public int minDistance(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        int[][] dp = new int[m + 1][n + 1];
        // base case
        for (int i = 1; i <= m; i++)
            dp[i][0] = i;
        for (int j = 1; j <= n; j++)
            dp[0][j] = j;
        // è‡ªåº•å‘ä¸Šæ±‚è§£
        for (int i = 1; i <= m; i++)
            for (int j = 1; j <= n; j++)
                if (s1.charAt(i - 1) == s2.charAt(j - 1))
                    dp[i][j] = dp[i - 1][j - 1];
                else
                    dp[i][j] = min(
                        dp[i - 1][j] + 1,
                        /**<extend up -300>
                        ![](../pictures/editDistance/delete.gif)
                        */
                        dp[i][j - 1] + 1,
                        /**<extend up -300>
                        ![](../pictures/editDistance/insert.gif)
                        */
                        dp[i - 1][j - 1] + 1
                        /**<extend up -300>
                        ![](../pictures/editDistance/replace.gif)
                        */
                    );
        // å‚¨å­˜ç€æ•´ä¸ª s1 å’Œ s2 çš„æœ€å°ç¼–è¾‘è·ç¦»
        return dp[m][n];
    }

    int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }
}
```

```javascript
// by chatGPT (javascript)
var minDistance = function(s1, s2) {
    let m = s1.length, n = s2.length;
    let dp = new Array(m + 1).fill().map(() => new Array(n + 1).fill(0));
    // base case
    for (let i = 1; i <= m; i++)
        dp[i][0] = i;
    for (let j = 1; j <= n; j++)
        dp[0][j] = j;
    // è‡ªåº•å‘ä¸Šæ±‚è§£
    for (let i = 1; i <= m; i++)
        for (let j = 1; j <= n; j++)
            if (s1.charAt(i - 1) == s2.charAt(j - 1))
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = Math.min(
                    dp[i - 1][j] + 1,
                    /**<extend up -300>
                    ![](../pictures/editDistance/delete.gif)
                    */
                    dp[i][j - 1] + 1,
                    /**<extend up -300>
                    ![](../pictures/editDistance/insert.gif)
                    */
                    dp[i - 1][j - 1] + 1
                    /**<extend up -300>
                    ![](../pictures/editDistance/replace.gif)
                    */
                );
    // å‚¨å­˜ç€æ•´ä¸ª s1 å’Œ s2 çš„æœ€å°ç¼–è¾‘è·ç¦»
    return dp[m][n];
}

function min(a, b, c) {
    return Math.min(a, Math.min(b, c));
}
```

```python
# by chatGPT (python)
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m, n = len(word1), len(word2)
        dp = [[0] * (n+1) for _ in range(m+1)]
        
        # base case
        for i in range(1, m+1):
            dp[i][0] = i
        for j in range(1, n+1):
            dp[0][j] = j
        
        # è‡ªåº•å‘ä¸Šæ±‚è§£
        for i in range(1, m+1):
            for j in range(1, n+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(
                        dp[i-1][j] + 1, # insert
                        dp[i][j-1] + 1, # delete
                        dp[i-1][j-1] + 1 # replace
                    )
        
        # å‚¨å­˜ç€æ•´ä¸ª word1 å’Œ word2 çš„æœ€å°ç¼–è¾‘è·ç¦»
        return dp[m][n]
```

https://leetcode.cn/problems/edit-distance çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
// ã€Œéå†ã€çš„æ€è·¯
class Solution {
public:
    // äºŒå‰æ ‘éå†å‡½æ•°
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }

        /**** å‰åºä½ç½® ****/
        // æ¯ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦åšçš„äº‹å°±æ˜¯äº¤æ¢å®ƒçš„å·¦å³å­èŠ‚ç‚¹
        TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;

        // éå†æ¡†æ¶ï¼Œå»éå†å·¦å³å­æ ‘çš„èŠ‚ç‚¹
        traverse(root->left);
        traverse(root->right);
    }

    // ä¸»å‡½æ•°
    TreeNode* invertTree(TreeNode* root) {
        // éå†äºŒå‰æ ‘ï¼Œäº¤æ¢æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
        traverse(root);
        return root;
    }
};

// ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯
class Solution2 {
public:
    // å®šä¹‰ï¼šå°†ä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘ç¿»è½¬ï¼Œè¿”å›ç¿»è½¬åçš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }
        // åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œå…ˆç¿»è½¬å·¦å³å­æ ‘
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);

        // ç„¶åäº¤æ¢å·¦å³å­èŠ‚ç‚¹
        root->left = right;
        root->right = left;

        // å’Œå®šä¹‰é€»è¾‘è‡ªæ°ï¼šä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘å·²ç»è¢«ç¿»è½¬ï¼Œè¿”å› root
        return root;
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

//ã€Œéå†ã€çš„æ€è·¯
func invertTree(root *TreeNode) *TreeNode {
    // éå†äºŒå‰æ ‘ï¼Œäº¤æ¢æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
    traverse(root)
    return root
}

// äºŒå‰æ ‘éå†å‡½æ•°
func traverse(root *TreeNode) {
    if root == nil {
        return
    }
    //æ¯ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦åšçš„äº‹å°±æ˜¯äº¤æ¢å®ƒçš„å·¦å³å­èŠ‚ç‚¹
    tmp := root.Left
    root.Left = root.Right
    root.Right = tmp

    // éå†æ¡†æ¶ï¼Œå»éå†å·¦å³å­æ ‘çš„èŠ‚ç‚¹
    traverse(root.Left)
    traverse(root.Right)
}

//ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    // åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œå…ˆç¿»è½¬å·¦å³å­æ ‘
    left := invertTree(root.Left)
    right := invertTree(root.Right)

    // ç„¶åäº¤æ¢å·¦å³å­èŠ‚ç‚¹
    root.Left = right
    root.Right = left

    // å’Œå®šä¹‰é€»è¾‘è‡ªæ°ï¼šä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘å·²ç»è¢«ç¿»è½¬ï¼Œè¿”å› root
    return root
}
```

```java
// by labuladong (java)
// ã€Œéå†ã€çš„æ€è·¯
class Solution {
    // ä¸»å‡½æ•°
    public TreeNode invertTree(TreeNode root) {
        // éå†äºŒå‰æ ‘ï¼Œäº¤æ¢æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
        traverse(root);
        return root;
    }

    // äºŒå‰æ ‘éå†å‡½æ•°
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }

        /**** å‰åºä½ç½® ****/
        // æ¯ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦åšçš„äº‹å°±æ˜¯äº¤æ¢å®ƒçš„å·¦å³å­èŠ‚ç‚¹
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;

        // éå†æ¡†æ¶ï¼Œå»éå†å·¦å³å­æ ‘çš„èŠ‚ç‚¹
        traverse(root.left);
        traverse(root.right);
    }
}

// ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯
class Solution2 {
    // å®šä¹‰ï¼šå°†ä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘ç¿»è½¬ï¼Œè¿”å›ç¿»è½¬åçš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        // åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œå…ˆç¿»è½¬å·¦å³å­æ ‘
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);

        // ç„¶åäº¤æ¢å·¦å³å­èŠ‚ç‚¹
        root.left = right;
        root.right = left;

        // å’Œå®šä¹‰é€»è¾‘è‡ªæ°ï¼šä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘å·²ç»è¢«ç¿»è½¬ï¼Œè¿”å› root
        return root;
    }
}
```

```javascript
// by chatGPT (javascript)
// ã€Œéå†ã€çš„æ€è·¯
var Solution = function() {};

// ä¸»å‡½æ•°
Solution.prototype.invertTree = function(root) {
    // éå†äºŒå‰æ ‘ï¼Œäº¤æ¢æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
    this.traverse(root);
    return root;
};

// äºŒå‰æ ‘éå†å‡½æ•°
Solution.prototype.traverse = function(root) {
    if (root == null) {
        return;
    }

    /**** å‰åºä½ç½® ****/
    // æ¯ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦åšçš„äº‹å°±æ˜¯äº¤æ¢å®ƒçš„å·¦å³å­èŠ‚ç‚¹
    var tmp = root.left;
    root.left = root.right;
    root.right = tmp;

    // éå†æ¡†æ¶ï¼Œå»éå†å·¦å³å­æ ‘çš„èŠ‚ç‚¹
    this.traverse(root.left);
    this.traverse(root.right);
};

// ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯
var Solution2 = function() {};

// å®šä¹‰ï¼šå°†ä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘ç¿»è½¬ï¼Œè¿”å›ç¿»è½¬åçš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
Solution2.prototype.invertTree = function(root) {
    if (root == null) {
        return null;
    }
    // åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œå…ˆç¿»è½¬å·¦å³å­æ ‘
    var left = this.invertTree(root.left);
    var right = this.invertTree(root.right);

    // ç„¶åäº¤æ¢å·¦å³å­èŠ‚ç‚¹
    root.left = right;
    root.right = left;

    // å’Œå®šä¹‰é€»è¾‘è‡ªæ°ï¼šä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘å·²ç»è¢«ç¿»è½¬ï¼Œè¿”å› root
    return root;
};
```

```python
# by chatGPT (python)
# ã€Œéå†ã€çš„æ€è·¯
class Solution:
    # ä¸»å‡½æ•°
    def invertTree(self, root: TreeNode) -> TreeNode:
        # éå†äºŒå‰æ ‘ï¼Œäº¤æ¢æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
        self.traverse(root)
        return root

    # äºŒå‰æ ‘éå†å‡½æ•°
    def traverse(self, root: TreeNode) -> None:
        if root is None:
            return

        # å‰åºä½ç½®
        # æ¯ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦åšçš„äº‹å°±æ˜¯äº¤æ¢å®ƒçš„å·¦å³å­èŠ‚ç‚¹
        tmp = root.left
        root.left = root.right
        root.right = tmp

        # éå†æ¡†æ¶ï¼Œå»éå†å·¦å³å­æ ‘çš„èŠ‚ç‚¹
        self.traverse(root.left)
        self.traverse(root.right)


# ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯
class Solution2:
    # å®šä¹‰ï¼šå°†ä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘ç¿»è½¬ï¼Œè¿”å›ç¿»è½¬åçš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    def invertTree(self, root: TreeNode) -> TreeNode:
        if root is None:
            return None

        # åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œå…ˆç¿»è½¬å·¦å³å­æ ‘
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)

        # ç„¶åäº¤æ¢å·¦å³å­èŠ‚ç‚¹
        root.left = right
        root.right = left

        # å’Œå®šä¹‰é€»è¾‘è‡ªæ°ï¼šä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘å·²ç»è¢«ç¿»è½¬ï¼Œè¿”å› root
        return root
```

https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
/***** è§£æ³•ä¸€ï¼Œå›æº¯ç®—æ³•æ€è·¯ *****/
class Solution {
    int depth = 0;
    int res = 0;

public:
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }

    // éå†äºŒå‰æ ‘
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }

        // å‰åºéå†ä½ç½®
        depth++;
        // éå†çš„è¿‡ç¨‹ä¸­è®°å½•æœ€å¤§æ·±åº¦
        res = std::max(res, depth);
        traverse(root->left);
        traverse(root->right);
        // ååºéå†ä½ç½®
        depth--;
    }
};

/***** è§£æ³•äºŒï¼ŒåŠ¨æ€è§„åˆ’æ€è·¯ *****/
class Solution2 {
public:
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
    int maxDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        // æ ¹æ®å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦æ¨å‡ºåŸäºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
        return 1 + std::max(leftMax, rightMax);
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

 // è§£æ³•ä¸€ï¼Œå›æº¯ç®—æ³•æ€è·¯
func maxDepth(root *TreeNode) int {
    depth := 0
    res := 0
    var traverse func(root *TreeNode)

    traverse = func(root *TreeNode) {
        if root == nil {
            return
        }

        depth++
        res = Max(res, depth)
        traverse(root.Left)
        traverse(root.Right)
        depth--
    }

    traverse(root)
    return res
}

// è§£æ³•äºŒï¼ŒåŠ¨æ€è§„åˆ’æ€è·¯
func maxDepth2(root *TreeNode) int {
    if root == nil {
        return 0
    }
    leftMax := maxDepth(root.Left)
    rightMax := maxDepth(root.Right)
    return 1 + Max(leftMax, rightMax)
}

func Max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
/***** è§£æ³•ä¸€ï¼Œå›æº¯ç®—æ³•æ€è·¯ *****/
class Solution {

    int depth = 0;
    int res = 0;

    public int maxDepth(TreeNode root) {
        traverse(root);
        return res;
    }

    // éå†äºŒå‰æ ‘
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }

        // å‰åºéå†ä½ç½®
        depth++;
        // éå†çš„è¿‡ç¨‹ä¸­è®°å½•æœ€å¤§æ·±åº¦
        res = Math.max(res, depth);
        traverse(root.left);
        traverse(root.right);
        // ååºéå†ä½ç½®
        depth--;
    }
}

/***** è§£æ³•äºŒï¼ŒåŠ¨æ€è§„åˆ’æ€è·¯ *****/
class Solution2 {
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftMax = maxDepth(root.left);
        int rightMax = maxDepth(root.right);
        // æ ¹æ®å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦æ¨å‡ºåŸäºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
        return 1 + Math.max(leftMax, rightMax);
    }
}
```

```javascript
// by chatGPT (javascript)
// è§£æ³•ä¸€ï¼Œå›æº¯ç®—æ³•æ€è·¯
var maxDepth = function(root) {
    let depth = 0;
    let res = 0;
    
    // éå†äºŒå‰æ ‘
    function traverse(root) {
        if (root === null) {
            return;
        }
        
        // å‰åºéå†ä½ç½®
        depth++;
        // éå†çš„è¿‡ç¨‹ä¸­è®°å½•æœ€å¤§æ·±åº¦
        res = Math.max(res, depth);
        traverse(root.left);
        traverse(root.right);
        // ååºéå†ä½ç½®
        depth--;
    }
    
    traverse(root);
    return res;
};

// è§£æ³•äºŒï¼ŒåŠ¨æ€è§„åˆ’æ€è·¯
var maxDepth = function(root) {
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
    if (root === null) {
        return 0;
    }
    let leftMax = maxDepth(root.left);
    let rightMax = maxDepth(root.right);
    // æ ¹æ®å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦æ¨å‡ºåŸäºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
    return 1 + Math.max(leftMax, rightMax);
};
```

```python
# by chatGPT (python)
# è§£æ³•ä¸€ï¼Œå›æº¯ç®—æ³•æ€è·¯
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        depth, res = 0, 0
        self.traverse(root, depth, res)
        return res
    
    # éå†äºŒå‰æ ‘
    def traverse(self, root: TreeNode, depth: int, res: int) -> None:
        if not root:
            return
        # å‰åºéå†ä½ç½®
        depth += 1
        # éå†çš„è¿‡ç¨‹ä¸­è®°å½•æœ€å¤§æ·±åº¦
        res = max(res, depth)
        self.traverse(root.left, depth, res)
        self.traverse(root.right, depth, res)
        # ååºéå†ä½ç½®
        depth -= 1

# è§£æ³•äºŒï¼ŒåŠ¨æ€è§„åˆ’æ€è·¯
class Solution2:
    # å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        leftMax = self.maxDepth(root.left)
        rightMax = self.maxDepth(root.right)
        # æ ¹æ®å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦æ¨å‡ºåŸäºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
        return 1 + max(leftMax, rightMax)
```

https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // base case
        if (root == nullptr) return nullptr;
        if (root == p || root == q) return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        // æƒ…å†µ 1
        if (left != nullptr && right != nullptr) {
            return root;
        }
        // æƒ…å†µ 2
        if (left == nullptr && right == nullptr) {
            return nullptr;
        }
        // æƒ…å†µ 3
        return left == nullptr ? right : left;
    }
};
```

```go
// by chatGPT (go)
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    // base case
    if root == nil {
        return nil
    }
    if root == p || root == q {
        return root
    }

    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    // æƒ…å†µ 1
    if left != nil && right != nil {
        return root
    }
    // æƒ…å†µ 2
    if left == nil && right == nil {
        return nil
    }
    // æƒ…å†µ 3
    if left == nil {
        return right
    } else {
        return left
    }
}
```

```java
// by labuladong (java)
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // base case
        if (root == null) return null;
        if (root == p || root == q) return root;

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // æƒ…å†µ 1
        if (left != null && right != null) {
            return root;
        }
        // æƒ…å†µ 2
        if (left == null && right == null) {
            return null;
        }
        // æƒ…å†µ 3
        return left == null ? right : left;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    // base case
    if (root == null) return null;
    if (root == p || root == q) return root;

    var left = lowestCommonAncestor(root.left, p, q);
    var right = lowestCommonAncestor(root.right, p, q);
    // æƒ…å†µ 1
    if (left != null && right != null) {
        return root;
    }
    // æƒ…å†µ 2
    if (left == null && right == null) {
        return null;
    }
    // æƒ…å†µ 3
    return left == null ? right : left;
};
```

```python
# by chatGPT (python)
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # base case
        if not root:
            return None
        if root == p or root == q:
            return root
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        
        # æƒ…å†µ 1
        if left and right:
            return root
        
        # æƒ…å†µ 2
        if not left and not right:
            return None
        
        # æƒ…å†µ 3
        return right if not left else left
```

https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int kthLargest(TreeNode* root, int k) {
        // åˆ©ç”¨ BST çš„ä¸­åºéå†ç‰¹æ€§
        traverse(root, k);
        return res;
    }

    // è®°å½•ç»“æœ
    int res = 0;
    // è®°å½•å½“å‰å…ƒç´ çš„æ’å
    int rank = 0;
    void traverse(TreeNode* root, int k) {
        if (root == nullptr) {
            return;
        }
        traverse(root->right, k);
        /* ä¸­åºéå†ä»£ç ä½ç½® */
        rank++;
        if (k == rank) {
            // æ‰¾åˆ°ç¬¬ k å¤§çš„å…ƒç´ 
            res = root->val;
            return;
        }
        /*****************/
        traverse(root->left, k);
    }
};
```

```go
// by chatGPT (go)
func kthLargest(root *TreeNode, k int) int {
    // åˆ©ç”¨ BST çš„ä¸­åºéå†ç‰¹æ€§
    traverse := func(node *TreeNode, k int) {}
    res, rank := 0, 0

    traverse = func(node *TreeNode, k int) {
        if node == nil {
            return
        }
        traverse(node.Right, k)
        /* ä¸­åºéå†ä»£ç ä½ç½® */
        rank++
        if k == rank {
            // æ‰¾åˆ°ç¬¬ k å¤§çš„å…ƒç´ 
            res = node.Val
            return
        }
        /*****************/
        traverse(node.Left, k)
    }

    traverse(root, k)
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int kthLargest(TreeNode root, int k) {
        // åˆ©ç”¨ BST çš„ä¸­åºéå†ç‰¹æ€§
        traverse(root, k);
        return res;
    }

    // è®°å½•ç»“æœ
    int res = 0;
    // è®°å½•å½“å‰å…ƒç´ çš„æ’å
    int rank = 0;
    void traverse(TreeNode root, int k) {
        if (root == null) {
            return;
        }
        traverse(root.right, k);
        /* ä¸­åºéå†ä»£ç ä½ç½® */
        rank++;
        if (k == rank) {
            // æ‰¾åˆ°ç¬¬ k å¤§çš„å…ƒç´ 
            res = root.val;
            return;
        }
        /*****************/
        traverse(root.left, k);
    }
}
```

```javascript
// by chatGPT (javascript)
var kthLargest = function(root, k) {
    let res = 0, rank = 0;

    const traverse = function(root, k) {
        if (root === null) {
            return;
        }
        traverse(root.right, k);
        /* ä¸­åºéå†ä»£ç ä½ç½® */
        rank++;
        if (k === rank) {
            // æ‰¾åˆ°ç¬¬ k å¤§çš„å…ƒç´ 
            res = root.val;
            return;
        }
        /*****************/
        traverse(root.left, k);
    }

    traverse(root, k);
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def kthLargest(self, root: TreeNode, k: int) -> int:
        # åˆ©ç”¨ BST çš„ä¸­åºéå†ç‰¹æ€§
        self.rank = 0
        self.traverse(root, k)
        return self.res
    
    # è®°å½•ç»“æœ
    res = 0
    # è®°å½•å½“å‰å…ƒç´ çš„æ’å
    rank = 0
    
    def traverse(self, root: TreeNode, k: int) -> None:
        if not root:
            return
        
        self.traverse(root.right, k)
        """ ä¸­åºéå†ä»£ç ä½ç½® """
        self.rank += 1
        if self.rank == k:
            # æ‰¾åˆ°ç¬¬ k å¤§çš„å…ƒç´ 
            self.res = root.val
            return
        /*****************/
        self.traverse(root.left, k)
```

https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        return check(postorder, 0, postorder.size() - 1);
    }

    // å®šä¹‰ï¼šæ£€æŸ¥ postorder[i..j] æ˜¯å¦æ˜¯ä¸€ä¸ªåˆæ³•çš„ BST
    bool check(vector<int>& postorder, int i, int j) {
        if (i >= j) {
            return true;
        }
        // æ ¹èŠ‚ç‚¹çš„å€¼æ˜¯ååºéå†ç»“æœçš„æœ€åä¸€ä¸ªå…ƒç´ 
        int root = postorder[j];

        // postorder[i..left) æ˜¯å·¦å­æ ‘ï¼Œåº”è¯¥éƒ½å°äº root
        int left = i;
        while (left < j && postorder[left] < root) {
            left++;
        }

        // postorder[left..j) æ˜¯å³å­æ ‘ï¼Œåº”è¯¥éƒ½å¤§äº root
        int right = left;
        while (right < j && postorder[right] > root) {
            right++;
        }
        if (right != j) {
            return false;
        }
        // é€’å½’æ£€æŸ¥å·¦å­æ ‘ [i..left) å’Œå³å­æ ‘ [left..j) ä¹Ÿç¬¦åˆ BST çš„æ€§è´¨
        return check(postorder, i, left - 1) && check(postorder, left, j - 1);
    }
};
```

```go
// by chatGPT (go)
func verifyPostorder(postorder []int) bool {
    return check(postorder, 0, len(postorder) - 1)
}

// å®šä¹‰ï¼šæ£€æŸ¥ postorder[i..j] æ˜¯å¦æ˜¯ä¸€ä¸ªåˆæ³•çš„ BST
func check(postorder []int, i int, j int) bool {
    if i >= j {
        return true
    }
    // æ ¹èŠ‚ç‚¹çš„å€¼æ˜¯ååºéå†ç»“æœçš„æœ€åä¸€ä¸ªå…ƒç´ 
    root := postorder[j]
    /**<extend up -200>
    ![](../pictures/äºŒå‰æ ‘ç³»åˆ—2/5.jpeg)
    */

    // postorder[i..left) æ˜¯å·¦å­æ ‘ï¼Œåº”è¯¥éƒ½å°äº root
    left := i
    for left < j && postorder[left] < root {
        left++
    }

    // postorder[left..j) æ˜¯å³å­æ ‘ï¼Œåº”è¯¥éƒ½å¤§äº root
    right := left
    for right < j && postorder[right] > root {
        right++
    }
    if right != j {
        return false
    }
    // é€’å½’æ£€æŸ¥å·¦å­æ ‘ [i..left) å’Œå³å­æ ‘ [left..j) ä¹Ÿç¬¦åˆ BST çš„æ€§è´¨
    return check(postorder, i, left - 1) && check(postorder, left, j - 1)
}
```

```java
// by labuladong (java)
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        return check(postorder, 0, postorder.length - 1);
    }

    // å®šä¹‰ï¼šæ£€æŸ¥ postorder[i..j] æ˜¯å¦æ˜¯ä¸€ä¸ªåˆæ³•çš„ BST
    boolean check(int[] postorder, int i, int j) {
        if (i >= j) {
            return true;
        }
        // æ ¹èŠ‚ç‚¹çš„å€¼æ˜¯ååºéå†ç»“æœçš„æœ€åä¸€ä¸ªå…ƒç´ 
        int root = postorder[j];
        /**<extend up -200>
        ![](../pictures/äºŒå‰æ ‘ç³»åˆ—2/5.jpeg)
        */

        // postorder[i..left) æ˜¯å·¦å­æ ‘ï¼Œåº”è¯¥éƒ½å°äº root
        int left = i;
        while (left < j && postorder[left] < root) {
            left++;
        }

        // postorder[left..j) æ˜¯å³å­æ ‘ï¼Œåº”è¯¥éƒ½å¤§äº root
        int right = left;
        while (right < j && postorder[right] > root) {
            right++;
        }
        if (right != j) {
            return false;
        }
        // é€’å½’æ£€æŸ¥å·¦å­æ ‘ [i..left) å’Œå³å­æ ‘ [left..j) ä¹Ÿç¬¦åˆ BST çš„æ€§è´¨
        return check(postorder, i, left - 1) && check(postorder, left, j - 1);
    }

}
```

```javascript
// by chatGPT (javascript)
var verifyPostorder = function(postorder) {
    return check(postorder, 0, postorder.length - 1);
};

// å®šä¹‰ï¼šæ£€æŸ¥ postorder[i..j] æ˜¯å¦æ˜¯ä¸€ä¸ªåˆæ³•çš„ BST
function check(postorder, i, j) {
    if (i >= j) {
        return true;
    }
    // æ ¹èŠ‚ç‚¹çš„å€¼æ˜¯ååºéå†ç»“æœçš„æœ€åä¸€ä¸ªå…ƒç´ 
    let root = postorder[j];

    // postorder[i..left) æ˜¯å·¦å­æ ‘ï¼Œåº”è¯¥éƒ½å°äº root
    let left = i;
    while (left < j && postorder[left] < root) {
        left++;
    }

    // postorder[left..j) æ˜¯å³å­æ ‘ï¼Œåº”è¯¥éƒ½å¤§äº root
    let right = left;
    while (right < j && postorder[right] > root) {
        right++;
    }
    if (right != j) {
        return false;
    }
    // é€’å½’æ£€æŸ¥å·¦å­æ ‘ [i..left) å’Œå³å­æ ‘ [left..j) ä¹Ÿç¬¦åˆ BST çš„æ€§è´¨
    return check(postorder, i, left - 1) && check(postorder, left, j - 1);
}
```

```python
# by chatGPT (python)
class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:
        return self.check(postorder, 0, len(postorder)-1)

    def check(self, postorder: List[int], i: int, j: int) -> bool:
        if i >= j:
            return True
        # æ ¹èŠ‚ç‚¹çš„å€¼æ˜¯ååºéå†ç»“æœçš„æœ€åä¸€ä¸ªå…ƒç´ 
        root = postorder[j]

        # postorder[i..left) æ˜¯å·¦å­æ ‘ï¼Œåº”è¯¥éƒ½å°äº root
        left = i
        while left < j and postorder[left] < root:
            left += 1

        # postorder[left..j) æ˜¯å³å­æ ‘ï¼Œåº”è¯¥éƒ½å¤§äº root
        right = left
        while right < j and postorder[right] > root:
            right += 1

        if right != j:
            return False

        # é€’å½’æ£€æŸ¥å·¦å­æ ‘ [i..left) å’Œå³å­æ ‘ [left..j) ä¹Ÿç¬¦åˆ BST çš„æ€§è´¨
        return self.check(postorder, i, left-1) and self.check(postorder, left, j-1)
```

https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int res = 0;
        while (n != 0) {
            n = n & (n - 1);
            res++;
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func hammingWeight(num uint32) int {
    res := 0
    for num != 0 {
        num &= (num - 1)
        res++
    }
    return res
}
```

```java
// by labuladong (java)
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res = 0;
        while (n != 0) {
            n = n & (n - 1);
            res++;
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n - a positive integer
 * @return {number} - the number of bits set to 1 in the binary representation of n
 */
var hammingWeight = function(n) {
    let res = 0;
    while (n !== 0) {
        n = n & (n - 1);
        res++;
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def hammingWeight(self, n: int) -> int:
        """
        :type n: int
        :rtype: int
        """
        res = 0
        while n != 0:
            n &= n - 1
            res += 1
        return res
```

https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        // åˆå§‹åŒ–åœ¨å³ä¸Šè§’
        int i = 0, j = n - 1;
        while (i < m && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            }
            if (matrix[i][j] < target) {
                // éœ€è¦å¤§ä¸€ç‚¹ï¼Œå¾€ä¸‹ç§»åŠ¨
                i++;
            } else {
                // éœ€è¦å°ä¸€ç‚¹ï¼Œå¾€å·¦ç§»åŠ¨
                j--;
            }
        }
        // while å¾ªç¯ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™ target ä¸å­˜åœ¨
        return false;
    }
};
```

```go
// by chatGPT (go)
func searchMatrix(matrix [][]int, target int) bool {
    m, n := len(matrix), len(matrix[0])
    // åˆå§‹åŒ–åœ¨å³ä¸Šè§’
    i, j := 0, n-1
    for i < m && j >= 0 {
        if matrix[i][j] == target {
            return true
        }
        if matrix[i][j] < target {
            // éœ€è¦å¤§ä¸€ç‚¹ï¼Œå¾€ä¸‹ç§»åŠ¨
            i++
        } else {
            // éœ€è¦å°ä¸€ç‚¹ï¼Œå¾€å·¦ç§»åŠ¨
            j--
        }
    }
    // while å¾ªç¯ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™ target ä¸å­˜åœ¨
    return false
}
```

```java
// by labuladong (java)
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length;
        // åˆå§‹åŒ–åœ¨å³ä¸Šè§’
        int i = 0, j = n - 1;
        while (i < m && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            }
            if (matrix[i][j] < target) {
                // éœ€è¦å¤§ä¸€ç‚¹ï¼Œå¾€ä¸‹ç§»åŠ¨
                i++;
            } else {
                // éœ€è¦å°ä¸€ç‚¹ï¼Œå¾€å·¦ç§»åŠ¨
                j--;
            }
        }
        // while å¾ªç¯ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™ target ä¸å­˜åœ¨
        return false;
    }
}
```

```javascript
// by chatGPT (javascript)
var searchMatrix = function(matrix, target) {
    const m = matrix.length;
    const n = matrix[0].length;
    // åˆå§‹åŒ–åœ¨å³ä¸Šè§’
    let i = 0;
    let j = n - 1;
    while (i < m && j >= 0) {
        if (matrix[i][j] === target) {
            return true;
        }
        if (matrix[i][j] < target) {
            // éœ€è¦å¤§ä¸€ç‚¹ï¼Œå¾€ä¸‹ç§»åŠ¨
            i++;
        } else {
            // éœ€è¦å°ä¸€ç‚¹ï¼Œå¾€å·¦ç§»åŠ¨
            j--;
        }
    }
    // while å¾ªç¯ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™ target ä¸å­˜åœ¨
    return false;
};
```

```python
# by chatGPT (python)
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m, n = len(matrix), len(matrix[0])
        # åˆå§‹åŒ–åœ¨å³ä¸Šè§’
        i, j = 0, n - 1
        while i < m and j >= 0:
            if matrix[i][j] == target:
                return True
            if matrix[i][j] < target:
                # éœ€è¦å¤§ä¸€ç‚¹ï¼Œå¾€ä¸‹ç§»åŠ¨
                i += 1
            else:
                # éœ€è¦å°ä¸€ç‚¹ï¼Œå¾€å·¦ç§»åŠ¨
                j -= 1
        # while å¾ªç¯ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™ target ä¸å­˜åœ¨
        return False
```

https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/evaluate-reverse-polish-notation çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> stk;
        for (const string& token : tokens) {
            if (string("+-*/").find(token) != string::npos) {
                // æ˜¯ä¸ªè¿ç®—ç¬¦ï¼Œä»æ ˆé¡¶æ‹¿å‡ºä¸¤ä¸ªæ•°å­—è¿›è¡Œè¿ç®—ï¼Œè¿ç®—ç»“æœå…¥æ ˆ
                int a = stk.top(); stk.pop();
                int b = stk.top(); stk.pop();
                switch (token[0]) {
                    case '+':
                        stk.push(a + b);
                        break;
                    case '*':
                        stk.push(a * b);
                        break;
                    // å¯¹äºå‡æ³•å’Œé™¤æ³•ï¼Œé¡ºåºåˆ«æåäº†ï¼Œç¬¬äºŒä¸ªæ•°æ˜¯è¢«é™¤ï¼ˆå‡ï¼‰æ•°
                    case '-':
                        stk.push(b - a);
                        break;
                    case '/':
                        stk.push(b / a);
                        break;
                }
            } else {
                // æ˜¯ä¸ªæ•°å­—ï¼Œç›´æ¥å…¥æ ˆå³å¯
                stk.push(stoi(token));
            }
        }
        // æœ€åæ ˆä¸­å‰©ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå³æ˜¯è®¡ç®—ç»“æœ
        return stk.top();
    }
};
```

```go
// by chatGPT (go)
func evalRPN(tokens []string) int {
    stk := make([]int, 0)
    for _, token := range tokens {
        if strings.Contains("+-*/", token) {
            // æ˜¯ä¸ªè¿ç®—ç¬¦ï¼Œä»æ ˆé¡¶æ‹¿å‡ºä¸¤ä¸ªæ•°å­—è¿›è¡Œè¿ç®—ï¼Œè¿ç®—ç»“æœå…¥æ ˆ
            a, b := stk[len(stk)-1], stk[len(stk)-2]
            stk = stk[:len(stk)-2]
            switch token {
            case "+":
                stk = append(stk, b+a)
            case "*":
                stk = append(stk, b*a)
            // å¯¹äºå‡æ³•å’Œé™¤æ³•ï¼Œé¡ºåºåˆ«æåäº†ï¼Œç¬¬äºŒä¸ªæ•°æ˜¯è¢«é™¤ï¼ˆå‡ï¼‰æ•°
            case "-":
                stk = append(stk, b-a)
            case "/":
                stk = append(stk, b/a)
            }
        } else {
            // æ˜¯ä¸ªæ•°å­—ï¼Œç›´æ¥å…¥æ ˆå³å¯
            num, _ := strconv.Atoi(token)
            stk = append(stk, num)
        }
    }
    // æœ€åæ ˆä¸­å‰©ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå³æ˜¯è®¡ç®—ç»“æœ
    return stk[0]
}
```

```java
// by labuladong (java)
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer> stk = new Stack<>();
        for (String token : tokens) {
            if ("+-*/".contains(token)) {
                // æ˜¯ä¸ªè¿ç®—ç¬¦ï¼Œä»æ ˆé¡¶æ‹¿å‡ºä¸¤ä¸ªæ•°å­—è¿›è¡Œè¿ç®—ï¼Œè¿ç®—ç»“æœå…¥æ ˆ
                int a = stk.pop(), b = stk.pop();
                switch (token) {
                    case "+":
                        stk.push(a + b);
                        break;
                    case "*":
                        stk.push(a * b);
                        break;
                    // å¯¹äºå‡æ³•å’Œé™¤æ³•ï¼Œé¡ºåºåˆ«æåäº†ï¼Œç¬¬äºŒä¸ªæ•°æ˜¯è¢«é™¤ï¼ˆå‡ï¼‰æ•°
                    case "-":
                        stk.push(b - a);
                        break;
                    case "/":
                        stk.push(b / a);
                        break;
                }
            } else {
                // æ˜¯ä¸ªæ•°å­—ï¼Œç›´æ¥å…¥æ ˆå³å¯
                stk.push(Integer.parseInt(token));
            }
        }
        // æœ€åæ ˆä¸­å‰©ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå³æ˜¯è®¡ç®—ç»“æœ
        return stk.pop();
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
    const stk = [];
    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        if ("+-*/".indexOf(token) !== -1) {
            // æ˜¯ä¸ªè¿ç®—ç¬¦ï¼Œä»æ ˆé¡¶æ‹¿å‡ºä¸¤ä¸ªæ•°å­—è¿›è¡Œè¿ç®—ï¼Œè¿ç®—ç»“æœå…¥æ ˆ
            const a = stk.pop(), b = stk.pop();
            switch (token) {
                case "+":
                    stk.push(a + b);
                    break;
                case "*":
                    stk.push(a * b);
                    break;
                // å¯¹äºå‡æ³•å’Œé™¤æ³•ï¼Œé¡ºåºåˆ«æåäº†ï¼Œç¬¬äºŒä¸ªæ•°æ˜¯è¢«é™¤ï¼ˆå‡ï¼‰æ•°
                case "-":
                    stk.push(b - a);
                    break;
                case "/":
                    stk.push(b / a | 0); // å–æ•´
                    break;
            }
        } else {
            // æ˜¯ä¸ªæ•°å­—ï¼Œç›´æ¥å…¥æ ˆå³å¯
            stk.push(parseInt(token));
        }
    }
    // æœ€åæ ˆä¸­å‰©ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå³æ˜¯è®¡ç®—ç»“æœ
    return stk.pop();
};
```

```python
# by chatGPT (python)
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stk = []
        for token in tokens:
            if token in "+-*/":
                # æ˜¯ä¸ªè¿ç®—ç¬¦ï¼Œä»æ ˆé¡¶æ‹¿å‡ºä¸¤ä¸ªæ•°å­—è¿›è¡Œè¿ç®—ï¼Œè¿ç®—ç»“æœå…¥æ ˆ
                a, b = stk.pop(), stk.pop()
                if token == "+":
                    stk.append(a + b)
                elif token == "*":
                    stk.append(a * b)
                # å¯¹äºå‡æ³•å’Œé™¤æ³•ï¼Œé¡ºåºåˆ«æåäº†ï¼Œç¬¬äºŒä¸ªæ•°æ˜¯è¢«é™¤ï¼ˆå‡ï¼‰æ•°
                elif token == "-":
                    stk.append(b - a)
                else:
                    stk.append(int(b / a))
            else:
                # æ˜¯ä¸ªæ•°å­—ï¼Œç›´æ¥å…¥æ ˆå³å¯
                stk.append(int(token))
        # æœ€åæ ˆä¸­å‰©ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå³æ˜¯è®¡ç®—ç»“æœ
        return stk.pop()
```

https://leetcode.cn/problems/evaluate-reverse-polish-notation çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/exam-room çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class ExamRoom {
private:
    // å°†ç«¯ç‚¹ p æ˜ å°„åˆ°ä»¥ p ä¸ºå·¦ç«¯ç‚¹çš„çº¿æ®µ
    unordered_map<int, vector<int>> startMap;
    // å°†ç«¯ç‚¹ p æ˜ å°„åˆ°ä»¥ p ä¸ºå³ç«¯ç‚¹çš„çº¿æ®µ
    unordered_map<int, vector<int>> endMap;
    // æ ¹æ®çº¿æ®µé•¿åº¦ä»å°åˆ°å¤§å­˜æ”¾æ‰€æœ‰çº¿æ®µ
    set<vector<int>> pq;
    int N;
public:
    ExamRoom(int N) {
        this->N = N;
        startMap.clear();
        endMap.clear();
        pq.clear();
        pq.insert({-1, N});
    }

    int seat() {
        // ä»æœ‰åºé›†åˆæ‹¿å‡ºæœ€é•¿çš„çº¿æ®µ
        auto longest = prev(pq.end());
        int x = longest->at(0);
        int y = longest->at(1);
        int seat;
        if (x == -1) { // æƒ…å†µä¸€
            seat = 0;
        } else if (y == N) { // æƒ…å†µäºŒ
            seat = N - 1;
        } else { // æƒ…å†µä¸‰
            seat = (y - x) / 2 + x;
        }
        // å°†æœ€é•¿çš„çº¿æ®µåˆ†æˆä¸¤æ®µ
        auto left = vector<int>{x, seat};
        auto right = vector<int>{seat, y};
        removeInterval(*longest);
        addInterval(left);
        addInterval(right);
        return seat;
    }

    void leave(int p) {
        // å°† p å·¦å³çš„çº¿æ®µæ‰¾å‡ºæ¥
        auto right = startMap[p];
        auto left = endMap[p];
        // åˆå¹¶ä¸¤ä¸ªçº¿æ®µæˆä¸ºä¸€ä¸ªçº¿æ®µ
        auto merged = vector<int>{left[0], right[1]};
        removeInterval(left);
        removeInterval(right);
        addInterval(merged);
    }


    /* å¢åŠ ä¸€ä¸ªçº¿æ®µ */
    void addInterval(vector<int> intv) {
        pq.insert(intv);
        startMap[intv[0]] = intv;
        endMap[intv[1]] = intv;
    }

    /* å»é™¤ä¸€ä¸ªçº¿æ®µ */
    void removeInterval(vector<int> intv) {
        pq.erase(intv);
        startMap.erase(intv[0]);
        endMap.erase(intv[1]);
    }

    /* è®¡ç®—ä¸€ä¸ªçº¿æ®µçš„é•¿åº¦ */
    int distance(vector<int> intv) {
        int x = intv[0];
        int y = intv[1];
        if (x == -1) return y;
        if (y == N) return N - 1 - x;
        // ä¸­ç‚¹å’Œç«¯ç‚¹ä¹‹é—´çš„é•¿åº¦
        return (y - x) / 2;
    }
};
```

```go
// by chatGPT (go)
type ExamRoom struct {
    // å°†ç«¯ç‚¹ p æ˜ å°„åˆ°ä»¥ p ä¸ºå·¦ç«¯ç‚¹çš„çº¿æ®µ
    startMap map[int][]int
    // å°†ç«¯ç‚¹ p æ˜ å°„åˆ°ä»¥ p ä¸ºå³ç«¯ç‚¹çš„çº¿æ®µ
    endMap map[int][]int
    // æ ¹æ®çº¿æ®µé•¿åº¦ä»å°åˆ°å¤§å­˜æ”¾æ‰€æœ‰çº¿æ®µ
    pq TreeSet
    N int
}

func Constructor(N int) ExamRoom {
    s := make(map[int][]int)
    e := make(map[int][]int)
    pq := newSTreeSet(func(a, b []int) int {
        distA := distance(a)
        distB := distance(b)
        if distA == distB {
            return b[0] - a[0]
        }
        return distA - distB
    })
    addInterval := func(intv []int) {
        pq.add(intv)
        s[intv[0]] = intv
        e[intv[1]] = intv
    }
    removeInterval := func(intv []int) {
        pq.remove(intv)
        delete(s, intv[0])
        delete(e, intv[1])
    }
    
    addInterval([]int{-1, N})
    return ExamRoom{startMap: s, endMap: e, pq: pq, N: N}
}

func (this *ExamRoom) Seat() int {
    longest := this.pq.last()
    x, y := longest[0], longest[1]
    var seat int
    if x == -1 { // æƒ…å†µä¸€
        seat = 0
    } else if y == this.N { // æƒ…å†µäºŒ
        seat = this.N - 1
    } else { // æƒ…å†µä¸‰
        seat = (y - x) / 2 + x
    }
    left := []int{x, seat}
    right := []int{seat, y}
    removeInterval := func() {
        this.pq.remove(longest)
        delete(this.startMap, longest[0])
        delete(this.endMap, longest[1])
    }
    removeInterval()
    addInterval(left)
    addInterval(right)
    return seat
}

func (this *ExamRoom) Leave(p int)  {
    right, left := this.startMap[p], this.endMap[p]
    merged := []int{left[0], right[1]}
    removeInterval := func(intv []int) {
        this.pq.remove(intv)
        delete(this.startMap, intv[0])
        delete(this.endMap, intv[1])
    }
    removeInterval(left)
    removeInterval(right)
    addInterval(merged)
}

/* è®¡ç®—ä¸€ä¸ªçº¿æ®µçš„é•¿åº¦ */
func distance(intv []int) int {
    x, y := intv[0], intv[1]
    if x == -1 {
        return y
    }
    if y == N {
        return N - 1 - x
    }
    return (y - x) / 2
}

type lambdaHeap struct {
    less func(i, j []int) bool
    pq   [][]int
}

func (h lambdaHeap) Len() int { return len(h.pq) }
func (h lambdaHeap) Less(i, j int) bool {
    return h.less(h.pq[i], h.pq[j])
}
func (h lambdaHeap) Swap(i, j int) {
    h.pq[i], h.pq[j] = h.pq[j], h.pq[i]
}
func (h *lambdaHeap) Push(x interface{}) {
    h.pq = append(h.pq, x.([]int))
}
func (h *lambdaHeap) Pop() interface{} {
    n := len(h.pq)
    x := h.pq[n-1]
    h.pq = h.pq[:n-1]
    return x
}

type TreeSet struct {
    less func(i, j []int) int
    heap lambdaHeap
}

func newSTreeSet(f func(i, j []int) int) TreeSet {
    h := lambdaHeap{less: func(i, j []int) bool {
        return f(i, j) < 0
    }}
    return TreeSet{less: f, heap: h}
}

func (t TreeSet) resize(n int) {
    pq := lambdaHeap{less: t.heap.less, pq: make([][]int, n)}
    copy(pq.pq, t.heap.pq)
    t.heap = pq
}

func (t *TreeSet) add(x []int) {
    t.heap.Push(x)
    if len(t.heap.pq) > (cap(t.heap.pq) >> 1) {
        t.resize(len(t.heap.pq) << 1)
    }
    for i, j := len(t.heap.pq)-1, (len(t.heap.pq)-2)>>1; i > 0 && t.heap.Less(i, j); i, j = j, (j-1)>>1 {
        t.heap.Swap(i, j)
    }
}

func (t *TreeSet) find(x []int) int {
    l, r := 0, len(t.heap.pq)-1
    less := t.less(x, t.heap.pq[0])
    if less < 0 {
        return -1
    } else if less == 0 {
        return 0
    }
    for l < r {
        mid := (l + r) >> 1
        if t.less(x, t.heap.pq[mid]) < 0 {
            r = mid
        } else {
            l = mid + 1
        }
    }
    return l
}

func (t *TreeSet) remove(x []int) {
    i := t.find(x)
    if i == -1 {
        return
    }
    t.heap.Swap(i, len(t.heap.pq)-1)
    t.heap.pq = t.heap.pq[:len(t.heap.pq)-1]
    for i < len(t.heap.pq) {
        left, right := (i<<1)|1, (i+1)<<1
        if left >= len(t.heap.pq) {
            break
        }
        k := left
        if right < len(t.heap.pq) && t.heap.Less(right, left) {
            k = right
        }
        if !t.heap.Less(k, i) {
            break
        }
        t.heap.Swap(i, k)
        i = k
    }
}
```

```java
// by labuladong (java)
class ExamRoom {
    // å°†ç«¯ç‚¹ p æ˜ å°„åˆ°ä»¥ p ä¸ºå·¦ç«¯ç‚¹çš„çº¿æ®µ
    private Map<Integer, int[]> startMap;
    // å°†ç«¯ç‚¹ p æ˜ å°„åˆ°ä»¥ p ä¸ºå³ç«¯ç‚¹çš„çº¿æ®µ
    private Map<Integer, int[]> endMap;
    // æ ¹æ®çº¿æ®µé•¿åº¦ä»å°åˆ°å¤§å­˜æ”¾æ‰€æœ‰çº¿æ®µ
    private TreeSet<int[]> pq;
    private int N;

    public ExamRoom(int N) {
        this.N = N;
        startMap = new HashMap<>();
        endMap = new HashMap<>();
        pq = new TreeSet<>((a, b) -> {
            int distA = distance(a);
            int distB = distance(b);
            // å¦‚æœé•¿åº¦ç›¸åŒï¼Œå°±æ¯”è¾ƒç´¢å¼•
            if (distA == distB)
                return b[0] - a[0];
            return distA - distB;
        });
        // åœ¨æœ‰åºé›†åˆä¸­å…ˆæ”¾ä¸€ä¸ªè™šæ‹Ÿçº¿æ®µ
        addInterval(new int[]{-1, N});
    }

    public int seat() {
        // ä»æœ‰åºé›†åˆæ‹¿å‡ºæœ€é•¿çš„çº¿æ®µ
        int[] longest = pq.last();
        int x = longest[0];
        int y = longest[1];
        int seat;
        if (x == -1) { // æƒ…å†µä¸€
            seat = 0;
        } else if (y == N) { // æƒ…å†µäºŒ
            seat = N - 1;
        } else { // æƒ…å†µä¸‰
            seat = (y - x) / 2 + x;
        }
        // å°†æœ€é•¿çš„çº¿æ®µåˆ†æˆä¸¤æ®µ
        int[] left = new int[]{x, seat};
        int[] right = new int[]{seat, y};
        removeInterval(longest);
        addInterval(left);
        addInterval(right);
        return seat;
    }

    public void leave(int p) {
        // å°† p å·¦å³çš„çº¿æ®µæ‰¾å‡ºæ¥
        int[] right = startMap.get(p);
        int[] left = endMap.get(p);
        // åˆå¹¶ä¸¤ä¸ªçº¿æ®µæˆä¸ºä¸€ä¸ªçº¿æ®µ
        int[] merged = new int[]{left[0], right[1]};
        removeInterval(left);
        removeInterval(right);
        addInterval(merged);
    }


    /* å¢åŠ ä¸€ä¸ªçº¿æ®µ */
    private void addInterval(int[] intv) {
        pq.add(intv);
        startMap.put(intv[0], intv);
        endMap.put(intv[1], intv);
    }

    /* å»é™¤ä¸€ä¸ªçº¿æ®µ */
    private void removeInterval(int[] intv) {
        pq.remove(intv);
        startMap.remove(intv[0]);
        endMap.remove(intv[1]);
    }

    /* è®¡ç®—ä¸€ä¸ªçº¿æ®µçš„é•¿åº¦ */
    private int distance(int[] intv) {
        int x = intv[0];
        int y = intv[1];
        if (x == -1) return y;
        if (y == N) return N - 1 - x;
        // ä¸­ç‚¹å’Œç«¯ç‚¹ä¹‹é—´çš„é•¿åº¦
        return (y - x) / 2;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} N
 */
var ExamRoom = function(N) {
    // å°†ç«¯ç‚¹ p æ˜ å°„åˆ°ä»¥ p ä¸ºå·¦ç«¯ç‚¹çš„çº¿æ®µ
    this.startMap = new Map();
    // å°†ç«¯ç‚¹ p æ˜ å°„åˆ°ä»¥ p ä¸ºå³ç«¯ç‚¹çš„çº¿æ®µ
    this.endMap = new Map();
    // æ ¹æ®çº¿æ®µé•¿åº¦ä»å°åˆ°å¤§å­˜æ”¾æ‰€æœ‰çº¿æ®µ
    this.pq = new TreeMap((a, b) => {
        let distA = this.distance(a);
        let distB = this.distance(b);
        // å¦‚æœé•¿åº¦ç›¸åŒï¼Œå°±æ¯”è¾ƒç´¢å¼•
        if (distA === distB) {
            return b[0] - a[0];
        }
        return distA - distB;
    });
    this.N = N;
    // åœ¨æœ‰åºé›†åˆä¸­å…ˆæ”¾ä¸€ä¸ªè™šæ‹Ÿçº¿æ®µ
    this.addInterval([-1, N]);
};

/**
 * @return {number}
 */
ExamRoom.prototype.seat = function() {
    // ä»æœ‰åºé›†åˆæ‹¿å‡ºæœ€é•¿çš„çº¿æ®µ
    let longest = this.pq.last();
    let x = longest[0];
    let y = longest[1];
    let seat;
    if (x === -1) { // æƒ…å†µä¸€
        seat = 0;
    } else if (y === this.N) { // æƒ…å†µäºŒ
        seat = this.N - 1;
    } else { // æƒ…å†µä¸‰
        seat = Math.floor((y - x) / 2) + x;
    }
    // å°†æœ€é•¿çš„çº¿æ®µåˆ†æˆä¸¤æ®µ
    let left = [x, seat];
    let right = [seat, y];
    this.removeInterval(longest);
    this.addInterval(left);
    this.addInterval(right);
    return seat;
};

/**
 * @param {number} p
 * @return {void}
 */
ExamRoom.prototype.leave = function(p) {
    // å°† p å·¦å³çš„çº¿æ®µæ‰¾å‡ºæ¥
    let right = this.startMap.get(p);
    let left = this.endMap.get(p);
    // åˆå¹¶ä¸¤ä¸ªçº¿æ®µæˆä¸ºä¸€ä¸ªçº¿æ®µ
    let merged = [left[0], right[1]];
    this.removeInterval(left);
    this.removeInterval(right);
    this.addInterval(merged);
};

/**
 * @param {number[]} intv
 * @return {void}
 */
ExamRoom.prototype.addInterval = function(intv) {
    this.pq.add(intv);
    this.startMap.set(intv[0], intv);
    this.endMap.set(intv[1], intv);
};

/**
 * @param {number[]} intv
 * @return {void}
 */
ExamRoom.prototype.removeInterval = function(intv) {
    this.pq.remove(intv);
    this.startMap.delete(intv[0]);
    this.endMap.delete(intv[1]);
};

/**
 * @param {number[]} intv
 * @return {number}
 */
ExamRoom.prototype.distance = function(intv) {
    let x = intv[0];
    let y = intv[1];
    if (x === -1) {
        return y;
    }
    if (y === this.N) {
        return this.N - 1 - x;
    }
    // ä¸­ç‚¹å’Œç«¯ç‚¹ä¹‹é—´çš„é•¿åº¦
    return Math.floor((y - x) / 2);
};
```

```python
# by chatGPT (python)
class ExamRoom:
    def __init__(self, N: int):
        self.N = N
        self.startMap = {}
        self.endMap = {}
        self.pq = [(self.distance([-1, self.N]), -1, self.N)]  # ä¸€ä¸ªå…ƒç»„ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºé•¿åº¦ï¼Œåä¸¤ä¸ªä¸ºåæ ‡
                                                               # æ‰€æœ‰çº¿æ®µå·²æŒ‰ç…§é•¿åº¦æ’åºï¼Œç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºæœ€å°é•¿åº¦
                                                               # è¡¨ç¤ºæœ€å¼€å§‹çš„è™šæ‹Ÿçº¿æ®µ
    def seat(self) -> int:
        # ä»ä¼˜å…ˆé˜Ÿåˆ—æ‹¿å‡ºé•¿åº¦æœ€å¤§çš„çº¿æ®µ
        dist, x, y = heapq.heappop(self.pq)
        if x == -1:     # è‹¥æœ€å¤§çº¿æ®µä¸ºè™šæ‹Ÿçº¿æ®µï¼Œç›´æ¥è¿”å›
            seat = 0
        elif y == self.N:
            seat = self.N - 1
        else:
            seat = (y - x) // 2 + x  # è®¡ç®—åº§ä½ä½ç½®
        # æŠŠæ–°çº¿æ®µåˆ†æˆä¸¤ä¸ªåŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—
        heapq.heappush(self.pq, (self.distance([x, seat]), x, seat))
        heapq.heappush(self.pq, (self.distance([seat, y]), seat, y))
        # æ›´æ–°ä¸¤ä¸ªæ˜ å°„
        self.startMap[seat] = [x, seat]
        self.endMap[seat] = [seat, y]
        return seat

    def leave(self, p: int) -> None:
        # ä»ä¸¤ä¸ªæ˜ å°„æ‰¾åˆ°å·¦å³çº¿æ®µï¼Œå¹¶å°†å®ƒä»¬åˆ é™¤
        left, right = self.startMap[p], self.endMap[p]
        del self.startMap[p], self.endMap[p]
        # ä»ä¼˜å…ˆé˜Ÿåˆ—ä¸­åˆ é™¤ä¸¤ä¸ªçº¿æ®µ
        self.pq.remove((self.distance(left), left[0], left[1]))
        self.pq.remove((self.distance(right), right[0], right[1]))
        # åˆå¹¶å·¦å³çº¿æ®µæˆä¸ºä¸€ä¸ªæ–°çš„çº¿æ®µ
        merged = [left[0], right[1]]
        heapq.heappush(self.pq, (self.distance(merged), merged[0], merged[1]))

    def distance(self, interval: List[int]) -> int:
        x, y = interval
        if x == -1: return y
        if y == self.N: return self.N - 1 - x
        return abs(y - x) // 2
```

https://leetcode.cn/problems/exam-room çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/factorial-trailing-zeroes çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int trailingZeroes(int n) {
        int res = 0;
        long long divisor = 5;
        while (divisor <= n) {
            res += n / divisor;
            divisor *= 5;
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func trailingZeroes(n int) int {
    res := 0
    divisor := int64(5)
    for divisor <= int64(n) {
        res += n / int(divisor)
        divisor *= 5
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int trailingZeroes(int n) {
        int res = 0;
        long divisor = 5;
        while (divisor <= n) {
            res += n / divisor;
            divisor *= 5;
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @return {number}
 */
var trailingZeroes = function(n) {
    let res = 0;
    let divisor = 5;
    while (divisor <= n) {
        res += Math.floor(n / divisor);
        divisor *= 5;
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def trailingZeroes(self, n: int) -> int:
        res = 0
        divisor = 5
        while divisor <= n:
            res += n // divisor
            divisor *= 5
        return res
```

https://leetcode.cn/problems/factorial-trailing-zeroes çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    string reverseWords(string s) {
        // å…ˆæ¸…æ´—ä¸€ä¸‹æ•°æ®ï¼ŒæŠŠå¤šäºçš„ç©ºæ ¼éƒ½åˆ æ‰
        string sb;
        for (int i = 0; i < s.length(); i++) {
            char c = s[i];
            if (c != ' ') {
                // å•è¯ä¸­çš„å­—æ¯/æ•°å­—
                sb += c;
            } else if (!sb.empty() && sb[sb.length() - 1] != ' ') {
                // å•è¯ä¹‹é—´ä¿ç•™ä¸€ä¸ªç©ºæ ¼
                sb += ' ';
            }
        }
        if (sb.empty()) {
            return "";
        }
        // æœ«å°¾å¦‚æœæœ‰ç©ºæ ¼ï¼Œæ¸…é™¤ä¹‹
        if (sb[sb.length() - 1] == ' ') {
            sb.erase(sb.length() - 1, 1);
        }

        // æ¸…æ´—ä¹‹åçš„å­—ç¬¦ä¸²
        char* chars = new char[sb.length() + 1];
        strcpy(chars, sb.c_str());
        int n = strlen(chars);
        // è¿›è¡Œå•è¯çš„ç¿»è½¬ï¼Œå…ˆæ•´ä½“ç¿»è½¬
        reverse(chars, 0, n - 1);
        // å†æŠŠæ¯ä¸ªå•è¯ç¿»è½¬
        for (int i = 0; i < n; ) {
            for (int j = i; j < n; j++) {
                if (j + 1 == n || chars[j + 1] == ' ') {
                    // chars[i..j] æ˜¯ä¸€ä¸ªå•è¯ï¼Œç¿»è½¬ä¹‹
                    reverse(chars, i, j);
                    // æŠŠ i ç½®ä¸ºä¸‹ä¸€ä¸ªå•è¯çš„é¦–å­—æ¯
                    i = j + 2;
                    break;
                }
            }
        }
        // æœ€åå¾—åˆ°é¢˜ç›®æƒ³è¦çš„ç»“æœ
        string res(chars);
        delete[] chars;
        return res;
    }

    // ç¿»è½¬ arr[i..j]
    void reverse(char* arr, int i, int j) {
        while (i < j) {
            char temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
};
```

```go
// by chatGPT (go)
func reverseWords(s string) string {
    var sb strings.Builder
    // å…ˆæ¸…æ´—ä¸€ä¸‹æ•°æ®ï¼ŒæŠŠå¤šä½™çš„ç©ºæ ¼éƒ½åˆ æ‰
    for i := 0; i < len(s); i++ {
        c := s[i]
        if c != ' ' {
            // å•è¯ä¸­çš„å­—æ¯/æ•°å­—
            sb.WriteByte(c)
        } else if sb.Len() > 0 && sb.String()[sb.Len()-1] != ' ' {
            // å•è¯ä¹‹é—´ä¿ç•™ä¸€ä¸ªç©ºæ ¼
            sb.WriteByte(' ')
        }
    }
    // æœ«å°¾å¦‚æœæœ‰ç©ºæ ¼ï¼Œæ¸…é™¤ä¹‹
    if sb.Len() > 0 && sb.String()[sb.Len()-1] == ' ' {
        sb.Truncate(sb.Len() - 1)
    }

    // æ¸…æ´—ä¹‹åçš„å­—ç¬¦ä¸²
    chars := []byte(sb.String())
    n := len(chars)
    // è¿›è¡Œå•è¯çš„ç¿»è½¬ï¼Œå…ˆæ•´ä½“ç¿»è½¬
    reverse := func(arr []byte, i int, j int) {
        for i < j {
            arr[i], arr[j] = arr[j], arr[i]
            i++
            j--
        }
    }
    reverse(chars, 0, n-1)
    // å†æŠŠæ¯ä¸ªå•è¯ç¿»è½¬
    for i := 0; i < n; {
        for j := i; j < n; j++ {
            if j+1 == n || chars[j+1] == ' ' {
                // chars[i..j] æ˜¯ä¸€ä¸ªå•è¯ï¼Œç¿»è½¬ä¹‹
                reverse(chars, i, j)
                // æŠŠ i ç½®ä¸ºä¸‹ä¸€ä¸ªå•è¯çš„é¦–å­—æ¯
                i = j + 2
                break
            }
        }
    }
    // æœ€åå¾—åˆ°é¢˜ç›®æƒ³è¦çš„ç»“æœ
    return string(chars)
}
```

```java
// by labuladong (java)
class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = new StringBuilder();
        // å…ˆæ¸…æ´—ä¸€ä¸‹æ•°æ®ï¼ŒæŠŠå¤šäºçš„ç©ºæ ¼éƒ½åˆ æ‰
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c != ' ') {
                // å•è¯ä¸­çš„å­—æ¯/æ•°å­—
                sb.append(c);
            } else if (!sb.isEmpty() && sb.charAt(sb.length() - 1) != ' ') {
                // å•è¯ä¹‹é—´ä¿ç•™ä¸€ä¸ªç©ºæ ¼
                sb.append(' ');
            }
        }
        if (sb.isEmpty()) {
            return "";
        }
        // æœ«å°¾å¦‚æœæœ‰ç©ºæ ¼ï¼Œæ¸…é™¤ä¹‹
        if (sb.charAt(sb.length() - 1) == ' ') {
            sb.deleteCharAt(sb.length() - 1);
        }

        // æ¸…æ´—ä¹‹åçš„å­—ç¬¦ä¸²
        char[] chars = sb.toString().toCharArray();
        int n = chars.length;
        // è¿›è¡Œå•è¯çš„ç¿»è½¬ï¼Œå…ˆæ•´ä½“ç¿»è½¬
        reverse(chars, 0, n - 1);
        // å†æŠŠæ¯ä¸ªå•è¯ç¿»è½¬
        for (int i = 0; i < n; ) {
            for (int j = i; j < n; j++) {
                if (j + 1 == n || chars[j + 1] == ' ') {
                    // chars[i..j] æ˜¯ä¸€ä¸ªå•è¯ï¼Œç¿»è½¬ä¹‹
                    reverse(chars, i, j);
                    // æŠŠ i ç½®ä¸ºä¸‹ä¸€ä¸ªå•è¯çš„é¦–å­—æ¯
                    i = j + 2;
                    break;
                }
            }
        }
        // æœ€åå¾—åˆ°é¢˜ç›®æƒ³è¦çš„ç»“æœ
        return new String(chars);
    }

    // ç¿»è½¬ arr[i..j]
    void reverse(char[] arr, int i, int j) {
        while (i < j) {
            char temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  let sb = "";
  // å…ˆæ¸…æ´—ä¸€ä¸‹æ•°æ®ï¼ŒæŠŠå¤šäºçš„ç©ºæ ¼éƒ½åˆ æ‰
  for (let i = 0; i < s.length; i++) {
    let c = s.charAt(i);
    if (c !== ' ') {
      // å•è¯ä¸­çš„å­—æ¯/æ•°å­—
      sb += c;
    } else if (sb.length > 0 && sb.charAt(sb.length - 1) !== ' ') {
      // å•è¯ä¹‹é—´ä¿ç•™ä¸€ä¸ªç©ºæ ¼
      sb += ' ';
    }
  }
  // æœ«å°¾å¦‚æœæœ‰ç©ºæ ¼ï¼Œæ¸…é™¤ä¹‹
  if (sb.charAt(sb.length - 1) === ' ') {
    sb = sb.slice(0, sb.length - 1);
  }

  // æ¸…æ´—ä¹‹åçš„å­—ç¬¦ä¸²
  let chars = sb.split('');
  let n = chars.length;
  // è¿›è¡Œå•è¯çš„ç¿»è½¬ï¼Œå…ˆæ•´ä½“ç¿»è½¬
  reverse(chars, 0, n - 1);
  // å†æŠŠæ¯ä¸ªå•è¯ç¿»è½¬
  for (let i = 0; i < n; ) {
    for (let j = i; j < n; j++) {
      if (j + 1 === n || chars[j + 1] === ' ') {
        // chars[i..j] æ˜¯ä¸€ä¸ªå•è¯ï¼Œç¿»è½¬ä¹‹
        reverse(chars, i, j);
        // æŠŠ i ç½®ä¸ºä¸‹ä¸€ä¸ªå•è¯çš„é¦–å­—æ¯
        i = j + 2;
        break;
      }
    }
  }
  // æœ€åå¾—åˆ°é¢˜ç›®æƒ³è¦çš„ç»“æœ
  return chars.join('');
};

// ç¿»è½¬ arr[i..j]
function reverse(arr, i, j) {
  while (i < j) {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
    i++;
    j--;
  }
}
```

```python
# by chatGPT (python)
class Solution:
    def reverseWords(self, s: str) -> str:
        # å…ˆæ¸…æ´—ä¸€ä¸‹æ•°æ®ï¼ŒæŠŠå¤šäºçš„ç©ºæ ¼éƒ½åˆ æ‰
        sb = []
        for c in s:
            if c != ' ':
                # å•è¯ä¸­çš„å­—æ¯/æ•°å­—
                sb.append(c)
            elif sb and sb[-1] != ' ':
                # å•è¯ä¹‹é—´ä¿ç•™ä¸€ä¸ªç©ºæ ¼
                sb.append(' ')
        if not sb:
            return ""
        # æœ«å°¾å¦‚æœæœ‰ç©ºæ ¼ï¼Œæ¸…é™¤ä¹‹
        if sb[-1] == ' ':
            sb.pop()

        # æ¸…æ´—ä¹‹åçš„å­—ç¬¦ä¸²
        chars = ''.join(sb)
        chars = list(chars)
        n = len(chars)
        # è¿›è¡Œå•è¯çš„ç¿»è½¬ï¼Œå…ˆæ•´ä½“ç¿»è½¬
        self.reverse(chars, 0, n - 1)
        # å†æŠŠæ¯ä¸ªå•è¯ç¿»è½¬
        i = 0
        while i < n:
            j = i
            while j < n:
                if j + 1 == n or chars[j + 1] == ' ':
                    # chars[i..j] æ˜¯ä¸€ä¸ªå•è¯ï¼Œç¿»è½¬ä¹‹
                    self.reverse(chars, i, j)
                    # æŠŠ i ç½®ä¸ºä¸‹ä¸€ä¸ªå•è¯çš„é¦–å­—æ¯
                    i = j + 2
                    break
                j += 1
        # æœ€åå¾—åˆ°é¢˜ç›®æƒ³è¦çš„ç»“æœ
        return ''.join(chars)

    # ç¿»è½¬ arr[i..j]
    def reverse(self, arr, i, j):
        while i < j:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
            j -= 1
```

https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // å¦‚æœé“¾è¡¨ä¸ºç©ºæˆ–åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåˆ™ç›´æ¥è¿”å›è¯¥é“¾è¡¨
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        ListNode* last = nullptr;
        // å¼€å§‹è¿­ä»£ç¿»è½¬èŠ‚ç‚¹
        while (head != nullptr) {
            // å…ˆä¿å­˜å½“å‰èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹
            ListNode* next = head->next;
            // å°†å½“å‰èŠ‚ç‚¹çš„æŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹
            head->next = last;
            // æ›´æ–°å‰ä¸€ä¸ªèŠ‚ç‚¹ä¸ºå½“å‰èŠ‚ç‚¹
            last = head;
            // æ›´æ–°å½“å‰èŠ‚ç‚¹ä¸ºåç»§èŠ‚ç‚¹
            head = next;
        }
        // ç¿»è½¬é“¾è¡¨å®Œæˆï¼Œè¿”å›å¤´èŠ‚ç‚¹
        return last;
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */

func reverseList(head *ListNode) *ListNode {
    // å¦‚æœé“¾è¡¨ä¸ºç©ºæˆ–è€…é“¾è¡¨åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›head
    if head == nil || head.Next == nil {
        return head
    }
    // é€’å½’å¤„ç†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    last := reverseList(head.Next)
    // å¯¹äºå½“å‰èŠ‚ç‚¹ï¼š
    // åŸæ¥æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆåè½¬æŒ‡å‘ä¸Šä¸€ä¸ªèŠ‚ç‚¹
    head.Next.Next = head
    // åŸæ¥æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆæŒ‡å‘nil
    head.Next = nil
    // è¿”å›é“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œå³åè½¬åé“¾è¡¨çš„å¤´èŠ‚ç‚¹
    return last
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode last = reverseList(head.next);
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/3.jpg)
        */
        head.next.next = head;
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/4.jpg)
        */
        head.next = null;
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/5.jpg)
        */
        return last;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  if (head === null || head.next === null) {
    return head;
  }
  var last = reverseList(head.next);
  /**<extend up -200>
  ![](../pictures/åè½¬é“¾è¡¨/3.jpg)
  */
  head.next.next = head;
  /**<extend up -200>
  ![](../pictures/åè½¬é“¾è¡¨/4.jpg)
  */
  head.next = null;
  /**<extend up -200>
  ![](../pictures/åè½¬é“¾è¡¨/5.jpg)
  */
  return last;
};
```

```python
# by chatGPT (python)
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # å¦‚æœé“¾è¡¨ä¸ºç©ºæˆ–é“¾è¡¨åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œåˆ™ç›´æ¥è¿”å›head
        if head == None or head.next==None:
            return head
        # é€’å½’åè½¬é“¾è¡¨åé¢çš„éƒ¨åˆ†
        last = self.reverseList(head.next)
        """
        åè½¬ä¹‹å‰çš„é“¾è¡¨
        head      --> 3 --> 4 --> 5 --> null
        last      --> 5 --> null
        """
        # å°†é“¾è¡¨çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„åç»§æŒ‡é’ˆæŒ‡å‘å½“å‰èŠ‚ç‚¹
        head.next.next = head
        """
        åè½¬ä¹‹åçš„é“¾è¡¨
        last      --> 5 --> 4 --> 3 --> null
                          â†‘
        head      --> 4 ---â”˜
        """
        # å°†å½“å‰èŠ‚ç‚¹çš„åç»§æŒ‡é’ˆæŒ‡å‘null
        head.next = None
        """
        åè½¬ä¹‹åçš„é“¾è¡¨
        last      --> 5 --> 4 --> 3 --> null
        head      --> null
        """
        # è¿”å›åè½¬åçš„é“¾è¡¨
        return last
```

https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int fib(int n) {
        if (n == 0 || n == 1) {
            // base case
            return n;
        }
        int Q = 1000000007;
        // åˆ†åˆ«ä»£è¡¨ dp[i - 1] å’Œ dp[i - 2]
        int dp_i_1 = 1, dp_i_2 = 0;
        for (int i = 2; i <= n; i++) {
            // dp[i] = dp[i - 1] + dp[i - 2];
            int dp_i = (dp_i_1 % Q + dp_i_2 % Q) % Q;
            dp_i_2 = dp_i_1;
            dp_i_1 = dp_i;
        }
        return dp_i_1;
    }
};
```

```go
// by chatGPT (go)
func fib(n int) int {
    if n == 0 || n == 1 {
        // base case
        return n
    }
    Q := 1000000007
    // åˆ†åˆ«ä»£è¡¨ dp[i - 1] å’Œ dp[i - 2]
    dp_i_1, dp_i_2 := 1, 0
    for i := 2; i <= n; i++ {
        // dp[i] = dp[i - 1] + dp[i - 2];
        dp_i := (dp_i_1 % Q + dp_i_2 % Q) % Q
        dp_i_2 = dp_i_1
        dp_i_1 = dp_i
    }
    return dp_i_1
}
```

```java
// by labuladong (java)
class Solution {
    public int fib(int n) {
        if (n == 0 || n == 1) {
            // base case
            return n;
        }
        int Q = 1000000007;
        // åˆ†åˆ«ä»£è¡¨ dp[i - 1] å’Œ dp[i - 2]
        int dp_i_1 = 1, dp_i_2 = 0;
        for (int i = 2; i <= n; i++) {
            // dp[i] = dp[i - 1] + dp[i - 2];
            int dp_i = (dp_i_1 % Q + dp_i_2 % Q) % Q;
            dp_i_2 = dp_i_1;
            dp_i_1 = dp_i;
        }
        return dp_i_1;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    if (n === 0 || n === 1) {
        // base case
        return n;
    }
    const Q = 1000000007;
    // åˆ†åˆ«ä»£è¡¨ dp[i - 1] å’Œ dp[i - 2]
    let dp_i_1 = 1, dp_i_2 = 0;
    for (let i = 2; i <= n; i++) {
        // dp[i] = dp[i - 1] + dp[i - 2];
        const dp_i = (dp_i_1 % Q + dp_i_2 % Q) % Q;
        dp_i_2 = dp_i_1;
        dp_i_1 = dp_i;
    }
    return dp_i_1;
};
```

```python
# by chatGPT (python)
class Solution:
    def fib(self, n: int) -> int:
        if n == 0 or n == 1:
            # base case
            return n
        Q = 1000000007
        # åˆ†åˆ«ä»£è¡¨ dp[i - 1] å’Œ dp[i - 2]
        dp_i_1, dp_i_2 = 1, 0
        for i in range(2, n + 1):
            # dp[i] = dp[i - 1] + dp[i - 2];
            dp_i = (dp_i_1 % Q + dp_i_2 % Q) % Q
            dp_i_2 = dp_i_1
            dp_i_1 = dp_i
        return dp_i_1
```

https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/fibonacci-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int fib(int n) {
        if (n == 0 || n == 1) {
            // base case
            return n;
        }
        // åˆ†åˆ«ä»£è¡¨ dp[i - 1] å’Œ dp[i - 2]
        int dp_i_1 = 1, dp_i_2 = 0;
        for (int i = 2; i <= n; i++) {
            // dp[i] = dp[i - 1] + dp[i - 2];
            int dp_i = dp_i_1 + dp_i_2;
            dp_i_2 = dp_i_1;
            dp_i_1 = dp_i;
        }
        return dp_i_1;
    }
};
```

```go
// by chatGPT (go)
func fib(n int) int {
    if n == 0 || n == 1 {
        // base case
        return n
    }
    // åˆ†åˆ«ä»£è¡¨ dp[i - 1] å’Œ dp[i - 2]
    dp_i_1, dp_i_2 := 1, 0
    for i := 2; i <= n; i++ {
        // dp[i] = dp[i - 1] + dp[i - 2];
        dp_i := dp_i_1 + dp_i_2
        dp_i_2 = dp_i_1
        dp_i_1 = dp_i
    }
    return dp_i_1
}
```

```java
// by labuladong (java)
class Solution {
    public int fib(int n) {
        if (n == 0 || n == 1) {
            // base case
            return n;
        }
        // åˆ†åˆ«ä»£è¡¨ dp[i - 1] å’Œ dp[i - 2]
        int dp_i_1 = 1, dp_i_2 = 0;
        for (int i = 2; i <= n; i++) {
            // dp[i] = dp[i - 1] + dp[i - 2];
            int dp_i = dp_i_1 + dp_i_2;
            dp_i_2 = dp_i_1;
            dp_i_1 = dp_i;
        }
        return dp_i_1;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    if (n === 0 || n === 1) {
        // base case
        return n;
    }
    // åˆ†åˆ«ä»£è¡¨ dp[i - 1] å’Œ dp[i - 2]
    let dp_i_1 = 1, dp_i_2 = 0;
    for (let i = 2; i <= n; i++) {
        // dp[i] = dp[i - 1] + dp[i - 2];
        const dp_i = dp_i_1 + dp_i_2;
        dp_i_2 = dp_i_1;
        dp_i_1 = dp_i;
    }
    return dp_i_1;
};
```

```python
# by chatGPT (python)
class Solution:
    def fib(self, n: int) -> int:
        if n == 0 or n == 1:
            # base case
            return n
        # åˆ†åˆ«ä»£è¡¨ dp[i - 1] å’Œ dp[i - 2]
        dp_i_1, dp_i_2 = 1, 0
        for i in range(2, n+1):
            # dp[i] = dp[i - 1] + dp[i - 2];
            dp_i = dp_i_1 + dp_i_2
            dp_i_2 = dp_i_1
            dp_i_1 = dp_i
        return dp_i_1
```

https://leetcode.cn/problems/fibonacci-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/find-all-anagrams-in-a-string çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    vector<int> findAnagrams(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;

        int left = 0, right = 0;
        int valid = 0;
        vector<int> res; // è®°å½•ç»“æœ
        while (right < s.size()) {
            char c = s[right];
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c])
                    valid++;
            }
            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (right - left >= t.size()) {
                // å½“çª—å£ç¬¦åˆæ¡ä»¶æ—¶ï¼ŒæŠŠèµ·å§‹ç´¢å¼•åŠ å…¥ res
                if (valid == need.size())
                    res.push_back(left);
                char d = s[left];
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func findAnagrams(s string, t string) []int {
    need := make(map[byte]int)
    window := make(map[byte]int)
    for i := 0; i < len(t); i++ {
        need[t[i]]++
    }

    left, right := 0, 0
    valid := 0
    var res []int
    for right < len(s) {
        c := s[right]
        right++
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        if _, ok := need[c]; ok {
            window[c]++
            if window[c] == need[c] {
                valid++
            }
        }
        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        for right - left >= len(t) {
            // å½“çª—å£ç¬¦åˆæ¡ä»¶æ—¶ï¼ŒæŠŠèµ·å§‹ç´¢å¼•åŠ å…¥ res
            if valid == len(need) {
                res = append(res, left)
            }
            d := s[left]
            left++
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if _, ok := need[d]; ok {
                if window[d] == need[d] {
                    valid--
                }
                window[d]--
            }
        }
    }
    return res
}
```

```java
// by chatGPT (java)
class Solution {
    public List<Integer> findAnagrams(String s, String t) {
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);

        int left = 0, right = 0;
        int valid = 0;
        List<Integer> res = new ArrayList<>();
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c).equals(need.get(c)))
                    valid++;
            }
            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (right - left >= t.length()) {
                // å½“çª—å£ç¬¦åˆæ¡ä»¶æ—¶ï¼ŒæŠŠèµ·å§‹ç´¢å¼•åŠ å…¥ res
                if (valid == need.size())
                    res.add(left);
                char d = s.charAt(left);
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if (need.containsKey(d)) {
                    if (window.get(d).equals(need.get(d)))
                        valid--;
                    window.put(d, window.get(d) - 1);
                }
            }
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {string} s
 * @param {string} t
 * @return {number[]}
 */
var findAnagrams = function(s, t) {
    const need = new Map();
    const window = new Map();
    for (const c of t) {
        need.set(c, (need.get(c) || 0) + 1);
    }

    let left = 0, right = 0;
    let valid = 0;
    const res = [];

    while (right < s.length) {
        const c = s[right];
        right++;
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        if (need.has(c)) {
            window.set(c, (window.get(c) || 0) + 1);
            if (window.get(c) === need.get(c)) {
                valid++;
            }
        }
        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        while (right - left >= t.length) {
            // å½“çª—å£ç¬¦åˆæ¡ä»¶æ—¶ï¼ŒæŠŠèµ·å§‹ç´¢å¼•åŠ å…¥ res
            if (valid === need.size) {
                res.push(left);
            }
            const d = s[left];
            left++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.has(d)) {
                if (window.get(d) === need.get(d)) {
                    valid--;
                }
                window.set(d, window.get(d) - 1);
            }
        }
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def findAnagrams(self, s: str, t: str) -> List[int]:
        need = {}
        window = {}
        for c in t:
            if c in need:
                need[c] += 1
            else:
                need[c] = 1

        left = 0
        right = 0
        valid = 0
        res = []
        
        while right < len(s):
            c = s[right]
            right += 1
            # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if c in need:
                if c in window:
                    window[c] += 1
                else:
                    window[c] = 1
                if window[c] == need[c]:
                    valid += 1
            # åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while right - left >= len(t):
                # å½“çª—å£ç¬¦åˆæ¡ä»¶æ—¶ï¼ŒæŠŠèµ·å§‹ç´¢å¼•åŠ å…¥ res
                if valid == len(need):
                    res.append(left)
                d = s[left]
                left += 1
                # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if d in need:
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1

        return res
```

https://leetcode.cn/problems/find-all-anagrams-in-a-string çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/find-all-duplicates-in-an-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        int n = nums.size();
        vector<int> res;
        // ç”¨æ•°ç»„æ¨¡æ‹Ÿå“ˆå¸Œé›†åˆ
        vector<int> seen(n + 1);
        for (int num : nums) {
            if (seen[num] == 0) {
                // æ·»åŠ åˆ°å“ˆå¸Œé›†åˆ
                seen[num] = 1;
            } else {
                // æ‰¾åˆ°é‡å¤å…ƒç´ 
                res.push_back(num);
            }
        }
        return res;
    }
};

class Solution2 {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> res;
        for (int num : nums) {
            // æ³¨æ„ç´¢å¼•ï¼Œå…ƒç´ å¤§å°ä» 1 å¼€å§‹ï¼Œæœ‰ä¸€ä½ç´¢å¼•åç§»
            if (nums[abs(num) - 1] < 0) {
                // ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
                // è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡
                res.push_back(abs(num));
            } else {
                // æŠŠç´¢å¼• num - 1 ç½®ä¸ºè´Ÿæ•°
                nums[abs(num) - 1] *= -1;
            }
        }

        return res;
    }
};
```

```go
// by chatGPT (go)
func findDuplicates(nums []int) []int {
    n := len(nums)
    res := make([]int, 0)
    // ç”¨æ•°ç»„æ¨¡æ‹Ÿå“ˆå¸Œé›†åˆ
    seen := make([]int, n+1)
    for _, num := range nums {
        if seen[num] == 0 {
            // æ·»åŠ åˆ°å“ˆå¸Œé›†åˆ
            seen[num] = 1
        } else {
            // æ‰¾åˆ°é‡å¤å…ƒç´ 
            res = append(res, num)
        }
    }
    return res
}

func findDuplicates2(nums []int) []int {
    res := make([]int, 0)
    for _, num := range nums {
        // æ³¨æ„ç´¢å¼•ï¼Œå…ƒç´ å¤§å°ä» 1 å¼€å§‹ï¼Œæœ‰ä¸€ä½ç´¢å¼•åç§»
        if nums[abs(num)-1] < 0 {
            // ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
            // è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡
            res = append(res, abs(num))
        } else {
            // æŠŠç´¢å¼• num - 1 ç½®ä¸ºè´Ÿæ•°
            nums[abs(num)-1] *= -1
        }
    }

    return res
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```

```java
// by labuladong (java)
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        int n = nums.length;
        List<Integer> res = new LinkedList<>();
        // ç”¨æ•°ç»„æ¨¡æ‹Ÿå“ˆå¸Œé›†åˆ
        int[] seen = new int[n + 1];
        for (int num : nums) {
            if (seen[num] == 0) {
                // æ·»åŠ åˆ°å“ˆå¸Œé›†åˆ
                seen[num] = 1;
            } else {
                // æ‰¾åˆ°é‡å¤å…ƒç´ 
                res.add(num);
            }
        }
        return res;
    }
}

class Solution2 {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> res = new LinkedList<>();
        for (int num : nums) {
            // æ³¨æ„ç´¢å¼•ï¼Œnums ä¸­å…ƒç´ å¤§å°ä» 1 å¼€å§‹ï¼Œ
            // è€Œç´¢å¼•æ˜¯ä» 0 å¼€å§‹çš„ï¼Œæ‰€ä»¥æœ‰ä¸€ä½ç´¢å¼•åç§»
            if (nums[Math.abs(num) - 1] < 0) {
                // ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
                // è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡
                res.add(Math.abs(num));
            } else {
                // æŠŠç´¢å¼• num - 1 ç½®ä¸ºè´Ÿæ•°
                nums[Math.abs(num) - 1] *= -1;
            }
        }

        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var findDuplicates = function(nums) {
    const n = nums.length;
    const res = [];
    // ç”¨æ•°ç»„æ¨¡æ‹Ÿå“ˆå¸Œé›†åˆ
    const seen = new Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        const num = nums[i];
        if (seen[num] === 0) {
            // æ·»åŠ åˆ°å“ˆå¸Œé›†åˆ
            seen[num] = 1;
        } else {
            // æ‰¾åˆ°é‡å¤å…ƒç´ 
            res.push(num);
        }
    }
    return res;
};

var findDuplicates2 = function(nums) {
    const res = [];
    for (let i = 0; i < nums.length; i++) {
        const num = Math.abs(nums[i]);
        // æ³¨æ„ç´¢å¼•ï¼Œå…ƒç´ å¤§å°ä» 1 å¼€å§‹ï¼Œæœ‰ä¸€ä½ç´¢å¼•åç§»
        if (nums[num - 1] < 0) {
            // ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
            // è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡
            res.push(num);
        } else {
            // æŠŠç´¢å¼• num - 1 ç½®ä¸ºè´Ÿæ•°
            nums[num - 1] *= -1;
        }
    }

    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = []
        # ç”¨æ•°ç»„æ¨¡æ‹Ÿå“ˆå¸Œé›†åˆ
        seen = [0] * (n + 1)
        for num in nums:
            if seen[num] == 0:
                # æ·»åŠ åˆ°å“ˆå¸Œé›†åˆ
                seen[num] = 1
            else:
                # æ‰¾åˆ°é‡å¤å…ƒç´ 
                res.append(num)
        return res


class Solution2:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            # æ³¨æ„ç´¢å¼•ï¼Œå…ƒç´ å¤§å°ä» 1 å¼€å§‹ï¼Œæœ‰ä¸€ä½ç´¢å¼•åç§»
            if nums[abs(num) - 1] < 0:
                # ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
                # è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡
                res.append(abs(num))
            else:
                # æŠŠç´¢å¼• num - 1 ç½®ä¸ºè´Ÿæ•°
                nums[abs(num) - 1] *= -1
        return res
```

https://leetcode.cn/problems/find-all-duplicates-in-an-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        vector<int> count(n + 1, 0);
        for (int num : nums) {
            count[num]++;
        }
        vector<int> res;
        for (int num = 1; num <= n; num++) {
            if (count[num] == 0) {
                res.push_back(num);
            }
        }
        return res;
    }
};

class Solution2 {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        for (int num : nums) {
            // æ³¨æ„ç´¢å¼•ï¼Œå…ƒç´ å¤§å°ä» 1 å¼€å§‹ï¼Œæœ‰ä¸€ä½ç´¢å¼•åç§»
            if (nums[abs(num) - 1] < 0) {
                // ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
                // è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡ï¼Œä½†æˆ‘ä»¬ä¸ç”¨åšï¼Œè®©ç´¢å¼•ç»§ç»­ä¿æŒè´Ÿæ•°
            } else {
                // æŠŠç´¢å¼• num - 1 ç½®ä¸ºè´Ÿæ•°
                nums[abs(num) - 1] *= -1;
            }
        }

        vector<int> res;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) {
                // è¯´æ˜æ²¡æœ‰å…ƒç´ å’Œè¿™ä¸ªç´¢å¼•å¯¹åº”ï¼Œå³æ‰¾åˆ°ä¸€ä¸ªç¼ºå¤±å…ƒç´ 
                res.push_back(i + 1);
            }
        }

        return res;
    }
};
```

```go
// by chatGPT (go)
func findDisappearedNumbers(nums []int) []int {
    n := len(nums)
    count := make([]int, n+1)
    for _, num := range nums {
        count[num]++
    }
    res := make([]int, 0)
    for num := 1; num <= n; num++ {
        if count[num] == 0 {
            res = append(res, num)
        }
    }
    return res
}


func findDisappearedNumbers2(nums []int) []int {
    for _, num := range nums {
        // æ³¨æ„ç´¢å¼•ï¼Œå…ƒç´ å¤§å°ä» 1 å¼€å§‹ï¼Œæœ‰ä¸€ä½ç´¢å¼•åç§»
        if nums[abs(num)-1] < 0 {
            // ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
            // è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡ï¼Œä½†æˆ‘ä»¬ä¸ç”¨åšï¼Œè®©ç´¢å¼•ç»§ç»­ä¿æŒè´Ÿæ•°
        } else {
            // æŠŠç´¢å¼• num - 1 ç½®ä¸ºè´Ÿæ•°
            nums[abs(num)-1] *= -1
        }
    }

    res := make([]int, 0)
    for i, num := range nums {
        if num > 0 {
            // è¯´æ˜æ²¡æœ‰å…ƒç´ å’Œè¿™ä¸ªç´¢å¼•å¯¹åº”ï¼Œå³æ‰¾åˆ°ä¸€ä¸ªç¼ºå¤±å…ƒç´ 
            res = append(res, i+1)
        }
    }

    return res
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}
```

```java
// by labuladong (java)
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        int[] count = new int[n + 1];
        for (int num : nums) {
            count[num]++;
        }
        List<Integer> res = new LinkedList<>();
        for (int num = 1; num <= n; num++) {
            if (count[num] == 0) {
                res.add(num);
            }
        }
        return res;
    }
}


class Solution2 {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        for (int num : nums) {
            // æ³¨æ„ç´¢å¼•ï¼Œnums ä¸­å…ƒç´ å¤§å°ä» 1 å¼€å§‹ï¼Œ
            // è€Œç´¢å¼•æ˜¯ä» 0 å¼€å§‹çš„ï¼Œæ‰€ä»¥æœ‰ä¸€ä½ç´¢å¼•åç§»
            if (nums[Math.abs(num) - 1] < 0) {
                // ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
                // è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡ï¼Œä½†æˆ‘ä»¬ä»€ä¹ˆéƒ½ä¸ç”¨åšï¼Œè®©ç´¢å¼•ç»§ç»­ä¿æŒè´Ÿæ•°
            } else {
                // æŠŠç´¢å¼• num - 1 ç½®ä¸ºè´Ÿæ•°
                nums[Math.abs(num) - 1] *= -1;
            }
        }

        List<Integer> res = new LinkedList<>();
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                // è¯´æ˜æ²¡æœ‰å…ƒç´ å’Œè¿™ä¸ªç´¢å¼•å¯¹åº”ï¼Œå³æ‰¾åˆ°ä¸€ä¸ªç¼ºå¤±å…ƒç´ 
                res.add(i + 1);
            }
        }

        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var findDisappearedNumbers = function(nums) {
    const n = nums.length;
    const count = new Array(n+1).fill(0);
    for (let i = 0; i < n; i++) {
        count[nums[i]]++;
    }
    const res = [];
    for (let i = 1; i <= n; i++) {
        if (count[i] === 0) {
            res.push(i);
        }
    }
    return res;
}

var findDisappearedNumbers2 = function(nums) {
    for (let i = 0; i < nums.length; i++) {
        const num = Math.abs(nums[i]);
        // æ³¨æ„ç´¢å¼•ï¼Œå…ƒç´ å¤§å°ä» 1 å¼€å§‹ï¼Œæœ‰ä¸€ä½ç´¢å¼•åç§»
        if (nums[num - 1] > 0) {
            // æŠŠç´¢å¼• num - 1 ç½®ä¸ºè´Ÿæ•°
            nums[num - 1] *= -1;
        }
    }

    const res = [];
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] > 0) {
            // è¯´æ˜æ²¡æœ‰å…ƒç´ å’Œè¿™ä¸ªç´¢å¼•å¯¹åº”ï¼Œå³æ‰¾åˆ°ä¸€ä¸ªç¼ºå¤±å…ƒç´ 
            res.push(i + 1);
        }
    }

    return res;
}
```

```python
# by chatGPT (python)
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums)
        count = [0] * (n + 1)
        for num in nums:
            count[num] += 1
        res = []
        for num in range(1, n+1):
            if count[num] == 0:
                res.append(num)
        return res

class Solution2:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        for num in nums:
            # æ³¨æ„ç´¢å¼•ï¼Œå…ƒç´ å¤§å°ä» 1 å¼€å§‹ï¼Œæœ‰ä¸€ä½ç´¢å¼•åç§»
            if nums[abs(num) - 1] < 0:
                # ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
                # è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡ï¼Œä½†æˆ‘ä»¬ä¸ç”¨åšï¼Œè®©ç´¢å¼•ç»§ç»­ä¿æŒè´Ÿæ•°
                pass
            else:
                # æŠŠç´¢å¼• num - 1 ç½®ä¸ºè´Ÿæ•°
                nums[abs(num) - 1] *= -1

        res = []
        for i in range(len(nums)):
            if nums[i] > 0:
                # è¯´æ˜æ²¡æœ‰å…ƒç´ å’Œè¿™ä¸ªç´¢å¼•å¯¹åº”ï¼Œå³æ‰¾åˆ°ä¸€ä¸ªç¼ºå¤±å…ƒç´ 
                res.append(i + 1)

        return res
```

https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/find-distance-in-a-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int findDistance(TreeNode* root, int p, int q) {
        lca(root, p, q);
        return res;
    }

private:
    bool found = false;
    int res = 0;

    // å®šä¹‰ï¼šå½“å­æ ‘ä¸­ä¸åŒ…å« p æˆ– q æ—¶ï¼Œè¿”å› 0ï¼›
    // å½“å­æ ‘ä¸­ä»…åŒ…å« p æˆ– q ä¸­çš„ä¸€ä¸ªæ—¶ï¼Œè¿”å› root åˆ° p æˆ– q çš„è·ç¦»ï¼›
    // å½“å­æ ‘ä¸­åŒæ—¶åŒ…å« p å’Œ q æ—¶ï¼Œè¿”å›ä¸€ä¸ªæ— æ„ä¹‰çš„å€¼ï¼ˆç­”æ¡ˆä¼šè¢«å­˜åœ¨å¤–éƒ¨å˜é‡ res ä¸­ï¼‰
    int lca(TreeNode* root, int p, int q) {
        if (found) {
            // found ä¸º true æ—¶ç­”æ¡ˆå·²ç»è¢«è®°å½•åœ¨å…¨å±€ res ä¸­
            // é€’å½’å‡½æ•°çš„è¿”å›å€¼å·²ä¸éœ€è¦äº†ï¼Œæ­¤æ—¶è¿”å›ä»€ä¹ˆå€¼éƒ½æ— æ‰€è°“
            return 123;
        }
        if (!root) {
            return 0;
        }

        int left = lca(root->left, p, q);
        int right = lca(root->right, p, q);

        if (left == 0 && right == 0) {
            // root çš„å·¦å³å­æ ‘éƒ½ä¸åŒ…å« p æˆ– q
            if (root->val == p || root->val == q) {
                return 1;
            }
            return 0;
        }

        if (left != 0 && right != 0 && !found) {
            // å½“å‰èŠ‚ç‚¹ root å°±æ˜¯ p, q çš„æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹
            // ç­”æ¡ˆå·²ç»ç®—å‡ºæ¥äº†ï¼Œæ›´æ–°å…¨å±€å˜é‡
            res = left + right;
            // è¿™ä¸ªé€’å½’å‡½æ•°çš„è¿”å›å€¼å·²ç»ä¸é‡è¦äº†ï¼Œè®©å®ƒç»ˆæ­¢é€’å½’
            found = true;
            return 456;
        }

        // æ­¤æ—¶ left å’Œ right æœ‰ä¸€ä¸ªä¸º 0ï¼Œå³åªæ‰¾åˆ°äº†ä¸€ä¸ªèŠ‚ç‚¹
        // branch å°±æ˜¯åˆ°è¯¥èŠ‚ç‚¹çš„è·ç¦»
        int branch = left == 0 ? right : left;

        if (root->val == p || root->val == q) {
            res = branch;
        }

        return branch + 1;
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func findDistance(root *TreeNode, p int, q int) int {
    var found bool = false
    var res int = 0

    // å®šä¹‰ï¼šå½“å­æ ‘ä¸­ä¸åŒ…å« p æˆ– q æ—¶ï¼Œè¿”å› 0ï¼›
    // å½“å­æ ‘ä¸­ä»…åŒ…å« p æˆ– q ä¸­çš„ä¸€ä¸ªæ—¶ï¼Œè¿”å› root åˆ° p æˆ– q çš„è·ç¦»ï¼›
    // å½“å­æ ‘ä¸­åŒæ—¶åŒ…å« p å’Œ q æ—¶ï¼Œè¿”å›ä¸€ä¸ªæ— æ„ä¹‰çš„å€¼ï¼ˆç­”æ¡ˆä¼šè¢«å­˜åœ¨å¤–éƒ¨å˜é‡ res ä¸­ï¼‰
    var lca func(root *TreeNode, p, q int) int
    lca = func(root *TreeNode, p, q int) int {
        if found {
            // found ä¸º true æ—¶ç­”æ¡ˆå·²ç»è¢«è®°å½•åœ¨å…¨å±€ res ä¸­
            // é€’å½’å‡½æ•°çš„è¿”å›å€¼å·²ä¸éœ€è¦äº†ï¼Œæ­¤æ—¶è¿”å›ä»€ä¹ˆå€¼éƒ½æ— æ‰€è°“
            return 123
        }
        if root == nil {
            return 0
        }

        left := lca(root.Left, p, q)
        right := lca(root.Right, p, q)

        if left == 0 && right == 0 {
            // root çš„å·¦å³å­æ ‘éƒ½ä¸åŒ…å« p æˆ– q
            if root.Val == p || root.Val == q {
                return 1
            }
            return 0
        }

        if left != 0 && right != 0 && !found {
            // å½“å‰èŠ‚ç‚¹ root å°±æ˜¯ p, q çš„æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹
            // ç­”æ¡ˆå·²ç»ç®—å‡ºæ¥äº†ï¼Œæ›´æ–°å…¨å±€å˜é‡
            res = left + right
            // è¿™ä¸ªé€’å½’å‡½æ•°çš„è¿”å›å€¼å·²ç»ä¸é‡è¦äº†ï¼Œè®©å®ƒç»ˆæ­¢é€’å½’
            found = true
            return 456
        }

        // æ­¤æ—¶ left å’Œ right æœ‰ä¸€ä¸ªä¸º 0ï¼Œå³åªæ‰¾åˆ°äº†ä¸€ä¸ªèŠ‚ç‚¹
        // branch å°±æ˜¯åˆ°è¯¥èŠ‚ç‚¹çš„è·ç¦»
        branch := 0
        if left == 0 {
            branch = right
        } else {
            branch = left
        }

        if root.Val == p || root.Val == q {
            res = branch
        }

        return branch + 1
    }
    lca(root, p, q)
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int findDistance(TreeNode root, int p, int q) {
        lca(root, p, q);
        return res;
    }


    boolean found = false;
    int res = 0;

    // å®šä¹‰ï¼šå½“å­æ ‘ä¸­ä¸åŒ…å« p æˆ– q æ—¶ï¼Œè¿”å› 0ï¼›
    // å½“å­æ ‘ä¸­ä»…åŒ…å« p æˆ– q ä¸­çš„ä¸€ä¸ªæ—¶ï¼Œè¿”å› root åˆ° p æˆ– q çš„è·ç¦»ï¼›
    // å½“å­æ ‘ä¸­åŒæ—¶åŒ…å« p å’Œ q æ—¶ï¼Œè¿”å›ä¸€ä¸ªæ— æ„ä¹‰çš„å€¼ï¼ˆç­”æ¡ˆä¼šè¢«å­˜åœ¨å¤–éƒ¨å˜é‡ res ä¸­ï¼‰
    int lca(TreeNode root, int p, int q) {
        if (found) {
            // found ä¸º true æ—¶ç­”æ¡ˆå·²ç»è¢«è®°å½•åœ¨å…¨å±€ res ä¸­
            // é€’å½’å‡½æ•°çš„è¿”å›å€¼å·²ä¸éœ€è¦äº†ï¼Œæ­¤æ—¶è¿”å›ä»€ä¹ˆå€¼éƒ½æ— æ‰€è°“
            return 123;
        }
        if (root == null) {
            return 0;
        }

        int left = lca(root.left, p, q);
        int right = lca(root.right, p, q);

        if (left == 0 && right == 0) {
            // root çš„å·¦å³å­æ ‘éƒ½ä¸åŒ…å« p æˆ– q
            if (root.val == p || root.val == q) {
                return 1;
            }
            return 0;
        }

        if (left != 0 && right != 0 && !found) {
            // å½“å‰èŠ‚ç‚¹ root å°±æ˜¯ p, q çš„æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹
            // ç­”æ¡ˆå·²ç»ç®—å‡ºæ¥äº†ï¼Œæ›´æ–°å…¨å±€å˜é‡
            res = left + right;
            // è¿™ä¸ªé€’å½’å‡½æ•°çš„è¿”å›å€¼å·²ç»ä¸é‡è¦äº†ï¼Œè®©å®ƒç»ˆæ­¢é€’å½’
            found = true;
            return 456;
        }

        // æ­¤æ—¶ left å’Œ right æœ‰ä¸€ä¸ªä¸º 0ï¼Œå³åªæ‰¾åˆ°äº†ä¸€ä¸ªèŠ‚ç‚¹
        // branch å°±æ˜¯åˆ°è¯¥èŠ‚ç‚¹çš„è·ç¦»
        int branch = left == 0 ? right : left;

        if (root.val == p || root.val == q) {
            res = branch;
        }

        return branch + 1;
    }
}
```

```javascript
// by chatGPT (javascript)
var findDistance = function(root, p, q) {
    var found = false;
    var res = 0;

    // å®šä¹‰ï¼šå½“å­æ ‘ä¸­ä¸åŒ…å« p æˆ– q æ—¶ï¼Œè¿”å› 0ï¼›
    // å½“å­æ ‘ä¸­ä»…åŒ…å« p æˆ– q ä¸­çš„ä¸€ä¸ªæ—¶ï¼Œè¿”å› root åˆ° p æˆ– q çš„è·ç¦»ï¼›
    // å½“å­æ ‘ä¸­åŒæ—¶åŒ…å« p å’Œ q æ—¶ï¼Œè¿”å›ä¸€ä¸ªæ— æ„ä¹‰çš„å€¼ï¼ˆç­”æ¡ˆä¼šè¢«å­˜åœ¨å¤–éƒ¨å˜é‡ res ä¸­ï¼‰
    var lca = function(root, p, q) {
        if (found) {
            // found ä¸º true æ—¶ç­”æ¡ˆå·²ç»è¢«è®°å½•åœ¨å…¨å±€ res ä¸­
            // é€’å½’å‡½æ•°çš„è¿”å›å€¼å·²ä¸éœ€è¦äº†ï¼Œæ­¤æ—¶è¿”å›ä»€ä¹ˆå€¼éƒ½æ— æ‰€è°“
            return 123;
        }
        if (root == null) {
            return 0;
        }

        var left = lca(root.left, p, q);
        var right = lca(root.right, p, q);

        if (left == 0 && right == 0) {
            // root çš„å·¦å³å­æ ‘éƒ½ä¸åŒ…å« p æˆ– q
            if (root.val == p || root.val == q) {
                return 1;
            }
            return 0;
        }

        if (left != 0 && right != 0 && !found) {
            // å½“å‰èŠ‚ç‚¹ root å°±æ˜¯ p, q çš„æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹
            // ç­”æ¡ˆå·²ç»ç®—å‡ºæ¥äº†ï¼Œæ›´æ–°å…¨å±€å˜é‡
            res = left + right;
            // è¿™ä¸ªé€’å½’å‡½æ•°çš„è¿”å›å€¼å·²ç»ä¸é‡è¦äº†ï¼Œè®©å®ƒç»ˆæ­¢é€’å½’
            found = true;
            return 456;
        }

        // æ­¤æ—¶ left å’Œ right æœ‰ä¸€ä¸ªä¸º 0ï¼Œå³åªæ‰¾åˆ°äº†ä¸€ä¸ªèŠ‚ç‚¹
        // branch å°±æ˜¯åˆ°è¯¥èŠ‚ç‚¹çš„è·ç¦»
        var branch = left == 0 ? right : left;

        if (root.val == p || root.val == q) {
            res = branch;
        }

        return branch + 1;
    };

    lca(root, p, q);
    return res;
}
```

```python
# by chatGPT (python)
class Solution:
    def findDistance(self, root: TreeNode, p: int, q: int) -> int:
        self.found = False
        self.res = 0
        self.lca(root, p, q)
        return self.res

    # å®šä¹‰ï¼šå½“å­æ ‘ä¸­ä¸åŒ…å« p æˆ– q æ—¶ï¼Œè¿”å› 0ï¼›
    # å½“å­æ ‘ä¸­ä»…åŒ…å« p æˆ– q ä¸­çš„ä¸€ä¸ªæ—¶ï¼Œè¿”å› root åˆ° p æˆ– q çš„è·ç¦»ï¼›
    # å½“å­æ ‘ä¸­åŒæ—¶åŒ…å« p å’Œ q æ—¶ï¼Œè¿”å›ä¸€ä¸ªæ— æ„ä¹‰çš„å€¼ï¼ˆç­”æ¡ˆä¼šè¢«å­˜åœ¨å¤–éƒ¨å˜é‡ res ä¸­ï¼‰
    def lca(self, root: TreeNode, p: int, q: int) -> int:
        if self.found:
            # found ä¸º true æ—¶ç­”æ¡ˆå·²ç»è¢«è®°å½•åœ¨å…¨å±€ res ä¸­
            # é€’å½’å‡½æ•°çš„è¿”å›å€¼å·²ä¸éœ€è¦äº†ï¼Œæ­¤æ—¶è¿”å›ä»€ä¹ˆå€¼éƒ½æ— æ‰€è°“
            return 123
        if root is None:
            return 0

        left = self.lca(root.left, p, q)
        right = self.lca(root.right, p, q)

        if left == 0 and right == 0:
            # root çš„å·¦å³å­æ ‘éƒ½ä¸åŒ…å« p æˆ– q
            if root.val == p or root.val == q:
                return 1
            return 0

        if left != 0 and right != 0 and not self.found:
            # å½“å‰èŠ‚ç‚¹ root å°±æ˜¯ p, q çš„æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹
            # ç­”æ¡ˆå·²ç»ç®—å‡ºæ¥äº†ï¼Œæ›´æ–°å…¨å±€å˜é‡
            self.res = left + right
            # è¿™ä¸ªé€’å½’å‡½æ•°çš„è¿”å›å€¼å·²ç»ä¸é‡è¦äº†ï¼Œè®©å®ƒç»ˆæ­¢é€’å½’
            self.found = True
            return 456

        # æ­¤æ—¶ left å’Œ right æœ‰ä¸€ä¸ªä¸º 0ï¼Œå³åªæ‰¾åˆ°äº†ä¸€ä¸ªèŠ‚ç‚¹
        # branch å°±æ˜¯åˆ°è¯¥èŠ‚ç‚¹çš„è·ç¦»
        branch = right if left == 0 else left

        if root.val == p or root.val == q:
            self.res = branch

        return branch + 1
```

https://leetcode.cn/problems/find-distance-in-a-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/find-duplicate-subtrees çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
#include <unordered_map>
#include <vector>
using namespace std;

class Solution {
    // è®°å½•æ‰€æœ‰å­æ ‘ä»¥åŠå‡ºç°çš„æ¬¡æ•°
    unordered_map<string, int> memo;
    // è®°å½•é‡å¤çš„å­æ ‘æ ¹èŠ‚ç‚¹
    vector<TreeNode*> res;

public:
    /* ä¸»å‡½æ•° */
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        traverse(root);
        return res;
    }

    string traverse(TreeNode* root) {
        if (root == nullptr) {
            return "#";
        }

        string left = traverse(root->left);
        string right = traverse(root->right);

        string subTree = left + "," + right + "," + to_string(root->val);

        int freq = memo[subTree];
        // å¤šæ¬¡é‡å¤ä¹Ÿåªä¼šè¢«åŠ å…¥ç»“æœé›†ä¸€æ¬¡
        if (freq == 1) {
            res.push_back(root);
        }
        // ç»™å­æ ‘å¯¹åº”çš„å‡ºç°æ¬¡æ•°åŠ ä¸€
        memo[subTree] = freq + 1;
        return subTree;
    }
};
```

```go
// by chatGPT (go)
import (
    "strconv"
)

// TreeNode Definition for a binary tree node.

// findDuplicateSubtrees è®°å½•æ‰€æœ‰å­æ ‘ä»¥åŠå‡ºç°çš„æ¬¡æ•°
func findDuplicateSubtrees(root *TreeNode) []*TreeNode {
    memo := make(map[string]int)
    res := []*TreeNode{}

    traverse(root, memo, &res)

    return res
}

// traverse æ·±åº¦ä¼˜å…ˆéå†
func traverse(root *TreeNode, memo map[string]int, res *[]*TreeNode) string {
    if root == nil {
        return "#"
    }

    left := traverse(root.Left, memo, res)
    right := traverse(root.Right, memo, res)

    subTree := left + "," + right + "," + strconv.Itoa(root.Val)

    freq := memo[subTree]
    // å¤šæ¬¡é‡å¤ä¹Ÿåªä¼šè¢«åŠ å…¥ç»“æœé›†ä¸€æ¬¡
    if freq == 1 {
        *res = append(*res, root)
    }
    // ç»™å­æ ‘å¯¹åº”çš„å‡ºç°æ¬¡æ•°åŠ ä¸€
    memo[subTree]++
    return subTree
}
```

```java
// by labuladong (java)
class Solution {
    // è®°å½•æ‰€æœ‰å­æ ‘ä»¥åŠå‡ºç°çš„æ¬¡æ•°
    HashMap<String, Integer> memo = new HashMap<>();
    // è®°å½•é‡å¤çš„å­æ ‘æ ¹èŠ‚ç‚¹
    LinkedList<TreeNode> res = new LinkedList<>();

    /* ä¸»å‡½æ•° */
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        traverse(root);
        return res;
    }

    String traverse(TreeNode root) {
        if (root == null) {
            return "#";
        }

        String left = traverse(root.left);
        String right = traverse(root.right);

        String subTree = left + "," + right + "," + root.val;

        int freq = memo.getOrDefault(subTree, 0);
        // å¤šæ¬¡é‡å¤ä¹Ÿåªä¼šè¢«åŠ å…¥ç»“æœé›†ä¸€æ¬¡
        if (freq == 1) {
            res.add(root);
        }
        // ç»™å­æ ‘å¯¹åº”çš„å‡ºç°æ¬¡æ•°åŠ ä¸€
        memo.put(subTree, freq + 1);
        return subTree;
    }
}
```

```javascript
// by chatGPT (javascript)
var findDuplicateSubtrees = function(root) {
    // è®°å½•æ‰€æœ‰å­æ ‘ä»¥åŠå‡ºç°çš„æ¬¡æ•°
    const memo = new Map();
    // è®°å½•é‡å¤çš„å­æ ‘æ ¹èŠ‚ç‚¹
    const res = [];

    /* ä¸»å‡½æ•° */
    const traverse = function(root) {
        if (root == null) {
            return "#";
        }

        const left = traverse(root.left);
        const right = traverse(root.right);

        const subTree = left + "," + right + "," + root.val;

        const freq = memo.get(subTree) || 0;
        // å¤šæ¬¡é‡å¤ä¹Ÿåªä¼šè¢«åŠ å…¥ç»“æœé›†ä¸€æ¬¡
        if (freq === 1) {
            res.push(root);
        }
        // ç»™å­æ ‘å¯¹åº”çš„å‡ºç°æ¬¡æ•°åŠ ä¸€
        memo.set(subTree, freq + 1);
        return subTree;
    };

    traverse(root);
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:
        memo = {}
        res = []

        def traverse(root):
            if not root:
                return "#"

            left = traverse(root.left)
            right = traverse(root.right)

            subTree = left + "," + right + "," + str(root.val)

            freq = memo.get(subTree, 0)
            # å¤šæ¬¡é‡å¤ä¹Ÿåªä¼šè¢«åŠ å…¥ç»“æœé›†ä¸€æ¬¡
            if freq == 1:
                res.append(root)
            # ç»™å­æ ‘å¯¹åº”çš„å‡ºç°æ¬¡æ•°åŠ ä¸€
            memo[subTree] = freq + 1
            return subTree

        traverse(root)
        return res
```

https://leetcode.cn/problems/find-duplicate-subtrees çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = left_bound(nums, target);
        int right = right_bound(nums, target);
        return {left, right};
    }

    int left_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        // æœç´¢åŒºé—´ä¸º [left, right]
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                // æœç´¢åŒºé—´å˜ä¸º [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // æœç´¢åŒºé—´å˜ä¸º [left, mid-1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                // æ”¶ç¼©å³ä¾§è¾¹ç•Œ
                right = mid - 1;
            }
        }
        // æ£€æŸ¥å‡ºç•Œæƒ…å†µ
        if (left >= nums.size() || nums[left] != target) {
            /* <extend up -300>
            ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/2.jpg)
            */
            return -1;
        }
        return left;
    }

    int right_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // è¿™é‡Œæ”¹æˆæ”¶ç¼©å·¦ä¾§è¾¹ç•Œå³å¯
                left = mid + 1;
            }
        }
        // è¿™é‡Œæ”¹ä¸ºæ£€æŸ¥ right è¶Šç•Œçš„æƒ…å†µï¼Œè§ä¸‹å›¾
        if (right < 0 || nums[right] != target) {
            /* <extend up -300>
            ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/4.jpg)
            */
            return -1;
        }
        return right;
    }
};
```

```go
// by chatGPT (go)
func searchRange(nums []int, target int) []int {
    return []int{leftBound(nums, target), rightBound(nums, target)}
}

func leftBound(nums []int, target int) int {
    left, right := 0, len(nums)-1
    // æœç´¢åŒºé—´ä¸º [left, right]
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] < target {
            // æœç´¢åŒºé—´å˜ä¸º [mid+1, right]
            left = mid + 1
        } else if nums[mid] > target {
            // æœç´¢åŒºé—´å˜ä¸º [left, mid-1]
            right = mid - 1
        } else if nums[mid] == target {
            // æ”¶ç¼©å³ä¾§è¾¹ç•Œ
            right = mid - 1
        }
    }
    // æ£€æŸ¥å‡ºç•Œæƒ…å†µ
    if left >= len(nums) || nums[left] != target {
        /**<extend up -300>
        ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/2.jpg)
        */
        return -1
    }
    return left
}

func rightBound(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] < target {
            left = mid + 1
        } else if nums[mid] > target {
            right = mid - 1
        } else if nums[mid] == target {
            // è¿™é‡Œæ”¹æˆæ”¶ç¼©å·¦ä¾§è¾¹ç•Œå³å¯
            left = mid + 1
        }
    }
    // è¿™é‡Œæ”¹ä¸ºæ£€æŸ¥ right è¶Šç•Œçš„æƒ…å†µï¼Œè§ä¸‹å›¾
    if right < 0 || nums[right] != target {
        /**<extend up -300>
        ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/4.jpg)
        */
        return -1
    }
    return right
}
```

```java
// by labuladong (java)
class Solution {
    public int[] searchRange(int[] nums, int target) {
        return new int[]{left_bound(nums, target), right_bound(nums, target)};
    }

    int left_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        // æœç´¢åŒºé—´ä¸º [left, right]
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                // æœç´¢åŒºé—´å˜ä¸º [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // æœç´¢åŒºé—´å˜ä¸º [left, mid-1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                // æ”¶ç¼©å³ä¾§è¾¹ç•Œ
                right = mid - 1;
            }
        }
        // æ£€æŸ¥å‡ºç•Œæƒ…å†µ
        if (left >= nums.length || nums[left] != target) {
            /**<extend up -300>
            ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/2.jpg)
            */
            return -1;
        }
        return left;
    }

    int right_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // è¿™é‡Œæ”¹æˆæ”¶ç¼©å·¦ä¾§è¾¹ç•Œå³å¯
                left = mid + 1;
            }
        }
        // è¿™é‡Œæ”¹ä¸ºæ£€æŸ¥ right è¶Šç•Œçš„æƒ…å†µï¼Œè§ä¸‹å›¾
        if (right < 0 || nums[right] != target) {
            /**<extend up -300>
            ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/4.jpg)
            */
            return -1;
        }
        return right;
    }
}
```

```javascript
// by chatGPT (javascript)
var searchRange = function(nums, target) {
  return [left_bound(nums, target), right_bound(nums, target)];
};

var left_bound = function(nums, target) {
  let left = 0,
    right = nums.length - 1;
  // æœç´¢åŒºé—´ä¸º [left, right]
  while (left <= right) {
    let mid = left + Math.floor((right - left) / 2);
    if (nums[mid] < target) {
      // æœç´¢åŒºé—´å˜ä¸º [mid+1, right]
      left = mid + 1;
    } else if (nums[mid] > target) {
      // æœç´¢åŒºé—´å˜ä¸º [left, mid-1]
      right = mid - 1;
    } else if (nums[mid] === target) {
      // æ”¶ç¼©å³ä¾§è¾¹ç•Œ
      right = mid - 1;
    }
  }
  // æ£€æŸ¥å‡ºç•Œæƒ…å†µ
  if (left >= nums.length || nums[left] !== target) {
    /**<extend up -300>
    ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/2.jpg)
    */
    return -1;
  }
  return left;
};

var right_bound = function(nums, target) {
  let left = 0,right = nums.length - 1;
  while (left <= right) {
    let mid = left + Math.floor((right - left) / 2);
    if (nums[mid] < target) {
      left = mid + 1;
    } else if (nums[mid] > target) {
      right = mid - 1;
    } else if (nums[mid] === target) {
      // è¿™é‡Œæ”¹æˆæ”¶ç¼©å·¦ä¾§è¾¹ç•Œå³å¯
      left = mid + 1;
    }
  }
  // è¿™é‡Œæ”¹ä¸ºæ£€æŸ¥ right è¶Šç•Œçš„æƒ…å†µï¼Œè§ä¸‹å›¾
  if (right < 0 || nums[right] !== target) {
    /**<extend up -300>
    ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/4.jpg)
    */
    return -1;
  }
  return right;
};
```

```python
# by chatGPT (python)
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        return [self.left_bound(nums, target), self.right_bound(nums, target)]
    
    def left_bound(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        # æœç´¢åŒºé—´ä¸º [left, right]
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] < target:
                # æœç´¢åŒºé—´å˜ä¸º [mid+1, right]
                left = mid + 1
            elif nums[mid] > target:
                # æœç´¢åŒºé—´å˜ä¸º [left, mid-1]
                right = mid - 1
            elif nums[mid] == target:
                # æ”¶ç¼©å³ä¾§è¾¹ç•Œ
                right = mid - 1
        # æ£€æŸ¥å‡ºç•Œæƒ…å†µ
        if left >= len(nums) or nums[left] != target:
            """
            <extend up -300>
            ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/2.jpg)
            """f
            return -1
        return left
    
    def right_bound(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            elif nums[mid] == target:
                # è¿™é‡Œæ”¹æˆæ”¶ç¼©å·¦ä¾§è¾¹ç•Œå³å¯
                left = mid + 1
        # è¿™é‡Œæ”¹ä¸ºæ£€æŸ¥ right è¶Šç•Œçš„æƒ…å†µï¼Œè§ä¸‹å›¾
        if right < 0 or nums[right] != target:
            '''
            <extend up -300>
            ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/4.jpg)
            '''
            return -1
        return right
```

https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/find-k-closest-elements çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        // äºŒåˆ†æœç´¢æ‰¾åˆ° x çš„ä½ç½®
        int p = left_bound(arr, x);
        // ä¸¤ç«¯éƒ½å¼€çš„åŒºé—´ (left, right)
        int left = p - 1, right = p;
        vector<int> res;
        // æ‰©å±•åŒºé—´ï¼Œç›´åˆ°åŒºé—´å†…åŒ…å« k ä¸ªå…ƒç´ 
        while (right - left - 1 < k) {
            if (left == -1) {
                res.push_back(arr[right]);
                right++;
            } else if (right == arr.size()) {
                res.insert(res.begin(), arr[left]);
                left--;
            } else if (x - arr[left] > arr[right] - x) {
                res.push_back(arr[right]);
                right++;
            } else {
                res.insert(res.begin(), arr[left]);
                left--;
            }
        }
        return res;
    }

    // æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æœç´¢
    int left_bound(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid;
            }
        }
        return left;
    }
};
```

```go
// by chatGPT (go)
func findClosestElements(arr []int, k int, x int) []int {
    // äºŒåˆ†æœç´¢æ‰¾åˆ° x çš„ä½ç½®
    p := left_bound(arr, x)
    // ä¸¤ç«¯éƒ½å¼€çš„åŒºé—´ (left, right)
    left, right := p-1, p
    res := make([]int, 0)
    // æ‰©å±•åŒºé—´ï¼Œç›´åˆ°åŒºé—´å†…åŒ…å« k ä¸ªå…ƒç´ 
    for right-left-1 < k {
        if left == -1 {
            res = append(res, arr[right])
            right++
        } else if right == len(arr) {
            res = append([]int{arr[left]}, res...)
            left--
        } else if x-arr[left] > arr[right]-x {
            res = append(res, arr[right])
            right++
        } else {
            res = append([]int{arr[left]}, res...)
            left--
        }
    }
    return res
}

// æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æœç´¢
func left_bound(nums []int, target int) int {
    left := 0
    right := len(nums)

    for left < right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            right = mid
        } else if nums[mid] < target {
            left = mid + 1
        } else if nums[mid] > target {
            right = mid
        }
    }
    return left
}
```

```java
// by labuladong (java)
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        // äºŒåˆ†æœç´¢æ‰¾åˆ° x çš„ä½ç½®
        int p = left_bound(arr, x);
        // ä¸¤ç«¯éƒ½å¼€çš„åŒºé—´ (left, right)
        int left = p - 1, right = p;
        LinkedList<Integer> res = new LinkedList<>();
        // æ‰©å±•åŒºé—´ï¼Œç›´åˆ°åŒºé—´å†…åŒ…å« k ä¸ªå…ƒç´ 
        while (right - left - 1 < k) {
            if (left == -1) {
                res.addLast(arr[right]);
                right++;
            } else if (right == arr.length) {
                res.addFirst(arr[left]);
                left--;
            } else if (x - arr[left] > arr[right] - x) {
                res.addLast(arr[right]);
                right++;
            } else {
                res.addFirst(arr[left]);
                left--;
            }
        }
        return res;
    }

    // æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æœç´¢
    int left_bound(int[] nums, int target) {
        int left = 0;
        int right = nums.length;

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid;
            }
        }
        return left;
    }
}
```

```javascript
// by chatGPT (javascript)
var findClosestElements = function(arr, k, x) {
    // äºŒåˆ†æœç´¢æ‰¾åˆ° x çš„ä½ç½®
    let p = left_bound(arr, x);
    // ä¸¤ç«¯éƒ½å¼€çš„åŒºé—´ (left, right)
    let left = p - 1, right = p;
    let res = [];
    // æ‰©å±•åŒºé—´ï¼Œç›´åˆ°åŒºé—´å†…åŒ…å« k ä¸ªå…ƒç´ 
    while (right - left - 1 < k) {
        if (left == -1) {
            res.push(arr[right]);
            right++;
        } else if (right == arr.length) {
            res.unshift(arr[left]);
            left--;
        } else if (x - arr[left] > arr[right] - x) {
            res.push(arr[right]);
            right++;
        } else {
            res.unshift(arr[left]);
            left--;
        }
    }
    return res;
};

// æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æœç´¢
var left_bound = function(nums, target) {
    let left = 0;
    let right = nums.length;

    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (nums[mid] == target) {
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    return left;
};
```

```python
# by chatGPT (python)
class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        # äºŒåˆ†æœç´¢æ‰¾åˆ° x çš„ä½ç½®
        p = self.left_bound(arr, x)
        # ä¸¤ç«¯éƒ½å¼€çš„åŒºé—´ (left, right)
        left, right = p - 1, p
        res = []
        # æ‰©å±•åŒºé—´ï¼Œç›´åˆ°åŒºé—´å†…åŒ…å« k ä¸ªå…ƒç´ 
        while right - left - 1 < k:
            if left == -1:
                res.append(arr[right])
                right += 1
            elif right == len(arr):
                res.insert(0, arr[left])
                left -= 1
            elif x - arr[left] > arr[right] - x:
                res.append(arr[right])
                right += 1
            else:
                res.insert(0, arr[left])
                left -= 1
        return res

    # æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æœç´¢
    def left_bound(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)

        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                right = mid
            elif nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid
        return left
```

https://leetcode.cn/problems/find-k-closest-elements çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/find-k-pairs-with-smallest-sums çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        // å­˜å‚¨ä¸‰å…ƒç»„ (num1[i], nums2[i], i)
        // i è®°å½• nums2 å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq([](const vector<int>& a, const vector<int>& b) {
            // æŒ‰ç…§æ•°å¯¹çš„å…ƒç´ å’Œå‡åºæ’åº
            return a[0] + a[1] < b[0] + b[1];
        });
        // æŒ‰ç…§ 23 é¢˜çš„é€»è¾‘åˆå§‹åŒ–ä¼˜å…ˆçº§é˜Ÿåˆ—
        for (int i = 0; i < nums1.size(); i++) {
            pq.push({nums1[i], nums2[0], 0});
        }

        vector<vector<int>> res;
        // æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
        while (!pq.empty() && k > 0) {
            auto cur = pq.top();
            pq.pop();
            k--;
            // é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
            int next_index = cur[2] + 1;
            if (next_index < nums2.size()) {
                pq.push({cur[0], nums2[next_index], next_index});
            }

            vector<int> pair = {cur[0], cur[1]};
            res.push_back(pair);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int {
    // å­˜å‚¨ä¸‰å…ƒç»„ (num1[i], nums2[i], i)
    // i è®°å½• nums2 å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    pq := make(PriorityQueue, 0)
    heap.Init(&pq)
    // æŒ‰ç…§ 23 é¢˜çš„é€»è¾‘åˆå§‹åŒ–ä¼˜å…ˆçº§é˜Ÿåˆ—
    for i := 0; i < len(nums1); i++ {
        pq.Push([]int{nums1[i], nums2[0], 0})
    }

    res := make([][]int, 0)
    // æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
    for pq.Len() > 0 && k > 0 {
        cur := pq.Pop().([]int)
        k--
        // é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
        next_index := cur[2] + 1
        if next_index < len(nums2) {
            pq.Push([]int{cur[0], nums2[next_index], next_index})
        }

        pair := []int{cur[0], cur[1]}
        res = append(res, pair)
    }
    return res
}

type PriorityQueue [][]int

func (pq PriorityQueue) Len() int { return len(pq) }

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i][0]+pq[i][1] < pq[j][0]+pq[j][1]
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    *pq = append(*pq, x.([]int))
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
}
```

```java
// by labuladong (java)
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        // å­˜å‚¨ä¸‰å…ƒç»„ (num1[i], nums2[i], i)
        // i è®°å½• nums2 å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            // æŒ‰ç…§æ•°å¯¹çš„å…ƒç´ å’Œå‡åºæ’åº
            return (a[0] + a[1]) - (b[0] + b[1]);
        });
        // æŒ‰ç…§ 23 é¢˜çš„é€»è¾‘åˆå§‹åŒ–ä¼˜å…ˆçº§é˜Ÿåˆ—
        for (int i = 0; i < nums1.length; i++) {
            pq.offer(new int[]{nums1[i], nums2[0], 0});
        }

        List<List<Integer>> res = new ArrayList<>();
        // æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
        while (!pq.isEmpty() && k > 0) {
            int[] cur = pq.poll();
            k--;
            // é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
            int next_index = cur[2] + 1;
            if (next_index < nums2.length) {
                pq.add(new int[]{cur[0], nums2[next_index], next_index});
            }

            List<Integer> pair = new ArrayList<>();
            pair.add(cur[0]);
            pair.add(cur[1]);
            res.add(pair);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var kSmallestPairs = function(nums1, nums2, k) {
    // å­˜å‚¨ä¸‰å…ƒç»„ (num1[i], nums2[i], i)
    // i è®°å½• nums2 å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    const pq = new PriorityQueue((a, b) => {
        // æŒ‰ç…§æ•°å¯¹çš„å…ƒç´ å’Œå‡åºæ’åº
        return (a[0] + a[1]) - (b[0] + b[1]);
    });
    // æŒ‰ç…§ 23 é¢˜çš„é€»è¾‘åˆå§‹åŒ–ä¼˜å…ˆçº§é˜Ÿåˆ—
    for (let i = 0; i < nums1.length; i++) {
        pq.offer([nums1[i], nums2[0], 0]);
    }

    const res = [];
    // æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
    while (!pq.isEmpty() && k > 0) {
        const cur = pq.poll();
        k--;
        // é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
        const next_index = cur[2] + 1;
        if (next_index < nums2.length) {
            pq.add([cur[0], nums2[next_index], next_index]);
        }

        const pair = [cur[0], cur[1]];
        res.push(pair);
    }
    return res;
};

// ä¼˜å…ˆçº§é˜Ÿåˆ—çš„å®ç°ï¼Œç”¨äºå­˜å‚¨ä¸‰å…ƒç»„
class PriorityQueue {
    constructor(comparator) {
        this.heap = [];
        this.comparator = comparator;
    }

    isEmpty() {
        return this.heap.length === 0;
    }

    size() {
        return this.heap.length;
    }

    peek() {
        return this.heap[0];
    }

    offer(value) {
        this.heap.push(value);
        this.bubbleUp(this.heap.length - 1);
    }

    poll() {
        const result = this.heap[0];
        const end = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = end;
            this.bubbleDown(0);
        }
        return result;
    }

    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = (index - 1) >> 1;
            if (this.comparator(this.heap[index], this.heap[parentIndex]) < 0) {
                const tmp = this.heap[index];
                this.heap[index] = this.heap[parentIndex];
                this.heap[parentIndex] = tmp;
                index = parentIndex;
            } else {
                break;
            }
        }
    }

    bubbleDown(index) {
        const lastIndex = this.heap.length - 1;
        while (STATUS_PASSED_TEST) {
            const leftIndex = index * 2 + 1;
            const rightIndex = index * 2 + 2;
            let findIndex = index;
            if (leftIndex <= lastIndex && this.comparator(this.heap[leftIndex], this.heap[findIndex]) < 0) {
                findIndex = leftIndex;
            }
            if (rightIndex <= lastIndex && this.comparator(this.heap[rightIndex], this.heap[findIndex]) < 0) {
                findIndex = rightIndex;
            }
            if (index !== findIndex) {
                const tmp = this.heap[index];
                this.heap[index] = this.heap[findIndex];
                this.heap[findIndex] = tmp;
                index = findIndex;
            } else {
                break;
            }
        }
    }
}
```

```python
# by chatGPT (python)
import heapq

class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        # å­˜å‚¨ä¸‰å…ƒç»„ (num1[i], nums2[i], i)
        # i è®°å½• nums2 å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        pq = []
        for i in range(len(nums1)):
            heapq.heappush(pq, [nums1[i], nums2[0], 0])
            
        res = []
        # æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
        while pq and k > 0:
            cur = heapq.heappop(pq)
            k -= 1
            # é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
            next_index = cur[2] + 1
            if next_index < len(nums2):
                heapq.heappush(pq, [cur[0], nums2[next_index], next_index])
            
            pair = [cur[0], cur[1]]
            res.append(pair)
        
        return res
```

https://leetcode.cn/problems/find-k-pairs-with-smallest-sums çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/find-median-from-data-stream çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class MedianFinder {
private:
    priority_queue<int> large;  // å°é¡¶å †
    priority_queue<int, vector<int>, greater<int>> small;  // å¤§é¡¶å †

public:
    /** initialize your data structure here. */
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        if (small.size() >= large.size()) {
            small.push(num);
            large.push(small.top());
            small.pop();
        } else {
            large.push(num);
            small.push(large.top());
            large.pop();
        }
    }
    
    double findMedian() {
        /**<extend up -100>
        ![](../pictures/ä¸­ä½æ•°/2.jpeg)
        */
        // å¦‚æœå…ƒç´ ä¸ä¸€æ ·å¤šï¼Œå¤šçš„é‚£ä¸ªå †çš„å †é¡¶å…ƒç´ å°±æ˜¯ä¸­ä½æ•°
        if (large.size() < small.size()) {
            return small.top();
        } else if (large.size() > small.size()) {
            return large.top();
        }
        // å¦‚æœå…ƒç´ ä¸€æ ·å¤šï¼Œä¸¤ä¸ªå †å †é¡¶å…ƒç´ çš„å¹³å‡æ•°æ˜¯ä¸­ä½æ•°
        return (large.top() + small.top()) / 2.0;
        /**<extend up -100>
        ![](../pictures/ä¸­ä½æ•°/1.jpeg)
        */
    }
};
```

```go
// by chatGPT (go)
import "container/heap"

type MedianFinder struct {
    large *PriorityQueue
    small *PriorityQueue
}

// å°é¡¶å †
type PriorityQueue []int

func (pq PriorityQueue) Len() int {
    return len(pq)
}

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i] < pq[j]
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    *pq = append(*pq, x.(int))
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    x := old[n-1]
    *pq = old[:n-1]
    return x
}

// å¤§é¡¶å †
type ReversePriorityQueue []int

func (rpq ReversePriorityQueue) Len() int {
    return len(rpq)
}

func (rpq ReversePriorityQueue) Less(i, j int) bool {
    return rpq[i] > rpq[j]
}

func (rpq ReversePriorityQueue) Swap(i, j int) {
    rpq[i], rpq[j] = rpq[j], rpq[i]
}

func (rpq *ReversePriorityQueue) Push(x interface{}) {
    *rpq = append(*rpq, x.(int))
}

func (rpq *ReversePriorityQueue) Pop() interface{} {
    old := *rpq
    n := len(old)
    x := old[n-1]
    *rpq = old[:n-1]
    return x
}

func Constructor() MedianFinder {
    // å°é¡¶å †
    large := &PriorityQueue{}
    // å¤§é¡¶å †
    small := &ReversePriorityQueue{}

    return MedianFinder{
        large: large,
        small: small,
    }
}

func (this *MedianFinder) FindMedian() float64 {
    // å¦‚æœå…ƒç´ ä¸ä¸€æ ·å¤šï¼Œå¤šçš„é‚£ä¸ªå †çš„å †é¡¶å…ƒç´ å°±æ˜¯ä¸­ä½æ•°
    if this.large.Len() < this.small.Len() {
        return float64(this.small.Top())
    } else if this.large.Len() > this.small.Len() {
        return float64(this.large.Top())
    }
    // å¦‚æœå…ƒç´ ä¸€æ ·å¤šï¼Œä¸¤ä¸ªå †å †é¡¶å…ƒç´ çš„å¹³å‡æ•°æ˜¯ä¸­ä½æ•°
    return (float64(this.large.Top()) + float64(this.small.Top())) / 2.0
}

func (this *MedianFinder) AddNum(num int) {
    if this.small.Len() >= this.large.Len() {
        this.small.Push(num)
        heap.Push(this.large, this.small.Pop())
    } else {
        this.large.Push(num)
        heap.Push(this.small, this.large.Pop())
    }
}

// è¿”å›å †é¡¶å…ƒç´ 
func (pq *PriorityQueue) Top() int {
    return (*pq)[0]
}

// è¿”å›å †é¡¶å…ƒç´ 
func (rpq *ReversePriorityQueue) Top() int {
    return (*rpq)[0]
}
```

```java
// by labuladong (java)
class MedianFinder {
    private PriorityQueue<Integer> large;
    private PriorityQueue<Integer> small;

    public MedianFinder() {
        // å°é¡¶å †
        large = new PriorityQueue<>();
        // å¤§é¡¶å †
        small = new PriorityQueue<>((a, b) -> {
            return b - a;
        });
    }

    public double findMedian() {
        /**<extend up -100>
        ![](../pictures/ä¸­ä½æ•°/2.jpeg)
        */
        // å¦‚æœå…ƒç´ ä¸ä¸€æ ·å¤šï¼Œå¤šçš„é‚£ä¸ªå †çš„å †é¡¶å…ƒç´ å°±æ˜¯ä¸­ä½æ•°
        if (large.size() < small.size()) {
            return small.peek();
        } else if (large.size() > small.size()) {
            return large.peek();
        }
        // å¦‚æœå…ƒç´ ä¸€æ ·å¤šï¼Œä¸¤ä¸ªå †å †é¡¶å…ƒç´ çš„å¹³å‡æ•°æ˜¯ä¸­ä½æ•°
        return (large.peek() + small.peek()) / 2.0;
        /**<extend up -100>
        ![](../pictures/ä¸­ä½æ•°/1.jpeg)
        */
    }

    public void addNum(int num) {
        if (small.size() >= large.size()) {
            small.offer(num);
            large.offer(small.poll());
        } else {
            large.offer(num);
            small.offer(large.poll());
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var MedianFinder = function() {
    // å°é¡¶å †
    var large = new PriorityQueue();
    // å¤§é¡¶å †
    var small = new PriorityQueue(function(a, b) {
        return b - a;
    });

    this.findMedian = function() {
        // å¦‚æœå…ƒç´ ä¸ä¸€æ ·å¤šï¼Œå¤šçš„é‚£ä¸ªå †çš„å †é¡¶å…ƒç´ å°±æ˜¯ä¸­ä½æ•°
        if (large.size() < small.size()) {
            return small.peek();
        } else if (large.size() > small.size()) {
            return large.peek();
        }
        // å¦‚æœå…ƒç´ ä¸€æ ·å¤šï¼Œä¸¤ä¸ªå †å †é¡¶å…ƒç´ çš„å¹³å‡æ•°æ˜¯ä¸­ä½æ•°
        return (large.peek() + small.peek()) / 2.0;
    };

    this.addNum = function(num) {
        if (small.size() >= large.size()) {
            small.offer(num);
            large.offer(small.poll());
        } else {
            large.offer(num);
            small.offer(large.poll());
        }
    };
};
```

```python
# by chatGPT (python)
class MedianFinder:
    def __init__(self):
        # å°é¡¶å †
        self.large = []
        # å¤§é¡¶å †
        self.small = []

    def findMedian(self) -> float:
        # å¦‚æœå…ƒç´ ä¸ä¸€æ ·å¤šï¼Œå¤šçš„é‚£ä¸ªå †çš„å †é¡¶å…ƒç´ å°±æ˜¯ä¸­ä½æ•°
        if len(self.large) < len(self.small):
            return float(self.small[0])
        elif len(self.large) > len(self.small):
            return float(self.large[0])
        # å¦‚æœå…ƒç´ ä¸€æ ·å¤šï¼Œä¸¤ä¸ªå †å †é¡¶å…ƒç´ çš„å¹³å‡æ•°æ˜¯ä¸­ä½æ•°
        return (self.large[0] + self.small[0]) / 2.0

    def addNum(self, num: int) -> None:
        if len(self.small) >= len(self.large):
            self.small.append(num)
            self.large.append(-heapq.heappushpop(self.small, -self.large[0]))
        else:
            self.large.append(num)
            self.small.append(-heapq.heappushpop(self.large, -self.small[0]))
```

https://leetcode.cn/problems/find-median-from-data-stream çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/find-mode-in-binary-search-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> mode;
    TreeNode* prev = nullptr;
    // å½“å‰å…ƒç´ çš„é‡å¤æ¬¡æ•°
    int curCount = 0;
    // å…¨å±€çš„æœ€é•¿ç›¸åŒåºåˆ—é•¿åº¦
    int maxCount = 0;

    vector<int> findMode(TreeNode* root) {
        // æ‰§è¡Œä¸­åºéå†
        traverse(root);

        vector<int> res(mode.size());
        for (int i = 0; i < res.size(); i++) {
            res[i] = mode[i];
        }
        return res;
    }

    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        traverse(root->left);

        // ä¸­åºéå†ä½ç½®
        if (prev == nullptr) {
            // åˆå§‹åŒ–
            curCount = 1;
            maxCount = 1;
            mode.push_back(root->val);
        } else {
            if (root->val == prev->val) {
                // root.val é‡å¤çš„æƒ…å†µ
                curCount++;
                if (curCount == maxCount) {
                    // root.val æ˜¯ä¼—æ•°
                    mode.push_back(root->val);
                } else if (curCount > maxCount) {
                    // æ›´æ–°ä¼—æ•°
                    mode.clear();
                    maxCount = curCount;
                    mode.push_back(root->val);
                }
            }

            if (root->val != prev->val) {
                // root.val ä¸é‡å¤çš„æƒ…å†µ
                curCount = 1;
                if (curCount == maxCount) {
                    mode.push_back(root->val);
                }
            }
        }
        // åˆ«å¿˜äº†æ›´æ–° prev
        prev = root;

        traverse(root->right);
    }
};
```

```go
// by chatGPT (go)
func findMode(root *TreeNode) []int {
    var mode []int
    var prev *TreeNode
    var curCount, maxCount int

    traverse := func(node *TreeNode) {
        if node == nil {
            return
        }
        traverse(node.Left)

        // ä¸­åºéå†ä½ç½®
        if prev == nil {
            // åˆå§‹åŒ–
            curCount = 1
            maxCount = 1
            mode = append(mode, node.Val)
        } else {
            if node.Val == prev.Val {
                // node.Val é‡å¤çš„æƒ…å†µ
                curCount++
                if curCount == maxCount {
                    // node.Val æ˜¯ä¼—æ•°
                    mode = append(mode, node.Val)
                } else if curCount > maxCount {
                    // æ›´æ–°ä¼—æ•°
                    mode = make([]int, 0)
                    maxCount = curCount
                    mode = append(mode, node.Val)
                }
            }

            if node.Val != prev.Val {
                // node.Val ä¸é‡å¤çš„æƒ…å†µ
                curCount = 1
                if curCount == maxCount {
                    mode = append(mode, node.Val)
                }
            }
        }
        // åˆ«å¿˜äº†æ›´æ–° prev
        prev = node

        traverse(node.Right)
    }

    traverse(root)

    return mode
}
```

```java
// by labuladong (java)
class Solution {
    ArrayList<Integer> mode = new ArrayList<>();
    TreeNode prev = null;
    // å½“å‰å…ƒç´ çš„é‡å¤æ¬¡æ•°
    int curCount = 0;
    // å…¨å±€çš„æœ€é•¿ç›¸åŒåºåˆ—é•¿åº¦
    int maxCount = 0;

    public int[] findMode(TreeNode root) {
        // æ‰§è¡Œä¸­åºéå†
        traverse(root);

        int[] res = new int[mode.size()];
        for (int i = 0; i < res.length; i++) {
            res[i] = mode.get(i);
        }
        return res;
    }

    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        traverse(root.left);

        // ä¸­åºéå†ä½ç½®
        if (prev == null) {
            // åˆå§‹åŒ–
            curCount = 1;
            maxCount = 1;
            mode.add(root.val);
        } else {
            if (root.val == prev.val) {
                // root.val é‡å¤çš„æƒ…å†µ
                curCount++;
                if (curCount == maxCount) {
                    // root.val æ˜¯ä¼—æ•°
                    mode.add(root.val);
                } else if (curCount > maxCount) {
                    // æ›´æ–°ä¼—æ•°
                    mode.clear();
                    maxCount = curCount;
                    mode.add(root.val);
                }
            }

            if (root.val != prev.val) {
                // root.val ä¸é‡å¤çš„æƒ…å†µ
                curCount = 1;
                if (curCount == maxCount) {
                    mode.add(root.val);
                }
            }
        }
        // åˆ«å¿˜äº†æ›´æ–° prev
        prev = root;

        traverse(root.right);
    }
}
```

```javascript
// by chatGPT (javascript)
var findMode = function(root) {
    let mode = [];
    let prev = null;
    // å½“å‰å…ƒç´ çš„é‡å¤æ¬¡æ•°
    let curCount = 0;
    // å…¨å±€çš„æœ€é•¿ç›¸åŒåºåˆ—é•¿åº¦
    let maxCount = 0;

    function traverse(root) {
        if (root === null) {
            return;
        }
        traverse(root.left);

        // ä¸­åºéå†ä½ç½®
        if (prev === null) {
            // åˆå§‹åŒ–
            curCount = 1;
            maxCount = 1;
            mode.push(root.val);
        } else {
            if (root.val === prev.val) {
                // root.val é‡å¤çš„æƒ…å†µ
                curCount++;
                if (curCount === maxCount) {
                    // root.val æ˜¯ä¼—æ•°
                    mode.push(root.val);
                } else if (curCount > maxCount) {
                    // æ›´æ–°ä¼—æ•°
                    mode = [root.val];
                    maxCount = curCount;
                }
            }

            if (root.val !== prev.val) {
                // root.val ä¸é‡å¤çš„æƒ…å†µ
                curCount = 1;
                if (curCount === maxCount) {
                    mode.push(root.val);
                }
            }
        }
        // åˆ«å¿˜äº†æ›´æ–° prev
        prev = root;

        traverse(root.right);
    }

    traverse(root);

    return mode;
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.mode = []
        self.prev = None
        # å½“å‰å…ƒç´ çš„é‡å¤æ¬¡æ•°
        self.curCount = 0
        # å…¨å±€çš„æœ€é•¿ç›¸åŒåºåˆ—é•¿åº¦
        self.maxCount = 0
    
    def findMode(self, root: TreeNode) -> List[int]:
        # æ‰§è¡Œä¸­åºéå†
        self.traverse(root)

        return self.mode
    
    def traverse(self, root: TreeNode) -> None:
        if not root:
            return
        self.traverse(root.left)

        # ä¸­åºéå†ä½ç½®
        if not self.prev:
            # åˆå§‹åŒ–
            self.curCount = 1
            self.maxCount = 1
            self.mode.append(root.val)
        else:
            if root.val == self.prev.val:
                # root.val é‡å¤çš„æƒ…å†µ
                self.curCount += 1
                if self.curCount == self.maxCount:
                    # root.val æ˜¯ä¼—æ•°
                    self.mode.append(root.val)
                elif self.curCount > self.maxCount:
                    # æ›´æ–°ä¼—æ•°
                    self.mode.clear()
                    self.maxCount = self.curCount
                    self.mode.append(root.val)

            if root.val != self.prev.val:
                # root.val ä¸é‡å¤çš„æƒ…å†µ
                self.curCount = 1
                if self.curCount == self.maxCount:
                    self.mode.append(root.val)

        # åˆ«å¿˜äº†æ›´æ–° prev
        self.prev = root
        self.traverse(root.right)
```

https://leetcode.cn/problems/find-mode-in-binary-search-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/first-unique-character-in-a-string çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int firstUniqChar(string s) {
        int count[26] = {0};
        for (char c : s) {
            // å°†å­—ç¬¦è½¬åŒ–æˆæ•°å­—
            count[c - 'a']++;
        }
        for (int i = 0; i < s.length(); i++) {
            char c = s[i];
            if (count[c - 'a'] == 1) {
                // ç¬¬ä¸€ä¸ªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦
                return i;
            }
        }
        return -1;
    }
};
```

```go
// by chatGPT (go)
func firstUniqChar(s string) int {
    // åˆ›å»ºä¸€ä¸ªå¤§å°ä¸º26çš„æ•´æ•°æ•°ç»„count
    count := make([]int, 26)
    // éå†å­—ç¬¦ä¸²sçš„æ¯ä¸€ä¸ªå­—ç¬¦
    for _, c := range s {
        // å°†å­—ç¬¦è½¬åŒ–æˆæ•°å­—
        count[c-'a']++
    }
    // éå†å­—ç¬¦ä¸²sçš„æ¯ä¸€ä¸ªå­—ç¬¦
    for i, c := range s {
        // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦
        if count[c-'a'] == 1 {
            return i
        }
    }
    // æ²¡æœ‰å‡ºç°ä¸€æ¬¡çš„å­—ç¬¦
    return -1
}
```

```java
// by labuladong (java)
class Solution {
    public int firstUniqChar(String s) {
        int[] count = new int[26];
        for (char c : s.toCharArray()) {
            // å°†å­—ç¬¦è½¬åŒ–æˆæ•°å­—
            count[c - 'a']++;
        }
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (count[c - 'a'] == 1) {
                // ç¬¬ä¸€ä¸ªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦
                return i;
            }
        }
        return -1;
    }
}
```

```javascript
// by chatGPT (javascript)
var firstUniqChar = function(s) {
    let count = new Array(26).fill(0);
    for (let i = 0; i < s.length; i++) {
        // å°†å­—ç¬¦è½¬åŒ–æˆæ•°å­—
        count[s.charCodeAt(i) - 97]++;
    }
    for (let i = 0; i < s.length; i++) {
        if (count[s.charCodeAt(i) - 97] === 1) {
            // ç¬¬ä¸€ä¸ªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦
            return i;
        }
    }
    return -1;
}
```

```python
# by chatGPT (python)
class Solution:
    def firstUniqChar(self, s: str) -> int:
        count = [0]*26
        for c in s:
            # å°†å­—ç¬¦è½¬åŒ–æˆæ•°å­—
            count[ord(c) - ord('a')] += 1
        for i in range(len(s)):
            c = s[i]
            if count[ord(c) - ord('a')] == 1:
                # ç¬¬ä¸€ä¸ªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦
                return i
        return -1
```

https://leetcode.cn/problems/first-unique-character-in-a-string çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/flatten-binary-tree-to-linked-list çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // å®šä¹‰ï¼šå°†ä»¥ root ä¸ºæ ¹çš„æ ‘æ‹‰å¹³ä¸ºé“¾è¡¨
    void flatten(TreeNode* root) {
        // base case
        if (root == nullptr) return;
        // å…ˆé€’å½’æ‹‰å¹³å·¦å³å­æ ‘
        flatten(root->left);
        flatten(root->right);

        /****ååºéå†ä½ç½®****/
        // 1ã€å·¦å³å­æ ‘å·²ç»è¢«æ‹‰å¹³æˆä¸€æ¡é“¾è¡¨
        TreeNode* left = root->left;
        TreeNode* right = root->right;

        // 2ã€å°†å·¦å­æ ‘ä½œä¸ºå³å­æ ‘
        root->left = nullptr;
        root->right = left;

        // 3ã€å°†åŸå…ˆçš„å³å­æ ‘æ¥åˆ°å½“å‰å³å­æ ‘çš„æœ«ç«¯
        TreeNode* p = root;
        while (p->right != nullptr) {
            p = p->right;
        }
        p->right = right;
        /**<extend up -50>
        ![](../pictures/äºŒå‰æ ‘ç³»åˆ—/2.jpeg)
        */
    }
};
```

```go
// by chatGPT (go)
// å®šä¹‰ä¸€ä¸ª TreeNode ç»“æ„ä½“

// å®šä¹‰è§£é¢˜å‡½æ•°
func flatten(root *TreeNode)  {
    // base case
    if root == nil {
        return
    }
    // å…ˆé€’å½’æ‹‰å¹³å·¦å³å­æ ‘
    flatten(root.Left)
    flatten(root.Right)

    /****ååºéå†ä½ç½®****/
    // 1ã€å·¦å³å­æ ‘å·²ç»è¢«æ‹‰å¹³æˆä¸€æ¡é“¾è¡¨
    left := root.Left
    right := root.Right

    // 2ã€å°†å·¦å­æ ‘ä½œä¸ºå³å­æ ‘
    root.Left = nil
    root.Right = left

    // 3ã€å°†åŸå…ˆçš„å³å­æ ‘æ¥åˆ°å½“å‰å³å­æ ‘çš„æœ«ç«¯
    p := root
    for p.Right != nil {
        p = p.Right
    }
    p.Right = right
}
```

```java
// by labuladong (java)
class Solution {
    // å®šä¹‰ï¼šå°†ä»¥ root ä¸ºæ ¹çš„æ ‘æ‹‰å¹³ä¸ºé“¾è¡¨
    public void flatten(TreeNode root) {
        // base case
        if (root == null) return;
        // å…ˆé€’å½’æ‹‰å¹³å·¦å³å­æ ‘
        flatten(root.left);
        flatten(root.right);

        /****ååºéå†ä½ç½®****/
        // 1ã€å·¦å³å­æ ‘å·²ç»è¢«æ‹‰å¹³æˆä¸€æ¡é“¾è¡¨
        TreeNode left = root.left;
        TreeNode right = root.right;

        // 2ã€å°†å·¦å­æ ‘ä½œä¸ºå³å­æ ‘
        root.left = null;
        root.right = left;

        // 3ã€å°†åŸå…ˆçš„å³å­æ ‘æ¥åˆ°å½“å‰å³å­æ ‘çš„æœ«ç«¯
        TreeNode p = root;
        while (p.right != null) {
            p = p.right;
        }
        p.right = right;
        /**<extend up -50>
        ![](../pictures/äºŒå‰æ ‘ç³»åˆ—/2.jpeg)
        */
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
    // base case
    if (root == null) return;
    // å…ˆé€’å½’æ‹‰å¹³å·¦å³å­æ ‘
    flatten(root.left);
    flatten(root.right);

    /****ååºéå†ä½ç½®****/
    // 1ã€å·¦å³å­æ ‘å·²ç»è¢«æ‹‰å¹³æˆä¸€æ¡é“¾è¡¨
    var left = root.left;
    var right = root.right;

    // 2ã€å°†å·¦å­æ ‘ä½œä¸ºå³å­æ ‘
    root.left = null;
    root.right = left;

    // 3ã€å°†åŸå…ˆçš„å³å­æ ‘æ¥åˆ°å½“å‰å³å­æ ‘çš„æœ«ç«¯
    var p = root;
    while (p.right != null) {
        p = p.right;
    }
    p.right = right;
};
```

```python
# by chatGPT (python)
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        # base case
        if not root:
            return
        
        # å…ˆé€’å½’æ‹‰å¹³å·¦å³å­æ ‘
        self.flatten(root.left)
        self.flatten(root.right)
        
        # ååºéå†ä½ç½®
        # 1ã€å·¦å³å­æ ‘å·²ç»è¢«æ‹‰å¹³æˆä¸€æ¡é“¾è¡¨
        left = root.left
        right = root.right
        
        # 2ã€å°†å·¦å­æ ‘ä½œä¸ºå³å­æ ‘
        root.left = None
        root.right = left
        
        # 3ã€å°†åŸå…ˆçš„å³å­æ ‘æ¥åˆ°å½“å‰å³å­æ ‘çš„æœ«ç«¯
        p = root
        while p.right:
            p = p.right
        p.right = right
```

https://leetcode.cn/problems/flatten-binary-tree-to-linked-list çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/flatten-nested-list-iterator çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class NestedIterator {
private:
    std::deque<NestedInteger> list;

public:
    NestedIterator(std::vector<NestedInteger> &nestedList) {
        // ä¸ç›´æ¥ç”¨ nestedList çš„å¼•ç”¨ï¼Œæ˜¯å› ä¸ºä¸èƒ½ç¡®å®šå®ƒçš„åº•å±‚å®ç°
        // å¿…é¡»ä¿è¯æ˜¯ dequeï¼Œå¦åˆ™ä¸‹é¢çš„ push_front ä¼šå¾ˆä½æ•ˆ
        list = std::deque<NestedInteger>(nestedList.begin(), nestedList.end());
    }

    int next() {
        // hasNext æ–¹æ³•ä¿è¯äº†ç¬¬ä¸€ä¸ªå…ƒç´ ä¸€å®šæ˜¯æ•´æ•°ç±»å‹
        int val = list.front().getInteger();
        list.pop_front();
        return val;
    }

    bool hasNext() {
        // å¾ªç¯æ‹†åˆ†åˆ—è¡¨å…ƒç´ ï¼Œç›´åˆ°åˆ—è¡¨ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ•´æ•°ç±»å‹
        while (!list.empty() && !list.front().isInteger()) {
            // å½“åˆ—è¡¨å¼€å¤´ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯åˆ—è¡¨ç±»å‹æ—¶ï¼Œè¿›å…¥å¾ªç¯
            std::vector<NestedInteger> first = list.front().getList();
            // å°†ç¬¬ä¸€ä¸ªåˆ—è¡¨æ‰“å¹³å¹¶æŒ‰é¡ºåºæ·»åŠ åˆ°å¼€å¤´
            list.pop_front();
            for (int i = first.size() - 1; i >= 0; i--) {
                list.push_front(first[i]);
            }
        }
        return !list.empty();
    }
};
```

```go
// by chatGPT (go)
type NestedIterator struct {
    list []NestedInteger
}

func Constructor(nestedList []*NestedInteger) *NestedIterator {
    list := make([]NestedInteger, 0)
    for _, nestedInt := range nestedList {
        list = append(list, *nestedInt)
    }
    return &NestedIterator{list}
}

func (this *NestedIterator) Next() int {
    // hasNext æ–¹æ³•ä¿è¯äº†ç¬¬ä¸€ä¸ªå…ƒç´ ä¸€å®šæ˜¯æ•´æ•°ç±»å‹
    res := this.list[0].GetInteger()
    this.list = this.list[1:]
    return res
}

func (this *NestedIterator) HasNext() bool {
    // å¾ªç¯æ‹†åˆ†åˆ—è¡¨å…ƒç´ ï¼Œç›´åˆ°åˆ—è¡¨ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ•´æ•°ç±»å‹
    for len(this.list) > 0 && !this.list[0].IsInteger() {
        // å½“åˆ—è¡¨å¼€å¤´ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯åˆ—è¡¨ç±»å‹æ—¶ï¼Œè¿›å…¥å¾ªç¯
        first := this.list[0].GetList()
        this.list = this.list[1:]
        // å°†ç¬¬ä¸€ä¸ªåˆ—è¡¨æ‰“å¹³å¹¶æŒ‰é¡ºåºæ·»åŠ åˆ°å¼€å¤´
        for i := len(first) - 1; i >= 0; i-- {
            this.list = append([]NestedInteger{first[i]}, this.list...)
        }
    }
    return len(this.list) > 0
}
```

```java
// by labuladong (java)
public class NestedIterator implements Iterator<Integer> {
    private LinkedList<NestedInteger> list;

    public NestedIterator(List<NestedInteger> nestedList) {
        // ä¸ç›´æ¥ç”¨ nestedList çš„å¼•ç”¨ï¼Œæ˜¯å› ä¸ºä¸èƒ½ç¡®å®šå®ƒçš„åº•å±‚å®ç°
        // å¿…é¡»ä¿è¯æ˜¯ LinkedListï¼Œå¦åˆ™ä¸‹é¢çš„ addFirst ä¼šå¾ˆä½æ•ˆ
        list = new LinkedList<>(nestedList);
    }

    public Integer next() {
        // hasNext æ–¹æ³•ä¿è¯äº†ç¬¬ä¸€ä¸ªå…ƒç´ ä¸€å®šæ˜¯æ•´æ•°ç±»å‹
        return list.remove(0).getInteger();
    }

    public boolean hasNext() {
        // å¾ªç¯æ‹†åˆ†åˆ—è¡¨å…ƒç´ ï¼Œç›´åˆ°åˆ—è¡¨ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ•´æ•°ç±»å‹
        while (!list.isEmpty() && !list.get(0).isInteger()) {
            // å½“åˆ—è¡¨å¼€å¤´ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯åˆ—è¡¨ç±»å‹æ—¶ï¼Œè¿›å…¥å¾ªç¯
            List<NestedInteger> first = list.remove(0).getList();
            // å°†ç¬¬ä¸€ä¸ªåˆ—è¡¨æ‰“å¹³å¹¶æŒ‰é¡ºåºæ·»åŠ åˆ°å¼€å¤´
            for (int i = first.size() - 1; i >= 0; i--) {
                list.addFirst(first.get(i));
            }
        }
        return !list.isEmpty();
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @constructor
 * @param {Array<NestedInteger>} nestedList
 */
var NestedIterator = function(nestedList) {
    // ä¸ç›´æ¥ç”¨ nestedList çš„å¼•ç”¨ï¼Œæ˜¯å› ä¸ºä¸èƒ½ç¡®å®šå®ƒçš„åº•å±‚å®ç°
    // å¿…é¡»ä¿è¯æ˜¯ LinkedListï¼Œå¦åˆ™ä¸‹é¢çš„ addFirst ä¼šå¾ˆä½æ•ˆ
    this.list = new LinkedList(nestedList);
};

/**
 * @this NestedIterator
 * @returns {number}
 */
NestedIterator.prototype.next = function() {
    // hasNext æ–¹æ³•ä¿è¯äº†ç¬¬ä¸€ä¸ªå…ƒç´ ä¸€å®šæ˜¯æ•´æ•°ç±»å‹
    return this.list.remove(0).getInteger();
};

/**
 * @this NestedIterator
 * @returns {boolean}
 */
NestedIterator.prototype.hasNext = function() {
    // å¾ªç¯æ‹†åˆ†åˆ—è¡¨å…ƒç´ ï¼Œç›´åˆ°åˆ—è¡¨ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ•´æ•°ç±»å‹
    while (!this.list.isEmpty() && !this.list.get(0).isInteger()) {
        // å½“åˆ—è¡¨å¼€å¤´ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯åˆ—è¡¨ç±»å‹æ—¶ï¼Œè¿›å…¥å¾ªç¯
        const first = this.list.remove(0).getList();
        // å°†ç¬¬ä¸€ä¸ªåˆ—è¡¨æ‰“å¹³å¹¶æŒ‰é¡ºåºæ·»åŠ åˆ°å¼€å¤´
        for (let i = first.length - 1; i >= 0; i--) {
            this.list.addFirst(first[i]);
        }
    }
    return !this.list.isEmpty();
};
```

```python
# by chatGPT (python)
class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        # ä¸ç›´æ¥ç”¨ nestedList çš„å¼•ç”¨ï¼Œæ˜¯å› ä¸ºä¸èƒ½ç¡®å®šå®ƒçš„åº•å±‚å®ç°
        # å¿…é¡»ä¿è¯æ˜¯ LinkedListï¼Œå¦åˆ™ä¸‹é¢çš„ addFirst ä¼šå¾ˆä½æ•ˆ
        self.list = deque(nestedList)

    def next(self) -> int:
        # hasNext æ–¹æ³•ä¿è¯äº†ç¬¬ä¸€ä¸ªå…ƒç´ ä¸€å®šæ˜¯æ•´æ•°ç±»å‹
        return self.list.popleft().getInteger()

    def hasNext(self) -> bool:
        # å¾ªç¯æ‹†åˆ†åˆ—è¡¨å…ƒç´ ï¼Œç›´åˆ°åˆ—è¡¨ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ•´æ•°ç±»å‹
        while self.list and not self.list[0].isInteger():
            # å½“åˆ—è¡¨å¼€å¤´ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯åˆ—è¡¨ç±»å‹æ—¶ï¼Œè¿›å…¥å¾ªç¯
            first = self.list.popleft().getList()
            # å°†ç¬¬ä¸€ä¸ªåˆ—è¡¨æ‰“å¹³å¹¶æŒ‰é¡ºåºæ·»åŠ åˆ°å¼€å¤´
            for i in range(len(first)-1, -1, -1):
                self.list.appendleft(first[i])
        return bool(self.list)
```

https://leetcode.cn/problems/flatten-nested-list-iterator çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/flip-game çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<string> generatePossibleNextMoves(string currentState) {
        vector<string> res;
        for (int i = 1; i < currentState.size(); i++) {
            if (currentState[i] == '+' && currentState[i - 1] == '+') {
                // åšé€‰æ‹©
                currentState[i] = '-';
                currentState[i - 1] = '-';
                res.push_back(currentState);
                // æ’¤é”€é€‰æ‹©
                currentState[i] = '+';
                currentState[i - 1] = '+';
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func generatePossibleNextMoves(currentState string) []string {
    res := []string{}
    arr := []rune(currentState)
    for i := 1; i < len(arr); i++ {
        if arr[i] == '+' && arr[i-1] == '+' {
            // åšé€‰æ‹©
            arr[i] = '-'
            arr[i-1] = '-'
            res = append(res, string(arr))
            // æ’¤é”€é€‰æ‹©
            arr[i] = '+'
            arr[i-1] = '+'
        }
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public List<String> generatePossibleNextMoves(String currentState) {
        List<String> res = new ArrayList<>();
        char[] arr = currentState.toCharArray();
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] == '+' && arr[i - 1] == '+') {
                // åšé€‰æ‹©
                arr[i] = '-';
                arr[i - 1] = '-';
                res.add(new String(arr));
                // æ’¤é”€é€‰æ‹©
                arr[i] = '+';
                arr[i - 1] = '+';
            }
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var generatePossibleNextMoves = function(currentState) {
    var res = [];
    var arr = Array.from(currentState);
    for (var i = 1; i < arr.length; i++) {
        if (arr[i] === '+' && arr[i - 1] === '+') {
            // åšé€‰æ‹©
            arr[i] = '-';
            arr[i - 1] = '-';
            res.push(arr.join(''));
            // æ’¤é”€é€‰æ‹©
            arr[i] = '+';
            arr[i - 1] = '+';
        }
    }
    return res;
}
```

```python
# by chatGPT (python)
class Solution(object):
    def generatePossibleNextMoves(self, currentState):
        """
        :type currentState: str
        :rtype: List[str]
        """
        res = []
        for i in range(1, len(currentState)):
            if currentState[i] == '+' and currentState[i - 1] == '+':
                 # åšé€‰æ‹©
                res.append(currentState[:i - 1] + '--' + currentState[i + 1:])
                # æ’¤é”€é€‰æ‹© is not needed in python due to its immutability of string
        return res
```

https://leetcode.cn/problems/flip-game çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/flip-game-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // ç›´æ¥æŠŠ 293 çš„ä»£ç  copy è¿‡æ¥ï¼Œç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„ä¸‹ä¸€æ­¥
    vector<string> generatePossibleNextMoves(string currentState) {
        vector<string> res;
        for (int i = 1; i < currentState.size(); i++) {
            if (currentState[i] == '+' && currentState[i - 1] == '+') {
                // åšé€‰æ‹©
                currentState[i] = '-';
                currentState[i - 1] = '-';
                res.push_back(currentState);
                // æ’¤é”€é€‰æ‹©
                currentState[i] = '+';
                currentState[i - 1] = '+';
            }
        }
        return res;
    }

    // å¤‡å¿˜å½•
    unordered_map<string, bool> memo;

    bool canWin(string currentState) {
        // è®°å…¥å¤‡å¿˜å½•
        memo.clear();
        return dp(currentState);
    }

    // å®šä¹‰ï¼šè¾“å…¥å­—ç¬¦ä¸² sï¼Œè¿”å›åœ¨æ­¤å±€é¢ä¸‹å…ˆæ‰‹æ˜¯å¦å¯èƒ½èµ¢
    bool dp(string s) {
        if (memo.find(s) != memo.end()) {
            // ä¹‹å‰é‡åˆ°è¿‡è¿™ç§å±€é¢ï¼Œç›´æ¥è¿”å›ç»“æœ
            return memo[s];
        }
        vector<string> nextStates = generatePossibleNextMoves(s);
        bool res = false;
        for (string nextState : nextStates) {
            // åªè¦æœ‰ä¸€ä¸ªæ˜¯ falseï¼Œè¯´æ˜å½“å‰ç©å®¶èµ¢äº†
            bool win = dp(nextState);
            // ååºä½ç½®ï¼Œåšåˆ¤æ–­
            if (!win) {
                res = true;
                break;
            }
        }
        // è®°å…¥å¤‡å¿˜å½•
        memo[s] = res;
        return res;
    }
};
```

```go
// by chatGPT (go)
import "strings"

// ç›´æ¥æŠŠ 293 çš„ä»£ç  copy è¿‡æ¥ï¼Œç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„ä¸‹ä¸€æ­¥
func generatePossibleNextMoves(currentState string) []string {
    res := make([]string, 0)
    arr := []rune(currentState)
    for i := 1; i < len(arr); i++ {
        if arr[i] == '+' && arr[i-1] == '+' {
            // making a choice
            // åšé€‰æ‹©
            arr[i] = '-'
            arr[i-1] = '-'
            res = append(res, string(arr))
            // undo choice
            // æ’¤é”€é€‰æ‹©
            arr[i] = '+'
            arr[i-1] = '+'
        }
    }
    return res
}

func canWin(currentState string) bool {
    // Definition: Enter string s, return whether the first hand can win in this face.
    // å®šä¹‰ï¼šè¾“å…¥å­—ç¬¦ä¸² sï¼Œè¿”å›åœ¨æ­¤å±€é¢ä¸‹å…ˆæ‰‹æ˜¯å¦å¯èƒ½èµ¢
    var dp func(string, map[string]bool) bool
    dp = func(s string, memo map[string]bool) bool {
        if _, ok := memo[s]; ok {
            // have encountered this position before, return the result directly
            // ä¹‹å‰é‡åˆ°è¿‡è¿™ç§å±€é¢ï¼Œç›´æ¥è¿”å›ç»“æœ
            return memo[s]
        }
        res := false
        nextStates := generatePossibleNextMoves(s)
        for _, nextState := range nextStates {
            // As long as one is false, it means the current player won
            // åªè¦æœ‰ä¸€ä¸ªæ˜¯ falseï¼Œè¯´æ˜å½“å‰ç©å®¶èµ¢äº†
            win := dp(nextState, memo)
            // subsequent position, make a judgment
            // ååºä½ç½®ï¼Œåšåˆ¤æ–­
            if !win {
                res = true
                break
            }
        }
        // record in the memo
        // è®°å…¥å¤‡å¿˜å½•
        memo[s] = res
        return res
    }

    // memo is a map that acts as the memoization for dp.
    // å¤‡å¿˜å½•
    memo := make(map[string]bool)
    return dp(currentState, memo)
}
```

```java
// by labuladong (java)
class Solution {

    // ç›´æ¥æŠŠ 293 çš„ä»£ç  copy è¿‡æ¥ï¼Œç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„ä¸‹ä¸€æ­¥
    List<String> generatePossibleNextMoves(String currentState) {
        List<String> res = new ArrayList<>();
        char[] arr = currentState.toCharArray();
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] == '+' && arr[i - 1] == '+') {
                // åšé€‰æ‹©
                arr[i] = '-';
                arr[i - 1] = '-';
                res.add(new String(arr));
                // æ’¤é”€é€‰æ‹©
                arr[i] = '+';
                arr[i - 1] = '+';
            }
        }
        return res;
    }

    // å¤‡å¿˜å½•
    Map<String, Boolean> memo = new HashMap<>();

    public boolean canWin(String currentState) {
        // è®°å…¥å¤‡å¿˜å½•
        memo.clear();
        return dp(currentState);
    }

    // å®šä¹‰ï¼šè¾“å…¥å­—ç¬¦ä¸² sï¼Œè¿”å›åœ¨æ­¤å±€é¢ä¸‹å…ˆæ‰‹æ˜¯å¦å¯èƒ½èµ¢
    boolean dp(String s) {
        if (memo.containsKey(s)) {
            // ä¹‹å‰é‡åˆ°è¿‡è¿™ç§å±€é¢ï¼Œç›´æ¥è¿”å›ç»“æœ
            return memo.get(s);
        }
        boolean res = false;
        List<String> nextStates = generatePossibleNextMoves(s);
        for (String nextState : nextStates) {
            // åªè¦æœ‰ä¸€ä¸ªæ˜¯ falseï¼Œè¯´æ˜å½“å‰ç©å®¶èµ¢äº†
            boolean win = dp(nextState);
            // ååºä½ç½®ï¼Œåšåˆ¤æ–­
            if (!win) {
                res = true;
                break;
            }
        }
        // è®°å…¥å¤‡å¿˜å½•
        memo.put(s, res);
        return res;
    }
}
```

```python
# by chatGPT (python)
class Solution:

    # ç›´æ¥æŠŠ 293 çš„ä»£ç  copy è¿‡æ¥ï¼Œç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„ä¸‹ä¸€æ­¥
    def generatePossibleNextMoves(self, currentState):
        res = []
        arr = list(currentState)
        for i in range(1, len(arr)):
            if arr[i] == '+' and arr[i - 1] == '+':
                # åšé€‰æ‹©
                arr[i] = '-'
                arr[i - 1] = '-'
                res.append("".join(arr))
                # æ’¤é”€é€‰æ‹©
                arr[i] = '+'
                arr[i - 1] = '+'
        return res

    # å¤‡å¿˜å½•
    memo = {}

    def canWin(self, currentState):
        # è®°å…¥å¤‡å¿˜å½•
        self.memo.clear()
        return self.dp(currentState)

    # å®šä¹‰ï¼šè¾“å…¥å­—ç¬¦ä¸² sï¼Œè¿”å›åœ¨æ­¤å±€é¢ä¸‹å…ˆæ‰‹æ˜¯å¦å¯èƒ½èµ¢
    def dp(self, s):
        if s in self.memo:
            # ä¹‹å‰é‡åˆ°è¿‡è¿™ç§å±€é¢ï¼Œç›´æ¥è¿”å›ç»“æœ
            return self.memo[s]
        res = False
        nextStates = self.generatePossibleNextMoves(s)
        for nextState in nextStates:
            # åªè¦æœ‰ä¸€ä¸ªæ˜¯ falseï¼Œè¯´æ˜å½“å‰ç©å®¶èµ¢äº†
            win = self.dp(nextState)
            # ååºä½ç½®ï¼Œåšåˆ¤æ–­
            if not win:
                res = True
                break
        # è®°å…¥å¤‡å¿˜å½•
        self.memo[s] = res
        return res
```

https://leetcode.cn/problems/flip-game-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/freedom-trail çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    // å­—ç¬¦ -> ç´¢å¼•åˆ—è¡¨
    unordered_map<char, vector<int>> charToIndex;
    // å¤‡å¿˜å½•
    vector<vector<int>> memo;

    /* ä¸»å‡½æ•° */
    int findRotateSteps(string ring, string key) {
        int m = ring.size();
        int n = key.size();
        // å¤‡å¿˜å½•å…¨éƒ¨åˆå§‹åŒ–ä¸º 0
        memo.resize(m, vector<int>(n, 0));
        // è®°å½•åœ†ç¯ä¸Šå­—ç¬¦åˆ°ç´¢å¼•çš„æ˜ å°„
        for (int i = 0; i < ring.size(); i++) {
            charToIndex[ring[i]].push_back(i);
        }
        // åœ†ç›˜æŒ‡é’ˆæœ€åˆæŒ‡å‘ 12 ç‚¹é’Ÿæ–¹å‘ï¼Œ
        // ä»ç¬¬ä¸€ä¸ªå­—ç¬¦å¼€å§‹è¾“å…¥ key
        return dp(ring, 0, key, 0);
    }

    // è®¡ç®—åœ†ç›˜æŒ‡é’ˆåœ¨ ring[i]ï¼Œè¾“å…¥ key[j..] çš„æœ€å°‘æ“ä½œæ•°
    int dp(string& ring, int i, string& key, int j) {
        // base case å®Œæˆè¾“å…¥
        if (j == key.size()) return 0;
        // æŸ¥æ‰¾å¤‡å¿˜å½•ï¼Œé¿å…é‡å å­é—®é¢˜
        if (memo[i][j] != 0) return memo[i][j];

        int n = ring.size();
        // åšé€‰æ‹©
        int res = INT_MAX;
        // ring ä¸Šå¯èƒ½æœ‰å¤šä¸ªå­—ç¬¦ key[j]
        for (int k : charToIndex[key[j]]) {
            // æ‹¨åŠ¨æŒ‡é’ˆçš„æ¬¡æ•°
            int delta = abs(k - i);
            // é€‰æ‹©é¡ºæ—¶é’ˆè¿˜æ˜¯é€†æ—¶é’ˆ
            delta = min(delta, n - delta);
            // å°†æŒ‡é’ˆæ‹¨åˆ° ring[k]ï¼Œç»§ç»­è¾“å…¥ key[j+1..]
            int subProblem = dp(ring, k, key, j + 1);
            // é€‰æ‹©ã€Œæ•´ä½“ã€æ“ä½œæ¬¡æ•°æœ€å°‘çš„
            // åŠ ä¸€æ˜¯å› ä¸ºæŒ‰åŠ¨æŒ‰é’®ä¹Ÿæ˜¯ä¸€æ¬¡æ“ä½œ
            res = min(res, 1 + delta + subProblem);
        }
        // å°†ç»“æœå­˜å…¥å¤‡å¿˜å½•
        memo[i][j] = res;
        return res;
    }
};
```

```go
// by chatGPT (go)
// è®¡ç®—ä¸¤ä¸ªæ•°ç›¸å‡çš„ç»å¯¹å€¼
func abs(a, b int) int {
    if a > b {
        return b - a + 2*b
    } else {
        return a - b + 2*b
    }
}

// è¿”å›ä¸¤ä¸ªæ•°çš„æœ€å°å€¼
func min(a, b int) int {
    if a < b {
        return a
    } else {
        return b
    }
}

/* ä¸»å‡½æ•° */
func findRotateSteps(ring string, key string) int {
    m := len(ring)
    n := len(key)
    // å¤‡å¿˜å½•å…¨éƒ¨åˆå§‹åŒ–ä¸º 0
    memo := make([][]int, m)
    for i := range memo {
        memo[i] = make([]int, n)
    }
    // è®°å½•åœ†ç¯ä¸Šå­—ç¬¦åˆ°ç´¢å¼•çš„æ˜ å°„
    charToIndex := make(map[byte][]int)
    for i := range ring {
        charToIndex[ring[i]] = append(charToIndex[ring[i]], i)
    }
    // åœ†ç›˜æŒ‡é’ˆæœ€åˆæŒ‡å‘ 12 ç‚¹é’Ÿæ–¹å‘ï¼Œ
    // ä»ç¬¬ä¸€ä¸ªå­—ç¬¦å¼€å§‹è¾“å…¥ key
    return dp(ring, 0, key, 0, charToIndex, memo)
}

// è®¡ç®—åœ†ç›˜æŒ‡é’ˆåœ¨ ring[i]ï¼Œè¾“å…¥ key[j..] çš„æœ€å°‘æ“ä½œæ•°
func dp(ring string, i int, key string, j int, charToIndex map[byte][]int, memo [][]int) int {
    // base case å®Œæˆè¾“å…¥
    if j == len(key) {
        return 0
    }
    // æŸ¥æ‰¾å¤‡å¿˜å½•ï¼Œé¿å…é‡å å­é—®é¢˜
    if memo[i][j] != 0 {
        return memo[i][j]
    }

    n := len(ring)
    // åšé€‰æ‹©
    res := math.MaxInt32
    // ring ä¸Šå¯èƒ½æœ‰å¤šä¸ªå­—ç¬¦ key[j]
    for _, k := range charToIndex[key[j]] {
        // æ‹¨åŠ¨æŒ‡é’ˆçš„æ¬¡æ•°
        delta := abs(k-i, n)
        // é€‰æ‹©é¡ºæ—¶é’ˆè¿˜æ˜¯é€†æ—¶é’ˆ
        delta = min(delta, n-delta)
        // å°†æŒ‡é’ˆæ‹¨åˆ° ring[k]ï¼Œç»§ç»­è¾“å…¥ key[j+1..]
        subProblem := dp(ring, k, key, j+1, charToIndex, memo)
        // é€‰æ‹©ã€Œæ•´ä½“ã€æ“ä½œæ¬¡æ•°æœ€å°‘çš„
        // åŠ ä¸€æ˜¯å› ä¸ºæŒ‰åŠ¨æŒ‰é’®ä¹Ÿæ˜¯ä¸€æ¬¡æ“ä½œ
        res = min(res, 1+delta+subProblem)
    }
    // å°†ç»“æœå­˜å…¥å¤‡å¿˜å½•
    memo[i][j] = res
    return res
}
```

```java
// by chatGPT (java)
class Solution {
    // å­—ç¬¦ -> ç´¢å¼•åˆ—è¡¨
    Map<Character, List<Integer>> charToIndex = new HashMap<>();
    // å¤‡å¿˜å½•
    int[][] memo;

    /* ä¸»å‡½æ•° */
    public int findRotateSteps(String ring, String key) {
        int m = ring.length();
        int n = key.length();
        // å¤‡å¿˜å½•å…¨éƒ¨åˆå§‹åŒ–ä¸º 0
        memo = new int[m][n];
        for (int[] row : memo) {
            Arrays.fill(row, 0);
        }
        // è®°å½•åœ†ç¯ä¸Šå­—ç¬¦åˆ°ç´¢å¼•çš„æ˜ å°„
        for (int i = 0; i < ring.length(); i++) {
            char c = ring.charAt(i);
            List<Integer> list = charToIndex.getOrDefault(c, new ArrayList<>());
            list.add(i);
            charToIndex.put(c, list);
        }
        // åœ†ç›˜æŒ‡é’ˆæœ€åˆæŒ‡å‘ 12 ç‚¹é’Ÿæ–¹å‘ï¼Œ
        // ä»ç¬¬ä¸€ä¸ªå­—ç¬¦å¼€å§‹è¾“å…¥ key
        return dp(ring, 0, key, 0);
    }

    // è®¡ç®—åœ†ç›˜æŒ‡é’ˆåœ¨ ring[i]ï¼Œè¾“å…¥ key[j..] çš„æœ€å°‘æ“ä½œæ•°
    private int dp(String ring, int i, String key, int j) {
        // base case å®Œæˆè¾“å…¥
        if (j == key.length()) return 0;
        // æŸ¥æ‰¾å¤‡å¿˜å½•ï¼Œé¿å…é‡å å­é—®é¢˜
        if (memo[i][j] != 0) return memo[i][j];

        int n = ring.length();
        // åšé€‰æ‹©
        int res = Integer.MAX_VALUE;
        char c = key.charAt(j);
        // ring ä¸Šå¯èƒ½æœ‰å¤šä¸ªå­—ç¬¦ key[j]
        for (int k : charToIndex.getOrDefault(c, new ArrayList<>())) {
            // æ‹¨åŠ¨æŒ‡é’ˆçš„æ¬¡æ•°
            int delta = Math.abs(k - i);
            // é€‰æ‹©é¡ºæ—¶é’ˆè¿˜æ˜¯é€†æ—¶é’ˆ
            delta = Math.min(delta, n - delta);
            // å°†æŒ‡é’ˆæ‹¨åˆ° ring[k]ï¼Œç»§ç»­è¾“å…¥ key[j+1..]
            int subProblem = dp(ring, k, key, j + 1);
            // é€‰æ‹©ã€Œæ•´ä½“ã€æ“ä½œæ¬¡æ•°æœ€å°‘çš„
            // åŠ ä¸€æ˜¯å› ä¸ºæŒ‰åŠ¨æŒ‰é’®ä¹Ÿæ˜¯ä¸€æ¬¡æ“ä½œ
            res = Math.min(res, 1 + delta + subProblem);
        }
        // å°†ç»“æœå­˜å…¥å¤‡å¿˜å½•
        memo[i][j] = res;
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var findRotateSteps = function(ring, key) {
    // å­—ç¬¦ -> ç´¢å¼•åˆ—è¡¨
    const charToIndex = {};
    // å¤‡å¿˜å½•
    const memo = [];

    /* è®°å½•åœ†ç¯ä¸Šå­—ç¬¦åˆ°ç´¢å¼•çš„æ˜ å°„ */
    for (let i = 0; i < ring.length; i++) {
        const char = ring.charAt(i);
        if (charToIndex[char] === undefined) {
            charToIndex[char] = [];
        }
        charToIndex[char].push(i);
    }

    /* è®¡ç®—åœ†ç›˜æŒ‡é’ˆåœ¨ ring[i]ï¼Œè¾“å…¥ key[j..] çš„æœ€å°‘æ“ä½œæ•° */
    function dp(i, j) {
        // base case å®Œæˆè¾“å…¥
        if (j === key.length) {
            return 0;
        }
        // æŸ¥æ‰¾å¤‡å¿˜å½•ï¼Œé¿å…é‡å å­é—®é¢˜
        if (memo[i] !== undefined && memo[i][j] !== undefined) {
            return memo[i][j];
        }

        const n = ring.length;
        // åšé€‰æ‹©
        let res = Infinity;
        // ring ä¸Šå¯èƒ½æœ‰å¤šä¸ªå­—ç¬¦ key[j]
        for (let k of charToIndex[key.charAt(j)]) {
            // æ‹¨åŠ¨æŒ‡é’ˆçš„æ¬¡æ•°
            let delta = Math.abs(k - i);
            // é€‰æ‹©é¡ºæ—¶é’ˆè¿˜æ˜¯é€†æ—¶é’ˆ
            delta = Math.min(delta, n - delta);
            // å°†æŒ‡é’ˆæ‹¨åˆ° ring[k]ï¼Œç»§ç»­è¾“å…¥ key[j+1..]
            const subProblem = dp(k, j + 1);
            // é€‰æ‹©ã€Œæ•´ä½“ã€æ“ä½œæ¬¡æ•°æœ€å°‘çš„
            // åŠ ä¸€æ˜¯å› ä¸ºæŒ‰åŠ¨æŒ‰é’®ä¹Ÿæ˜¯ä¸€æ¬¡æ“ä½œ
            res = Math.min(res, 1 + delta + subProblem);
        }
        // å°†ç»“æœå­˜å…¥å¤‡å¿˜å½•
        if (memo[i] === undefined) {
            memo[i] = [];
        }
        memo[i][j] = res;
        return res;
    }

    return dp(0, 0);
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        # å­—ç¬¦ -> ç´¢å¼•åˆ—è¡¨
        self.charToIndex = {}
        # å¤‡å¿˜å½•
        self.memo = []

    # ä¸»å‡½æ•°
    def findRotateSteps(self, ring: str, key: str) -> int:
        m = len(ring)
        n = len(key)
        # å¤‡å¿˜å½•å…¨éƒ¨åˆå§‹åŒ–ä¸º 0
        self.memo = [[0] * n for _ in range(m)]
        # è®°å½•åœ†ç¯ä¸Šå­—ç¬¦åˆ°ç´¢å¼•çš„æ˜ å°„
        for i in range(m):
            char = ring[i]
            if char in self.charToIndex:
                self.charToIndex[char].append(i)
            else:
                self.charToIndex[char] = [i]
        # åœ†ç›˜æŒ‡é’ˆæœ€åˆæŒ‡å‘ 12 ç‚¹é’Ÿæ–¹å‘ï¼Œ
        # ä»ç¬¬ä¸€ä¸ªå­—ç¬¦å¼€å§‹è¾“å…¥ key
        return self.dp(ring, 0, key, 0)

    # è®¡ç®—åœ†ç›˜æŒ‡é’ˆåœ¨ ring[i]ï¼Œè¾“å…¥ key[j..] çš„æœ€å°‘æ“ä½œæ•°
    def dp(self, ring: str, i: int, key: str, j: int) -> int:
        # base case å®Œæˆè¾“å…¥
        if j == len(key):
            return 0
        # æŸ¥æ‰¾å¤‡å¿˜å½•ï¼Œé¿å…é‡å å­é—®é¢˜
        if self.memo[i][j] != 0:
            return self.memo[i][j]

        n = len(ring)
        # åšé€‰æ‹©
        res = float('inf')
        # ring ä¸Šå¯èƒ½æœ‰å¤šä¸ªå­—ç¬¦ key[j]
        for k in self.charToIndex[key[j]]:
            # æ‹¨åŠ¨æŒ‡é’ˆçš„æ¬¡æ•°
            delta = abs(k - i)
            # é€‰æ‹©é¡ºæ—¶é’ˆè¿˜æ˜¯é€†æ—¶é’ˆ
            delta = min(delta, n - delta)
            # å°†æŒ‡é’ˆæ‹¨åˆ° ring[k]ï¼Œç»§ç»­è¾“å…¥ key[j+1..]
            subProblem = self.dp(ring, k, key, j + 1)
            # é€‰æ‹©ã€Œæ•´ä½“ã€æ“ä½œæ¬¡æ•°æœ€å°‘çš„
            # åŠ ä¸€æ˜¯å› ä¸ºæŒ‰åŠ¨æŒ‰é’®ä¹Ÿæ˜¯ä¸€æ¬¡æ“ä½œ
            res = min(res, 1 + delta + subProblem)

        # å°†ç»“æœå­˜å…¥å¤‡å¿˜å½•
        self.memo[i][j] = res
        return res
```

https://leetcode.cn/problems/freedom-trail çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map<Node*, Node*> originToClone;
        // ç¬¬ä¸€æ¬¡éå†ï¼Œå…ˆæŠŠæ‰€æœ‰èŠ‚ç‚¹å…‹éš†å‡ºæ¥
        for (Node* p = head; p != nullptr; p = p->next) {
            if (originToClone.find(p) == originToClone.end()) {
                originToClone[p] = new Node(p->val);
            }
        }
        // ç¬¬äºŒæ¬¡éå†ï¼ŒæŠŠå…‹éš†èŠ‚ç‚¹çš„ç»“æ„è¿æ¥å¥½
        for (Node* p = head; p != nullptr; p = p->next) {
            if (p->next != nullptr) {
                originToClone[p]->next = originToClone[p->next];
            }
            if (p->random != nullptr) {
                originToClone[p]->random = originToClone[p->random];
            }
        }
        // è¿”å›å…‹éš†ä¹‹åçš„å¤´ç»“ç‚¹
        return originToClone[head];
    }
};

// ç”¨é€’å½’çš„æ–¹å¼è¿›è¡Œéå†
class Solution2 {
public:
    Node* copyRandomList(Node* head) {
        traverse(head);
        return originToClone[head];
    }

private:
    // è®°å½• DFS éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
    unordered_set<Node*> visited;
    // è®°å½•åŸèŠ‚ç‚¹åˆ°å…‹éš†èŠ‚ç‚¹çš„æ˜ å°„
    unordered_map<Node*, Node*> originToClone;

    // DFS å›¾éå†æ¡†æ¶
    void traverse(Node* node) {
        if (node == nullptr) {
            return;
        }
        if (visited.find(node) != visited.end()) {
            return;
        }
        // å‰åºä½ç½®ï¼Œæ ‡è®°ä¸ºå·²è®¿é—®
        visited.insert(node);
        // å‰åºä½ç½®ï¼Œå…‹éš†èŠ‚ç‚¹
        if (originToClone.find(node) == originToClone.end()) {
            originToClone[node] = new Node(node->val);
        }
        Node* cloneNode = originToClone[node];

        // é€’å½’éå†é‚»å±…èŠ‚ç‚¹ï¼Œå¹¶æ„å»ºå…‹éš†å›¾
        // é€’å½’ä¹‹åï¼Œé‚»å±…èŠ‚ç‚¹ä¸€å®šå­˜åœ¨ originToClone ä¸­

        traverse(node->next);
        cloneNode->next = originToClone[node->next];

        traverse(node->random);
        cloneNode->random = originToClone[node->random];
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Next *Node
 *	   Random *Node
 * }
 */

func copyRandomList(head *Node) *Node {
    originToClone := make(map[*Node]*Node)
    // ç¬¬ä¸€æ¬¡éå†ï¼Œå…ˆæŠŠæ‰€æœ‰èŠ‚ç‚¹å…‹éš†å‡ºæ¥
    for p := head; p != nil; p = p.Next {
        if _, ok := originToClone[p]; !ok {
            originToClone[p] = &Node{Val:p.Val}
        }
    }
    // ç¬¬äºŒæ¬¡éå†ï¼ŒæŠŠå…‹éš†èŠ‚ç‚¹çš„ç»“æ„è¿æ¥å¥½
    for p := head; p != nil; p = p.Next {
        if p.Next != nil {
            originToClone[p].Next = originToClone[p.Next]
        }
        if p.Random != nil {
            originToClone[p].Random = originToClone[p.Random]
        }
    }
    // è¿”å›å…‹éš†ä¹‹åçš„å¤´ç»“ç‚¹
    return originToClone[head]
}

// ç”¨é€’å½’çš„æ–¹å¼è¿›è¡Œéå†
func copyRandomList2(head *Node) *Node {
    if head == nil {
        return nil
    }
    visited := make(map[*Node]bool)
    originToClone := make(map[*Node]*Node)
    traverse(head, visited, originToClone)
    return originToClone[head]
}

// DFS å›¾éå†æ¡†æ¶
func traverse(node *Node, visited map[*Node]bool, originToClone map[*Node]*Node) {
    if visited[node] {
        return
    }
    // å‰åºä½ç½®ï¼Œæ ‡è®°ä¸ºå·²è®¿é—®
    visited[node] = true
    // å‰åºä½ç½®ï¼Œå…‹éš†èŠ‚ç‚¹
    if _, ok := originToClone[node]; !ok {
        originToClone[node] = &Node{Val:node.Val}
    }
    cloneNode := originToClone[node]

    // é€’å½’éå†é‚»å±…èŠ‚ç‚¹ï¼Œå¹¶æ„å»ºå…‹éš†å›¾
    // é€’å½’ä¹‹åï¼Œé‚»å±…èŠ‚ç‚¹ä¸€å®šå­˜åœ¨ originToClone ä¸­
    if node.Next != nil {
        traverse(node.Next, visited, originToClone)
        cloneNode.Next = originToClone[node.Next]
    }
    if node.Random != nil {
        traverse(node.Random, visited, originToClone)
        cloneNode.Random = originToClone[node.Random]
    }
}
```

```java
// by labuladong (java)
class Solution {
    public Node copyRandomList(Node head) {
        HashMap<Node, Node> originToClone = new HashMap<>();
        // ç¬¬ä¸€æ¬¡éå†ï¼Œå…ˆæŠŠæ‰€æœ‰èŠ‚ç‚¹å…‹éš†å‡ºæ¥
        for (Node p = head; p != null; p = p.next) {
            if (!originToClone.containsKey(p)) {
                originToClone.put(p, new Node(p.val));
            }
        }
        // ç¬¬äºŒæ¬¡éå†ï¼ŒæŠŠå…‹éš†èŠ‚ç‚¹çš„ç»“æ„è¿æ¥å¥½
        for (Node p = head; p != null; p = p.next) {
            if (p.next != null) {
                originToClone.get(p).next = originToClone.get(p.next);
            }
            if (p.random != null) {
                originToClone.get(p).random = originToClone.get(p.random);
            }
        }
        // è¿”å›å…‹éš†ä¹‹åçš„å¤´ç»“ç‚¹
        return originToClone.get(head);
    }
}

// ç”¨é€’å½’çš„æ–¹å¼è¿›è¡Œéå†
class Solution2 {
    public Node copyRandomList(Node head) {
        traverse(head);
        return originToClone.get(head);
    }

    // è®°å½• DFS éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
    HashSet<Node> visited = new HashSet<>();
    // è®°å½•åŸèŠ‚ç‚¹åˆ°å…‹éš†èŠ‚ç‚¹çš„æ˜ å°„
    HashMap<Node, Node> originToClone = new HashMap<>();

    // DFS å›¾éå†æ¡†æ¶
    void traverse(Node node) {
        if (node == null) {
            return;
        }
        if (visited.contains(node)) {
            return;
        }
        // å‰åºä½ç½®ï¼Œæ ‡è®°ä¸ºå·²è®¿é—®
        visited.add(node);
        // å‰åºä½ç½®ï¼Œå…‹éš†èŠ‚ç‚¹
        if (!originToClone.containsKey(node)) {
            originToClone.put(node, new Node(node.val));
        }
        Node cloneNode = originToClone.get(node);

        // é€’å½’éå†é‚»å±…èŠ‚ç‚¹ï¼Œå¹¶æ„å»ºå…‹éš†å›¾
        // é€’å½’ä¹‹åï¼Œé‚»å±…èŠ‚ç‚¹ä¸€å®šå­˜åœ¨ originToClone ä¸­

        traverse(node.next);
        cloneNode.next = originToClone.get(node.next);

        traverse(node.random);
        cloneNode.random = originToClone.get(node.random);
    }
}
```

```javascript
// by chatGPT (javascript)
var copyRandomList = function(head) {
    const originToClone = new Map();

    // ç¬¬ä¸€æ¬¡éå†ï¼Œå…ˆæŠŠæ‰€æœ‰èŠ‚ç‚¹å…‹éš†å‡ºæ¥
    for (let p = head; p != null; p = p.next) {
        if (!originToClone.has(p)) {
            originToClone.set(p, new Node(p.val));
        }
    }

    // ç¬¬äºŒæ¬¡éå†ï¼ŒæŠŠå…‹éš†èŠ‚ç‚¹çš„ç»“æ„è¿æ¥å¥½
    for (let p = head; p != null; p = p.next) {
        if (p.next != null) {
            originToClone.get(p).next = originToClone.get(p.next);
        }
        if (p.random != null) {
            originToClone.get(p).random = originToClone.get(p.random);
        }
    }

    // è¿”å›å…‹éš†ä¹‹åçš„å¤´ç»“ç‚¹
    return originToClone.get(head);
};

// ç”¨é€’å½’çš„æ–¹å¼è¿›è¡Œéå†
var copyRandomList2 = function(head) {
    const visited = new Set();
    const originToClone = new Map();

    // DFS å›¾éå†æ¡†æ¶
    const traverse = (node) => {
        if (node == null) {
            return;
        }
        if (visited.has(node)) {
            return;
        }

        // å‰åºä½ç½®ï¼Œæ ‡è®°ä¸ºå·²è®¿é—®
        visited.add(node);

        // å‰åºä½ç½®ï¼Œå…‹éš†èŠ‚ç‚¹
        if (!originToClone.has(node)) {
            originToClone.set(node, new Node(node.val));
        }

        const cloneNode = originToClone.get(node);

        // é€’å½’éå†é‚»å±…èŠ‚ç‚¹ï¼Œå¹¶æ„å»ºå…‹éš†å›¾
        // é€’å½’ä¹‹åï¼Œé‚»å±…èŠ‚ç‚¹ä¸€å®šå­˜åœ¨ originToClone ä¸­

        traverse(node.next);
        cloneNode.next = originToClone.get(node.next);

        traverse(node.random);
        cloneNode.random = originToClone.get(node.random);
    };

    traverse(head);
    return originToClone.get(head);
};
```

```python
# by chatGPT (python)
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        originToClone = {}
        # ç¬¬ä¸€æ¬¡éå†ï¼Œå…ˆæŠŠæ‰€æœ‰èŠ‚ç‚¹å…‹éš†å‡ºæ¥
        for p in [head]:
            while p:
                if p not in originToClone:
                    originToClone[p] = Node(p.val)
                p = p.next
        # ç¬¬äºŒæ¬¡éå†ï¼ŒæŠŠå…‹éš†èŠ‚ç‚¹çš„ç»“æ„è¿æ¥å¥½
        for p in [head]:
            while p:
                if p.next:
                    originToClone[p].next = originToClone[p.next]
                if p.random:
                    originToClone[p].random = originToClone[p.random]
                p = p.next
        # è¿”å›å…‹éš†ä¹‹åçš„å¤´ç»“ç‚¹
        return originToClone.get(head)

class Solution2:
    def copyRandomList(self, head: 'Node') -> 'Node':
        self.visited = set()
        self.originToClone = {}
        self.traverse(head)
        return self.originToClone.get(head)

    # DFS å›¾éå†æ¡†æ¶
    def traverse(self, node):
        if not node:
            return
        if node in self.visited:
            return
        # å‰åºä½ç½®ï¼Œæ ‡è®°ä¸ºå·²è®¿é—®
        self.visited.add(node)
        # å‰åºä½ç½®ï¼Œå…‹éš†èŠ‚ç‚¹
        if node not in self.originToClone:
            self.originToClone[node] = Node(node.val)
        cloneNode = self.originToClone[node]

        # é€’å½’éå†é‚»å±…èŠ‚ç‚¹ï¼Œå¹¶æ„å»ºå…‹éš†å›¾
        # é€’å½’ä¹‹åï¼Œé‚»å±…èŠ‚ç‚¹ä¸€å®šå­˜åœ¨ originToClone ä¸­

        self.traverse(node.next)
        cloneNode.next = self.originToClone.get(node.next)

        self.traverse(node.random)
        cloneNode.random = self.originToClone.get(node.random)
```

https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/g5c51o çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
// ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—è§£å†³è¿™é“é¢˜
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
        unordered_map<int, int> valToFreq;
        for (int v : nums) {
            valToFreq[v]++;
        }

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        // é˜Ÿåˆ—æŒ‰ç…§é”®å€¼å¯¹ä¸­çš„å€¼ï¼ˆå…ƒç´ å‡ºç°é¢‘ç‡ï¼‰ä»å°åˆ°å¤§æ’åº
        for (auto entry : valToFreq) {
            pq.push(make_pair(entry.second, entry.first));
            if (pq.size() > k) {
                // å¼¹å‡ºæœ€å°å…ƒç´ ï¼Œç»´æŠ¤é˜Ÿåˆ—å†…æ˜¯ k ä¸ªé¢‘ç‡æœ€å¤§çš„å…ƒç´ 
                pq.pop();
            }
        }

        vector<int> res(k);
        for (int i = 0; i < k; i++) {
            // res æ•°ç»„ä¸­å­˜å‚¨å‰ k ä¸ªæœ€å¤§å…ƒç´ 
            res[i] = pq.top().second;
            pq.pop();
        }

        return res;
    }
};

// ç”¨è®¡æ•°æ’åºçš„æ–¹æ³•è§£å†³è¿™é“é¢˜
class Solution2 {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
        unordered_map<int, int> valToFreq;
        for (int v : nums) {
            valToFreq[v]++;
        }

        // é¢‘ç‡ -> è¿™ä¸ªé¢‘ç‡æœ‰å“ªäº›å…ƒç´ 
        vector<vector<int>> freqToVals(nums.size() + 1);
        for (auto entry : valToFreq) {
            int val = entry.first;
            int freq = entry.second;
            freqToVals[freq].push_back(val);
        }

        vector<int> res;
        // freqToVals ä»åå¾€å‰å­˜å‚¨ç€å‡ºç°æœ€å¤šçš„å…ƒç´ 
        for (int i = freqToVals.size() - 1; i >= 0; i--) {
            if (freqToVals[i].size() == 0) continue;
            for (int j = 0; j < freqToVals[i].size(); j++) {
                // å°†å‡ºç°æ¬¡æ•°æœ€å¤šçš„ k ä¸ªå…ƒç´ è£…å…¥ res
                res.push_back(freqToVals[i][j]);
                if (res.size() == k) {
                    return res;
                }
            }
        }

        return res;
    }
};
```

```go
// by chatGPT (go)
// ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—è§£å†³è¿™é“é¢˜
func topKFrequent(nums []int, k int) []int {
    // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
    valToFreq := make(map[int]int)
    for _, v := range nums {
        valToFreq[v] = valToFreq[v] + 1
    }

    // ä¸ªæ€§åŒ–çš„ lambda
    lessFn := func(a, b interface{}) bool {
        a.(*MapEntry).Value.(int)
        return a.(*MapEntry).Value.(int) < b.(*MapEntry).Value.(int)
    }

    pq := priorityqueue.NewPriorityQueue(lessFn)
    for key, val := range valToFreq {
        pq.Insert(&MapEntry{Key: key, Value: val})
        if pq.Len() > k {
            pq.Pop()
        }
    }

    res := make([]int, k)
    for i := k - 1; i >= 0; i-- {
        // res æ•°ç»„ä¸­å­˜å‚¨å‰ k ä¸ªæœ€å¤§å…ƒç´ 
        res[i] = pq.Pop().(*MapEntry).Key.(int)
    }

    return res
}

// MapEntry æä¾›ç»™ä¼˜å…ˆçº§é˜Ÿåˆ—ä½¿ç”¨çš„æ•°æ®ç»“æ„
type MapEntry struct {
    Key   interface{}
    Value interface{}
}

// ç”¨è®¡æ•°æ’åºçš„æ–¹æ³•è§£å†³è¿™é“é¢˜
func topKFrequent2(nums []int, k int) []int {
    // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
    valToFreq := make(map[int]int)
    for _, v := range nums {
        valToFreq[v] = valToFreq[v] + 1
    }

    // é¢‘ç‡ -> è¿™ä¸ªé¢‘ç‡æœ‰å“ªäº›å…ƒç´ 
    freqToVals := make([][]int, len(nums)+1)
    for key, val := range valToFreq {
        if freqToVals[val] == nil {
            freqToVals[val] = make([]int, 0)
        }
        freqToVals[val] = append(freqToVals[val], key)
    }

    res := make([]int, k)
    p := 0
    // freqToVals ä»åå¾€å‰å­˜å‚¨ç€å‡ºç°æœ€å¤šçš„å…ƒç´ 
    for i := len(freqToVals) - 1; i > 0; i-- {
        valList := freqToVals[i]
        if valList == nil {
            continue
        }
        for _, val := range valList {
            // å°†å‡ºç°æ¬¡æ•°æœ€å¤šçš„ k ä¸ªå…ƒç´ è£…å…¥ res
            res[p] = val
            p++
            if p == k {
                return res
            }
        }
    }

    return nil
}
```

```java
// by labuladong (java)
// ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—è§£å†³è¿™é“é¢˜
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
        HashMap<Integer, Integer> valToFreq = new HashMap<>();
        for (int v : nums) {
            valToFreq.put(v, valToFreq.getOrDefault(v, 0) + 1);
        }

        PriorityQueue<Map.Entry<Integer, Integer>>
                pq = new PriorityQueue<>((entry1, entry2) -> {
            // é˜Ÿåˆ—æŒ‰ç…§é”®å€¼å¯¹ä¸­çš„å€¼ï¼ˆå…ƒç´ å‡ºç°é¢‘ç‡ï¼‰ä»å°åˆ°å¤§æ’åº
            return entry1.getValue().compareTo(entry2.getValue());
        });

        for (Map.Entry<Integer, Integer> entry : valToFreq.entrySet()) {
            pq.offer(entry);
            if (pq.size() > k) {
                // å¼¹å‡ºæœ€å°å…ƒç´ ï¼Œç»´æŠ¤é˜Ÿåˆ—å†…æ˜¯ k ä¸ªé¢‘ç‡æœ€å¤§çš„å…ƒç´ 
                pq.poll();
            }
        }

        int[] res = new int[k];
        for (int i = k - 1; i >= 0; i--) {
            // res æ•°ç»„ä¸­å­˜å‚¨å‰ k ä¸ªæœ€å¤§å…ƒç´ 
            res[i] = pq.poll().getKey();
        }

        return res;
    }
}

// ç”¨è®¡æ•°æ’åºçš„æ–¹æ³•è§£å†³è¿™é“é¢˜
class Solution2 {
    public int[] topKFrequent(int[] nums, int k) {
        // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
        HashMap<Integer, Integer> valToFreq = new HashMap<>();
        for (int v : nums) {
            valToFreq.put(v, valToFreq.getOrDefault(v, 0) + 1);
        }

        // é¢‘ç‡ -> è¿™ä¸ªé¢‘ç‡æœ‰å“ªäº›å…ƒç´ 
        ArrayList<Integer>[] freqToVals = new ArrayList[nums.length + 1];
        for (int val : valToFreq.keySet()) {
            int freq = valToFreq.get(val);
            if (freqToVals[freq] == null) {
                freqToVals[freq] = new ArrayList<>();
            }
            freqToVals[freq].add(val);
        }

        int[] res = new int[k];
        int p = 0;
        // freqToVals ä»åå¾€å‰å­˜å‚¨ç€å‡ºç°æœ€å¤šçš„å…ƒç´ 
        for (int i = freqToVals.length - 1; i > 0; i--) {
            ArrayList<Integer> valList = freqToVals[i];
            if (valList == null) continue;
            for (int j = 0; j < valList.size(); j++) {
                // å°†å‡ºç°æ¬¡æ•°æœ€å¤šçš„ k ä¸ªå…ƒç´ è£…å…¥ res
                res[p] = valList.get(j);
                p++;
                if (p == k) {
                    return res;
                }
            }
        }

        return null;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function(nums, k) {
  // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
  const valToFreq = new Map();
  for (const v of nums) {
    valToFreq.set(v, (valToFreq.get(v) || 0) + 1);
  }

  const compare = (entry1, entry2) => entry1[1] - entry2[1];
  // é˜Ÿåˆ—æŒ‰ç…§é”®å€¼å¯¹ä¸­çš„å€¼ï¼ˆå…ƒç´ å‡ºç°é¢‘ç‡ï¼‰ä»å°åˆ°å¤§æ’åº
  const pq = new PriorityQueue(compare);

  for (const entry of valToFreq.entries()) {
    pq.push(entry);
    if (pq.size() > k) {
      // å¼¹å‡ºæœ€å°å…ƒç´ ï¼Œç»´æŠ¤é˜Ÿåˆ—å†…æ˜¯ k ä¸ªé¢‘ç‡æœ€å¤§çš„å…ƒç´ 
      pq.pop();
    }
  }

  const res = new Array(k);
  for (let i = k - 1; i >= 0; i--) {
    // res æ•°ç»„ä¸­å­˜å‚¨å‰ k ä¸ªæœ€å¤§å…ƒç´ 
    res[i] = pq.pop()[0];
  }

  return res;
};

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent2 = function(nums, k) {
  // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
  const valToFreq = new Map();
  for (const v of nums) {
    valToFreq.set(v, (valToFreq.get(v) || 0) + 1);
  }

  // é¢‘ç‡ -> è¿™ä¸ªé¢‘ç‡æœ‰å“ªäº›å…ƒç´ 
  const maxFreq = nums.length;
  const freqToVals = new Array(maxFreq + 1).map(() => new Array());
  for (const [val, freq] of valToFreq.entries()) {
    freqToVals[freq].push(val);
  }

  const res = new Array(k);
  let p = 0;
  // freqToVals ä»åå¾€å‰å­˜å‚¨ç€å‡ºç°æœ€å¤šçš„å…ƒç´ 
  for (let freq = maxFreq; freq > 0; freq--) {
    const valList = freqToVals[freq];
    for (const val of valList) {
      // å°†å‡ºç°æ¬¡æ•°æœ€å¤šçš„ k ä¸ªå…ƒç´ è£…å…¥ res
      res[p] = val;
      p++;
      if (p === k) {
        return res;
      }
    }
  }

  return null;
}
```

```python
# by chatGPT (python)
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
        valToFreq = {}
        for v in nums:
            valToFreq[v] = valToFreq.get(v, 0) + 1

        # äºŒå‰å †æŒ‰ç…§é”®å€¼å¯¹ä¸­çš„å€¼ï¼ˆå…ƒç´ å‡ºç°é¢‘ç‡çš„è´Ÿå€¼ï¼‰ä»å°åˆ°å¤§æ’åˆ—
        # ä»äºŒå‰å †ä¸­popå‡ºæ¥çš„å°±æ˜¯é¢‘ç‡æœ€å¤§çš„é”® ï¼ˆé¢‘ç‡è¶Šå¤§ï¼Œè´Ÿå€¼è¶Šå°ï¼‰
        pq = [(-freq, val) for val, freq in valToFreq.items()]
        heapq.heapify(pq)

        # å°†å‰ k ä¸ªæœ€å¤§å…ƒç´ è£…å…¥ res
        res = []
        for i in range(k):
            res.append(heapq.heappop(pq)[1])

        return res


class Solution2:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
        valToFreq = {}
        for v in nums:
            valToFreq[v] = valToFreq.get(v, 0) + 1

        # é¢‘ç‡ -> è¿™ä¸ªé¢‘ç‡æœ‰å“ªäº›å…ƒç´ 
        freqToVals = [[] for _ in range(len(nums) + 1)]
        for val, freq in valToFreq.items():
            freqToVals[freq].append(val)

        # freqToVals ä»åå¾€å‰å­˜å‚¨ç€å‡ºç°æœ€å¤šçš„å…ƒç´ 
        res = []
        for i in range(len(nums), 0, -1):
            if freqToVals[i]:
                for val in freqToVals[i]:
                    res.append(val)
                    if len(res) == k:
                        return res

        return res
```

https://leetcode.cn/problems/g5c51o çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/gaM7Ch çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> memo;

    int coinChange(vector<int>& coins, int amount) {
        memo.resize(amount + 1, -666);
        // dp æ•°ç»„å…¨éƒ½åˆå§‹åŒ–ä¸ºç‰¹æ®Šå€¼
        return dp(coins, amount);
    }

    int dp(vector<int>& coins, int amount) {
        if (amount == 0) return 0;
        if (amount < 0) return -1;
        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[amount] != -666)
            return memo[amount];

        int res = INT_MAX;
        for (int coin : coins) {
            // è®¡ç®—å­é—®é¢˜çš„ç»“æœ
            int subProblem = dp(coins, amount - coin);
            /**<extend up -200> 
            ![](../pictures/åŠ¨æ€è§„åˆ’è¯¦è§£è¿›é˜¶/5.jpg)
            */
            // å­é—®é¢˜æ— è§£åˆ™è·³è¿‡
            if (subProblem == -1) continue;
            // åœ¨å­é—®é¢˜ä¸­é€‰æ‹©æœ€ä¼˜è§£ï¼Œç„¶ååŠ ä¸€
            res = min(res, subProblem + 1);
        }
        // æŠŠè®¡ç®—ç»“æœå­˜å…¥å¤‡å¿˜å½•
        memo[amount] = (res == INT_MAX) ? -1 : res;
        return memo[amount];
    }
};
```

```go
// by chatGPT (go)
func coinChange(coins []int, amount int) int {
    memo := make([]int, amount+1)
    // dp æ•°ç»„å…¨éƒ½åˆå§‹åŒ–ä¸ºç‰¹æ®Šå€¼
    for i := 0; i < len(memo); i++ {
        memo[i] = -666
    }
    return dp(coins, amount, memo)
}

func dp(coins []int, amount int, memo []int) int {
    if amount == 0 {
        return 0
    }
    if amount < 0 {
        return -1
    }
    // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
    if memo[amount] != -666 {
        return memo[amount]
    }

    res := math.MaxInt32
    for _, coin := range coins {
        // è®¡ç®—å­é—®é¢˜çš„ç»“æœ
        subProblem := dp(coins, amount-coin, memo)
        /**<extend up -200>
        ![](../pictures/åŠ¨æ€è§„åˆ’è¯¦è§£è¿›é˜¶/5.jpg)
        */
        // å­é—®é¢˜æ— è§£åˆ™è·³è¿‡
        if subProblem == -1 {
            continue
        }
        // åœ¨å­é—®é¢˜ä¸­é€‰æ‹©æœ€ä¼˜è§£ï¼Œç„¶ååŠ ä¸€
        res = min(res, subProblem+1)
    }
    // æŠŠè®¡ç®—ç»“æœå­˜å…¥å¤‡å¿˜å½•
    if res == math.MaxInt32 {
        memo[amount] = -1
    } else {
        memo[amount] = res
    }
    return memo[amount]
}

func min(x, y int) int {
    if x < y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {
    int[] memo;

    public int coinChange(int[] coins, int amount) {
        memo = new int[amount + 1];
        // dp æ•°ç»„å…¨éƒ½åˆå§‹åŒ–ä¸ºç‰¹æ®Šå€¼
        Arrays.fill(memo, -666);
        return dp(coins, amount);
    }

    int dp(int[] coins, int amount) {
        if (amount == 0) return 0;
        if (amount < 0) return -1;
        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[amount] != -666)
            return memo[amount];

        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            // è®¡ç®—å­é—®é¢˜çš„ç»“æœ
            int subProblem = dp(coins, amount - coin);
            /**<extend up -200> 
            ![](../pictures/åŠ¨æ€è§„åˆ’è¯¦è§£è¿›é˜¶/5.jpg)
            */
            // å­é—®é¢˜æ— è§£åˆ™è·³è¿‡
            if (subProblem == -1) continue;
            // åœ¨å­é—®é¢˜ä¸­é€‰æ‹©æœ€ä¼˜è§£ï¼Œç„¶ååŠ ä¸€
            res = Math.min(res, subProblem + 1);
        }
        // æŠŠè®¡ç®—ç»“æœå­˜å…¥å¤‡å¿˜å½•
        memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
        return memo[amount];
    }
}
```

```javascript
// by chatGPT (javascript)
var coinChange = function(coins, amount) {
    let memo = new Array(amount + 1).fill(-666);
    return dp(coins, amount);

    function dp(coins, amount) {
        if (amount == 0) return 0;
        if (amount < 0) return -1;
        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[amount] != -666)
            return memo[amount];

        let res = Number.MAX_VALUE;
        for (let coin of coins) {
            // è®¡ç®—å­é—®é¢˜çš„ç»“æœ
            let subProblem = dp(coins, amount - coin);
            /**<extend up -200> 
            ![](../pictures/åŠ¨æ€è§„åˆ’è¯¦è§£è¿›é˜¶/5.jpg)
            */
            // å­é—®é¢˜æ— è§£åˆ™è·³è¿‡
            if (subProblem == -1) continue;
            // åœ¨å­é—®é¢˜ä¸­é€‰æ‹©æœ€ä¼˜è§£ï¼Œç„¶ååŠ ä¸€
            res = Math.min(res, subProblem + 1);
        }
        // æŠŠè®¡ç®—ç»“æœå­˜å…¥å¤‡å¿˜å½•
        memo[amount] = (res == Number.MAX_VALUE) ? -1 : res;
        return memo[amount];
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        memo = [-666] * (amount + 1)  # dp æ•°ç»„å…¨éƒ½åˆå§‹åŒ–ä¸ºç‰¹æ®Šå€¼
        return self.dp(coins, amount, memo)

    def dp(self, coins: List[int], amount: int, memo: List[int]) -> int:
        if amount == 0:
            return 0
        if amount < 0:
            return -1
        # æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if memo[amount] != -666:
            return memo[amount]

        res = float('inf')
        for coin in coins:
            # è®¡ç®—å­é—®é¢˜çš„ç»“æœ
            sub_problem = self.dp(coins, amount - coin, memo)
            # å­é—®é¢˜æ— è§£åˆ™è·³è¿‡
            if sub_problem == -1:
                continue
            # åœ¨å­é—®é¢˜ä¸­é€‰æ‹©æœ€ä¼˜è§£ï¼Œç„¶ååŠ ä¸€
            res = min(res, sub_problem + 1)

        # æŠŠè®¡ç®—ç»“æœå­˜å…¥å¤‡å¿˜å½•
        memo[amount] = -1 if res == float('inf') else res
        return memo[amount]
```

https://leetcode.cn/problems/gaM7Ch çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/gas-station çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        // ç›¸å½“äºå›¾åƒä¸­çš„åæ ‡ç‚¹å’Œæœ€ä½ç‚¹
        int sum = 0, minSum = 0;
        int start = 0;
        for (int i = 0; i < n; i++) {
            sum += gas[i] - cost[i];
            if (sum < minSum) {
                // ç»è¿‡ç¬¬ i ä¸ªç«™ç‚¹åï¼Œä½¿ sum åˆ°è¾¾æ–°ä½
                // æ‰€ä»¥ç«™ç‚¹ i + 1 å°±æ˜¯æœ€ä½ç‚¹ï¼ˆèµ·ç‚¹ï¼‰
                start = i + 1;
                minSum = sum;
            }
        }
        if (sum < 0) {
            // æ€»æ²¹é‡å°äºæ€»çš„æ¶ˆè€—ï¼Œæ— è§£
            return -1;
        }
        // ç¯å½¢æ•°ç»„ç‰¹æ€§
        return start == n ? 0 : start;
    }
};
```

```go
// by chatGPT (go)
func canCompleteCircuit(gas []int, cost []int) int {
    n := len(gas)
    // ç›¸å½“äºå›¾åƒä¸­çš„åæ ‡ç‚¹å’Œæœ€ä½ç‚¹
    sum, minSum := 0, 0
    start := 0
    for i := 0; i < n; i++ {
        sum += gas[i] - cost[i]
        if sum < minSum {
            // ç»è¿‡ç¬¬ i ä¸ªç«™ç‚¹åï¼Œä½¿ sum åˆ°è¾¾æ–°ä½
            // æ‰€ä»¥ç«™ç‚¹ i + 1 å°±æ˜¯æœ€ä½ç‚¹ï¼ˆèµ·ç‚¹ï¼‰
            start = i + 1
            minSum = sum
        }
    }
    if sum < 0 {
        // æ€»æ²¹é‡å°äºæ€»çš„æ¶ˆè€—ï¼Œæ— è§£
        return -1
    }
    // ç¯å½¢æ•°ç»„ç‰¹æ€§
    if start == n {
        return 0
    }
    return start
}
```

```java
// by labuladong (java)
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;
        // ç›¸å½“äºå›¾åƒä¸­çš„åæ ‡ç‚¹å’Œæœ€ä½ç‚¹
        int sum = 0, minSum = 0;
        int start = 0;
        for (int i = 0; i < n; i++) {
            sum += gas[i] - cost[i];
            if (sum < minSum) {
                // ç»è¿‡ç¬¬ i ä¸ªç«™ç‚¹åï¼Œä½¿ sum åˆ°è¾¾æ–°ä½
                // æ‰€ä»¥ç«™ç‚¹ i + 1 å°±æ˜¯æœ€ä½ç‚¹ï¼ˆèµ·ç‚¹ï¼‰
                start = i + 1;
                minSum = sum;
            }
        }
        if (sum < 0) {
            // æ€»æ²¹é‡å°äºæ€»çš„æ¶ˆè€—ï¼Œæ— è§£
            return -1;
        }
        // ç¯å½¢æ•°ç»„ç‰¹æ€§
        return start == n ? 0 : start;
    }
}
```

```javascript
// by chatGPT (javascript)
var canCompleteCircuit = function(gas, cost) {
    const n = gas.length;
    // ç›¸å½“äºå›¾åƒä¸­çš„åæ ‡ç‚¹å’Œæœ€ä½ç‚¹
    let sum = 0, minSum = 0;
    let start = 0;
    for (let i = 0; i < n; i++) {
        sum += gas[i] - cost[i];
        if (sum < minSum) {
            // ç»è¿‡ç¬¬ i ä¸ªç«™ç‚¹åï¼Œä½¿ sum åˆ°è¾¾æ–°ä½
            // æ‰€ä»¥ç«™ç‚¹ i + 1 å°±æ˜¯æœ€ä½ç‚¹ï¼ˆèµ·ç‚¹ï¼‰
            start = i + 1;
            minSum = sum;
        }
    }
    if (sum < 0) {
        // æ€»æ²¹é‡å°äºæ€»çš„æ¶ˆè€—ï¼Œæ— è§£
        return -1;
    }
    // ç¯å½¢æ•°ç»„ç‰¹æ€§
    return start == n ? 0 : start;
};
```

```python
# by chatGPT (python)
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        n = len(gas)
        # ç›¸å½“äºå›¾åƒä¸­çš„åæ ‡ç‚¹å’Œæœ€ä½ç‚¹
        sum_, minSum, start = 0, 0, 0
        for i in range(n):
            sum_ += gas[i] - cost[i]
            if sum_ < minSum:
                # ç»è¿‡ç¬¬ i ä¸ªç«™ç‚¹åï¼Œä½¿ sum åˆ°è¾¾æ–°ä½
                # æ‰€ä»¥ç«™ç‚¹ i + 1 å°±æ˜¯æœ€ä½ç‚¹ï¼ˆèµ·ç‚¹ï¼‰
                start = i + 1
                minSum = sum_
        if sum_ < 0:
            # æ€»æ²¹é‡å°äºæ€»çš„æ¶ˆè€—ï¼Œæ— è§£
            return -1
        # ç¯å½¢æ•°ç»„ç‰¹æ€§
        return 0 if start == n else start
```

https://leetcode.cn/problems/gas-station çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/generate-parentheses çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    vector<string> generateParenthesis(int n) {
        if (n == 0) return {};
        // è®°å½•æ‰€æœ‰åˆæ³•çš„æ‹¬å·ç»„åˆ
        vector<string> res;
        // å›æº¯è¿‡ç¨‹ä¸­çš„è·¯å¾„
        string track;
        // å¯ç”¨çš„å·¦æ‹¬å·å’Œå³æ‹¬å·æ•°é‡åˆå§‹åŒ–ä¸º n
        backtrack(n, n, track, res);
        return res;
    }

    // å¯ç”¨çš„å·¦æ‹¬å·æ•°é‡ä¸º left ä¸ªï¼Œå¯ç”¨çš„å³æ‹¬å·æ•°é‡ä¸º rgiht ä¸ª
    void backtrack(int left, int right, 
                string& track, vector<string>& res) {
        // è‹¥å·¦æ‹¬å·å‰©ä¸‹çš„å¤šï¼Œè¯´æ˜ä¸åˆæ³•
        if (right < left) return;
        // æ•°é‡å°äº 0 è‚¯å®šæ˜¯ä¸åˆæ³•çš„
        if (left < 0 || right < 0) return;
        // å½“æ‰€æœ‰æ‹¬å·éƒ½æ°å¥½ç”¨å®Œæ—¶ï¼Œå¾—åˆ°ä¸€ä¸ªåˆæ³•çš„æ‹¬å·ç»„åˆ
        if (left == 0 && right == 0) {
            res.push_back(track);
            return;
        }
        
        // å°è¯•æ”¾ä¸€ä¸ªå·¦æ‹¬å·
        track.push_back('('); // é€‰æ‹©
        backtrack(left - 1, right, track, res);
        track.pop_back(); // æ’¤æ¶ˆé€‰æ‹©

        // å°è¯•æ”¾ä¸€ä¸ªå³æ‹¬å·
        track.push_back(')'); // é€‰æ‹©
        backtrack(left, right - 1, track, res);
        track.pop_back(); // æ’¤æ¶ˆé€‰æ‹©
    }
}
```

```go
// by chatGPT (go)
func generateParenthesis(n int) []string {
    if n == 0 {
        return []string{}
    }
    // è®°å½•æ‰€æœ‰åˆæ³•çš„æ‹¬å·ç»„åˆ
    res := []string{}
    // å›æº¯è¿‡ç¨‹ä¸­çš„è·¯å¾„
    var track string
    // å¯ç”¨çš„å·¦æ‹¬å·å’Œå³æ‹¬å·æ•°é‡åˆå§‹åŒ–ä¸º n
    backtrack(n, n, &track, &res)
    return res
}

// å¯ç”¨çš„å·¦æ‹¬å·æ•°é‡ä¸º left ä¸ªï¼Œå¯ç”¨çš„å³æ‹¬å·æ•°é‡ä¸º right ä¸ª
func backtrack(left int, right int, track *string, res *[]string) {
    // è‹¥å·¦æ‹¬å·å‰©ä¸‹çš„å¤šï¼Œè¯´æ˜ä¸åˆæ³•
    if right < left {
        return
    }
    // æ•°é‡å°äº 0 è‚¯å®šæ˜¯ä¸åˆæ³•çš„
    if left < 0 || right < 0 {
        return
    }
    // å½“æ‰€æœ‰æ‹¬å·éƒ½æ°å¥½ç”¨å®Œæ—¶ï¼Œå¾—åˆ°ä¸€ä¸ªåˆæ³•çš„æ‹¬å·ç»„åˆ
    if left == 0 && right == 0 {
        *res = append(*res, *track)
        return
    }

    // å°è¯•æ”¾ä¸€ä¸ªå·¦æ‹¬å·
    *track += "(" // é€‰æ‹©
    backtrack(left-1, right, track, res)
    *track = (*track)[:len(*track)-1] // æ’¤æ¶ˆé€‰æ‹©

    // å°è¯•æ”¾ä¸€ä¸ªå³æ‹¬å·
    *track += ")" // é€‰æ‹©
    backtrack(left, right-1, track, res)
    *track = (*track)[:len(*track)-1] // æ’¤æ¶ˆé€‰æ‹©
}
```

```java
// by chatGPT (java)
class Solution {
    public List<String> generateParenthesis(int n) {
        if (n == 0) return new ArrayList<>();
        // è®°å½•æ‰€æœ‰åˆæ³•çš„æ‹¬å·ç»„åˆ
        List<String> res = new ArrayList<>();
        // å›æº¯è¿‡ç¨‹ä¸­çš„è·¯å¾„
        StringBuilder track = new StringBuilder();
        // å¯ç”¨çš„å·¦æ‹¬å·å’Œå³æ‹¬å·æ•°é‡åˆå§‹åŒ–ä¸º n
        backtrack(n, n, track, res);
        return res;
    }

    // å¯ç”¨çš„å·¦æ‹¬å·æ•°é‡ä¸º left ä¸ªï¼Œå¯ç”¨çš„å³æ‹¬å·æ•°é‡ä¸º right ä¸ª
    void backtrack(int left, int right, 
                StringBuilder track, List<String> res) {
        // è‹¥å·¦æ‹¬å·å‰©ä¸‹çš„å¤šï¼Œè¯´æ˜ä¸åˆæ³•
        if (right < left) return;
        // æ•°é‡å°äº 0 è‚¯å®šæ˜¯ä¸åˆæ³•çš„
        if (left < 0 || right < 0) return;
        // å½“æ‰€æœ‰æ‹¬å·éƒ½æ°å¥½ç”¨å®Œæ—¶ï¼Œå¾—åˆ°ä¸€ä¸ªåˆæ³•çš„æ‹¬å·ç»„åˆ
        if (left == 0 && right == 0) {
            res.add(track.toString());
            return;
        }
        
        // å°è¯•æ”¾ä¸€ä¸ªå·¦æ‹¬å·
        track.append('('); // é€‰æ‹©
        backtrack(left - 1, right, track, res);
        track.deleteCharAt(track.length() - 1); // æ’¤æ¶ˆé€‰æ‹©

        // å°è¯•æ”¾ä¸€ä¸ªå³æ‹¬å·
        track.append(')'); // é€‰æ‹©
        backtrack(left, right - 1, track, res);
        track.deleteCharAt(track.length() - 1); // æ’¤æ¶ˆé€‰æ‹©
    }
}
```

```javascript
// by chatGPT (javascript)
var generateParenthesis = function(n) {
    if (n === 0) return [];
    // è®°å½•æ‰€æœ‰åˆæ³•çš„æ‹¬å·ç»„åˆ
    var res = [];
    // å›æº¯è¿‡ç¨‹ä¸­çš„è·¯å¾„
    var track = "";
    // å¯ç”¨çš„å·¦æ‹¬å·å’Œå³æ‹¬å·æ•°é‡åˆå§‹åŒ–ä¸º n
    backtrack(n, n, track, res);
    return res;
};

// å¯ç”¨çš„å·¦æ‹¬å·æ•°é‡ä¸º left ä¸ªï¼Œå¯ç”¨çš„å³æ‹¬å·æ•°é‡ä¸º right ä¸ª
function backtrack(left, right, track, res) {
    // è‹¥å·¦æ‹¬å·å‰©ä¸‹çš„å¤šï¼Œè¯´æ˜ä¸åˆæ³•
    if (right < left) return;
    // æ•°é‡å°äº 0 è‚¯å®šæ˜¯ä¸åˆæ³•çš„
    if (left < 0 || right < 0) return;
    // å½“æ‰€æœ‰æ‹¬å·éƒ½æ°å¥½ç”¨å®Œæ—¶ï¼Œå¾—åˆ°ä¸€ä¸ªåˆæ³•çš„æ‹¬å·ç»„åˆ
    if (left === 0 && right === 0) {
        res.push(track);
        return;
    }

    // å°è¯•æ”¾ä¸€ä¸ªå·¦æ‹¬å·
    track += '('; // é€‰æ‹©
    backtrack(left - 1, right, track, res);
    track = track.slice(0, -1); // æ’¤æ¶ˆé€‰æ‹©

    // å°è¯•æ”¾ä¸€ä¸ªå³æ‹¬å·
    track += ')'; // é€‰æ‹©
    backtrack(left, right - 1, track, res);
    track = track.slice(0, -1); // æ’¤æ¶ˆé€‰æ‹©
}
```

```python
# by chatGPT (python)
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        if n == 0:
            return []
        # è®°å½•æ‰€æœ‰åˆæ³•çš„æ‹¬å·ç»„åˆ
        res = []
        # å›æº¯è¿‡ç¨‹ä¸­çš„è·¯å¾„
        track = ''
        # å¯ç”¨çš„å·¦æ‹¬å·å’Œå³æ‹¬å·æ•°é‡åˆå§‹åŒ–ä¸º n
        self.backtrack(n, n, track, res)
        return res

    # å¯ç”¨çš„å·¦æ‹¬å·æ•°é‡ä¸º left ä¸ªï¼Œå¯ç”¨çš„å³æ‹¬å·æ•°é‡ä¸º right ä¸ª
    def backtrack(self, left, right, track, res):
        # è‹¥å·¦æ‹¬å·å‰©ä¸‹çš„å¤šï¼Œè¯´æ˜ä¸åˆæ³•
        if right < left:
            return
        # æ•°é‡å°äº 0 è‚¯å®šæ˜¯ä¸åˆæ³•çš„
        if left < 0 or right < 0:
            return
        # å½“æ‰€æœ‰æ‹¬å·éƒ½æ°å¥½ç”¨å®Œæ—¶ï¼Œå¾—åˆ°ä¸€ä¸ªåˆæ³•çš„æ‹¬å·ç»„åˆ
        if left == 0 and right == 0:
            res.append(track)
            return

        # å°è¯•æ”¾ä¸€ä¸ªå·¦æ‹¬å·
        track += '('  # é€‰æ‹©
        self.backtrack(left - 1, right, track, res)
        track = track[:-1]  # æ’¤æ¶ˆé€‰æ‹©

        # å°è¯•æ”¾ä¸€ä¸ªå³æ‹¬å·
        track += ')'  # é€‰æ‹©
        self.backtrack(left, right - 1, track, res)
        track = track[:-1]  # æ’¤æ¶ˆé€‰æ‹©
```

https://leetcode.cn/problems/generate-parentheses çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> constructArr(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return vector<int>();
        }
        // ä»å·¦åˆ°å³çš„å‰ç¼€ç§¯ï¼Œprefix[i] æ˜¯ nums[0..i] çš„å…ƒç´ ç§¯
        vector<int> prefix(n);
        prefix[0] = nums[0];
        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] * nums[i];
        }
        // ä»å³åˆ°å·¦çš„å‰ç¼€ç§¯ï¼Œsuffix[i] æ˜¯ nums[i..n-1] çš„å…ƒç´ ç§¯
        vector<int> suffix(n);
        suffix[n - 1] = nums[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            suffix[i] = suffix[i + 1] * nums[i];
        }
        // ç»“æœæ•°ç»„
        vector<int> res(n);
        res[0] = suffix[1];
        res[n - 1] = prefix[n - 2];
        for (int i = 1; i < n - 1; i++) {
            // é™¤äº† nums[i] è‡ªå·±çš„å…ƒç´ ç§¯å°±æ˜¯ nums[i] å·¦ä¾§å’Œå³ä¾§æ‰€æœ‰å…ƒç´ ä¹‹ç§¯
            res[i] = prefix[i - 1] * suffix[i + 1];
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func constructArr(nums []int) []int {
    n := len(nums)
    if n == 0 {
        return []int{}
    }
    // ä»å·¦åˆ°å³çš„å‰ç¼€ç§¯ï¼Œprefix[i] æ˜¯ nums[0..i] çš„å…ƒç´ ç§¯
    prefix := make([]int, n)
    prefix[0] = nums[0]
    for i := 1; i < n; i++ {
        prefix[i] = prefix[i-1] * nums[i]
    }
    // ä»å³åˆ°å·¦çš„å‰ç¼€ç§¯ï¼Œsuffix[i] æ˜¯ nums[i..n-1] çš„å…ƒç´ ç§¯
    suffix := make([]int, n)
    suffix[n-1] = nums[n-1]
    for i := n - 2; i >= 0; i-- {
        suffix[i] = suffix[i+1] * nums[i]
    }
    // ç»“æœæ•°ç»„
    res := make([]int, n)
    res[0] = suffix[1]
    res[n-1] = prefix[n-2]
    for i := 1; i < n-1; i++ {
        // é™¤äº† nums[i] è‡ªå·±çš„å…ƒç´ ç§¯å°±æ˜¯ nums[i] å·¦ä¾§å’Œå³ä¾§æ‰€æœ‰å…ƒç´ ä¹‹ç§¯
        res[i] = prefix[i-1] * suffix[i+1]
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int[] constructArr(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return new int[0];
        }
        // ä»å·¦åˆ°å³çš„å‰ç¼€ç§¯ï¼Œprefix[i] æ˜¯ nums[0..i] çš„å…ƒç´ ç§¯
        int[] prefix = new int[n];
        prefix[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            prefix[i] = prefix[i - 1] * nums[i];
        }
        // ä»å³åˆ°å·¦çš„å‰ç¼€ç§¯ï¼Œsuffix[i] æ˜¯ nums[i..n-1] çš„å…ƒç´ ç§¯
        int[] suffix = new int[n];
        suffix[n - 1] = nums[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            suffix[i] = suffix[i + 1] * nums[i];
        }
        // ç»“æœæ•°ç»„
        int[] res = new int[n];
        res[0] = suffix[1];
        res[n - 1] = prefix[n - 2];
        for (int i = 1; i < n - 1; i++) {
            // é™¤äº† nums[i] è‡ªå·±çš„å…ƒç´ ç§¯å°±æ˜¯ nums[i] å·¦ä¾§å’Œå³ä¾§æ‰€æœ‰å…ƒç´ ä¹‹ç§¯
            res[i] = prefix[i - 1] * suffix[i + 1];
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var constructArr = function(nums) {
    var n = nums.length;
    if (n == 0) {
        return new Array(0);
    }
    // ä»å·¦åˆ°å³çš„å‰ç¼€ç§¯ï¼Œprefix[i] æ˜¯ nums[0..i] çš„å…ƒç´ ç§¯
    var prefix = new Array(n);
    prefix[0] = nums[0];
    for (var i = 1; i < nums.length; i++) {
        prefix[i] = prefix[i - 1] * nums[i];
    }
    // ä»å³åˆ°å·¦çš„å‰ç¼€ç§¯ï¼Œsuffix[i] æ˜¯ nums[i..n-1] çš„å…ƒç´ ç§¯
    var suffix = new Array(n);
    suffix[n - 1] = nums[n - 1];
    for (var i = n - 2; i >= 0; i--) {
        suffix[i] = suffix[i + 1] * nums[i];
    }
    // ç»“æœæ•°ç»„
    var res = new Array(n);
    res[0] = suffix[1];
    res[n - 1] = prefix[n - 2];
    for (var i = 1; i < n - 1; i++) {
        // é™¤äº† nums[i] è‡ªå·±çš„å…ƒç´ ç§¯å°±æ˜¯ nums[i] å·¦ä¾§å’Œå³ä¾§æ‰€æœ‰å…ƒç´ ä¹‹ç§¯
        res[i] = prefix[i - 1] * suffix[i + 1];
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def constructArr(self, nums: List[int]) -> List[int]:
        n = len(nums)
        if n == 0:
            return []
        # ä»å·¦åˆ°å³çš„å‰ç¼€ç§¯ï¼Œprefix[i] æ˜¯ nums[0..i] çš„å…ƒç´ ç§¯
        prefix = [0] * n
        prefix[0] = nums[0]
        for i in range(1, n):
            prefix[i] = prefix[i - 1] * nums[i]
        # ä»å³åˆ°å·¦çš„å‰ç¼€ç§¯ï¼Œsuffix[i] æ˜¯ nums[i..n-1] çš„å…ƒç´ ç§¯
        suffix = [0] * n
        suffix[n - 1] = nums[n - 1]
        for i in range(n - 2, -1, -1):
            suffix[i] = suffix[i + 1] * nums[i]
        # ç»“æœæ•°ç»„
        res = [0] * n
        res[0] = suffix[1]
        res[n - 1] = prefix[n - 2]
        for i in range(1, n - 1):
            # é™¤äº† nums[i] è‡ªå·±çš„å…ƒç´ ç§¯å°±æ˜¯ nums[i] å·¦ä¾§å’Œå³ä¾§æ‰€æœ‰å…ƒç´ ä¹‹ç§¯
            res[i] = prefix[i - 1] * suffix[i + 1]
        return res
```

https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/graph-valid-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool validTree(int n, vector<vector<int>>& edges) {
        // åˆå§‹åŒ– 0...n-1 å…± n ä¸ªèŠ‚ç‚¹
        UF uf(n);
        // éå†æ‰€æœ‰è¾¹ï¼Œå°†ç»„æˆè¾¹çš„ä¸¤ä¸ªèŠ‚ç‚¹è¿›è¡Œè¿æ¥
        for (auto edge : edges) {
            int u = edge[0];
            int v = edge[1];
            // è‹¥ä¸¤ä¸ªèŠ‚ç‚¹å·²ç»åœ¨åŒä¸€è¿é€šåˆ†é‡ä¸­ï¼Œä¼šäº§ç”Ÿç¯
            if (uf.connected(u, v)) {
                /**<extend down -200>
                ![](../pictures/kruskal/4.png)
                */
                return false;
            }
            // è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œå¯ä»¥æ˜¯æ ‘çš„ä¸€éƒ¨åˆ†
            uf.union(u, v);
            /**<extend down -150>
            ![](../pictures/kruskal/5.png)
            */
        }
        // è¦ä¿è¯æœ€ååªå½¢æˆäº†ä¸€æ£µæ ‘ï¼Œå³åªæœ‰ä¸€ä¸ªè¿é€šåˆ†é‡
        return uf.count() == 1;
    }

private:
    class UF {
        // è¿é€šåˆ†é‡ä¸ªæ•°
        int count;
        // å­˜å‚¨ä¸€æ£µæ ‘
        vector<int> parent;
        // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
        vector<int> size;

    public:
        // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
        UF(int n) {
            count = n;
            parent.resize(n);
            size.resize(n);
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }

        // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
        void union(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ)
                return;

            // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
            if (size[rootP] > size[rootQ]) {
                parent[rootQ] = rootP;
                size[rootP] += size[rootQ];
            } else {
                parent[rootP] = rootQ;
                size[rootQ] += size[rootP];
            }
            // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
            count--;
        }

        // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
        bool connected(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            return rootP == rootQ;
        }

        // è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
        int find(int x) {
            while (parent[x] != x) {
                // è¿›è¡Œè·¯å¾„å‹ç¼©
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }

        // è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
        int count() {
            return count;
        }
    };
};
```

```go
// by chatGPT (go)
type UF struct {
    // è¿é€šåˆ†é‡ä¸ªæ•°
    count   int
    parent  []int
    size    []int
}

func newUF(n int) *UF {
    uf := new(UF)
    uf.count = n
    uf.parent = make([]int, n)
    uf.size = make([]int, n)
    for i := 0; i < n; i++ {
        uf.parent[i] = i
        uf.size[i] = 1
    }
    return uf
}

func (uf *UF) Union(p, q int) {
    rootP := uf.Find(p)
    rootQ := uf.Find(q)
    if rootP == rootQ {
        return
    }

    // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
    if uf.size[rootP] > uf.size[rootQ] {
        uf.parent[rootQ] = rootP
        uf.size[rootP] += uf.size[rootQ]
    } else {
        uf.parent[rootP] = rootQ
        uf.size[rootQ] += uf.size[rootP]
    }
    // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
    uf.count--
}

func (uf *UF) Connected(p, q int) bool {
    rootP := uf.Find(p)
    rootQ := uf.Find(q)
    return rootP == rootQ
}

func (uf *UF) Find(x int) int {
    for uf.parent[x] != x {
        // è¿›è¡Œè·¯å¾„å‹ç¼©
        uf.parent[x] = uf.parent[uf.parent[x]]
        x = uf.parent[x]
    }
    return x
}

func (uf *UF) Count() int {
    return uf.count
}

func validTree(n int, edges [][]int) bool {
    // åˆå§‹åŒ– 0...n-1 å…± n ä¸ªèŠ‚ç‚¹
    uf := newUF(n)
    // éå†æ‰€æœ‰è¾¹ï¼Œå°†ç»„æˆè¾¹çš„ä¸¤ä¸ªèŠ‚ç‚¹è¿›è¡Œè¿æ¥
    for _, edge := range edges {
        u, v := edge[0], edge[1]
        // è‹¥ä¸¤ä¸ªèŠ‚ç‚¹å·²ç»åœ¨åŒä¸€è¿é€šåˆ†é‡ä¸­ï¼Œä¼šäº§ç”Ÿç¯
        if uf.Connected(u, v) {
            /*
                ![](../pictures/kruskal/4.png)
            */
            return false
        }
        // è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œå¯ä»¥æ˜¯æ ‘çš„ä¸€éƒ¨åˆ†
        uf.Union(u, v)
        /*
            ![](../pictures/kruskal/5.png)
        */
    }
    // è¦ä¿è¯æœ€ååªå½¢æˆäº†ä¸€æ£µæ ‘ï¼Œå³åªæœ‰ä¸€ä¸ªè¿é€šåˆ†é‡
    return uf.Count() == 1
}
```

```java
// by labuladong (java)
class Solution {
    public boolean validTree(int n, int[][] edges) {
        // åˆå§‹åŒ– 0...n-1 å…± n ä¸ªèŠ‚ç‚¹
        UF uf = new UF(n);
        // éå†æ‰€æœ‰è¾¹ï¼Œå°†ç»„æˆè¾¹çš„ä¸¤ä¸ªèŠ‚ç‚¹è¿›è¡Œè¿æ¥
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            // è‹¥ä¸¤ä¸ªèŠ‚ç‚¹å·²ç»åœ¨åŒä¸€è¿é€šåˆ†é‡ä¸­ï¼Œä¼šäº§ç”Ÿç¯
            if (uf.connected(u, v)) {
                /**<extend down -200>
                ![](../pictures/kruskal/4.png)
                */
                return false;
            }
            // è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œå¯ä»¥æ˜¯æ ‘çš„ä¸€éƒ¨åˆ†
            uf.union(u, v);
            /**<extend down -150>
            ![](../pictures/kruskal/5.png)
            */
        }
        // è¦ä¿è¯æœ€ååªå½¢æˆäº†ä¸€æ£µæ ‘ï¼Œå³åªæœ‰ä¸€ä¸ªè¿é€šåˆ†é‡
        return uf.count() == 1;
    }

    class UF {
        // è¿é€šåˆ†é‡ä¸ªæ•°
        private int count;
        // å­˜å‚¨ä¸€æ£µæ ‘
        private int[] parent;
        // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
        private int[] size;

        // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
        public UF(int n) {
            this.count = n;
            parent = new int[n];
            size = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }

        // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
        public void union(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ)
                return;

            // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
            if (size[rootP] > size[rootQ]) {
                parent[rootQ] = rootP;
                size[rootP] += size[rootQ];
            } else {
                parent[rootP] = rootQ;
                size[rootQ] += size[rootP];
            }
            // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
            count--;
        }

        // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
        public boolean connected(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            return rootP == rootQ;
        }

        // è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
        private int find(int x) {
            while (parent[x] != x) {
                // è¿›è¡Œè·¯å¾„å‹ç¼©
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }

        // è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
        public int count() {
            return count;
        }
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {boolean}
 */
var validTree = function(n, edges) {
    // åˆå§‹åŒ– 0...n-1 å…± n ä¸ªèŠ‚ç‚¹
    let uf = new UF(n);
    // éå†æ‰€æœ‰è¾¹ï¼Œå°†ç»„æˆè¾¹çš„ä¸¤ä¸ªèŠ‚ç‚¹è¿›è¡Œè¿æ¥
    for (let edge of edges) {
        let u = edge[0];
        let v = edge[1];
        // è‹¥ä¸¤ä¸ªèŠ‚ç‚¹å·²ç»åœ¨åŒä¸€è¿é€šåˆ†é‡ä¸­ï¼Œä¼šäº§ç”Ÿç¯
        if (uf.connected(u, v)) {
            return false;
        }
        // è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œå¯ä»¥æ˜¯æ ‘çš„ä¸€éƒ¨åˆ†
        uf.union(u, v);
    }
    // è¦ä¿è¯æœ€ååªå½¢æˆäº†ä¸€æ£µæ ‘ï¼Œå³åªæœ‰ä¸€ä¸ªè¿é€šåˆ†é‡
    return uf.count() == 1;
};

class UF {
    constructor(n) {
        this.count = n;
        this.parent = new Array(n);
        this.size = new Array(n);
        for (let i = 0; i < n; i++) {
            this.parent[i] = i;
            this.size[i] = 1;
        }
    }
    
    // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    union(p, q) {
        let rootP = this.find(p);
        let rootQ = this.find(q);
        if (rootP === rootQ) {
            return;
        }
    
        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (this.size[rootP] > this.size[rootQ]) {
            this.parent[rootQ] = rootP;
            this.size[rootP] += this.size[rootQ];
        } else {
            this.parent[rootP] = rootQ;
            this.size[rootQ] += this.size[rootP];
        }
        // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        this.count--;
    }

    // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    connected(p, q) {
        let rootP = this.find(p);
        let rootQ = this.find(q);
        return rootP === rootQ;
    }

    // è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
    find(x) {
        while (this.parent[x] !== x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            this.parent[x] = this.parent[this.parent[x]];
            x = this.parent[x];
        }
        return x;
    }

    // è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
    count() {
        return this.count;
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        # åˆå§‹åŒ– 0...n-1 å…± n ä¸ªèŠ‚ç‚¹
        uf = UF(n)
        # éå†æ‰€æœ‰è¾¹ï¼Œå°†ç»„æˆè¾¹çš„ä¸¤ä¸ªèŠ‚ç‚¹è¿›è¡Œè¿æ¥
        for edge in edges:
            u, v = edge[0], edge[1]
            # è‹¥ä¸¤ä¸ªèŠ‚ç‚¹å·²ç»åœ¨åŒä¸€è¿é€šåˆ†é‡ä¸­ï¼Œä¼šäº§ç”Ÿç¯
            if uf.connected(u, v):
                '''
                ![](../pictures/kruskal/4.png)
                '''
                return False
            # è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œå¯ä»¥æ˜¯æ ‘çš„ä¸€éƒ¨åˆ†
            uf.union(u, v)
            '''
            ![](../pictures/kruskal/5.png)
            '''
        # è¦ä¿è¯æœ€ååªå½¢æˆäº†ä¸€æ£µæ ‘ï¼Œå³åªæœ‰ä¸€ä¸ªè¿é€šåˆ†é‡
        return uf.count() == 1

class UF:
    # è¿é€šåˆ†é‡ä¸ªæ•°
    def count(self)->int:
        return self.__count

    # n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
    def __init__(self, n: int):
        self.__count = n
        self.__parent = list(range(n))
        self.__size = [1] * n

    # å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    def union(self, p: int, q: int):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP == rootQ:
            return

        # å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if self.__size[rootP] > self.__size[rootQ]:
            self.__parent[rootQ] = rootP
            self.__size[rootP] += self.__size[rootQ]
        else:
            self.__parent[rootP] = rootQ
            self.__size[rootQ] += self.__size[rootP]
        # ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        self.__count -= 1

    # åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    def connected(self, p: int, q: int) -> bool:
        rootP = self.find(p)
        rootQ = self.find(q)
        return rootP == rootQ

    # è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
    def find(self, x: int) -> int:
        while self.__parent[x] != x:
            # è¿›è¡Œè·¯å¾„å‹ç¼©
            self.__parent[x] = self.__parent[self.__parent[x]]
            x = self.__parent[x]
        return x
```

https://leetcode.cn/problems/graph-valid-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/group-anagrams çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // ç¼–ç åˆ°åˆ†ç»„çš„æ˜ å°„
        unordered_map<string, vector<string>> codeToGroup;
        for (string s : strs) {
            // å¯¹å­—ç¬¦ä¸²è¿›è¡Œç¼–ç 
            string code = encode(s);
            // æŠŠç¼–ç ç›¸åŒçš„å­—ç¬¦ä¸²æ”¾åœ¨ä¸€èµ·
            codeToGroup[code].push_back(s);
        }

        // è·å–ç»“æœ
        vector<vector<string>> res;
        for (auto group : codeToGroup) {
            res.push_back(group.second);
        }

        return res;
    }

    // åˆ©ç”¨æ¯ä¸ªå­—ç¬¦çš„å‡ºç°æ¬¡æ•°è¿›è¡Œç¼–ç 
    string encode(string s) {
        vector<char> count(26, 0);
        for (char c : s) {
            int delta = c - 'a';
            count[delta]++;
        }
        string code(count.begin(), count.end());
        return code;
    }
};
```

```go
// by chatGPT (go)
func groupAnagrams(strs []string) [][]string {
    // ç¼–ç åˆ°åˆ†ç»„çš„æ˜ å°„
    codeToGroup := make(map[string][]string)
    for _, s := range strs {
        // å¯¹å­—ç¬¦ä¸²è¿›è¡Œç¼–ç 
        code := encode(s)
        // æŠŠç¼–ç ç›¸åŒçš„å­—ç¬¦ä¸²æ”¾åœ¨ä¸€èµ·
        codeToGroup[code] = append(codeToGroup[code], s)
    }

    // è·å–ç»“æœ
    res := make([][]string, 0, len(codeToGroup))
    for _, group := range codeToGroup {
        res = append(res, group)
    }

    return res
}

// åˆ©ç”¨æ¯ä¸ªå­—ç¬¦çš„å‡ºç°æ¬¡æ•°è¿›è¡Œç¼–ç 
func encode(s string) string {
    count := make([]byte, 26)
    for i := 0; i < len(s); i++ {
        delta := s[i] - 'a'
        count[delta]++
    }
    return string(count)
}
```

```java
// by labuladong (java)
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        // ç¼–ç åˆ°åˆ†ç»„çš„æ˜ å°„
        HashMap<String, List<String>> codeToGroup = new HashMap<>();
        for (String s : strs) {
            // å¯¹å­—ç¬¦ä¸²è¿›è¡Œç¼–ç 
            String code = encode(s);
            // æŠŠç¼–ç ç›¸åŒçš„å­—ç¬¦ä¸²æ”¾åœ¨ä¸€èµ·
            codeToGroup.putIfAbsent(code, new LinkedList<>());
            codeToGroup.get(code).add(s);
        }

        // è·å–ç»“æœ
        List<List<String>> res = new LinkedList<>();
        for (List<String> group : codeToGroup.values()) {
            res.add(group);
        }

        return res;
    }

    // åˆ©ç”¨æ¯ä¸ªå­—ç¬¦çš„å‡ºç°æ¬¡æ•°è¿›è¡Œç¼–ç 
    String encode(String s) {
        char[] count = new char[26];
        for (char c : s.toCharArray()) {
            int delta = c - 'a';
            count[delta]++;
        }
        return new String(count);
    }
}
```

```javascript
// by chatGPT (javascript)
var groupAnagrams = function(strs) {
    // ç¼–ç åˆ°åˆ†ç»„çš„æ˜ å°„
    let codeToGroup = new Map();
    for (let s of strs) {
        // å¯¹å­—ç¬¦ä¸²è¿›è¡Œç¼–ç 
        let code = encode(s);
        // æŠŠç¼–ç ç›¸åŒçš„å­—ç¬¦ä¸²æ”¾åœ¨ä¸€èµ·
        if (!codeToGroup.has(code)) {
            codeToGroup.set(code, []);
        }
        codeToGroup.get(code).push(s);
    }

    // è·å–ç»“æœ
    let res = [];
    for (let group of codeToGroup.values()) {
        res.push(group);
    }

    return res;
};

// åˆ©ç”¨æ¯ä¸ªå­—ç¬¦çš„å‡ºç°æ¬¡æ•°è¿›è¡Œç¼–ç 
function encode(s) {
    let count = new Array(26).fill(0);
    for (let c of s) {
        let delta = c.charCodeAt() - 'a'.charCodeAt();
        count[delta]++;
    }
    return count.toString();
}
```

```python
# by chatGPT (python)
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        # ç¼–ç åˆ°åˆ†ç»„çš„æ˜ å°„
        codeToGroup = {}
        for s in strs:
            # å¯¹å­—ç¬¦ä¸²è¿›è¡Œç¼–ç 
            code = self.encode(s)
            # æŠŠç¼–ç ç›¸åŒçš„å­—ç¬¦ä¸²æ”¾åœ¨ä¸€èµ·
            if code not in codeToGroup:
                codeToGroup[code] = []
            codeToGroup[code].append(s)

        # è·å–ç»“æœ
        res = []
        for group in codeToGroup.values():
            res.append(group)

        return res

    # åˆ©ç”¨æ¯ä¸ªå­—ç¬¦çš„å‡ºç°æ¬¡æ•°è¿›è¡Œç¼–ç 
    def encode(self, s: str) -> str:
        count = [0] * 26
        for c in s:
            delta = ord(c) - ord('a')
            count[delta] += 1
        return str(count)
```

https://leetcode.cn/problems/group-anagrams çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2));
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][1], -prices[i]);
        }
        return dp[n - 1][0];
    }
};
```

```go
// by chatGPT (go)
func maxProfit(prices []int) int {
    n := len(prices)
    dp := make([][]int, n)
    for i := range dp {
        dp[i] = make([]int, 2)
    }
    for i := 0; i < n; i++ {
        if i-1 == -1 {
            dp[i][0] = 0
            dp[i][1] = -prices[i]
            continue
        }
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
        dp[i][1] = max(dp[i-1][1], -prices[i])
    }
    return dp[n-1][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
        }
        return dp[n - 1][0];
    }
}
```

```javascript
// by chatGPT (javascript)
var maxProfit = function(prices) {
    const n = prices.length;
    const dp = Array.from(Array(n), () => new Array(2).fill(0));
    for (let i = 0; i < n; i++) {
        if (i - 1 === -1) {
            // base case
            dp[i][0] = 0;
            dp[i][1] = -prices[i];
            continue;
        }
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
    }
    return dp[n - 1][0];
};
```

```python
# by chatGPT (python)
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0]*2 for _ in range(n)]
        for i in range(n):
            if i - 1 == -1:
                dp[i][0] = 0
                dp[i][1] = -prices[i]
                continue
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
            dp[i][1] = max(dp[i-1][1], -prices[i])
        return dp[n-1][0]
```

https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/h54YBf çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Codec {
    string SEP = ",";
    string NULL = "#";

public:
    /* ä¸»å‡½æ•°ï¼Œå°†äºŒå‰æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸² */
    string serialize(TreeNode* root) {
        stringstream ss;
        serialize(root, ss);
        return ss.str();
    }

    /* è¾…åŠ©å‡½æ•°ï¼Œå°†äºŒå‰æ ‘å­˜å…¥ stringstream */
    void serialize(TreeNode* root, stringstream& ss) {
        if (root == nullptr) {
            ss << NULL << SEP;
            return;
        }

        /******å‰åºéå†ä½ç½®******/
        ss << root->val << SEP;
        /***********************/

        serialize(root->left, ss);
        serialize(root->right, ss);
    }

    /* ä¸»å‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„ */
    TreeNode* deserialize(string data) {
        // å°†å­—ç¬¦ä¸²è½¬åŒ–æˆåˆ—è¡¨
        vector<string> nodes;
        stringstream ss(data);
        string s;
        while (getline(ss, s, SEP[0])) {
            nodes.push_back(s);
        }
        return deserialize(nodes);
    }

    /* è¾…åŠ©å‡½æ•°ï¼Œé€šè¿‡ nodes åˆ—è¡¨æ„é€ äºŒå‰æ ‘ */
    TreeNode* deserialize(vector<string>& nodes) {
        if (nodes.empty()) return nullptr;

        /******å‰åºéå†ä½ç½®******/
        // åˆ—è¡¨æœ€å·¦ä¾§å°±æ˜¯æ ¹èŠ‚ç‚¹
        string first = nodes[0];
        nodes.erase(nodes.begin());
        if (first == NULL) return nullptr;
        TreeNode* root = new TreeNode(stoi(first));
        /***********************/

        root->left = deserialize(nodes);
        root->right = deserialize(nodes);

        return root;
    }
};
```

```go
// by chatGPT (go)
type Codec struct {
    SEP  string
    NULL string
}

func Constructor() Codec {
    return Codec{",", "#"}
}

/* ä¸»å‡½æ•°ï¼Œå°†äºŒå‰æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸² */
func (this *Codec) serialize(root *TreeNode) string {
    var sb strings.Builder
    this.serializeHelper(root, &sb)
    return sb.String()
}

/* è¾…åŠ©å‡½æ•°ï¼Œå°†äºŒå‰æ ‘å­˜å…¥ StringBuilder */
func (this *Codec) serializeHelper(root *TreeNode, sb *strings.Builder) {
    if root == nil {
        sb.WriteString(this.NULL)
        sb.WriteString(this.SEP)
        return
    }

    /******å‰åºéå†ä½ç½®******/
    sb.WriteString(strconv.Itoa(root.Val))
    sb.WriteString(this.SEP)
    /***********************/

    this.serializeHelper(root.Left, sb)
    this.serializeHelper(root.Right, sb)
}

/* ä¸»å‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„ */
func (this *Codec) deserialize(data string) *TreeNode {
    // å°†å­—ç¬¦ä¸²è½¬åŒ–æˆåˆ—è¡¨
    nodes := strings.Split(data, this.SEP)
    return this.deserializeHelper(&nodes)
}

/* è¾…åŠ©å‡½æ•°ï¼Œé€šè¿‡ nodes åˆ—è¡¨æ„é€ äºŒå‰æ ‘ */
func (this *Codec) deserializeHelper(nodes *[]string) *TreeNode {
    if len(*nodes) == 0 {
        return nil
    }

    /******å‰åºéå†ä½ç½®******/
    // åˆ—è¡¨æœ€å·¦ä¾§å°±æ˜¯æ ¹èŠ‚ç‚¹
    first := (*nodes)[0]
    *nodes = (*nodes)[1:]
    if first == this.NULL {
        return nil
    }
    val, _ := strconv.Atoi(first)
    root := &TreeNode{val, nil, nil}
    /***********************/

    root.Left = this.deserializeHelper(nodes)
    root.Right = this.deserializeHelper(nodes)

    return root
}
```

```java
// by labuladong (java)
public class Codec {
    String SEP = ",";
    String NULL = "#";

    /* ä¸»å‡½æ•°ï¼Œå°†äºŒå‰æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸² */
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serialize(root, sb);
        return sb.toString();
    }

    /* è¾…åŠ©å‡½æ•°ï¼Œå°†äºŒå‰æ ‘å­˜å…¥ StringBuilder */
    void serialize(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(NULL).append(SEP);
            return;
        }

        /******å‰åºéå†ä½ç½®******/
        sb.append(root.val).append(SEP);
        /***********************/

        serialize(root.left, sb);
        serialize(root.right, sb);
    }

    /* ä¸»å‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„ */
    public TreeNode deserialize(String data) {
        // å°†å­—ç¬¦ä¸²è½¬åŒ–æˆåˆ—è¡¨
        LinkedList<String> nodes = new LinkedList<>();
        for (String s : data.split(SEP)) {
            nodes.addLast(s);
        }
        return deserialize(nodes);
    }

    /* è¾…åŠ©å‡½æ•°ï¼Œé€šè¿‡ nodes åˆ—è¡¨æ„é€ äºŒå‰æ ‘ */
    TreeNode deserialize(LinkedList<String> nodes) {
        if (nodes.isEmpty()) return null;

        /******å‰åºéå†ä½ç½®******/
        // åˆ—è¡¨æœ€å·¦ä¾§å°±æ˜¯æ ¹èŠ‚ç‚¹
        String first = nodes.removeFirst();
        if (first.equals(NULL)) return null;
        TreeNode root = new TreeNode(Integer.parseInt(first));
        /***********************/

        root.left = deserialize(nodes);
        root.right = deserialize(nodes);

        return root;
    }
}
```

```javascript
// by chatGPT (javascript)
var Codec = function() {
    this.SEP = ",";
    this.NULL = "#";
};

/* ä¸»å‡½æ•°ï¼Œå°†äºŒå‰æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸² */
Codec.prototype.serialize = function(root) {
    let sb = [];
    this._serialize(root, sb);
    return sb.join('');
};

/* è¾…åŠ©å‡½æ•°ï¼Œå°†äºŒå‰æ ‘å­˜å…¥ StringBuilder */
Codec.prototype._serialize = function(root, sb) {
    if (!root) {
        sb.push(this.NULL, this.SEP);
        return;
    }

    /******å‰åºéå†ä½ç½®******/
    sb.push(root.val, this.SEP);
    /***********************/

    this._serialize(root.left, sb);
    this._serialize(root.right, sb);
};

/* ä¸»å‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„ */
Codec.prototype.deserialize = function(data) {
    // å°†å­—ç¬¦ä¸²è½¬åŒ–æˆåˆ—è¡¨
    let nodes = data.split(this.SEP);
    return this._deserialize(nodes);
};

/* è¾…åŠ©å‡½æ•°ï¼Œé€šè¿‡ nodes åˆ—è¡¨æ„é€ äºŒå‰æ ‘ */
Codec.prototype._deserialize = function(nodes) {
    if (!nodes.length) return null;

    /******å‰åºéå†ä½ç½®******/
    // åˆ—è¡¨æœ€å·¦ä¾§å°±æ˜¯æ ¹èŠ‚ç‚¹
    let first = nodes.shift();
    if (first === this.NULL) return null;
    let root = new TreeNode(parseInt(first));
    /***********************/

    root.left = this._deserialize(nodes);
    root.right = this._deserialize(nodes);

    return root;
};
```

```python
# by chatGPT (python)
class Codec:
    SEP = ","
    NULL = "#"

    def serialize(self, root: TreeNode) -> str:
        """
        Encodes a tree to a single string.

        :param root: TreeNode
        :return: str
        """
        sb = []
        self._serialize(root, sb)
        return self.SEP.join(sb)

    def _serialize(self, root: TreeNode, sb: List[str]) -> None:
        """
        Helper function to serialize the tree.

        :param root: TreeNode
        :param sb: List[str]
        """
        if root is None:
            sb.append(self.NULL)
            return

        # å‰åºéå†ä½ç½®
        sb.append(str(root.val))
        # é€’å½’éå†å·¦å­æ ‘
        self._serialize(root.left, sb)
        # é€’å½’éå†å³å­æ ‘
        self._serialize(root.right, sb)

    def deserialize(self, data: str) -> TreeNode:
        """
        Decodes your encoded data to tree.

        :param data: str
        :return: TreeNode
        """
        nodes = data.split(self.SEP)
        return self._deserialize(nodes)

    def _deserialize(self, nodes: List[str]) -> TreeNode:
        """
        Helper function to deserialize the tree.

        :param nodes: List[str]
        :return: TreeNode
        """
        if not nodes:
            return None

        # å‰åºéå†ä½ç½®
        val = nodes.pop(0)
        if val == self.NULL:
            return None

        # åˆ›å»ºå½“å‰èŠ‚ç‚¹
        root = TreeNode(int(val))
        # é€’å½’æ„å»ºå·¦å­æ ‘
        root.left = self._deserialize(nodes)
        # é€’å½’æ„å»ºå³å­æ ‘
        root.right = self._deserialize(nodes)

        return root
```

https://leetcode.cn/problems/h54YBf çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy;
        ListNode* p1 = l1;
        ListNode* p2 = l2;

        while (p1 != nullptr && p2 != nullptr) {
            /**<extend down -200>
            ![](../pictures/é“¾è¡¨æŠ€å·§/1.gif)
            */
            // æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ
            // å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ
            if (p1->val > p2->val) {
                p->next = p2;
                p2 = p2->next;
            } else {
                p->next = p1;
                p1 = p1->next;
            }
            // p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p->next;
        }

        if (p1 != nullptr) {
            p->next = p1;
        }

        if (p2 != nullptr) {
            p->next = p2;
        }

        return dummy->next;
    }
};
```

```go
// by chatGPT (go)
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    dummy := &ListNode{-1, nil}
    p := dummy
    p1, p2 := l1, l2

    for p1 != nil && p2 != nil {
        /**<extend down -200>
        ![](../pictures/é“¾è¡¨æŠ€å·§/1.gif)
        */
        // æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ
        // å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ
        if p1.Val > p2.Val {
            p.Next = p2
            p2 = p2.Next
        } else {
            p.Next = p1
            p1 = p1.Next
        }
        // p æŒ‡é’ˆä¸æ–­å‰è¿›
        p = p.Next
    }

    if p1 != nil {
        p.Next = p1
    }

    if p2 != nil {
        p.Next = p2
    }

    return dummy.Next
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode dummy = new ListNode(-1), p = dummy;
        ListNode p1 = l1, p2 = l2;

        while (p1 != null && p2 != null) {
            /**<extend down -200>
            ![](../pictures/é“¾è¡¨æŠ€å·§/1.gif)
            */
            // æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ
            // å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ
            if (p1.val > p2.val) {
                p.next = p2;
                p2 = p2.next;
            } else {
                p.next = p1;
                p1 = p1.next;
            }
            // p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p.next;
        }

        if (p1 != null) {
            p.next = p1;
        }

        if (p2 != null) {
            p.next = p2;
        }

        return dummy.next;
    }
}
```

```javascript
// by chatGPT (javascript)
var mergeTwoLists = function(l1, l2) {
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    let dummy = new ListNode(-1), p = dummy;
    let p1 = l1, p2 = l2;

    while (p1 != null && p2 != null) {
        /**<extend down -200>
        ![](../pictures/é“¾è¡¨æŠ€å·§/1.gif)
        */
        // æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ
        // å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ
        if (p1.val > p2.val) {
            p.next = p2;
            p2 = p2.next;
        } else {
            p.next = p1;
            p1 = p1.next;
        }
        // p æŒ‡é’ˆä¸æ–­å‰è¿›
        p = p.next;
    }

    if (p1 != null) {
        p.next = p1;
    }

    if (p2 != null) {
        p.next = p2;
    }

    return dummy.next;
};
```

```python
# by chatGPT (python)
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        # è™šæ‹Ÿå¤´ç»“ç‚¹
        dummy = ListNode(-1)
        p = dummy
        p1, p2 = l1, l2
        
        while p1 and p2:
            # æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ
            # å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ
            if p1.val > p2.val:
                p.next = p2
                p2 = p2.next
            else:
                p.next = p1
                p1 = p1.next
            # p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p.next
        
        if p1:
            p.next = p1
        if p2:
            p.next = p2
        
        return dummy.next
```

https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // å·¦å³åŒæŒ‡é’ˆ
        int left = 0, right = nums.size() - 1;
        while (left < right) {
            int sum = nums[left] + nums[right];
            if (sum < target) {
                // è®©å’Œå¤§ä¸€ç‚¹
                left++;
            } else if (sum > target) {
                // è®©å’Œå°ä¸€ç‚¹
                right--;
            } else {
                // æ‰¾åˆ°ä¸¤ä¸ªæ•°
                return {nums[left], nums[right]};
            }
        }
        return {};
    }
};
```

```go
// by chatGPT (go)
func twoSum(nums []int, target int) []int {
    // å·¦å³åŒæŒ‡é’ˆ
    left, right := 0, len(nums)-1
    for left < right {
        sum := nums[left] + nums[right]
        if sum < target {
            // è®©å’Œå¤§ä¸€ç‚¹
            left++
        } else if sum > target {
            // è®©å’Œå°ä¸€ç‚¹
            right--
        } else {
            // æ‰¾åˆ°ä¸¤ä¸ªæ•°
            return []int{nums[left], nums[right]}
        }
    }
    return nil
}
```

```java
// by labuladong (java)
class Solution {
    public int[] twoSum(int[] nums, int target) {
        // å·¦å³åŒæŒ‡é’ˆ
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int sum = nums[left] + nums[right];
            if (sum < target) {
                // è®©å’Œå¤§ä¸€ç‚¹
                left++;
            } else if (sum > target) {
                // è®©å’Œå°ä¸€ç‚¹
                right--;
            } else {
                // æ‰¾åˆ°ä¸¤ä¸ªæ•°
                return new int[]{nums[left], nums[right]};
            }
        }
        return null;
    }
}
```

```javascript
// by chatGPT (javascript)
var twoSum = function(nums, target) {
    // å·¦å³åŒæŒ‡é’ˆ
    let left = 0, right = nums.length - 1;
    while (left < right) {
        let sum = nums[left] + nums[right];
        if (sum < target) {
            // è®©å’Œå¤§ä¸€ç‚¹
            left++;
        } else if (sum > target) {
            // è®©å’Œå°ä¸€ç‚¹
            right--;
        } else {
            // æ‰¾åˆ°ä¸¤ä¸ªæ•°
            return [nums[left], nums[right]];
        }
    }
    return null;
};
```

```python
# by chatGPT (python)
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # å·¦å³åŒæŒ‡é’ˆ
        left, right = 0, len(nums) - 1
        while left < right:
            sum = nums[left] + nums[right]
            if sum < target:
                # è®©å’Œå¤§ä¸€ç‚¹
                left += 1
            elif sum > target:
                # è®©å’Œå°ä¸€ç‚¹
                right -= 1
            else:
                # æ‰¾åˆ°ä¸¤ä¸ªæ•°
                return [nums[left], nums[right]]
        return None
```

https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/house-robber çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
private:
    // å¤‡å¿˜å½•
    vector<int> memo;
public:
    // ä¸»å‡½æ•°
    int rob(vector<int>& nums) {
        // åˆå§‹åŒ–å¤‡å¿˜å½•
        memo = vector<int>(nums.size(), -1);
        // å¼ºç›—ä»ç¬¬ 0 é—´æˆ¿å­å¼€å§‹æŠ¢åŠ«
        return dp(nums, 0);
    }

    // è¿”å› dp[start..] èƒ½æŠ¢åˆ°çš„æœ€å¤§å€¼
    int dp(vector<int>& nums, int start) {
        if (start >= nums.size()) {
            return 0;
        }
        // é¿å…é‡å¤è®¡ç®—
        if (memo[start] != -1) {
            return memo[start];
        }

        int res = max(dp(nums, start + 1), nums[start] + dp(nums, start + 2));
        // è®°å…¥å¤‡å¿˜å½•
        memo[start] = res;
        return res;
    }
};
```

```go
// by chatGPT (go)
import "math"

// ä¸»å‡½æ•°
func rob(nums []int) int {
    // å¤‡å¿˜å½•æ•°ç»„
    memo := make([]int, len(nums))
    // å¡«å……å¤‡å¿˜å½•æ•°ç»„ä¸º -1
    for i := range memo {
        memo[i] = -1
    }
    // å¼ºç›—ä»ç¬¬ 0 é—´æˆ¿å­å¼€å§‹æŠ¢åŠ«
    return dp(nums, 0, memo)
}

// è¿”å› dp[start..] èƒ½æŠ¢åˆ°çš„æœ€å¤§å€¼
func dp(nums []int, start int, memo []int) int {
    if start >= len(nums) {
        return 0
    }
    // é¿å…é‡å¤è®¡ç®—
    if memo[start] != -1 {
        return memo[start]
    }

    res := int(math.Max(float64(dp(nums, start+1, memo)), float64(nums[start]+dp(nums, start+2, memo))))
    // è®°å…¥å¤‡å¿˜å½•
    memo[start] = res
    return res
}
```

```java
// by labuladong (java)
class Solution {
    // å¤‡å¿˜å½•
    private int[] memo;
    // ä¸»å‡½æ•°
    public int rob(int[] nums) {
        // åˆå§‹åŒ–å¤‡å¿˜å½•
        memo = new int[nums.length];
        Arrays.fill(memo, -1);
        // å¼ºç›—ä»ç¬¬ 0 é—´æˆ¿å­å¼€å§‹æŠ¢åŠ«
        return dp(nums, 0);
    }

    // è¿”å› dp[start..] èƒ½æŠ¢åˆ°çš„æœ€å¤§å€¼
    private int dp(int[] nums, int start) {
        if (start >= nums.length) {
            return 0;
        }
        // é¿å…é‡å¤è®¡ç®—
        if (memo[start] != -1) return memo[start];

        int res = Math.max(dp(nums, start + 1),
                nums[start] + dp(nums, start + 2));
        // è®°å…¥å¤‡å¿˜å½•
        memo[start] = res;
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var rob = function(nums) {
    // å¤‡å¿˜å½•
    let memo = new Array(nums.length).fill(-1);
    // å¼ºç›—ä»ç¬¬ 0 é—´æˆ¿å­å¼€å§‹æŠ¢åŠ«
    return dp(nums, 0, memo);
};

// è¿”å› dp[start..] èƒ½æŠ¢åˆ°çš„æœ€å¤§å€¼
function dp(nums, start, memo) {
    if (start >= nums.length) {
        return 0;
    }
    // é¿å…é‡å¤è®¡ç®—
    if (memo[start] != -1) return memo[start];

    let res = Math.max(dp(nums, start + 1, memo),
            nums[start] + dp(nums, start + 2, memo));
    // è®°å…¥å¤‡å¿˜å½•
    memo[start] = res;
    return res;
}
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.memo = []

    def rob(self, nums: List[int]) -> int:
        self.memo = [-1] * len(nums)
        # å¼ºç›—ä»ç¬¬ 0 é—´æˆ¿å­å¼€å§‹æŠ¢åŠ«
        return self.dp(nums, 0)

    # è¿”å› dp[start..] èƒ½æŠ¢åˆ°çš„æœ€å¤§å€¼
    def dp(self, nums: List[int], start: int) -> int:
        if start >= len(nums):
            return 0
        # é¿å…é‡å¤è®¡ç®—
        if self.memo[start] != -1:
            return self.memo[start]

        res = max(self.dp(nums, start + 1),
                  nums[start] + self.dp(nums, start + 2))
        # è®°å…¥å¤‡å¿˜å½•
        self.memo[start] = res
        return res
```

https://leetcode.cn/problems/house-robber çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/house-robber-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];

        vector<int> memo1(n, -1);
        vector<int> memo2(n, -1);
        // ä¸¤æ¬¡è°ƒç”¨ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„å¤‡å¿˜å½•
        return max(
                dp(nums, 0, n - 2, memo1),
                dp(nums, 1, n - 1, memo2)
        );
    }

    // å®šä¹‰ï¼šè®¡ç®—é—­åŒºé—´ [start,end] çš„æœ€ä¼˜ç»“æœ
    int dp(vector<int>& nums, int start, int end, vector<int>& memo) {
        if (start > end) {
            return 0;
        }

        if (memo[start] != -1) {
            return memo[start];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        int res = max(
                dp(nums, start + 2, end, memo) + nums[start],
                dp(nums, start + 1, end, memo)
        );

        memo[start] = res;
        return res;
    }
};
```

```go
// by chatGPT (go)
func rob(nums []int) int {
    n := len(nums)
    if n == 1 {
        return nums[0]
    }

    memo1 := make([]int, n)
    memo2 := make([]int, n)
    for i := 0; i < n; i++ {
        memo1[i] = -1
        memo2[i] = -1
    }
    // ä¸¤æ¬¡è°ƒç”¨ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„å¤‡å¿˜å½•
    return max(
        func() int {
            res := dp(nums, 0, n-2, memo1)
            return res
        }(),
        func() int {
            res := dp(nums, 1, n-1, memo2)
            return res
        }(),
    )
}

// å®šä¹‰ï¼šè®¡ç®—é—­åŒºé—´ [start,end] çš„æœ€ä¼˜ç»“æœ
func dp(nums []int, start, end int, memo []int) int {
    if start > end {
        return 0
    }

    if memo[start] != -1 {
        return memo[start]
    }
    // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
    res := max(
        func() int {
            res := dp(nums, start+2, end, memo) + nums[start]
            return res
        }(),
        func() int {
            res := dp(nums, start+1, end, memo)
            return res
        }(),
    )

    memo[start] = res
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {

    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];

        int[] memo1 = new int[n];
        int[] memo2 = new int[n];
        Arrays.fill(memo1, -1);
        Arrays.fill(memo2, -1);
        // ä¸¤æ¬¡è°ƒç”¨ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„å¤‡å¿˜å½•
        return Math.max(
                dp(nums, 0, n - 2, memo1),
                dp(nums, 1, n - 1, memo2)
        );
    }

    // å®šä¹‰ï¼šè®¡ç®—é—­åŒºé—´ [start,end] çš„æœ€ä¼˜ç»“æœ
    int dp(int[] nums, int start, int end, int[] memo) {
        if (start > end) {
            return 0;
        }

        if (memo[start] != -1) {
            return memo[start];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        int res = Math.max(
                dp(nums, start + 2, end, memo) + nums[start],
                dp(nums, start + 1, end, memo)
        );

        memo[start] = res;
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var rob = function(nums) {
    const n = nums.length;
    if (n == 1) return nums[0];

    const memo1 = new Array(n).fill(-1);
    const memo2 = new Array(n).fill(-1);
    // ä¸¤æ¬¡è°ƒç”¨ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„å¤‡å¿˜å½•
    return Math.max(
        dp(nums, 0, n - 2, memo1),
        dp(nums, 1, n - 1, memo2)
    );
};

// å®šä¹‰ï¼šè®¡ç®—é—­åŒºé—´ [start,end] çš„æœ€ä¼˜ç»“æœ
const dp = function(nums, start, end, memo) {
    if (start > end) {
        return 0;
    }

    if (memo[start] != -1) {
        return memo[start];
    }
    // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
    const res = Math.max(
        dp(nums, start + 2, end, memo) + nums[start],
        dp(nums, start + 1, end, memo)
    );

    memo[start] = res;
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return nums[0]

        memo1 = [-1] * n
        memo2 = [-1] * n
        # ä¸¤æ¬¡è°ƒç”¨ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„å¤‡å¿˜å½•
        return max(
            self.dp(nums, 0, n - 2, memo1),
            self.dp(nums, 1, n - 1, memo2)
        )

    # å®šä¹‰ï¼šè®¡ç®—é—­åŒºé—´ [start,end] çš„æœ€ä¼˜ç»“æœ
    def dp(self, nums: List[int], start: int, end: int, memo: List[int]) -> int:
        if start > end:
            return 0

        if memo[start] != -1:
            return memo[start]
        # çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        res = max(
            self.dp(nums, start + 2, end, memo) + nums[start],
            self.dp(nums, start + 1, end, memo)
        )

        memo[start] = res
        return res
```

https://leetcode.cn/problems/house-robber-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/house-robber-iii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    unordered_map<TreeNode*, int> memo;

    int rob(TreeNode* root) {
        if (root == nullptr) return 0;
        // åˆ©ç”¨å¤‡å¿˜å½•æ¶ˆé™¤é‡å å­é—®é¢˜
        if (memo.count(root))
            return memo[root];
        // æŠ¢ï¼Œç„¶åå»ä¸‹ä¸‹å®¶
        int do_it = root->val
                    + (root->left == nullptr ?
                       0 : rob(root->left->left) + rob(root->left->right))
                    + (root->right == nullptr ?
                       0 : rob(root->right->left) + rob(root->right->right));
        // ä¸æŠ¢ï¼Œç„¶åå»ä¸‹å®¶
        int not_do = rob(root->left) + rob(root->right);

        int res = max(do_it, not_do);
        memo[root] = res;
        return res;
    }
};
```

```go
// by chatGPT (go)
// Definition for a binary tree node.
// type TreeNode struct {
//     Val int
//     Left *TreeNode
//     Right *TreeNode
// }

func rob(root *TreeNode) int {
    memo := make(map[*TreeNode]int)
    var robSub func(*TreeNode) int
    robSub = func(node *TreeNode) int {
        if node == nil {
            return 0
        }
        if _, ok := memo[node]; ok {
            return memo[node]
        }
        //è€ƒè™‘å·å–è¯¥èŠ‚ç‚¹
        doIt := node.Val
        if node.Left != nil {
            doIt += robSub(node.Left.Left) + robSub(node.Left.Right)
        }
        if node.Right != nil {
            doIt += robSub(node.Right.Left) + robSub(node.Right.Right)
        }
        //ä¸å·å–è¯¥èŠ‚ç‚¹
        notDo := robSub(node.Left) + robSub(node.Right)
        res := max(doIt, notDo)
        memo[node] = res
        return res
    }
    return robSub(root)
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {
    Map<TreeNode, Integer> memo = new HashMap<>();

    public int rob(TreeNode root) {
        if (root == null) return 0;
        // åˆ©ç”¨å¤‡å¿˜å½•æ¶ˆé™¤é‡å å­é—®é¢˜
        if (memo.containsKey(root))
            return memo.get(root);
        // æŠ¢ï¼Œç„¶åå»ä¸‹ä¸‹å®¶
        int do_it = root.val
                + (root.left == null ?
                0 : rob(root.left.left) + rob(root.left.right))
                + (root.right == null ?
                0 : rob(root.right.left) + rob(root.right.right));
        // ä¸æŠ¢ï¼Œç„¶åå»ä¸‹å®¶
        int not_do = rob(root.left) + rob(root.right);

        int res = Math.max(do_it, not_do);
        memo.put(root, res);
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var rob = function(root) {
    const memo = new Map();
    if (root === null) {
        return 0;
    }
    // åˆ©ç”¨å¤‡å¿˜å½•æ¶ˆé™¤é‡å å­é—®é¢˜
    if (memo.has(root)) {
        return memo.get(root);
    }
    // æŠ¢ï¼Œç„¶åå»ä¸‹ä¸‹å®¶
    let do_it = root.val +
        ((root.left === null) ?
            0 :
            rob(root.left.left) + rob(root.left.right)) +
        ((root.right === null) ?
            0 :
            rob(root.right.left) + rob(root.right.right));
    // ä¸æŠ¢ï¼Œç„¶åå»ä¸‹å®¶
    let not_do = rob(root.left) + rob(root.right);
    let res = Math.max(do_it, not_do);
    memo.set(root, res);
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.memo = {}

    def rob(self, root: TreeNode) -> int:
        if not root:
            return 0

        # åˆ©ç”¨å¤‡å¿˜å½•æ¶ˆé™¤é‡å å­é—®é¢˜
        if root in self.memo:
            return self.memo[root]

        # æŠ¢ï¼Œç„¶åå»ä¸‹ä¸‹å®¶
        do_it = root.val
        if root.left:
            do_it += self.rob(root.left.left) + self.rob(root.left.right)
        if root.right:
            do_it += self.rob(root.right.left) + self.rob(root.right.right)

        # ä¸æŠ¢ï¼Œç„¶åå»ä¸‹å®¶
        not_do = self.rob(root.left) + self.rob(root.right)

        res = max(do_it, not_do)
        self.memo[root] = res
        return res
```

https://leetcode.cn/problems/house-robber-iii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    /* å•è°ƒé˜Ÿåˆ—çš„å®ç° */
    class MonotonicQueue {
        deque<int> q;
    public:
        void push(int n) {
            // å°†å°äº n çš„å…ƒç´ å…¨éƒ¨åˆ é™¤
            while (!q.empty() && q.back() < n) {
                 /**<extend down -300>
                ![](../pictures/å•è°ƒé˜Ÿåˆ—/3.png)
                */
                q.pop_back();
            }
            // ç„¶åå°† n åŠ å…¥å°¾éƒ¨
            q.push_back(n);
        }

        int max() {
            return q.front();
        }

        void pop(int n) {
            if (n == q.front()) {
                q.pop_front();
            }
        }
    };

public:
    /* è§£é¢˜å‡½æ•°çš„å®ç° */
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MonotonicQueue window;
        vector<int> res;

        for (int i = 0; i < nums.size(); i++) {
            if (i < k - 1) {
                //å…ˆå¡«æ»¡çª—å£çš„å‰ k - 1
                window.push(nums[i]);
            } else {
                /**<extend up -150>
                ![](../pictures/å•è°ƒé˜Ÿåˆ—/1.png)
                */
                // çª—å£å‘å‰æ»‘åŠ¨ï¼ŒåŠ å…¥æ–°æ•°å­—
                window.push(nums[i]);
                // è®°å½•å½“å‰çª—å£çš„æœ€å¤§å€¼
                res.push_back(window.max());
                // ç§»å‡ºæ—§æ•°å­—
                window.pop(nums[i - k + 1]);
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
type MonotonicQueue struct {
    q []int
}

func (mq *MonotonicQueue) push(n int) {
    // å°†å°äº n çš„å…ƒç´ å…¨éƒ¨åˆ é™¤
    for len(mq.q) > 0 && mq.q[len(mq.q)-1] < n {
        mq.q = mq.q[:len(mq.q)-1]
    }
    // ç„¶åå°† n åŠ å…¥å°¾éƒ¨
    mq.q = append(mq.q, n)
}

func (mq *MonotonicQueue) max() int {
    return mq.q[0]
}

func (mq *MonotonicQueue) pop(n int) {
    if n == mq.q[0] {
        mq.q = mq.q[1:]
    }
}

func maxSlidingWindow(nums []int, k int) []int {
    window := &MonotonicQueue{}
    res := []int{}

    for i := 0; i < len(nums); i++ {
        if i < k-1 {
            // å…ˆå¡«æ»¡çª—å£çš„å‰ k - 1
            window.push(nums[i])
        } else {
            // çª—å£å‘å‰æ»‘åŠ¨ï¼ŒåŠ å…¥æ–°æ•°å­—
            window.push(nums[i])
            // è®°å½•å½“å‰çª—å£çš„æœ€å¤§å€¼
            res = append(res, window.max())
            // ç§»å‡ºæ—§æ•°å­—
            window.pop(nums[i-k+1])
        }
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    /* å•è°ƒé˜Ÿåˆ—çš„å®ç° */
    class MonotonicQueue {
        LinkedList<Integer> q = new LinkedList<>();
        public void push(int n) {
            // å°†å°äº n çš„å…ƒç´ å…¨éƒ¨åˆ é™¤
            while (!q.isEmpty() && q.getLast() < n) {
                 /**<extend down -300>
                ![](../pictures/å•è°ƒé˜Ÿåˆ—/3.png)
                */
                q.pollLast();
            }
            // ç„¶åå°† n åŠ å…¥å°¾éƒ¨
            q.addLast(n);
        }

        public int max() {
            return q.getFirst();
        }

        public void pop(int n) {
            if (n == q.getFirst()) {
                q.pollFirst();
            }
        }
    }

    /* è§£é¢˜å‡½æ•°çš„å®ç° */
    public int[] maxSlidingWindow(int[] nums, int k) {
        MonotonicQueue window = new MonotonicQueue();
        List<Integer> res = new ArrayList<>();

        for (int i = 0; i < nums.length; i++) {
            if (i < k - 1) {
                //å…ˆå¡«æ»¡çª—å£çš„å‰ k - 1
                window.push(nums[i]);
            } else {
                /**<extend up -150>
                ![](../pictures/å•è°ƒé˜Ÿåˆ—/1.png)
                */
                // çª—å£å‘å‰æ»‘åŠ¨ï¼ŒåŠ å…¥æ–°æ•°å­—
                window.push(nums[i]);
                // è®°å½•å½“å‰çª—å£çš„æœ€å¤§å€¼
                res.add(window.max());
                // ç§»å‡ºæ—§æ•°å­—
                window.pop(nums[i - k + 1]);
            }
        }
        // éœ€è¦è½¬æˆ int[] æ•°ç»„å†è¿”å›
        int[] arr = new int[res.size()];
        for (int i = 0; i < res.size(); i++) {
            arr[i] = res.get(i);
        }
        return arr;
    }
}
```

```javascript
// by chatGPT (javascript)
var Solution = function() {
    /* å•è°ƒé˜Ÿåˆ—çš„å®ç° */
    class MonotonicQueue {
        constructor() {
            this.q = [];
        }
        push(n) {
            // å°†å°äº n çš„å…ƒç´ å…¨éƒ¨åˆ é™¤
            while (this.q.length > 0 && this.q[this.q.length - 1] < n) {
                 /**<extend down -300>
                ![](../pictures/å•è°ƒé˜Ÿåˆ—/3.png)
                */
                this.q.pop();
            }
            // ç„¶åå°† n åŠ å…¥å°¾éƒ¨
            this.q.push(n);
        }
        max() {
            return this.q[0];
        }
        pop(n) {
            if (n === this.q[0]) {
                this.q.shift();
            }
        }
    }

    /* è§£é¢˜å‡½æ•°çš„å®ç° */
    this.maxSlidingWindow = function(nums, k) {
        const window = new MonotonicQueue();
        const res = [];

        for (let i = 0; i < nums.length; i++) {
            if (i < k - 1) {
                // å…ˆå¡«æ»¡çª—å£çš„å‰ k - 1
                window.push(nums[i]);
            } else {
                /**<extend up -150>
                ![](../pictures/å•è°ƒé˜Ÿåˆ—/1.png)
                */
                // çª—å£å‘å‰æ»‘åŠ¨ï¼ŒåŠ å…¥æ–°æ•°å­—
                window.push(nums[i]);
                // è®°å½•å½“å‰çª—å£çš„æœ€å¤§å€¼
                res.push(window.max());
                // ç§»å‡ºæ—§æ•°å­—
                window.pop(nums[i - k + 1]);
            }
        }
        // éœ€è¦è½¬æˆ int[] æ•°ç»„å†è¿”å›
        return res;
    }
}
```

```python
# by chatGPT (python)
class Solution:
    # å•è°ƒé˜Ÿåˆ—çš„å®ç°
    class MonotonicQueue:
        def __init__(self):
            self.q = []
        def push(self, n: int) -> None:
            # å°†å°äº n çš„å…ƒç´ å…¨éƒ¨åˆ é™¤
            while self.q and self.q[-1] < n:
                '''
                <extend down -300>
                ![](../pictures/å•è°ƒé˜Ÿåˆ—/3.png)
                '''
                self.q.pop()
            # ç„¶åå°† n åŠ å…¥å°¾éƒ¨
            self.q.append(n)

        def max(self) -> int:
            return self.q[0]

        def pop(self, n: int) -> None:
            if n == self.q[0]:
                self.q.pop(0)

    # è§£é¢˜å‡½æ•°çš„å®ç°
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        window = self.MonotonicQueue()
        res = []

        for i in range(len(nums)):
            if i < k - 1:
                # å…ˆå¡«æ»¡çª—å£çš„å‰ k - 1
                window.push(nums[i])
            else:
                '''
                <extend up -150>
                ![](../pictures/å•è°ƒé˜Ÿåˆ—/1.png)
                '''
                # çª—å£å‘å‰æ»‘åŠ¨ï¼ŒåŠ å…¥æ–°æ•°å­—
                window.push(nums[i])
                # è®°å½•å½“å‰çª—å£çš„æœ€å¤§å€¼
                res.append(window.max())
                # ç§»å‡ºæ—§æ•°å­—
                window.pop(nums[i - k + 1])
        
        # éœ€è¦è½¬æˆ int[] æ•°ç»„å†è¿”å›
        return res
```

https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/implement-queue-using-stacks çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class MyQueue {
private:
    stack<int> s1, s2;

public:
    MyQueue() {}

    /**
     * æ·»åŠ å…ƒç´ åˆ°é˜Ÿå°¾
     */
    void push(int x) {
        s1.push(x);
    }

    /**
     * åˆ é™¤é˜Ÿå¤´çš„å…ƒç´ å¹¶è¿”å›
     */
    int pop() {
        // å…ˆè°ƒç”¨ peek ä¿è¯ s2 éç©º
        peek();
        int element = s2.top();
        s2.pop();
        return element;
    }

    /**
     * è¿”å›é˜Ÿå¤´å…ƒç´ 
     */
    int peek() {
        if (s2.empty())
            // æŠŠ s1 å…ƒç´ å‹å…¥ s2
            while (!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        return s2.top();
    }

    /**
     * åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
     */
    bool empty() {
        return s1.empty() && s2.empty();
    }
};
```

```go
// by chatGPT (go)
type MyQueue struct {
    s1, s2 []int
}

func Constructor() MyQueue {
    return MyQueue{}
}

/** 
 * æ·»åŠ å…ƒç´ åˆ°é˜Ÿå°¾
 */
func (q *MyQueue) Push(x int) {
    q.s1 = append(q.s1, x)
}

/** 
 * åˆ é™¤é˜Ÿå¤´çš„å…ƒç´ å¹¶è¿”å›
 */
func (q *MyQueue) Pop() int {
    // å…ˆè°ƒç”¨ Peek ä¿è¯ s2 éç©º
    q.Peek()
    val := q.s2[len(q.s2)-1]
    q.s2 = q.s2[:len(q.s2)-1]
    return val
}

/**
 * è¿”å›é˜Ÿå¤´å…ƒç´ 
 */
func (q *MyQueue) Peek() int {
    if len(q.s2) == 0 {
        // æŠŠ s1 å…ƒç´ å‹å…¥ s2
        for len(q.s1) != 0 {
            q.s2 = append(q.s2, q.s1[len(q.s1)-1])
            q.s1 = q.s1[:len(q.s1)-1]
        }
    }
    return q.s2[len(q.s2)-1]
}

/** 
 * åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
 */
func (q *MyQueue) Empty() bool {
    return len(q.s1) == 0 && len(q.s2) == 0
}
```

```java
// by labuladong (java)
class MyQueue {
    private Stack<Integer> s1, s2;

    public MyQueue() {
        s1 = new Stack<>();
        s2 = new Stack<>();
    }

    /**
     * æ·»åŠ å…ƒç´ åˆ°é˜Ÿå°¾
     */
    public void push(int x) {
        s1.push(x);
    }

    /**
     * åˆ é™¤é˜Ÿå¤´çš„å…ƒç´ å¹¶è¿”å›
     */
    public int pop() {
        // å…ˆè°ƒç”¨ peek ä¿è¯ s2 éç©º
        peek();
        return s2.pop();
    }

    /**
     * è¿”å›é˜Ÿå¤´å…ƒç´ 
     */
    public int peek() {
        if (s2.isEmpty())
            // æŠŠ s1 å…ƒç´ å‹å…¥ s2
            while (!s1.isEmpty())
                s2.push(s1.pop());
        return s2.peek();
    }

    /**
     * åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
     */
    public boolean empty() {
        return s1.isEmpty() && s2.isEmpty();
    }
}
```

```javascript
// by chatGPT (javascript)
var MyQueue = function() {
    this.s1 = [];
    this.s2 = [];
};

/**
 * æ·»åŠ å…ƒç´ åˆ°é˜Ÿå°¾
 */
MyQueue.prototype.push = function(x) {
    this.s1.push(x);
};

/**
 * åˆ é™¤é˜Ÿå¤´çš„å…ƒç´ å¹¶è¿”å›
 */
MyQueue.prototype.pop = function() {
    // å…ˆè°ƒç”¨ peek ä¿è¯ s2 éç©º
    this.peek();
    return this.s2.pop();
};

/**
 * è¿”å›é˜Ÿå¤´å…ƒç´ 
 */
MyQueue.prototype.peek = function() {
    if (this.s2.length === 0)
        // æŠŠ s1 å…ƒç´ å‹å…¥ s2
        while (this.s1.length > 0)
            this.s2.push(this.s1.pop());
    return this.s2[this.s2.length - 1];
};

/**
 * åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
 */
MyQueue.prototype.empty = function() {
    return this.s1.length === 0 && this.s2.length === 0;
};
```

```python
# by chatGPT (python)
class MyQueue:

    def __init__(self):
        self.s1 = []
        self.s2 = []

    def push(self, x: int) -> None:
        self.s1.append(x)

    def pop(self) -> int:
        # å…ˆè°ƒç”¨ peek ä¿è¯ s2 éç©º
        self.peek()
        return self.s2.pop()

    def peek(self) -> int:
        if not self.s2:
            # æŠŠ s1 å…ƒç´ å‹å…¥ s2
            while self.s1:
                self.s2.append(self.s1.pop())
        return self.s2[-1]

    def empty(self) -> bool:
        return not self.s1 and not self.s2
```

https://leetcode.cn/problems/implement-queue-using-stacks çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/implement-stack-using-queues çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class MyStack {
    queue<int> q;
    int top_elem = 0;

public:
    /**
     * æ·»åŠ å…ƒç´ åˆ°æ ˆé¡¶
     */
    void push(int x) {
        // x æ˜¯é˜Ÿåˆ—çš„é˜Ÿå°¾ï¼Œæ˜¯æ ˆçš„æ ˆé¡¶
        q.push(x);
        top_elem = x;
    }

    /**
     * è¿”å›æ ˆé¡¶å…ƒç´ 
     */
    int top() {
        return top_elem;
    }

    /**
     * åˆ é™¤æ ˆé¡¶çš„å…ƒç´ å¹¶è¿”å›
     */
    int pop() {
        int size = q.size();
        // ç•™ä¸‹é˜Ÿå°¾ 2 ä¸ªå…ƒç´ 
        while (size > 2) {
            q.push(q.front());
            q.pop();
            size--;
        }
        // è®°å½•æ–°çš„é˜Ÿå°¾å…ƒç´ 
        top_elem = q.front();
        q.push(q.front());
        q.pop();
        // åˆ é™¤ä¹‹å‰çš„é˜Ÿå°¾å…ƒç´ 
        int tmp=q.front();
        q.pop();
        return tmp;
    }

    /**
     * åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
     */
    bool empty() {
        return q.empty();
    }
};
```

```go
// by mario-huang (go)
package ImplementStackusingQueues

type MyStack struct {
    q       []int
    topElem int
}

func Constructor() MyStack {
    return MyStack{q: []int{}, topElem: 0}
}

/**
 * æ·»åŠ å…ƒç´ åˆ°æ ˆé¡¶
 */
func (this *MyStack) Push(x int) {
    // x æ˜¯é˜Ÿåˆ—çš„é˜Ÿå°¾ï¼Œæ˜¯æ ˆçš„æ ˆé¡¶
    this.q = append(this.q, x)
    this.topElem = x
}

/**
 * åˆ é™¤æ ˆé¡¶çš„å…ƒç´ å¹¶è¿”å›
 */
func (this *MyStack) Pop() int {
    size := len(this.q)
    // ç•™ä¸‹é˜Ÿå°¾ 2 ä¸ªå…ƒç´ 
    for size > 2 {
        this.q = append(this.q, this.q[0])
        this.q = this.q[1:]
        size--
    }
    // è®°å½•æ–°çš„é˜Ÿå°¾å…ƒç´ 
    this.topElem = this.q[0]
    this.q = append(this.q, this.q[0])
    this.q = this.q[1:]
    // åˆ é™¤ä¹‹å‰çš„é˜Ÿå°¾å…ƒç´ 
    val := this.q[0]
    this.q = this.q[1:]
    return val
}

/**
 * è¿”å›æ ˆé¡¶å…ƒç´ 
 */
func (this *MyStack) Top() int {
    return this.topElem
}

/**
 * åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
 */
func (this *MyStack) Empty() bool {
    return len(this.q) == 0
}
```

```java
// by labuladong (java)
class MyStack {
    Queue<Integer> q = new LinkedList<>();
    int top_elem = 0;

    /**
     * æ·»åŠ å…ƒç´ åˆ°æ ˆé¡¶
     */
    public void push(int x) {
        // x æ˜¯é˜Ÿåˆ—çš„é˜Ÿå°¾ï¼Œæ˜¯æ ˆçš„æ ˆé¡¶
        q.offer(x);
        top_elem = x;
    }

    /**
     * è¿”å›æ ˆé¡¶å…ƒç´ 
     */
    public int top() {
        return top_elem;
    }

    /**
     * åˆ é™¤æ ˆé¡¶çš„å…ƒç´ å¹¶è¿”å›
     */
    public int pop() {
        int size = q.size();
        // ç•™ä¸‹é˜Ÿå°¾ 2 ä¸ªå…ƒç´ 
        while (size > 2) {
            q.offer(q.poll());
            size--;
        }
        // è®°å½•æ–°çš„é˜Ÿå°¾å…ƒç´ 
        top_elem = q.peek();
        q.offer(q.poll());
        // åˆ é™¤ä¹‹å‰çš„é˜Ÿå°¾å…ƒç´ 
        return q.poll();
    }

    /**
     * åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
     */
    public boolean empty() {
        return q.isEmpty();
    }
}
```

```javascript
// by chatGPT (javascript)
var MyStack = function() {
    this.q = [];
    this.top_elem = 0;
};

/**
 * æ·»åŠ å…ƒç´ åˆ°æ ˆé¡¶
 */
MyStack.prototype.push = function(x) {
    // x æ˜¯é˜Ÿåˆ—çš„é˜Ÿå°¾ï¼Œæ˜¯æ ˆçš„æ ˆé¡¶
    this.q.push(x);
    this.top_elem = x;
};

/**
 * è¿”å›æ ˆé¡¶å…ƒç´ 
 */
MyStack.prototype.top = function() {
    return this.top_elem;
};

/**
 * åˆ é™¤æ ˆé¡¶çš„å…ƒç´ å¹¶è¿”å›
 */
MyStack.prototype.pop = function() {
    var size = this.q.length;
    // ç•™ä¸‹é˜Ÿå°¾ 2 ä¸ªå…ƒç´ 
    while (size > 2) {
        this.q.push(this.q.shift());
        size--;
    }
    // è®°å½•æ–°çš„é˜Ÿå°¾å…ƒç´ 
    this.top_elem = this.q[0];
    this.q.push(this.q.shift());
    // åˆ é™¤ä¹‹å‰çš„é˜Ÿå°¾å…ƒç´ 
    return this.q.shift();
};

/**
 * åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
 */
MyStack.prototype.empty = function() {
    return this.q.length === 0;
};
```

```python
# by chatGPT (python)
from queue import Queue

class MyStack:
    def __init__(self):
        self.q = Queue()
        self.top_elem = 0

    def push(self, x: int) -> None:
        """
        æ·»åŠ å…ƒç´ åˆ°æ ˆé¡¶
        """
        # x æ˜¯é˜Ÿåˆ—çš„é˜Ÿå°¾ï¼Œæ˜¯æ ˆçš„æ ˆé¡¶
        self.q.put(x)
        self.top_elem = x

    def pop(self) -> int:
        """
        åˆ é™¤æ ˆé¡¶çš„å…ƒç´ å¹¶è¿”å›
        """
        size = self.q.qsize()
        # ç•™ä¸‹é˜Ÿå°¾ 2 ä¸ªå…ƒç´ 
        while size > 2:
            self.q.put(self.q.get())
            size -= 1
        # è®°å½•æ–°çš„é˜Ÿå°¾å…ƒç´ 
        self.top_elem = self.q.queue[0]
        self.q.put(self.q.get())
        # åˆ é™¤ä¹‹å‰çš„é˜Ÿå°¾å…ƒç´ 
        return self.q.get()

    def top(self) -> int:
        """
        è¿”å›æ ˆé¡¶å…ƒç´ 
        """
        return self.top_elem

    def empty(self) -> bool:
        """
        åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
        """
        return self.q.empty()
```

https://leetcode.cn/problems/implement-stack-using-queues çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/insert-delete-getrandom-o1 çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class RandomizedSet {
    public:
    // å­˜å‚¨å…ƒç´ çš„å€¼
    vector<int> nums;
    // è®°å½•æ¯ä¸ªå…ƒç´ å¯¹åº”åœ¨ nums ä¸­çš„ç´¢å¼•
    unordered_map<int,int> valToIndex;

    bool insert(int val) {
        // è‹¥ val å·²å­˜åœ¨ï¼Œä¸ç”¨å†æ’å…¥
        if (valToIndex.count(val)) {
            return false;
        }
        // è‹¥ val ä¸å­˜åœ¨ï¼Œæ’å…¥åˆ° nums å°¾éƒ¨ï¼Œ
        // å¹¶è®°å½• val å¯¹åº”çš„ç´¢å¼•å€¼
        valToIndex[val] = nums.size();
        nums.push_back(val);
        return true;
    }

    bool remove(int val) {
        // è‹¥ val ä¸å­˜åœ¨ï¼Œä¸ç”¨å†åˆ é™¤
        if (!valToIndex.count(val)) {
            return false;
        }
        // å…ˆæ‹¿åˆ° val çš„ç´¢å¼•
        int index = valToIndex[val];
        // å°†æœ€åä¸€ä¸ªå…ƒç´ å¯¹åº”çš„ç´¢å¼•ä¿®æ”¹ä¸º index
        valToIndex[nums.back()] = index;
        // äº¤æ¢ val å’Œæœ€åä¸€ä¸ªå…ƒç´ 
        swap(nums[index], nums.back());
        // åœ¨æ•°ç»„ä¸­åˆ é™¤å…ƒç´  val
        nums.pop_back();
        // åˆ é™¤å…ƒç´  val å¯¹åº”çš„ç´¢å¼•
        valToIndex.erase(val);
        return true;
    }

    int getRandom() {
        // éšæœºè·å– nums ä¸­çš„ä¸€ä¸ªå…ƒç´ 
        return nums[rand() % nums.size()];
    }
};
```

```go
// by chatGPT (go)
type RandomizedSet struct {
    // å­˜å‚¨å…ƒç´ çš„å€¼
    nums []int
    // è®°å½•æ¯ä¸ªå…ƒç´ å¯¹åº”åœ¨ nums ä¸­çš„ç´¢å¼•
    valToIndex map[int]int
}

func Constructor() RandomizedSet {
    return RandomizedSet{
        nums: []int{},
        valToIndex: make(map[int]int),
    }
}

func (this *RandomizedSet) Insert(val int) bool {
    // è‹¥ val å·²å­˜åœ¨ï¼Œä¸ç”¨å†æ’å…¥
    if _, ok := this.valToIndex[val]; ok {
        return false
    }
    // è‹¥ val ä¸å­˜åœ¨ï¼Œæ’å…¥åˆ° nums å°¾éƒ¨ï¼Œ
    // å¹¶è®°å½• val å¯¹åº”çš„ç´¢å¼•å€¼
    this.valToIndex[val] = len(this.nums)
    this.nums = append(this.nums, val)
    return true
}

func (this *RandomizedSet) Remove(val int) bool {
    // è‹¥ val ä¸å­˜åœ¨ï¼Œä¸ç”¨å†åˆ é™¤
    if _, ok := this.valToIndex[val]; !ok {
        return false
    }
    // å…ˆæ‹¿åˆ° val çš„ç´¢å¼•
    index := this.valToIndex[val]
    // å°†æœ€åä¸€ä¸ªå…ƒç´ å¯¹åº”çš„ç´¢å¼•ä¿®æ”¹ä¸º index
    this.valToIndex[this.nums[len(this.nums)-1]] = index
    // äº¤æ¢ val å’Œæœ€åä¸€ä¸ªå…ƒç´ 
    this.nums[index], this.nums[len(this.nums)-1] = this.nums[len(this.nums)-1], this.nums[index]
    // åœ¨æ•°ç»„ä¸­åˆ é™¤å…ƒç´  val
    this.nums = this.nums[:len(this.nums)-1]
    // åˆ é™¤å…ƒç´  val å¯¹åº”çš„ç´¢å¼•
    delete(this.valToIndex, val)
    return true
}

func (this *RandomizedSet) GetRandom() int {
    // éšæœºè·å– nums ä¸­çš„ä¸€ä¸ªå…ƒç´ 
    return this.nums[rand.Intn(len(this.nums))]
}
```

```java
// by chatGPT (java)
class RandomizedSet {
    // å­˜å‚¨å…ƒç´ çš„å€¼
    List<Integer> nums;
    // è®°å½•æ¯ä¸ªå…ƒç´ å¯¹åº”åœ¨ nums ä¸­çš„ç´¢å¼•
    Map<Integer, Integer> valToIndex;

    public RandomizedSet() {
        nums = new ArrayList<>();
        valToIndex = new HashMap<>();
    }

    public boolean insert(int val) {
        // è‹¥ val å·²å­˜åœ¨ï¼Œä¸ç”¨å†æ’å…¥
        if (valToIndex.containsKey(val)) {
            return false;
        }
        // è‹¥ val ä¸å­˜åœ¨ï¼Œæ’å…¥åˆ° nums å°¾éƒ¨ï¼Œ
        // å¹¶è®°å½• val å¯¹åº”çš„ç´¢å¼•å€¼
        valToIndex.put(val, nums.size());
        nums.add(val);
        return true;
    }

    public boolean remove(int val) {
        // è‹¥ val ä¸å­˜åœ¨ï¼Œä¸ç”¨å†åˆ é™¤
        if (!valToIndex.containsKey(val)) {
            return false;
        }
        // å…ˆæ‹¿åˆ° val çš„ç´¢å¼•
        int index = valToIndex.get(val);
        // å°†æœ€åä¸€ä¸ªå…ƒç´ å¯¹åº”çš„ç´¢å¼•ä¿®æ”¹ä¸º index
        valToIndex.put(nums.get(nums.size() - 1), index);
        // äº¤æ¢ val å’Œæœ€åä¸€ä¸ªå…ƒç´ 
        Collections.swap(nums, index, nums.size() - 1);
        // åœ¨æ•°ç»„ä¸­åˆ é™¤å…ƒç´  val
        nums.remove(nums.size() - 1);
        // åˆ é™¤å…ƒç´  val å¯¹åº”çš„ç´¢å¼•
        valToIndex.remove(val);
        return true;
    }

    public int getRandom() {
        // éšæœºè·å– nums ä¸­çš„ä¸€ä¸ªå…ƒç´ 
        return nums.get((int)(Math.random() * nums.size()));
    }
}
```

```javascript
// by chatGPT (javascript)
var RandomizedSet = function() {
    // å­˜å‚¨å…ƒç´ çš„å€¼
    this.nums = [];
    // è®°å½•æ¯ä¸ªå…ƒç´ å¯¹åº”åœ¨ nums ä¸­çš„ç´¢å¼•
    this.valToIndex = {};
};

RandomizedSet.prototype.insert = function(val) {
    // è‹¥ val å·²å­˜åœ¨ï¼Œä¸ç”¨å†æ’å…¥
    if (this.valToIndex[val] !== undefined) {
        return false;
    }
    // è‹¥ val ä¸å­˜åœ¨ï¼Œæ’å…¥åˆ° nums å°¾éƒ¨ï¼Œ
    // å¹¶è®°å½• val å¯¹åº”çš„ç´¢å¼•å€¼
    this.valToIndex[val] = this.nums.length;
    this.nums.push(val);
    return true;
};

RandomizedSet.prototype.remove = function(val) {
    // è‹¥ val ä¸å­˜åœ¨ï¼Œä¸ç”¨å†åˆ é™¤
    if (this.valToIndex[val] === undefined) {
        return false;
    }
    // å…ˆæ‹¿åˆ° val çš„ç´¢å¼•
    var index = this.valToIndex[val];
    // å°†æœ€åä¸€ä¸ªå…ƒç´ å¯¹åº”çš„ç´¢å¼•ä¿®æ”¹ä¸º index
    this.valToIndex[this.nums[this.nums.length - 1]] = index;
    // äº¤æ¢ val å’Œæœ€åä¸€ä¸ªå…ƒç´ 
    var temp = this.nums[index];
    this.nums[index] = this.nums[this.nums.length - 1];
    this.nums[this.nums.length - 1] = temp;
    // åœ¨æ•°ç»„ä¸­åˆ é™¤å…ƒç´  val
    this.nums.pop();
    // åˆ é™¤å…ƒç´  val å¯¹åº”çš„ç´¢å¼•
    delete this.valToIndex[val];
    return true;
};

RandomizedSet.prototype.getRandom = function() {
    // éšæœºè·å– nums ä¸­çš„ä¸€ä¸ªå…ƒç´ 
    return this.nums[Math.floor(Math.random() * this.nums.length)];
};
```

```python
# by chatGPT (python)
class RandomizedSet:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.nums = []              # å­˜å‚¨å…ƒç´ çš„å€¼
        self.valToIndex = dict()    # è®°å½•æ¯ä¸ªå…ƒç´ å¯¹åº”åœ¨ nums ä¸­çš„ç´¢å¼•

    def insert(self, val: int) -> bool:
        """
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        """
        # è‹¥ val å·²å­˜åœ¨ï¼Œä¸ç”¨å†æ’å…¥
        if val in self.valToIndex:
            return False
        # è‹¥ val ä¸å­˜åœ¨ï¼Œæ’å…¥åˆ° nums å°¾éƒ¨ï¼Œ
        # å¹¶è®°å½• val å¯¹åº”çš„ç´¢å¼•å€¼
        self.valToIndex[val] = len(self.nums)
        self.nums.append(val)
        return True

    def remove(self, val: int) -> bool:
        """
        Removes a value from the set. Returns true if the set contained the specified element.
        """
        # è‹¥ val ä¸å­˜åœ¨ï¼Œä¸ç”¨å†åˆ é™¤
        if val not in self.valToIndex:
            return False
        # å…ˆæ‹¿åˆ° val çš„ç´¢å¼•
        index = self.valToIndex[val]
        # å°†æœ€åä¸€ä¸ªå…ƒç´ å¯¹åº”çš„ç´¢å¼•ä¿®æ”¹ä¸º index
        self.valToIndex[self.nums[-1]] = index
        # äº¤æ¢ val å’Œæœ€åä¸€ä¸ªå…ƒç´ 
        self.nums[index], self.nums[-1] = self.nums[-1], self.nums[index]
        # åœ¨æ•°ç»„ä¸­åˆ é™¤å…ƒç´  val
        self.nums.pop()
        # åˆ é™¤å…ƒç´  val å¯¹åº”çš„ç´¢å¼•
        del self.valToIndex[val]
        return True

    def getRandom(self) -> int:
        """
        Get a random element from the set.
        """
        # éšæœºè·å– nums ä¸­çš„ä¸€ä¸ªå…ƒç´ 
        return self.nums[random.randint(0, len(self.nums) - 1)]
```

https://leetcode.cn/problems/insert-delete-getrandom-o1 çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/insert-into-a-binary-search-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        // æ‰¾åˆ°ç©ºä½ç½®æ’å…¥æ–°èŠ‚ç‚¹
        if (root == nullptr) return new TreeNode(val);
        // if (root->val == val)
        //     BST ä¸­ä¸€èˆ¬ä¸ä¼šæ’å…¥å·²å­˜åœ¨å…ƒç´ 
        if (root->val < val)
            root->right = insertIntoBST(root->right, val);
        if (root->val > val)
            root->left = insertIntoBST(root->left, val);
        return root;
    }
};
```

```go
// by chatGPT (go)
func insertIntoBST(root *TreeNode, val int) *TreeNode {
    // æ‰¾åˆ°ç©ºä½ç½®æ’å…¥æ–°èŠ‚ç‚¹
    if root == nil {
        return &TreeNode{Val: val}
    }
    // if (root.val == val)
    //     BST ä¸­ä¸€èˆ¬ä¸ä¼šæ’å…¥å·²å­˜åœ¨å…ƒç´ 
    if root.Val < val {
        root.Right = insertIntoBST(root.Right, val)
    }
    if root.Val > val {
        root.Left = insertIntoBST(root.Left, val)
    }
    return root
}
```

```java
// by labuladong (java)
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        // æ‰¾åˆ°ç©ºä½ç½®æ’å…¥æ–°èŠ‚ç‚¹
        if (root == null) return new TreeNode(val);
        // if (root.val == val)
        //     BST ä¸­ä¸€èˆ¬ä¸ä¼šæ’å…¥å·²å­˜åœ¨å…ƒç´ 
        if (root.val < val)
            root.right = insertIntoBST(root.right, val);
        if (root.val > val)
            root.left = insertIntoBST(root.left, val);
        return root;
    }
}
```

```javascript
// by chatGPT (javascript)
var insertIntoBST = function(root, val) {
    // æ‰¾åˆ°ç©ºä½ç½®æ’å…¥æ–°èŠ‚ç‚¹
    if (root == null) return new TreeNode(val);
    // if (root.val == val)
    //     BST ä¸­ä¸€èˆ¬ä¸ä¼šæ’å…¥å·²å­˜åœ¨å…ƒç´ 
    if (root.val < val)
        root.right = insertIntoBST(root.right, val);
    if (root.val > val)
        root.left = insertIntoBST(root.left, val);
    return root;
};
```

```python
# by chatGPT (python)
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        # æ‰¾åˆ°ç©ºä½ç½®æ’å…¥æ–°èŠ‚ç‚¹
        if root is None:
            return TreeNode(val)
        # if (root.val == val)
        #     BST ä¸­ä¸€èˆ¬ä¸ä¼šæ’å…¥å·²å­˜åœ¨å…ƒç´ 
        if root.val < val:
            root.right = self.insertIntoBST(root.right, val)
        if root.val > val:
            root.left = self.insertIntoBST(root.left, val)
        return root
```

https://leetcode.cn/problems/insert-into-a-binary-search-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/intersection-of-two-linked-lists çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        // p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
        ListNode *p1 = headA, *p2 = headB;
        while (p1 != p2) {
            // p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
            if (p1 == nullptr) p1 = headB;
            else                p1 = p1->next;
            // p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
            if (p2 == nullptr) p2 = headA;
            else                p2 = p2->next;
        }
        return p1;
    }
};
```

```go
// by chatGPT (go)
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    // p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
    p1, p2 := headA, headB
    for p1 != p2 {
        // p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
        if p1 == nil {
            p1 = headB
        } else {
            p1 = p1.Next
        }
        // p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
        if p2 == nil {
            p2 = headA
        } else {
            p2 = p2.Next
        }
    }
    return p1
}
```

```java
// by labuladong (java)
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
        ListNode p1 = headA, p2 = headB;
        while (p1 != p2) {
            // p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
            if (p1 == null) p1 = headB;
            else            p1 = p1.next;
            // p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
            if (p2 == null) p2 = headA;
            else            p2 = p2.next;
        }
        return p1;
    }
}
```

```javascript
// by chatGPT (javascript)
var getIntersectionNode = function(headA, headB) {
    // p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
    let p1 = headA, p2 = headB;
    while (p1 !== p2) {
        // p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
        if (p1 === null) p1 = headB;
        else             p1 = p1.next;
        // p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
        if (p2 === null) p2 = headA;
        else             p2 = p2.next;
    }
    return p1;
};
```

```python
# by chatGPT (python)
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        # p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
        p1, p2 = headA, headB
        while p1 != p2:
            # p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
            if p1 is None:
                p1 = headB
            else:
                p1 = p1.next
            # p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
            if p2 is None:
                p2 = headA
            else:
                p2 = p2.next
        return p1
```

https://leetcode.cn/problems/intersection-of-two-linked-lists çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/interval-list-intersections çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> intervalIntersection(vector<vector<int>>& A, vector<vector<int>>& B) {
        vector<vector<int>> res;
        int i = 0, j = 0;
        while (i < A.size() && j < B.size()) {
            int a1 = A[i][0], a2 = A[i][1];
            int b1 = B[j][0], b2 = B[j][1];

            if (b2 >= a1 && a2 >= b1) {
                res.push_back({
                    max(a1, b1), min(a2, b2)
                });
            }
            if (b2 < a2) {
                j++;
            } else {
                i++;
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func intervalIntersection(A [][]int, B [][]int) [][]int {
    res := [][]int{}
    i, j := 0, 0
    for i < len(A) && j < len(B) {
        a1, a2 := A[i][0], A[i][1]
        b1, b2 := B[j][0], B[j][1]

        if b2 >= a1 && a2 >= b1 {
            res = append(res, []int{
                max(a1, b1), min(a2, b2),
            })
        }
        if b2 < a2 {
            j++
        } else {
            i++
        }
    }
    return res
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}

func min(x, y int) int {
    if x < y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {
    public int[][] intervalIntersection(int[][] A, int[][] B) {
        List<int[]> res = new LinkedList<>();
        int i = 0, j = 0;
        while (i < A.length && j < B.length) {
            int a1 = A[i][0], a2 = A[i][1];
            int b1 = B[j][0], b2 = B[j][1];

            if (b2 >= a1 && a2 >= b1) {
                res.add(new int[]{
                        Math.max(a1, b1), Math.min(a2, b2)
                });
            }
            if (b2 < a2) {
                j++;
            } else {
                i++;
            }
        }
        return res.toArray(new int[0][0]);
    }
}
```

```javascript
// by chatGPT (javascript)
var intervalIntersection = function(A, B) {
    const res = [];
    let i = 0, j = 0;
    while (i < A.length && j < B.length) {
        const a1 = A[i][0], a2 = A[i][1];
        const b1 = B[j][0], b2 = B[j][1];

        if (b2 >= a1 && a2 >= b1) {
            res.push([
                Math.max(a1, b1), Math.min(a2, b2)
            ]);
        }
        if (b2 < a2) {
            j++;
        } else {
            i++;
        }
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        res = []
        i, j = 0, 0
        while i < len(A) and j < len(B):
            a1, a2 = A[i][0], A[i][1]
            b1, b2 = B[j][0], B[j][1]

            if b2 >= a1 and a2 >= b1:
                res.append([max(a1, b1), min(a2, b2)])

            if b2 < a2:
                j += 1
            else:
                i += 1

        return res
```

https://leetcode.cn/problems/interval-list-intersections çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/invert-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
// ã€Œéå†ã€çš„æ€è·¯
class Solution {
public:
    // ä¸»å‡½æ•°
    TreeNode* invertTree(TreeNode* root) {
        // éå†äºŒå‰æ ‘ï¼Œäº¤æ¢æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
        traverse(root);
        return root;
    }

    // äºŒå‰æ ‘éå†å‡½æ•°
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }

        /**** å‰åºä½ç½® ****/
        // æ¯ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦åšçš„äº‹å°±æ˜¯äº¤æ¢å®ƒçš„å·¦å³å­èŠ‚ç‚¹
        TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;

        // éå†æ¡†æ¶ï¼Œå»éå†å·¦å³å­æ ‘çš„èŠ‚ç‚¹
        traverse(root->left);
        traverse(root->right);
    }
};

// ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯
class Solution2 {
public:
    // å®šä¹‰ï¼šå°†ä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘ç¿»è½¬ï¼Œè¿”å›ç¿»è½¬åçš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }
        // åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œå…ˆç¿»è½¬å·¦å³å­æ ‘
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);

        // ç„¶åäº¤æ¢å·¦å³å­èŠ‚ç‚¹
        root->left = right;
        root->right = left;

        // å’Œå®šä¹‰é€»è¾‘è‡ªæ°ï¼šä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘å·²ç»è¢«ç¿»è½¬ï¼Œè¿”å› root
        return root;
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

//ã€Œéå†ã€çš„æ€è·¯
func invertTree(root *TreeNode) *TreeNode {
    //éå†äºŒå‰æ ‘ï¼Œäº¤æ¢æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
    traverse(root)
    return root
} 

//äºŒå‰æ ‘éå†å‡½æ•°
func traverse(root *TreeNode) {
    if root == nil {
        return
    }
    // æ¯ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦åšçš„äº‹å°±æ˜¯äº¤æ¢å®ƒçš„å·¦å³å­èŠ‚ç‚¹
    tmp := root.Left
    root.Left = root.Right
    root.Right = tmp
    // éå†æ¡†æ¶ï¼Œå»éå†å·¦å³å­æ ‘çš„èŠ‚ç‚¹
    traverse(root.Left)
    traverse(root.Right)
}

// ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯
func invertTree2(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    // åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œå…ˆç¿»è½¬å·¦å³å­æ ‘
    left := invertTree2(root.Left)
    right := invertTree2(root.Right)
    // ç„¶åäº¤æ¢å·¦å³å­èŠ‚ç‚¹
    root.Left = right
    root.Right = left
    // å’Œå®šä¹‰é€»è¾‘è‡ªæ°ï¼šä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘å·²ç»è¢«ç¿»è½¬ï¼Œè¿”å› root
    return root
}
```

```java
// by labuladong (java)
// ã€Œéå†ã€çš„æ€è·¯
class Solution {
    // ä¸»å‡½æ•°
    public TreeNode invertTree(TreeNode root) {
        // éå†äºŒå‰æ ‘ï¼Œäº¤æ¢æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
        traverse(root);
        return root;
    }

    // äºŒå‰æ ‘éå†å‡½æ•°
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }

        /**** å‰åºä½ç½® ****/
        // æ¯ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦åšçš„äº‹å°±æ˜¯äº¤æ¢å®ƒçš„å·¦å³å­èŠ‚ç‚¹
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;

        // éå†æ¡†æ¶ï¼Œå»éå†å·¦å³å­æ ‘çš„èŠ‚ç‚¹
        traverse(root.left);
        traverse(root.right);
    }
}

// ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯
class Solution2 {
    // å®šä¹‰ï¼šå°†ä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘ç¿»è½¬ï¼Œè¿”å›ç¿»è½¬åçš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        // åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œå…ˆç¿»è½¬å·¦å³å­æ ‘
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);

        // ç„¶åäº¤æ¢å·¦å³å­èŠ‚ç‚¹
        root.left = right;
        root.right = left;

        // å’Œå®šä¹‰é€»è¾‘è‡ªæ°ï¼šä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘å·²ç»è¢«ç¿»è½¬ï¼Œè¿”å› root
        return root;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * ã€Œéå†ã€çš„æ€è·¯
 */
var invertTree = function(root) {
  /**
   * äºŒå‰æ ‘éå†å‡½æ•°
   */
  var traverse = function(root) {
    if (root === null) {
      return;
    }

    /**** å‰åºä½ç½® ****/
    // æ¯ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦åšçš„äº‹å°±æ˜¯äº¤æ¢å®ƒçš„å·¦å³å­èŠ‚ç‚¹
    var tmp = root.left;
    root.left = root.right;
    root.right = tmp;

    // éå†æ¡†æ¶ï¼Œå»éå†å·¦å³å­æ ‘çš„èŠ‚ç‚¹
    traverse(root.left);
    traverse(root.right);
  }

  // éå†äºŒå‰æ ‘ï¼Œäº¤æ¢æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
  traverse(root);
  return root;
};

/**
 * ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯
 */
var invertTree2 = function(root) {
  /**
   * å®šä¹‰ï¼šå°†ä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘ç¿»è½¬ï¼Œè¿”å›ç¿»è½¬åçš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
   */
  var invert = function(root) {
    if (root === null) {
      return null;
    }
    // åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œå…ˆç¿»è½¬å·¦å³å­æ ‘
    var left = invert(root.left);
    var right = invert(root.right);

    // ç„¶åäº¤æ¢å·¦å³å­èŠ‚ç‚¹
    root.left = right;
    root.right = left;

    // å’Œå®šä¹‰é€»è¾‘è‡ªæ°ï¼šä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘å·²ç»è¢«ç¿»è½¬ï¼Œè¿”å› root
    return root;
  }

  // è¿”å›ç¿»è½¬åçš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
  return invert(root);
};
```

```python
# by chatGPT (python)
# ã€Œéå†ã€çš„æ€è·¯
class Solution:
    # ä¸»å‡½æ•°
    def invertTree(self, root: TreeNode) -> TreeNode:
        # éå†äºŒå‰æ ‘ï¼Œäº¤æ¢æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
        self.traverse(root)
        return root

    # äºŒå‰æ ‘éå†å‡½æ•°
    def traverse(self, root: TreeNode) -> None:
        if not root:
            return

        # å‰åºä½ç½®
        # æ¯ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦åšçš„äº‹å°±æ˜¯äº¤æ¢å®ƒçš„å·¦å³å­èŠ‚ç‚¹
        tmp = root.left
        root.left = root.right
        root.right = tmp

        # éå†æ¡†æ¶ï¼Œå»éå†å·¦å³å­æ ‘çš„èŠ‚ç‚¹
        self.traverse(root.left)
        self.traverse(root.right)


# ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯
class Solution2:
    # å®šä¹‰ï¼šå°†ä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘ç¿»è½¬ï¼Œè¿”å›ç¿»è½¬åçš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        # åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œå…ˆç¿»è½¬å·¦å³å­æ ‘
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)

        # ç„¶åäº¤æ¢å·¦å³å­èŠ‚ç‚¹
        root.left = right
        root.right = left

        # å’Œå®šä¹‰é€»è¾‘è‡ªæ°ï¼šä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘å·²ç»è¢«ç¿»è½¬ï¼Œè¿”å› root
        return root
```

https://leetcode.cn/problems/invert-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/is-graph-bipartite çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // è®°å½•å›¾æ˜¯å¦ç¬¦åˆäºŒåˆ†å›¾æ€§è´¨
    bool ok = true;
    // è®°å½•å›¾ä¸­èŠ‚ç‚¹çš„é¢œè‰²ï¼Œfalse å’Œ true ä»£è¡¨ä¸¤ç§ä¸åŒé¢œè‰²
    vector<bool> color;
    // è®°å½•å›¾ä¸­èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡
    vector<bool> visited;

    // ä¸»å‡½æ•°ï¼Œè¾“å…¥é‚»æ¥è¡¨ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        color.resize(n);
        visited.resize(n);
        // å› ä¸ºå›¾ä¸ä¸€å®šæ˜¯è”é€šçš„ï¼Œå¯èƒ½å­˜åœ¨å¤šä¸ªå­å›¾
        // æ‰€ä»¥è¦æŠŠæ¯ä¸ªèŠ‚ç‚¹éƒ½ä½œä¸ºèµ·ç‚¹è¿›è¡Œä¸€æ¬¡éå†
        // å¦‚æœå‘ç°ä»»ä½•ä¸€ä¸ªå­å›¾ä¸æ˜¯äºŒåˆ†å›¾ï¼Œæ•´å¹…å›¾éƒ½ä¸ç®—äºŒåˆ†å›¾
        for (int v = 0; v < n; v++) {
            if (!visited[v]) {
                traverse(graph, v);
            }
        }
        return ok;
    }

    // DFS éå†æ¡†æ¶
    void traverse(vector<vector<int>>& graph, int v) {
        // å¦‚æœå·²ç»ç¡®å®šä¸æ˜¯äºŒåˆ†å›¾äº†ï¼Œå°±ä¸ç”¨æµªè´¹æ—¶é—´å†é€’å½’éå†äº†
        if (!ok) return;

        visited[v] = true;
        for (int w : graph[v]) {
            if (!visited[w]) {
                // ç›¸é‚»èŠ‚ç‚¹ w æ²¡æœ‰è¢«è®¿é—®è¿‡
                // é‚£ä¹ˆåº”è¯¥ç»™èŠ‚ç‚¹ w æ¶‚ä¸Šå’ŒèŠ‚ç‚¹ v ä¸åŒçš„é¢œè‰²
                color[w] = !color[v];
                // ç»§ç»­éå† w
                traverse(graph, w);
            } else {
                // ç›¸é‚»èŠ‚ç‚¹ w å·²ç»è¢«è®¿é—®è¿‡
                // æ ¹æ® v å’Œ w çš„é¢œè‰²åˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾
                if (color[w] == color[v]) {
                    // è‹¥ç›¸åŒï¼Œåˆ™æ­¤å›¾ä¸æ˜¯äºŒåˆ†å›¾
                    ok = false;
                }
            }
        }
    }
};
```

```go
// by chatGPT (go)
func isBipartite(graph [][]int) bool {
    n := len(graph)
    // è®°å½•å›¾æ˜¯å¦ç¬¦åˆäºŒåˆ†å›¾æ€§è´¨
    ok := true
    // è®°å½•å›¾ä¸­èŠ‚ç‚¹çš„é¢œè‰²ï¼Œfalse å’Œ true ä»£è¡¨ä¸¤ç§ä¸åŒé¢œè‰²
    color := make([]bool, n)
    // è®°å½•å›¾ä¸­èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡
    visited := make([]bool, n)

    traverse := func(v int) {
        // å¦‚æœå·²ç»ç¡®å®šä¸æ˜¯äºŒåˆ†å›¾äº†ï¼Œå°±ä¸ç”¨æµªè´¹æ—¶é—´å†é€’å½’éå†äº†
        if !ok {
            return
        }

        visited[v] = true
        for _, w := range graph[v] {
            if !visited[w] {
                // ç›¸é‚»èŠ‚ç‚¹ w æ²¡æœ‰è¢«è®¿é—®è¿‡
                // é‚£ä¹ˆåº”è¯¥ç»™èŠ‚ç‚¹ w æ¶‚ä¸Šå’ŒèŠ‚ç‚¹ v ä¸åŒçš„é¢œè‰²
                color[w] = !color[v]
                // ç»§ç»­éå† w
                traverse(w)
            } else {
                // ç›¸é‚»èŠ‚ç‚¹ w å·²ç»è¢«è®¿é—®è¿‡
                // æ ¹æ® v å’Œ w çš„é¢œè‰²åˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾
                if color[w] == color[v] {
                    // è‹¥ç›¸åŒï¼Œåˆ™æ­¤å›¾ä¸æ˜¯äºŒåˆ†å›¾
                    ok = false
                }
            }
        }
    }

    // å› ä¸ºå›¾ä¸ä¸€å®šæ˜¯è”é€šçš„ï¼Œå¯èƒ½å­˜åœ¨å¤šä¸ªå­å›¾
    // æ‰€ä»¥è¦æŠŠæ¯ä¸ªèŠ‚ç‚¹éƒ½ä½œä¸ºèµ·ç‚¹è¿›è¡Œä¸€æ¬¡éå†
    // å¦‚æœå‘ç°ä»»ä½•ä¸€ä¸ªå­å›¾ä¸æ˜¯äºŒåˆ†å›¾ï¼Œæ•´å¹…å›¾éƒ½ä¸ç®—äºŒåˆ†å›¾
    for v := 0; v < n; v++ {
        if !visited[v] {
            traverse(v)
        }
    }
    return ok
}
```

```java
// by labuladong (java)
class Solution {

    // è®°å½•å›¾æ˜¯å¦ç¬¦åˆäºŒåˆ†å›¾æ€§è´¨
    private boolean ok = true;
    // è®°å½•å›¾ä¸­èŠ‚ç‚¹çš„é¢œè‰²ï¼Œfalse å’Œ true ä»£è¡¨ä¸¤ç§ä¸åŒé¢œè‰²
    private boolean[] color;
    // è®°å½•å›¾ä¸­èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡
    private boolean[] visited;

    // ä¸»å‡½æ•°ï¼Œè¾“å…¥é‚»æ¥è¡¨ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾
    public boolean isBipartite(int[][] graph) {
        int n = graph.length;
        color = new boolean[n];
        visited = new boolean[n];
        // å› ä¸ºå›¾ä¸ä¸€å®šæ˜¯è”é€šçš„ï¼Œå¯èƒ½å­˜åœ¨å¤šä¸ªå­å›¾
        // æ‰€ä»¥è¦æŠŠæ¯ä¸ªèŠ‚ç‚¹éƒ½ä½œä¸ºèµ·ç‚¹è¿›è¡Œä¸€æ¬¡éå†
        // å¦‚æœå‘ç°ä»»ä½•ä¸€ä¸ªå­å›¾ä¸æ˜¯äºŒåˆ†å›¾ï¼Œæ•´å¹…å›¾éƒ½ä¸ç®—äºŒåˆ†å›¾
        for (int v = 0; v < n; v++) {
            if (!visited[v]) {
                traverse(graph, v);
            }
        }
        return ok;
    }

    // DFS éå†æ¡†æ¶
    private void traverse(int[][] graph, int v) {
        // å¦‚æœå·²ç»ç¡®å®šä¸æ˜¯äºŒåˆ†å›¾äº†ï¼Œå°±ä¸ç”¨æµªè´¹æ—¶é—´å†é€’å½’éå†äº†
        if (!ok) return;

        visited[v] = true;
        for (int w : graph[v]) {
            if (!visited[w]) {
                // ç›¸é‚»èŠ‚ç‚¹ w æ²¡æœ‰è¢«è®¿é—®è¿‡
                // é‚£ä¹ˆåº”è¯¥ç»™èŠ‚ç‚¹ w æ¶‚ä¸Šå’ŒèŠ‚ç‚¹ v ä¸åŒçš„é¢œè‰²
                color[w] = !color[v];
                // ç»§ç»­éå† w
                traverse(graph, w);
            } else {
                // ç›¸é‚»èŠ‚ç‚¹ w å·²ç»è¢«è®¿é—®è¿‡
                // æ ¹æ® v å’Œ w çš„é¢œè‰²åˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾
                if (color[w] == color[v]) {
                    // è‹¥ç›¸åŒï¼Œåˆ™æ­¤å›¾ä¸æ˜¯äºŒåˆ†å›¾
                    ok = false;
                }
            }
        }
    }

}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} graph é‚»æ¥è¡¨
 * @return {boolean} æ˜¯å¦æ˜¯äºŒåˆ†å›¾
 */
var isBipartite = function(graph) {
    // è®°å½•å›¾æ˜¯å¦ç¬¦åˆäºŒåˆ†å›¾æ€§è´¨
    let ok = true;
    // è®°å½•å›¾ä¸­èŠ‚ç‚¹çš„é¢œè‰²ï¼Œfalse å’Œ true ä»£è¡¨ä¸¤ç§ä¸åŒé¢œè‰²
    const color = new Array(graph.length).fill(false);
    // è®°å½•å›¾ä¸­èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡
    const visited = new Array(graph.length).fill(false);

    /**
     * DFS éå†æ¡†æ¶
     * @param {number} v èŠ‚ç‚¹
     */
    const traverse = function(v) {
        // å¦‚æœå·²ç»ç¡®å®šä¸æ˜¯äºŒåˆ†å›¾äº†ï¼Œå°±ä¸ç”¨æµªè´¹æ—¶é—´å†é€’å½’éå†äº†
        if (!ok) {
            return;
        }

        visited[v] = true;
        for (const w of graph[v]) {
            if (!visited[w]) {
                // ç›¸é‚»èŠ‚ç‚¹ w æ²¡æœ‰è¢«è®¿é—®è¿‡
                // é‚£ä¹ˆåº”è¯¥ç»™èŠ‚ç‚¹ w æ¶‚ä¸Šå’ŒèŠ‚ç‚¹ v ä¸åŒçš„é¢œè‰²
                color[w] = !color[v];
                // ç»§ç»­éå† w
                traverse(w);
            } else {
                // ç›¸é‚»èŠ‚ç‚¹ w å·²ç»è¢«è®¿é—®è¿‡
                // æ ¹æ® v å’Œ w çš„é¢œè‰²åˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾
                if (color[w] === color[v]) {
                    // è‹¥ç›¸åŒï¼Œåˆ™æ­¤å›¾ä¸æ˜¯äºŒåˆ†å›¾
                    ok = false;
                }
            }
        }
    }

    // å› ä¸ºå›¾ä¸ä¸€å®šæ˜¯è”é€šçš„ï¼Œå¯èƒ½å­˜åœ¨å¤šä¸ªå­å›¾
    // æ‰€ä»¥è¦æŠŠæ¯ä¸ªèŠ‚ç‚¹éƒ½ä½œä¸ºèµ·ç‚¹è¿›è¡Œä¸€æ¬¡éå†
    // å¦‚æœå‘ç°ä»»ä½•ä¸€ä¸ªå­å›¾ä¸æ˜¯äºŒåˆ†å›¾ï¼Œæ•´å¹…å›¾éƒ½ä¸ç®—äºŒåˆ†å›¾
    for (let v = 0; v < graph.length; v++) {
        if (!visited[v]) {
            traverse(v);
        }
    }

    return ok;
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        # è®°å½•å›¾æ˜¯å¦ç¬¦åˆäºŒåˆ†å›¾æ€§è´¨
        self.ok = True
        # è®°å½•å›¾ä¸­èŠ‚ç‚¹çš„é¢œè‰²ï¼Œfalse å’Œ true ä»£è¡¨ä¸¤ç§ä¸åŒé¢œè‰²
        self.color = None
        # è®°å½•å›¾ä¸­èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡
        self.visited = None

    # ä¸»å‡½æ•°ï¼Œè¾“å…¥é‚»æ¥è¡¨ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        self.color = [False] * n
        self.visited = [False] * n
        # å› ä¸ºå›¾ä¸ä¸€å®šæ˜¯è”é€šçš„ï¼Œå¯èƒ½å­˜åœ¨å¤šä¸ªå­å›¾
        # æ‰€ä»¥è¦æŠŠæ¯ä¸ªèŠ‚ç‚¹éƒ½ä½œä¸ºèµ·ç‚¹è¿›è¡Œä¸€æ¬¡éå†
        # å¦‚æœå‘ç°ä»»ä½•ä¸€ä¸ªå­å›¾ä¸æ˜¯äºŒåˆ†å›¾ï¼Œæ•´å¹…å›¾éƒ½ä¸ç®—äºŒåˆ†å›¾
        for v in range(n):
            if not self.visited[v]:
                self.traverse(graph, v)
        return self.ok

    # DFS éå†æ¡†æ¶
    def traverse(self, graph: List[List[int]], v: int) -> None:
        # å¦‚æœå·²ç»ç¡®å®šä¸æ˜¯äºŒåˆ†å›¾äº†ï¼Œå°±ä¸ç”¨æµªè´¹æ—¶é—´å†é€’å½’éå†äº†
        if not self.ok:
            return

        self.visited[v] = True
        for w in graph[v]:
            if not self.visited[w]:
                # ç›¸é‚»èŠ‚ç‚¹ w æ²¡æœ‰è¢«è®¿é—®è¿‡
                # é‚£ä¹ˆåº”è¯¥ç»™èŠ‚ç‚¹ w æ¶‚ä¸Šå’ŒèŠ‚ç‚¹ v ä¸åŒçš„é¢œè‰²
                self.color[w] = not self.color[v]
                # ç»§ç»­éå† w
                self.traverse(graph, w)
            else:
                # ç›¸é‚»èŠ‚ç‚¹ w å·²ç»è¢«è®¿é—®è¿‡
                # æ ¹æ® v å’Œ w çš„é¢œè‰²åˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾
                if self.color[w] == self.color[v]:
                    # è‹¥ç›¸åŒï¼Œåˆ™æ­¤å›¾ä¸æ˜¯äºŒåˆ†å›¾
                    self.ok = False
```

https://leetcode.cn/problems/is-graph-bipartite çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/is-subsequence çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int i = 0, j = 0;
        while (i < s.length() && j < t.length()) {
            if (s[i] == t[j]) {
                i++;
            }
            j++;
        }
        return i == s.length();
    }
};
```

```go
// by chatGPT (go)
func isSubsequence(s string, t string) bool {
    i, j := 0, 0
    for i < len(s) && j < len(t) {
        if s[i] == t[j] {
            i++
        }
        j++
    }
    return i == len(s)
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isSubsequence(String s, String t) {
        int i = 0, j = 0;
        while (i < s.length() && j < t.length()) {
            if (s.charAt(i) == t.charAt(j)) {
                i++;
            }
            j++;
        }
        return i == s.length();
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isSubsequence = function(s, t) {
    let i = 0, j = 0;
    while (i < s.length && j < t.length) {
        if (s.charAt(i) === t.charAt(j)) {
            i++;
        }
        j++;
    }
    return i === s.length;
};
```

```python
# by chatGPT (python)
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i, j = 0, 0
        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                i += 1
            j += 1
        return i == len(s)
```

https://leetcode.cn/problems/is-subsequence çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/jBjn9C çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class KthLargest {
private:
    int k;
    // é»˜è®¤æ˜¯å°é¡¶å †
    priority_queue<int, vector<int>, greater<int>> pq;
public:
    KthLargest(int k, vector<int>& nums) {
        // å°† nums è£…å…¥å°é¡¶å †ï¼Œä¿ç•™ä¸‹å‰ k å¤§çš„å…ƒç´ 
        for (int e : nums) {
            pq.push(e);
            if (pq.size() > k) {
                pq.pop();
            }
        }
        this->k = k;
    }

    int add(int val) {
        // ç»´æŠ¤å°é¡¶å †åªä¿ç•™å‰ k å¤§çš„å…ƒç´ 
        pq.push(val);
        if (pq.size() > k) {
            pq.pop();
        }
        // å †é¡¶å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼ˆå³å€’æ•°ç¬¬ k å°çš„å…ƒç´ ï¼‰
        return pq.top();
    }
};
```

```go
// by chatGPT (go)
import (
	"container/heap"
)

// KthLargest æ˜¯ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œå®ƒç»´æŠ¤äº†ä¸€ä¸ªä¿ç•™å‰ k å¤§å…ƒç´ çš„å°é¡¶å †
type KthLargest struct {
	k  int
	pq PriorityQueue
}

// Constructor æ˜¯ KthLargest çš„æ„é€ å‡½æ•°
func Constructor(k int, nums []int) KthLargest {
	pq := make(PriorityQueue, 0, k)
	for _, e := range nums {
		pq.offer(e)
		if pq.Len() > k {
			pq.poll()
		}
	}
	return KthLargest{
		k:  k,
		pq: pq,
	}
}

// add æ–¹æ³•å°†ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°å°é¡¶å †ä¸­ï¼Œå¹¶è¿”å›ç¬¬ k å¤§å…ƒç´ 
func (kl *KthLargest) add(val int) int {
	kl.pq.offer(val)
	if kl.pq.Len() > kl.k {
		kl.pq.poll()
	}
	// å †é¡¶å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼ˆå³å€’æ•°ç¬¬ k å°çš„å…ƒç´ ï¼‰
	return kl.pq.peek()
}

// PriorityQueue æ˜¯ä¸€ä¸ªå¸¦æœ‰ Peek æ–¹æ³•çš„å°é¡¶å †
type PriorityQueue []int

// Len è¿”å›å°é¡¶å †ä¸­çš„å…ƒç´ æ•°é‡
func (pq PriorityQueue) Len() int {
	return len(pq)
}

// Less å®šä¹‰äº†å°é¡¶å †çš„æ’åºè§„åˆ™
func (pq PriorityQueue) Less(i, j int) bool {
	return pq[i] < pq[j]
}

// Swap äº¤æ¢å°é¡¶å †ä¸­çš„ä¸¤ä¸ªå…ƒç´ çš„ä½ç½®
func (pq PriorityQueue) Swap(i, j int) {
	pq[i], pq[j] = pq[j], pq[i]
}

// Push å‘å°é¡¶å †ä¸­æ·»åŠ ä¸€ä¸ªå…ƒç´ 
func (pq *PriorityQueue) Push(x interface{}) {
	item := x.(int)
	*pq = append(*pq, item)
}

// Pop ä»å°é¡¶å †ä¸­å¼¹å‡ºæœ€å°çš„å…ƒç´ 
func (pq *PriorityQueue) Pop() interface{} {
	old := *pq
	n := len(old)
	item := old[n-1]
	*pq = old[:n-1]
	return item
}

// Peek è¿”å›å°é¡¶å †ä¸­çš„æœ€å°å…ƒç´ 
func (pq PriorityQueue) Peek() int {
	return pq[0]
}
```

```java
// by labuladong (java)
class KthLargest {

    private int k;
    // é»˜è®¤æ˜¯å°é¡¶å †
    private PriorityQueue<Integer> pq = new PriorityQueue<>();

    public KthLargest(int k, int[] nums) {
        // å°† nums è£…å…¥å°é¡¶å †ï¼Œä¿ç•™ä¸‹å‰ k å¤§çš„å…ƒç´ 
        for (int e : nums) {
            pq.offer(e);
            if (pq.size() > k) {
                pq.poll();
            }
        }
        this.k = k;
    }

    public int add(int val) {
        // ç»´æŠ¤å°é¡¶å †åªä¿ç•™å‰ k å¤§çš„å…ƒç´ 
        pq.offer(val);
        if (pq.size() > k) {
            pq.poll();
        }
        // å †é¡¶å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼ˆå³å€’æ•°ç¬¬ k å°çš„å…ƒç´ ï¼‰
        return pq.peek();
    }
}
```

```javascript
// by chatGPT (javascript)
var KthLargest = function(k, nums) {
    this.k = k;
    // é»˜è®¤æ˜¯å°é¡¶å †
    this.pq = new PriorityQueue();
    // å°† nums è£…å…¥å°é¡¶å †ï¼Œä¿ç•™ä¸‹å‰ k å¤§çš„å…ƒç´ 
    for (let e of nums) {
        this.pq.offer(e);
        if (this.pq.size() > k) {
            this.pq.poll();
        }
    }
};

KthLargest.prototype.add = function(val) {
    // ç»´æŠ¤å°é¡¶å †åªä¿ç•™å‰ k å¤§çš„å…ƒç´ 
    this.pq.offer(val);
    if (this.pq.size() > this.k) {
        this.pq.poll();
    }
    // å †é¡¶å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼ˆå³å€’æ•°ç¬¬ k å°çš„å…ƒç´ ï¼‰
    return this.pq.peek();
};

// PriorityQueue implementation
var PriorityQueue = function() {
    this.data = [];
};

PriorityQueue.prototype.offer = function(val) {
    this.data.push(val);
    this.bubbleUp(this.data.length - 1);
};

PriorityQueue.prototype.poll = function() {
    const last = this.data.pop();
    const result = this.data[0];
    if (this.data.length > 0) {
        this.data[0] = last;
        this.bubbleDown(0);
    }
    return result;
};

PriorityQueue.prototype.peek = function() {
    return this.data[0];
};

PriorityQueue.prototype.size = function() {
    return this.data.length;
};

PriorityQueue.prototype.bubbleUp = function(pos) {
    while (pos > 0) {
        const parent = Math.floor((pos - 1) / 2);
        if (this.data[parent] > this.data[pos]) {
            this.swap(parent, pos);
            pos = parent;
        } else {
            break;
        }
    }
};

PriorityQueue.prototype.bubbleDown = function(pos) {
    while (pos * 2 + 1 < this.data.length) {
        let minChild = pos * 2 + 1;
        if (pos * 2 + 2 < this.data.length && this.data[pos * 2 + 2] < this.data[minChild]) {
            minChild = pos * 2 + 2;
        }
        if (this.data[minChild] < this.data[pos]) {
            this.swap(minChild, pos);
            pos = minChild;
        } else {
            break;
        }
    }
};

PriorityQueue.prototype.swap = function(i, j) {
    const temp = this.data[i];
    this.data[i] = this.data[j];
    this.data[j] = temp;
};
```

```python
# by chatGPT (python)
from queue import PriorityQueue

class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.k = k
        # é»˜è®¤æ˜¯å°é¡¶å †
        self.pq = PriorityQueue()
        # å°† nums è£…å…¥å°é¡¶å †ï¼Œä¿ç•™ä¸‹å‰ k å¤§çš„å…ƒç´ 
        for e in nums:
            self.pq.put(e)
            if self.pq.qsize() > k:
                self.pq.get()

    def add(self, val: int) -> int:
        # ç»´æŠ¤å°é¡¶å †åªä¿ç•™å‰ k å¤§çš„å…ƒç´ 
        self.pq.put(val)
        if self.pq.qsize() > self.k:
            self.pq.get()
        # å †é¡¶å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼ˆå³å€’æ•°ç¬¬ k å°çš„å…ƒç´ ï¼‰
        return self.pq.queue[0]
```

https://leetcode.cn/problems/jBjn9C çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int movingCount(int m, int n, int k) {
        vector<vector<bool>> visited(m, vector<bool>(n, false)); // åˆå§‹åŒ– visited çŸ©é˜µä¸º false
        dfs(m, n, k, 0, 0, visited);
        return res;
    }
    
    // è®°å½•åˆæ³•åæ ‡æ•°
    int res = 0;
    
    void dfs(int m, int n, int k, int i, int j, vector<vector<bool>>& visited) {
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return;
        }
        
        if (i / 10 + i % 10 + j / 10 + j % 10 > k) {
            // åæ ‡å’Œè¶…å‡º k çš„é™åˆ¶
            return;
        }
        
        if (visited[i][j]) {
            // ä¹‹å‰å·²ç»è®¿é—®è¿‡å½“å‰åæ ‡
            return;
        }
        
        // èµ°åˆ°ä¸€ä¸ªåˆæ³•åæ ‡
        res++;
        visited[i][j] = true;
        
        // DFS éå†ä¸Šä¸‹å·¦å³
        dfs(m, n, k, i + 1, j, visited);
        dfs(m, n, k, i, j + 1, visited);
        dfs(m, n, k, i - 1, j, visited);
        dfs(m, n, k, i, j - 1, visited);
    }
};
```

```go
// by chatGPT (go)
func movingCount(m int, n int, k int) int {
    visited := make([][]bool, m)
    for i := 0; i < m; i++ {
        visited[i] = make([]bool, n)
    }
    res := 0
    dfs(m, n, k, 0, 0, visited, &res)
    return res
}

func dfs(m, n, k, i, j int, visited [][]bool, res *int) {
    if i < 0 || j < 0 || i >= m || j >= n {
        return // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
    }
    if i/10+i%10+j/10+j%10 > k {
        return // åæ ‡å’Œè¶…å‡º k çš„é™åˆ¶
    }
    if visited[i][j] {
        return // ä¹‹å‰å·²ç»è®¿é—®è¿‡å½“å‰åæ ‡
    }
    *res++
    visited[i][j] = true
    dfs(m, n, k, i+1, j, visited, res)
    dfs(m, n, k, i, j+1, visited, res)
    dfs(m, n, k, i-1, j, visited, res)
    dfs(m, n, k, i, j-1, visited, res)
}
```

```java
// by labuladong (java)
class Solution {
    public int movingCount(int m, int n, int k) {
        boolean[][] visited = new boolean[m][n];
        dfs(m, n, k, 0, 0, visited);
        return res;
    }

    // è®°å½•åˆæ³•åæ ‡æ•°
    int res = 0;

    public void dfs(int m, int n, int k, int i, int j, boolean[][] visited) {
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return;
        }

        if (i / 10 + i % 10 + j / 10 + j % 10 > k) {
            // åæ ‡å’Œè¶…å‡º k çš„é™åˆ¶
            return;
        }

        if (visited[i][j]) {
            // ä¹‹å‰å·²ç»è®¿é—®è¿‡å½“å‰åæ ‡
            return;
        }

        // èµ°åˆ°ä¸€ä¸ªåˆæ³•åæ ‡
        res++;
        visited[i][j] = true;

        // DFS éå†ä¸Šä¸‹å·¦å³
        dfs(m, n, k, i + 1, j, visited);
        dfs(m, n, k, i, j + 1, visited);
        dfs(m, n, k, i - 1, j, visited);
        dfs(m, n, k, i, j - 1, visited);
    }
}
```

```javascript
// by chatGPT (javascript)
var movingCount = function(m, n, k) {
    let visited = new Array(m).fill(false).map(() => new Array(n).fill(false));
    let res = 0;
    
    function dfs(m, n, k, i, j, visited) {
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return;
        }

        if (Math.floor(i / 10) + i % 10 + Math.floor(j / 10) + j % 10 > k) {
            // åæ ‡å’Œè¶…å‡º k çš„é™åˆ¶
            return;
        }

        if (visited[i][j]) {
            // ä¹‹å‰å·²ç»è®¿é—®è¿‡å½“å‰åæ ‡
            return;
        }

        // èµ°åˆ°ä¸€ä¸ªåˆæ³•åæ ‡
        res++;
        visited[i][j] = true;

        // DFS éå†ä¸Šä¸‹å·¦å³
        dfs(m, n, k, i + 1, j, visited);
        dfs(m, n, k, i, j + 1, visited);
        dfs(m, n, k, i - 1, j, visited);
        dfs(m, n, k, i, j - 1, visited);
    }
    
    dfs(m, n, k, 0, 0, visited);
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def movingCount(self, m: int, n: int, k: int) -> int:
        def dfs(i: int, j: int, visited: List[List[bool]]):
            nonlocal res
            if i < 0 or j < 0 or i >= m or j >= n:
                # è¶…å‡ºç´¢å¼•è¾¹ç•Œ
                return

            if i // 10 + i % 10 + j // 10 + j % 10 > k:
                # åæ ‡å’Œè¶…å‡º k çš„é™åˆ¶
                return

            if visited[i][j]:
                # ä¹‹å‰å·²ç»è®¿é—®è¿‡å½“å‰åæ ‡
                return

            # èµ°åˆ°ä¸€ä¸ªåˆæ³•åæ ‡
            res += 1
            visited[i][j] = True

            # DFS éå†ä¸Šä¸‹å·¦å³
            dfs(i + 1, j, visited)
            dfs(i, j + 1, visited)
            dfs(i - 1, j, visited)
            dfs(i, j - 1, visited)

        # è®°å½•åˆæ³•åæ ‡æ•°
        res = 0
        visited = [[False] * n for _ in range(m)]
        dfs(0, 0, visited)
        return res
```

https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/jump-game çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int farthest = 0;
        for (int i = 0; i < n - 1; i++) {
            // ä¸æ–­è®¡ç®—èƒ½è·³åˆ°çš„æœ€è¿œè·ç¦»
            farthest = max(farthest, i + nums[i]);
            // å¯èƒ½ç¢°åˆ°äº† 0ï¼Œå¡ä½è·³ä¸åŠ¨äº†
            if (farthest <= i) {
                return false;
            }
        }
        return farthest >= n - 1;
    }
};
```

```go
// by chatGPT (go)
func canJump(nums []int) bool {
    n := len(nums)
    farthest := 0
    for i := 0; i < n-1; i++ {
        // ä¸æ–­è®¡ç®—èƒ½è·³åˆ°çš„æœ€è¿œè·ç¦»
        farthest = max(farthest, i+nums[i])
        // å¯èƒ½ç¢°åˆ°äº† 0ï¼Œå¡ä½è·³ä¸åŠ¨äº†
        if farthest <= i {
            return false
        }
    }
    return farthest >= n-1
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int farthest = 0;
        for (int i = 0; i < n - 1; i++) {
            // ä¸æ–­è®¡ç®—èƒ½è·³åˆ°çš„æœ€è¿œè·ç¦»
            farthest = Math.max(farthest, i + nums[i]);
            // å¯èƒ½ç¢°åˆ°äº† 0ï¼Œå¡ä½è·³ä¸åŠ¨äº†
            if (farthest <= i) {
                return false;
            }
        }
        return farthest >= n - 1;
    }
}
```

```javascript
// by chatGPT (javascript)
var canJump = function(nums) {
    let n = nums.length;
    let farthest = 0;
    for (let i = 0; i < n - 1; i++) {
        // ä¸æ–­è®¡ç®—èƒ½è·³åˆ°çš„æœ€è¿œè·ç¦»
        farthest = Math.max(farthest, i + nums[i]);
        // å¯èƒ½ç¢°åˆ°äº† 0ï¼Œå¡ä½è·³ä¸åŠ¨äº†
        if (farthest <= i) {
            return false;
        }
    }
    return farthest >= n - 1;
};
```

```python
# by chatGPT (python)
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        farthest = 0
        for i in range(n - 1):
            # ä¸æ–­è®¡ç®—èƒ½è·³åˆ°çš„æœ€è¿œè·ç¦»
            farthest = max(farthest, i + nums[i])
            # å¯èƒ½ç¢°åˆ°äº† 0ï¼Œå¡ä½è·³ä¸åŠ¨äº†
            if farthest <= i:
                return False
        return farthest >= n - 1
```

https://leetcode.cn/problems/jump-game çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/jump-game-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        int end = 0, farthest = 0;
        int jumps = 0;
        for (int i = 0; i < n - 1; i++) {
            farthest = max(nums[i] + i, farthest);
            if (end == i) {
                jumps++;
                end = farthest;
            }
        }
        return jumps;
    }
};
```

```go
// by chatGPT (go)
func jump(nums []int) int {
    n := len(nums)
    end, farthest, jumps := 0, 0, 0
    for i := 0; i < n-1; i++ {
        farthest = max(nums[i]+i, farthest)
        if end == i {
            jumps++
            end = farthest
        }
    }
    return jumps
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int end = 0, farthest = 0;
        int jumps = 0;
        for (int i = 0; i < n - 1; i++) {
            farthest = Math.max(nums[i] + i, farthest);
            if (end == i) {
                jumps++;
                end = farthest;
            }
        }
        return jumps;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
    const n = nums.length;
    let end = 0, farthest = 0, jumps = 0;
    for (let i = 0; i < n - 1; i++) {
        farthest = Math.max(nums[i] + i, farthest);
        if (end === i) {
            jumps++;
            end = farthest;
        }
    }
    return jumps;
};
```

```python
# by chatGPT (python)
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        end, farthest, jumps = 0, 0, 0
        for i in range(n - 1):
            farthest = max(nums[i] + i, farthest)
            if end == i:
                jumps += 1
                end = farthest
        return jumps
```

https://leetcode.cn/problems/jump-game-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/kill-process çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {
        // æ„å»ºå¤šå‰æ ‘ï¼Œkey ä¸ºçˆ¶èŠ‚ç‚¹ï¼Œvalue ä¸ºæ‰€æœ‰å­èŠ‚ç‚¹çš„åˆ—è¡¨
        unordered_map<int, vector<int>> tree;
        for (int i = 0; i < pid.size(); i++) {
            int child = pid[i];
            int parent = ppid[i];
            tree[parent].push_back(child);
        }

        vector<int> res;
        // æˆ‘è¿™é‡Œç”¨ BFS ç®—æ³•éå†å­æ ‘ï¼Œåˆ é™¤ä»¥ kill ä¸ºæ ¹çš„æ‰€æœ‰å­èŠ‚ç‚¹
        queue<int> q;
        q.push(kill);
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            res.push_back(cur);
            if (tree.count(cur)) {
                // æ‰€æœ‰å­èŠ‚ç‚¹å…¥é˜Ÿ
                for (int child : tree[cur]) {
                    q.push(child);
                }
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func killProcess(pid []int, ppid []int, kill int) []int {
    // æ„å»ºå¤šå‰æ ‘ï¼Œkey ä¸ºçˆ¶èŠ‚ç‚¹ï¼Œvalue ä¸ºæ‰€æœ‰å­èŠ‚ç‚¹çš„åˆ—è¡¨
    tree := make(map[int][]int)
    for i := 0; i < len(pid); i++ {
        child := pid[i]
        parent := ppid[i]
        _, ok := tree[parent]
        if !ok {
            tree[parent] = make([]int, 0)
        }
        tree[parent] = append(tree[parent], child)
    }

    res := make([]int, 0)
    // æˆ‘è¿™é‡Œç”¨ BFS ç®—æ³•éå†å­æ ‘ï¼Œåˆ é™¤ä»¥ kill ä¸ºæ ¹çš„æ‰€æœ‰å­èŠ‚ç‚¹
    q := make([]int, 0)
    q = append(q, kill)
    for len(q) > 0 {
        cur := q[0]
        q = q[1:]
        res = append(res, cur)
        if children, ok := tree[cur]; ok {
            // æ‰€æœ‰å­èŠ‚ç‚¹å…¥é˜Ÿ
            for _, child := range children {
                q = append(q, child)
            }
        }
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public List<Integer> killProcess(List<Integer> pid, List<Integer> ppid, int kill) {
        // æ„å»ºå¤šå‰æ ‘ï¼Œkey ä¸ºçˆ¶èŠ‚ç‚¹ï¼Œvalue ä¸ºæ‰€æœ‰å­èŠ‚ç‚¹çš„åˆ—è¡¨
        HashMap<Integer, List<Integer>> tree = new HashMap<>();
        for (int i = 0; i < pid.size(); i++) {
            int child = pid.get(i);
            int parent = ppid.get(i);
            tree.putIfAbsent(parent, new ArrayList<>());
            tree.get(parent).add(child);
        }

        List<Integer> res = new LinkedList<>();
        // æˆ‘è¿™é‡Œç”¨ BFS ç®—æ³•éå†å­æ ‘ï¼Œåˆ é™¤ä»¥ kill ä¸ºæ ¹çš„æ‰€æœ‰å­èŠ‚ç‚¹
        Queue<Integer> q = new LinkedList<>();
        q.offer(kill);
        while (!q.isEmpty()) {
            int cur = q.poll();
            res.add(cur);
            if (tree.containsKey(cur)) {
                // æ‰€æœ‰å­èŠ‚ç‚¹å…¥é˜Ÿ
                q.addAll(tree.get(cur));
            }
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var killProcess = function(pid, ppid, kill) {
    // æ„å»ºå¤šå‰æ ‘ï¼Œkey ä¸ºçˆ¶èŠ‚ç‚¹ï¼Œvalue ä¸ºæ‰€æœ‰å­èŠ‚ç‚¹çš„åˆ—è¡¨
    const tree = new Map();
    for (let i = 0; i < pid.length; i++) {
        const child = pid[i];
        const parent = ppid[i];
        if (!tree.has(parent)) {
            tree.set(parent, []);
        }
        tree.get(parent).push(child);
    }

    const res = [];
    // æˆ‘è¿™é‡Œç”¨ BFS ç®—æ³•éå†å­æ ‘ï¼Œåˆ é™¤ä»¥ kill ä¸ºæ ¹çš„æ‰€æœ‰å­èŠ‚ç‚¹
    const q = [];
    q.push(kill);
    while (q.length) {
        const cur = q.shift();
        res.push(cur);
        if (tree.has(cur)) {
            // æ‰€æœ‰å­èŠ‚ç‚¹å…¥é˜Ÿ
            q.push(...tree.get(cur));
        }
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def killProcess(self, pid: List[int], ppid: List[int], kill: int) -> List[int]:
        # æ„å»ºå¤šå‰æ ‘ï¼Œkey ä¸ºçˆ¶èŠ‚ç‚¹ï¼Œvalue ä¸ºæ‰€æœ‰å­èŠ‚ç‚¹çš„åˆ—è¡¨
        tree = {}
        for i in range(len(pid)):
            child = pid[i]
            parent = ppid[i]
            if parent not in tree:
                tree[parent] = []
            tree[parent].append(child)

        res = []
        # æˆ‘è¿™é‡Œç”¨ BFS ç®—æ³•éå†å­æ ‘ï¼Œåˆ é™¤ä»¥ kill ä¸ºæ ¹çš„æ‰€æœ‰å­èŠ‚ç‚¹
        q = []
        q.append(kill)
        while len(q) > 0:
            cur = q.pop(0)
            res.append(cur)
            if cur in tree:
                # æ‰€æœ‰å­èŠ‚ç‚¹å…¥é˜Ÿ
                q.extend(tree[cur])
        return res
```

https://leetcode.cn/problems/kill-process çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/koko-eating-bananas çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int H) {
        int left = 1;
        int right = 1000000000 + 1;

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (f(piles, mid) <= H) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    // å®šä¹‰ï¼šé€Ÿåº¦ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å°æ—¶åƒå®Œæ‰€æœ‰é¦™è•‰
    // f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
    int f(vector<int>& piles, int x) {
        int hours = 0;
        for (int i = 0; i < piles.size(); i++) {
            hours += piles[i] / x;
            if (piles[i] % x > 0) {
                hours++;
            }
        }
        return hours;
    }
};
```

```go
// by chatGPT (go)
func minEatingSpeed(piles []int, H int) int {
	left, right := 1, 1000000000+1

	for left < right {
		mid := left + (right-left)/2
		if f(piles, mid) <= H {
			right = mid
		} else {
			left = mid + 1
		}
	}

	return left
}

// å®šä¹‰ï¼šé€Ÿåº¦ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å°æ—¶åƒå®Œæ‰€æœ‰é¦™è•‰
// f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
func f(piles []int, x int) int {
	hours := 0
	for i := 0; i < len(piles); i++ {
		hours += piles[i] / x
		if piles[i]%x > 0 {
			hours++
		}
	}
	return hours
}
```

```java
// by labuladong (java)
class Solution {
    public int minEatingSpeed(int[] piles, int H) {
        int left = 1;
        int right = 1000000000 + 1;

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (f(piles, mid) <= H) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    // å®šä¹‰ï¼šé€Ÿåº¦ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å°æ—¶åƒå®Œæ‰€æœ‰é¦™è•‰
    // f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
    int f(int[] piles, int x) {
        int hours = 0;
        for (int i = 0; i < piles.length; i++) {
            hours += piles[i] / x;
            if (piles[i] % x > 0) {
                hours++;
            }
        }
        return hours;
    }
}
```

```javascript
// by chatGPT (javascript)
var minEatingSpeed = function(piles, H) {
    let left = 1;
    let right = 1000000000 + 1;

    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (f(piles, mid) <= H) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
};

// å®šä¹‰ï¼šé€Ÿåº¦ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å°æ—¶åƒå®Œæ‰€æœ‰é¦™è•‰
// f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
var f = function(piles, x) {
    let hours = 0;
    for (let i = 0; i < piles.length; i++) {
        hours += Math.floor(piles[i] / x);
        if (piles[i] % x > 0) {
            hours++;
        }
    }
    return hours;
};
```

```python
# by chatGPT (python)
class Solution:
    def minEatingSpeed(self, piles: List[int], H: int) -> int:
        left = 1
        right = 1000000000 + 1

        while left < right:
            mid = left + (right - left) // 2
            if self.f(piles, mid) <= H:
                right = mid
            else:
                left = mid + 1
        return left

    # å®šä¹‰ï¼šé€Ÿåº¦ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å°æ—¶åƒå®Œæ‰€æœ‰é¦™è•‰
    # f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
    def f(self, piles: List[int], x: int) -> int:
        hours = 0
        for i in range(len(piles)):
            hours += piles[i] // x
            if piles[i] % x > 0:
                hours += 1
        return hours
```

https://leetcode.cn/problems/koko-eating-bananas çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/kth-largest-element-in-a-stream çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class KthLargest {
private:
    int k;
    // é»˜è®¤æ˜¯å°é¡¶å †
    priority_queue<int, vector<int>, greater<int>> pq;

public:
    KthLargest(int k, vector<int>& nums) {
        // å°† nums è£…å…¥å°é¡¶å †ï¼Œä¿ç•™ä¸‹å‰ k å¤§çš„å…ƒç´ 
        for (int e : nums) {
            pq.push(e);
            if (pq.size() > k) {
                pq.pop();
            }
        }
        this->k = k;
    }

    int add(int val) {
        // ç»´æŠ¤å°é¡¶å †åªä¿ç•™å‰ k å¤§çš„å…ƒç´ 
        pq.push(val);
        if (pq.size() > k) {
            pq.pop();
        }
        // å †é¡¶å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼ˆå³å€’æ•°ç¬¬ k å°çš„å…ƒç´ ï¼‰
        return pq.top();
    }
};
```

```go
// by chatGPT (go)
type KthLargest struct {
    k int
    pq *PriorityQueue
}

func Constructor(k int, nums []int) KthLargest {
    // åˆå§‹åŒ–ä¼˜å…ˆé˜Ÿåˆ—
    pq := PriorityQueue{}
    heap.Init(&pq)

    // å°† nums è£…å…¥å°é¡¶å †ï¼Œä¿ç•™ä¸‹å‰ k å¤§çš„å…ƒç´ 
    for _, e := range nums {
        heap.Push(&pq, e)
        if pq.Len() > k {
            heap.Pop(&pq)
        }
    }

    return KthLargest{k: k, pq: &pq}
}

func (this *KthLargest) Add(val int) int {
    // ç»´æŠ¤å°é¡¶å †åªä¿ç•™å‰ k å¤§çš„å…ƒç´ 
    heap.Push(this.pq, val)
    if this.pq.Len() > this.k {
        heap.Pop(this.pq)
    }
    // å †é¡¶å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼ˆå³å€’æ•°ç¬¬ k å°çš„å…ƒç´ ï¼‰
    return this.pq.Peek()
}

type PriorityQueue []int

func (pq PriorityQueue) Len() int {
    return len(pq)
}

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i] < pq[j]
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    *pq = append(*pq, x.(int))
}

func (pq *PriorityQueue) Pop() interface{} {
    n := len(*pq)
    x := (*pq)[n-1]
    *pq = (*pq)[:n-1]
    return x
}

func (pq *PriorityQueue) Peek() int {
    return (*pq)[0]
}
```

```java
// by labuladong (java)
class KthLargest {

    private int k;
    // é»˜è®¤æ˜¯å°é¡¶å †
    private PriorityQueue<Integer> pq = new PriorityQueue<>();

    public KthLargest(int k, int[] nums) {
        // å°† nums è£…å…¥å°é¡¶å †ï¼Œä¿ç•™ä¸‹å‰ k å¤§çš„å…ƒç´ 
        for (int e : nums) {
            pq.offer(e);
            if (pq.size() > k) {
                pq.poll();
            }
        }
        this.k = k;
    }

    public int add(int val) {
        // ç»´æŠ¤å°é¡¶å †åªä¿ç•™å‰ k å¤§çš„å…ƒç´ 
        pq.offer(val);
        if (pq.size() > k) {
            pq.poll();
        }
        // å †é¡¶å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼ˆå³å€’æ•°ç¬¬ k å°çš„å…ƒç´ ï¼‰
        return pq.peek();
    }
}
```

```javascript
// by chatGPT (javascript)
var KthLargest = function(k, nums) {
    this.k = k;
    // é»˜è®¤æ˜¯å°é¡¶å †
    this.pq = new PriorityQueue();
    
    // å°† nums è£…å…¥å°é¡¶å †ï¼Œä¿ç•™ä¸‹å‰ k å¤§çš„å…ƒç´ 
    for (var i = 0; i < nums.length; i++) {
        this.pq.offer(nums[i]);
        if (this.pq.size() > k) {
            this.pq.poll();
        }
    }
};

KthLargest.prototype.add = function(val) {
    // ç»´æŠ¤å°é¡¶å †åªä¿ç•™å‰ k å¤§çš„å…ƒç´ 
    this.pq.offer(val);
    if (this.pq.size() > this.k) {
        this.pq.poll();
    }
    // å †é¡¶å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼ˆå³å€’æ•°ç¬¬ k å°çš„å…ƒç´ ï¼‰
    return this.pq.peek();
};

// å®ç°ä¸€ä¸ªå°é¡¶å †ï¼Œè‡ªè¡Œå®ç°æ·»åŠ å’Œå¼¹å‡ºæ–¹æ³•
class PriorityQueue {
    constructor() {
        this.data = [];
    }
    offer(val) {
        this.data.push(val);
        this.heapifyUp();
    }
    poll() {
        const first = this.data[0];
        const last = this.data.pop();
        if (this.data.length > 0) {
            this.data[0] = last;
            this.heapifyDown();
        }
        return first;
    }
    size() {
        return this.data.length;
    }
    heapifyUp() {
        let i = this.data.length - 1;
        while (i > 0) {
            const parent = (i - 1) >> 1;
            if (this.data[parent] > this.data[i]) {
                this.swap(parent, i);
                i = parent;
            } else {
                break;
            }
        }
    }
    heapifyDown() {
        let i = 0;
        const size = this.data.length;
        while (i < size) {
            let left = i * 2 + 1;
            let right = i * 2 + 2;
            if (left >= size) {
                break;
            }
            let j = left;
            if (right < size && this.data[right] < this.data[left]) {
                j = right;
            }
            if (this.data[i] > this.data[j]) {
                this.swap(i, j);
                i = j;
            } else {
                break;
            }
        }
    }
    swap(i, j) {
        [this.data[i], this.data[j]] = [this.data[j], this.data[i]];
    }
}
```

```python
# by chatGPT (python)
import queue

class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.pq = queue.PriorityQueue()
        # å°† nums è£…å…¥å°é¡¶å †ï¼Œä¿ç•™ä¸‹å‰ k å¤§çš„å…ƒç´ 
        for e in nums:
            self.pq.put(e)
            if self.pq.qsize() > k:
                self.pq.get()

    def add(self, val: int) -> int:
        # ç»´æŠ¤å°é¡¶å †åªä¿ç•™å‰ k å¤§çš„å…ƒç´ 
        self.pq.put(val)
        if self.pq.qsize() > self.k:
            self.pq.get()
        # å †é¡¶å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼ˆå³å€’æ•°ç¬¬ k å°çš„å…ƒç´ ï¼‰
        return self.pq.queue[0]
```

https://leetcode.cn/problems/kth-largest-element-in-a-stream çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/kth-largest-element-in-an-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        // å°é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å°å…ƒç´ 
        priority_queue<int, vector<int>, greater<int>> pq;
        for (int e : nums) {
            // æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
            pq.push(e);
            // å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
            if (pq.size() > k) {
                pq.pop();
            }
        }
        // pq ä¸­å‰©ä¸‹çš„æ˜¯ nums ä¸­ k ä¸ªæœ€å¤§å…ƒç´ ï¼Œ
        // å †é¡¶æ˜¯æœ€å°çš„é‚£ä¸ªï¼Œå³ç¬¬ k ä¸ªæœ€å¤§å…ƒç´ 
        return pq.top();
    }
};
```

```go
// by chatGPT (go)
func findKthLargest(nums []int, k int) int {
    // å°é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å°å…ƒç´ 
    pq := priorityQueue{}
    for _, e := range nums {
        // æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
        pq.offer(e)
        // å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
        if pq.size() > k {
            pq.poll()
        }
    }
    // pq ä¸­å‰©ä¸‹çš„æ˜¯ nums ä¸­ k ä¸ªæœ€å¤§å…ƒç´ ï¼Œ
    // å †é¡¶æ˜¯æœ€å°çš„é‚£ä¸ªï¼Œå³ç¬¬ k ä¸ªæœ€å¤§å…ƒç´ 
    return pq.peek()
}

type priorityQueue []int

func (pq *priorityQueue) Len() int { return len(*pq) }

func (pq *priorityQueue) Less(i, j int) bool { return (*pq)[i] < (*pq)[j] }

func (pq *priorityQueue) Swap(i, j int) { (*pq)[i], (*pq)[j] = (*pq)[j], (*pq)[i] }

func (pq *priorityQueue) Push(x interface{}) { *pq = append(*pq, x.(int)) }

func (pq *priorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    x := old[n-1]
    *pq = old[0 : n-1]
    return x
}

func (pq *priorityQueue) offer(e int) { heap.Push(pq, e) }

func (pq *priorityQueue) poll() int { return heap.Pop(pq).(int) }

func (pq *priorityQueue) peek() int { return (*pq)[0] }
```

```java
// by labuladong (java)
class Solution {
    public int findKthLargest(int[] nums, int k) {
        // å°é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å°å…ƒç´ 
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int e : nums) {
            // æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
            pq.offer(e);
            // å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
            if (pq.size() > k) {
                pq.poll();
            }
        }
        // pq ä¸­å‰©ä¸‹çš„æ˜¯ nums ä¸­ k ä¸ªæœ€å¤§å…ƒç´ ï¼Œ
        // å †é¡¶æ˜¯æœ€å°çš„é‚£ä¸ªï¼Œå³ç¬¬ k ä¸ªæœ€å¤§å…ƒç´ 
        return pq.peek();
    }
}
```

```javascript
// by chatGPT (javascript)
var findKthLargest = function(nums, k) {
    // å°é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å°å…ƒç´ 
    let pq = new PriorityQueue();
    for (let e of nums) {
        // æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
        pq.offer(e);
        // å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
        if (pq.size() > k) {
            pq.poll();
        }
    }
    // pq ä¸­å‰©ä¸‹çš„æ˜¯ nums ä¸­ k ä¸ªæœ€å¤§å…ƒç´ ï¼Œ
    // å †é¡¶æ˜¯æœ€å°çš„é‚£ä¸ªï¼Œå³ç¬¬ k ä¸ªæœ€å¤§å…ƒç´ 
    return pq.peek();
};

// JavaScript çš„ PriorityQueue å®ç°å¯èƒ½ä¸å¤ªä¸€æ ·ï¼Œè¿™é‡Œåªæ˜¯ä¸€ä¸ªç®€å•å®ç°ä½œä¸ºä¾‹å­
class PriorityQueue {
    constructor() {
        this.data = [];
    }
    offer(val) {
        this.data.push(val);
        this.bubbleUp(this.size() - 1);
    }
    poll() {
        if (this.size() === 0) {
            return undefined;
        }
        const result = this.data[0];
        const last = this.data.pop();
        if (this.size() !== 0) {
            this.data[0] = last;
            this.bubbleDown(0);
        }
        return result;
    }
    peek() {
        return this.size() === 0 ? undefined : this.data[0];
    }
    size() {
        return this.data.length;
    }
    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.data[index] >= this.data[parentIndex]) {
                break;
            }
            this.swap(index, parentIndex);
            index = parentIndex;
        }
    }
    bubbleDown(index) {
        while (STATUS_PASSED_TEST) {
            const leftChildIndex = index * 2 + 1;
            const rightChildIndex = index * 2 + 2;
            let smallestChildIndex = index;
            if (leftChildIndex < this.size() && this.data[leftChildIndex] < this.data[smallestChildIndex]) {
                smallestChildIndex = leftChildIndex;
            }
            if (rightChildIndex < this.size() && this.data[rightChildIndex] < this.data[smallestChildIndex]) {
                smallestChildIndex = rightChildIndex;
            }
            if (smallestChildIndex === index) {
                break;
            }
            this.swap(index, smallestChildIndex);
            index = smallestChildIndex;
        }
    }
    swap(i, j) {
        [this.data[i], this.data[j]] = [this.data[j], this.data[i]];
    }
}
```

```python
# by chatGPT (python)
import heapq

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # å°é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å°å…ƒç´ 
        pq = []
        for e in nums:
            # æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
            heapq.heappush(pq, e)
            # å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
            if len(pq) > k:
                heapq.heappop(pq)
        # pq ä¸­å‰©ä¸‹çš„æ˜¯ nums ä¸­ k ä¸ªæœ€å¤§å…ƒç´ ï¼Œ
        # å †é¡¶æ˜¯æœ€å°çš„é‚£ä¸ªï¼Œå³ç¬¬ k ä¸ªæœ€å¤§å…ƒç´ 
        return pq[0]
```

https://leetcode.cn/problems/kth-largest-element-in-an-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/kth-smallest-element-in-a-bst çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        // åˆ©ç”¨ BST çš„ä¸­åºéå†ç‰¹æ€§
        traverse(root, k);
        return res;
    }

private:
    // è®°å½•ç»“æœ
    int res = 0;
    // è®°å½•å½“å‰å…ƒç´ çš„æ’å
    int rank = 0;
    void traverse(TreeNode* root, int k) {
        if (root == nullptr) {
            return;
        }
        traverse(root->left, k);
        /* ä¸­åºéå†ä»£ç ä½ç½® */
        rank++;
        if (k == rank) {
            // æ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ 
            res = root->val;
            return;
        }
        /*****************/
        traverse(root->right, k);
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

// kthSmallest returns the kth smallest element in the BST rooted with root.
func kthSmallest(root *TreeNode, k int) int {
    // è®°å½•ç»“æœ
    var res int
    // è®°å½•å½“å‰å…ƒç´ çš„æ’å
    var rank int

    // traverse recursively traverses the BST rooted with root in-order
    // and finds the rank-th smallest element in the BST.
    // It updates rank and res accordingly.
    var traverse func(root *TreeNode)
    traverse = func(root *TreeNode) {
        if root == nil {
            return
        }
        traverse(root.Left)
        /* ä¸­åºéå†ä»£ç ä½ç½® */
        rank++
        if k == rank {
            // æ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ 
            res = root.Val
            return
        }
        /*****************/
        traverse(root.Right)
    }

    traverse(root)
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        // åˆ©ç”¨ BST çš„ä¸­åºéå†ç‰¹æ€§
        traverse(root, k);
        return res;
    }

    // è®°å½•ç»“æœ
    int res = 0;
    // è®°å½•å½“å‰å…ƒç´ çš„æ’å
    int rank = 0;
    void traverse(TreeNode root, int k) {
        if (root == null) {
            return;
        }
        traverse(root.left, k);
        /* ä¸­åºéå†ä»£ç ä½ç½® */
        rank++;
        if (k == rank) {
            // æ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ 
            res = root.val;
            return;
        }
        /*****************/
        traverse(root.right, k);
    }
}
```

```javascript
// by chatGPT (javascript)
var kthSmallest = function(root, k) {
    // è®°å½•ç»“æœ
    let res = 0;
    // è®°å½•å½“å‰å…ƒç´ çš„æ’å
    let rank = 0;
    function traverse(root, k) {
        if (root == null) {
            return;
        }
        traverse(root.left, k);
        /* ä¸­åºéå†ä»£ç ä½ç½® */
        rank++;
        if (k == rank) {
            // æ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ 
            res = root.val;
            return;
        }
        /*****************/
        traverse(root.right, k);
    }

    // åˆ©ç”¨ BST çš„ä¸­åºéå†ç‰¹æ€§
    traverse(root, k);
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -> int:
        # åˆ©ç”¨ BST çš„ä¸­åºéå†ç‰¹æ€§
        self.res = 0
        self.rank = 0
        self.traverse(root, k)
        return self.res

    def traverse(self, root: TreeNode, k: int) -> None:
        if root is None:
            return
        self.traverse(root.left, k)
        # ä¸­åºéå†ä»£ç ä½ç½®
        self.rank += 1
        if k == self.rank:
            # æ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ 
            self.res = root.val
            return
        self.traverse(root.right, k)
```

https://leetcode.cn/problems/kth-smallest-element-in-a-bst çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        // å­˜å‚¨äºŒå…ƒç»„ (matrix[i][j], i, j)
        // i, j è®°å½•å½“å‰å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        // åˆå§‹åŒ–ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒæŠŠæ¯ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªå…ƒç´ è£…è¿›å»
        for (int i = 0; i < matrix.size(); i++) {
            pq.push({matrix[i][0], i, 0});
        }

        int res = -1;
        // æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘ï¼Œæ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ 
        while (!pq.empty() && k > 0) {
            auto cur = pq.top();
            pq.pop();
            res = cur[0];
            k--;
            // é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
            int i = cur[1], j = cur[2];
            if (j + 1 < matrix[i].size()) {
                pq.push({matrix[i][j + 1], i, j + 1});
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
import (
    "container/heap"
)

func kthSmallest(matrix [][]int, k int) int {
    // è‡ªå®šä¹‰ä¸€ä¸ªæœ€å°å †ç±»å‹
    pq := IntHeap{}
    // åˆå§‹åŒ–å †ï¼ŒæŠŠæ¯ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªå…ƒç´ è£…è¿›å»
    for i := 0; i < len(matrix); i++ {
        pq = append(pq, Item{value: matrix[i][0], row: i, col: 0})
    }
    heap.Init(&pq)

    var res int
    // æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘ï¼Œæ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ 
    for k > 0 && pq.Len() > 0 {
        cur := heap.Pop(&pq).(Item)
        res = cur.value
        k--
        // é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥å †
        row, col := cur.row, cur.col+1
        if col < len(matrix[row]) {
            heap.Push(&pq, Item{value: matrix[row][col], row: row, col: col})
        }
    }

    return res
}

// å®šä¹‰ä¸€ä¸ª Item ç±»å‹ï¼Œè¡¨ç¤ºå †ä¸­çš„å…ƒç´ 
type Item struct {
    value int // å½“å‰å…ƒç´ çš„å€¼
    row   int // å½“å‰å…ƒç´ æ‰€åœ¨çš„è¡Œ
    col   int // å½“å‰å…ƒç´ æ‰€åœ¨çš„åˆ—
}

// å®šä¹‰ä¸€ä¸ªæœ€å°å †ç±»å‹ IntHeap
// å®ç° heap.Interface æ¥å£çš„æ–¹æ³•
type IntHeap []Item

func (t IntHeap) Len() int {
    return len(t)
}

func (t IntHeap) Less(i, j int) bool {
    return t[i].value < t[j].value
}

func (t IntHeap) Swap(i, j int) {
    t[i], t[j] = t[j], t[i]
}

func (t *IntHeap) Push(x interface{}) {
    *t = append(*t, x.(Item))
}

func (t *IntHeap) Pop() interface{} {
    n := len(*t)
    x := (*t)[n-1]
    *t = (*t)[:n-1]
    return x
}
```

```java
// by labuladong (java)
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        // å­˜å‚¨äºŒå…ƒç»„ (matrix[i][j], i, j)
        // i, j è®°å½•å½“å‰å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            // æŒ‰ç…§å…ƒç´ å¤§å°å‡åºæ’åº
            return a[0] - b[0];
        });


        // åˆå§‹åŒ–ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒæŠŠæ¯ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªå…ƒç´ è£…è¿›å»
        for (int i = 0; i < matrix.length; i++) {
            pq.offer(new int[]{matrix[i][0], i, 0});
        }

        int res = -1;
        // æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘ï¼Œæ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ 
        while (!pq.isEmpty() && k > 0) {
            int[] cur = pq.poll();
            res = cur[0];
            k--;
            // é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
            int i = cur[1], j = cur[2];
            if (j + 1 < matrix[i].length) {
                pq.add(new int[]{matrix[i][j + 1], i, j + 1});
            }
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var kthSmallest = function(matrix, k) {
    // å­˜å‚¨äºŒå…ƒç»„ (matrix[i][j], i, j)
    // i, j è®°å½•å½“å‰å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    const pq = new PriorityQueue((a, b) => {
        // æŒ‰ç…§å…ƒç´ å¤§å°å‡åºæ’åº
        return a[0] - b[0];
    });


    // åˆå§‹åŒ–ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒæŠŠæ¯ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªå…ƒç´ è£…è¿›å»
    for (let i = 0; i < matrix.length; i++) {
        pq.offer([matrix[i][0], i, 0]);
    }

    let res = -1;
    // æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘ï¼Œæ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ 
    while (!pq.isEmpty() && k > 0) {
        const cur = pq.poll();
        res = cur[0];
        k--;
        // é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
        const i = cur[1], j = cur[2];
        if (j + 1 < matrix[i].length) {
            pq.offer([matrix[i][j + 1], i, j + 1]);
        }
    }
    return res;
};

class PriorityQueue {
    constructor(comparator) {
        this.heap = [];
        this.comparator = comparator;
    }

    isEmpty() {
        return this.heap.length === 0;
    }

    offer(val) {
        this.heap.push(val);
        this.bubbleUp(this.heap.length - 1);
    }

    poll() {
        if (this.isEmpty()) {
            return null;
        }
        const val = this.heap[0];
        const lastVal = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = lastVal;
            this.sinkDown(0);
        }
        return val;
    }

    bubbleUp(pos) {
        while (pos > 0) {
            const parentPos = (pos - 1) >>> 1;
            if (this.comparator(this.heap[pos], this.heap[parentPos]) < 0) {
                [this.heap[pos], this.heap[parentPos]] = [this.heap[parentPos], this.heap[pos]];
                pos = parentPos;
            } else {
                break;
            }
        }
    }

    sinkDown(pos) {
        const lastPos = this.heap.length - 1;
        while (STATUS_PASSED_TEST) {
            const leftChildPos = pos * 2 + 1;
            const rightChildPos = pos * 2 + 2;
            let minPos = pos;
            if (leftChildPos <= lastPos && this.comparator(this.heap[leftChildPos], this.heap[minPos]) < 0) {
                minPos = leftChildPos;
            }
            if (rightChildPos <= lastPos && this.comparator(this.heap[rightChildPos], this.heap[minPos]) < 0) {
                minPos = rightChildPos;
            }
            if (minPos !== pos) {
                [this.heap[pos], this.heap[minPos]] = [this.heap[minPos], this.heap[pos]];
                pos = minPos;
            } else {
                break;
            }
        }
    }
};
```

```python
# by chatGPT (python)
import heapq

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        # å­˜å‚¨äºŒå…ƒç»„ (matrix[i][j], i, j)
        # i, j è®°å½•å½“å‰å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        pq = []
        
        # åˆå§‹åŒ–ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒæŠŠæ¯ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªå…ƒç´ è£…è¿›å»
        for i in range(len(matrix)):
            heapq.heappush(pq, [matrix[i][0], i, 0])

        res = -1
        # æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘ï¼Œæ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ 
        while len(pq) > 0 and k > 0:
            cur = heapq.heappop(pq)
            res = cur[0]
            k -= 1
            # é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
            i, j = cur[1], cur[2]
            if j + 1 < len(matrix[i]):
                heapq.heappush(pq, [matrix[i][j + 1], i, j + 1])
        return res
```

https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/lMSNwu çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // æŠŠé“¾è¡¨å…ƒç´ è½¬å…¥æ ˆä¸­
        stack<int> stk1, stk2;
        while (l1 != nullptr) {
            stk1.push(l1->val);
            l1 = l1->next;
        }
        while (l2 != nullptr) {
            stk2.push(l2->val);
            l2 = l2->next;
        }

        // æ¥ä¸‹æ¥åŸºæœ¬ä¸Šæ˜¯å¤ç”¨æˆ‘åœ¨ç¬¬ 2 é¢˜çš„ä»£ç é€»è¾‘
        // æ³¨æ„æ–°èŠ‚ç‚¹è¦ç›´æ¥æ’å…¥åˆ° dummy åé¢

        // è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
        ListNode* dummy = new ListNode(-1);

        // è®°å½•è¿›ä½
        int carry = 0;
        // å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
        while (!stk1.empty() || !stk2.empty() || carry > 0) {
            // å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
            int val = carry;
            if (!stk1.empty()) {
                val += stk1.top();
                stk1.pop();
            }
            if (!stk2.empty()) {
                val += stk2.top();
                stk2.pop();
            }
            // å¤„ç†è¿›ä½æƒ…å†µ
            carry = val / 10;
            val = val % 10;
            // æ„å»ºæ–°èŠ‚ç‚¹ï¼Œç›´æ¥æ¥åœ¨ dummy åé¢
            ListNode* newNode = new ListNode(val);
            newNode->next = dummy->next;
            dummy->next = newNode;
        }
        // è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
        ListNode* retNode = dummy->next;
        delete dummy;
        return retNode;
    }
};
```

```go
// by chatGPT (go)
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    // æŠŠé“¾è¡¨å…ƒç´ è½¬å…¥æ ˆä¸­
    stk1 := new(Stack)
    for l1 != nil {
        stk1.Push(l1.Val)
        l1 = l1.Next
    }
    stk2 := new(Stack)
    for l2 != nil {
        stk2.Push(l2.Val)
        l2 = l2.Next
    }

    // æ¥ä¸‹æ¥åŸºæœ¬ä¸Šæ˜¯å¤ç”¨æˆ‘åœ¨ç¬¬ 2 é¢˜çš„ä»£ç é€»è¾‘
    // æ³¨æ„æ–°èŠ‚ç‚¹è¦ç›´æ¥æ’å…¥åˆ° dummy åé¢

    // è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
    dummy := &ListNode{Val: -1}

    // è®°å½•è¿›ä½
    carry := 0
    // å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
    for !stk1.IsEmpty() || !stk2.IsEmpty() || carry > 0 {
        // å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
        val := carry
        if !stk1.IsEmpty() {
            val += stk1.Pop().(int)
        }
        if !stk2.IsEmpty() {
            val += stk2.Pop().(int)
        }
        // å¤„ç†è¿›ä½æƒ…å†µ
        carry = val / 10
        val = val % 10
        // æ„å»ºæ–°èŠ‚ç‚¹ï¼Œç›´æ¥æ¥åœ¨ dummy åé¢
        newNode := &ListNode{Val: val}
        newNode.Next = dummy.Next
        dummy.Next = newNode
    }
    // è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
    return dummy.Next
}

// Stack å®šä¹‰
type Stack struct {
    values []interface{}
}

func (s *Stack) Push(val interface{}) {
    s.values = append(s.values, val)
}

func (s *Stack) Pop() interface{} {
    if s.IsEmpty() {
        return nil
    }
    lastIndex := len(s.values) - 1
    val := s.values[lastIndex]
    s.values = s.values[:lastIndex]
    return val
}

func (s *Stack) IsEmpty() bool {
    return len(s.values) == 0
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // æŠŠé“¾è¡¨å…ƒç´ è½¬å…¥æ ˆä¸­
        Stack<Integer> stk1 = new Stack<>();
        while (l1 != null) {
            stk1.push(l1.val);
            l1 = l1.next;
        }
        Stack<Integer> stk2 = new Stack<>();
        while (l2 != null) {
            stk2.push(l2.val);
            l2 = l2.next;
        }

        // æ¥ä¸‹æ¥åŸºæœ¬ä¸Šæ˜¯å¤ç”¨æˆ‘åœ¨ç¬¬ 2 é¢˜çš„ä»£ç é€»è¾‘
        // æ³¨æ„æ–°èŠ‚ç‚¹è¦ç›´æ¥æ’å…¥åˆ° dummy åé¢

        // è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
        ListNode dummy = new ListNode(-1);

        // è®°å½•è¿›ä½
        int carry = 0;
        // å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
        while (!stk1.isEmpty() || !stk2.isEmpty() || carry > 0) {
            // å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
            int val = carry;
            if (!stk1.isEmpty()) {
                val += stk1.pop();
            }
            if (!stk2.isEmpty()) {
                val += stk2.pop();
            }
            // å¤„ç†è¿›ä½æƒ…å†µ
            carry = val / 10;
            val = val % 10;
            // æ„å»ºæ–°èŠ‚ç‚¹ï¼Œç›´æ¥æ¥åœ¨ dummy åé¢
            ListNode newNode = new ListNode(val);
            newNode.next = dummy.next;
            dummy.next = newNode;
        }
        // è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
        return dummy.next;
    }
}
```

```javascript
// by chatGPT (javascript)
var addTwoNumbers = function(l1, l2) {
    // æŠŠé“¾è¡¨å…ƒç´ è½¬å…¥æ ˆä¸­
    const stk1 = [];
    while (l1 !== null) {
        stk1.push(l1.val);
        l1 = l1.next;
    }
    const stk2 = [];
    while (l2 !== null) {
        stk2.push(l2.val);
        l2 = l2.next;
    }

    // æ¥ä¸‹æ¥åŸºæœ¬ä¸Šæ˜¯å¤ç”¨æˆ‘åœ¨ç¬¬ 2 é¢˜çš„ä»£ç é€»è¾‘
    // æ³¨æ„æ–°èŠ‚ç‚¹è¦ç›´æ¥æ’å…¥åˆ° dummy åé¢

    // è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
    const dummy = new ListNode(-1);

    // è®°å½•è¿›ä½
    let carry = 0;
    // å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
    while (stk1.length !== 0 || stk2.length !== 0 || carry > 0) {
        // å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
        let val = carry;
        if (stk1.length !== 0) {
            val += stk1.pop();
        }
        if (stk2.length !== 0) {
            val += stk2.pop();
        }
        // å¤„ç†è¿›ä½æƒ…å†µ
        carry = Math.floor(val / 10);
        val = val % 10;
        // æ„å»ºæ–°èŠ‚ç‚¹ï¼Œç›´æ¥æ¥åœ¨ dummy åé¢
        const newNode = new ListNode(val);
        newNode.next = dummy.next;
        dummy.next = newNode;
    }
    // è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
    return dummy.next;
};
```

```python
# by chatGPT (python)
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        # æŠŠé“¾è¡¨å…ƒç´ è½¬å…¥æ ˆä¸­
        stk1 = []
        while l1:
            stk1.append(l1.val)
            l1 = l1.next
        stk2 = []
        while l2:
            stk2.append(l2.val)
            l2 = l2.next

        # æ¥ä¸‹æ¥åŸºæœ¬ä¸Šæ˜¯å¤ç”¨æˆ‘åœ¨ç¬¬ 2 é¢˜çš„ä»£ç é€»è¾‘
        # æ³¨æ„æ–°èŠ‚ç‚¹è¦ç›´æ¥æ’å…¥åˆ° dummy åé¢

        # è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆæ„å»ºæ–°é“¾è¡¨æ—¶çš„å¸¸ç”¨æŠ€å·§ï¼‰
        dummy = ListNode(-1)

        # è®°å½•è¿›ä½
        carry = 0
        # å¼€å§‹æ‰§è¡ŒåŠ æ³•ï¼Œä¸¤æ¡é“¾è¡¨èµ°å®Œä¸”æ²¡æœ‰è¿›ä½æ—¶æ‰èƒ½ç»“æŸå¾ªç¯
        while stk1 or stk2 or carry > 0:
            # å…ˆåŠ ä¸Šä¸Šæ¬¡çš„è¿›ä½
            val = carry
            if stk1:
                val += stk1.pop()
            if stk2:
                val += stk2.pop()
            # å¤„ç†è¿›ä½æƒ…å†µ
            carry = val // 10
            val = val % 10
            # æ„å»ºæ–°èŠ‚ç‚¹ï¼Œç›´æ¥æ¥åœ¨ dummy åé¢
            newNode = ListNode(val)
            newNode.next = dummy.next
            dummy.next = newNode
        # è¿”å›ç»“æœé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆå»é™¤è™šæ‹Ÿå¤´ç»“ç‚¹ï¼‰
        return dummy.next
```

https://leetcode.cn/problems/lMSNwu çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/letter-case-permutation çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    string track;
    vector<string> res;
    
    vector<string> letterCasePermutation(string s) {
        backtrack(s, 0);
        return res;
    }

    void backtrack(string s, int index) {
        if (index == s.size()) {
            res.push_back(track);
            return;
        }

        if ('0' <= s[index] && s[index] <= '9') {
            // s[index] æ˜¯æ•°å­—
            // åšé€‰æ‹©
            track.push_back(s[index]);
            backtrack(s, index + 1);
            // æ’¤é”€é€‰æ‹©
            track.pop_back();
        } else {
            // s[index] æ˜¯å­—æ¯
            
            // å°å†™å­—æ¯ï¼Œåšé€‰æ‹©
            track.push_back(tolower(s[index]));
            backtrack(s, index + 1);
            // æ’¤é”€é€‰æ‹©
            track.pop_back();

            // å¤§å†™å­—æ¯ï¼Œåšé€‰æ‹©
            track.push_back(toupper(s[index]));
            backtrack(s, index + 1);
            // æ’¤é”€é€‰æ‹©
            track.pop_back();
        }
    }
};
```

```go
// by chatGPT (go)
func letterCasePermutation(s string) []string {
    var track []byte
    var res []string

    var backtrack func(s string, index int)
    backtrack = func(s string, index int) {
        if index == len(s) {
            res = append(res, string(track))
            return
        }

        if '0' <= s[index] && s[index] <= '9' {
            // s[index] æ˜¯æ•°å­—
            // åšé€‰æ‹©
            track = append(track, s[index])
            backtrack(s, index + 1)
            // æ’¤é”€é€‰æ‹©
            track = track[:len(track)-1]
        } else {
            // s[index] æ˜¯å­—æ¯

            // å°å†™å­—æ¯ï¼Œåšé€‰æ‹©
            track = append(track, byte(unicode.ToLower(rune(s[index]))))
            backtrack(s, index + 1)
            // æ’¤é”€é€‰æ‹©
            track = track[:len(track)-1]

            // å¤§å†™å­—æ¯ï¼Œåšé€‰æ‹©
            track = append(track, byte(unicode.ToUpper(rune(s[index]))))
            backtrack(s, index + 1)
            // æ’¤é”€é€‰æ‹©
            track = track[:len(track)-1]
        }
    }

    backtrack(s, 0)

    return res
}
```

```java
// by labuladong (java)
class Solution {
    public List<String> letterCasePermutation(String s) {
        backtrack(s, 0);
        return res;
    }

    StringBuilder track = new StringBuilder();
    List<String> res = new LinkedList<>();

    void backtrack(String s, int index) {
        if (index == s.length()) {
            res.add(track.toString());
            return;
        }

        if ('0' <= s.charAt(index) && s.charAt(index) <= '9') {
            // s[index] æ˜¯æ•°å­—
            // åšé€‰æ‹©
            track.append(s.charAt(index));
            backtrack(s, index + 1);
            // æ’¤é”€é€‰æ‹©
            track.deleteCharAt(track.length() - 1);
        } else {
            // s[index] æ˜¯å­—æ¯
            
            // å°å†™å­—æ¯ï¼Œåšé€‰æ‹©
            track.append(Character.toLowerCase(s.charAt(index)));
            backtrack(s, index + 1);
            // æ’¤é”€é€‰æ‹©
            track.deleteCharAt(track.length() - 1);

            // å¤§å†™å­—æ¯ï¼Œåšé€‰æ‹©
            track.append(Character.toUpperCase(s.charAt(index)));
            backtrack(s, index + 1);
            // æ’¤é”€é€‰æ‹©
            track.deleteCharAt(track.length() - 1);
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var Solution = function() {
    this.track = [];
    this.res = [];

    this.letterCasePermutation = function(s) {
        this.backtrack(s, 0);
        return this.res;
    }

    this.backtrack = function(s, index) {
        if (index == s.length) {
            this.res.push(this.track.join(''));
            return;
        }

        if ('0' <= s.charAt(index) && s.charAt(index) <= '9') {
            // s[index] æ˜¯æ•°å­—
            // åšé€‰æ‹©
            this.track.push(s.charAt(index));
            this.backtrack(s, index + 1);
            // æ’¤é”€é€‰æ‹©
            this.track.pop();
        } else {
            // s[index] æ˜¯å­—æ¯
            
            // å°å†™å­—æ¯ï¼Œåšé€‰æ‹©
            this.track.push(s.charAt(index).toLowerCase());
            this.backtrack(s, index + 1);
            // æ’¤é”€é€‰æ‹©
            this.track.pop();

            // å¤§å†™å­—æ¯ï¼Œåšé€‰æ‹©
            this.track.push(s.charAt(index).toUpperCase());
            this.backtrack(s, index + 1);
            // æ’¤é”€é€‰æ‹©
            this.track.pop();
        }
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.track = ""
        self.res = []    

    def letterCasePermutation(self, s: str) -> List[str]:
        self.backtrack(s, 0)
        return self.res

    def backtrack(self, s, index):
        if index == len(s):
            self.res.append(self.track)
            return

        if '0' <= s[index] <= '9':
            # s[index] æ˜¯æ•°å­—
            # åšé€‰æ‹©
            self.track += s[index]
            self.backtrack(s, index + 1)
            # æ’¤é”€é€‰æ‹©
            self.track = self.track[:-1]
        else:
            # s[index] æ˜¯å­—æ¯
            
            # å°å†™å­—æ¯ï¼Œåšé€‰æ‹©
            self.track += s[index].lower()
            self.backtrack(s, index + 1)
            # æ’¤é”€é€‰æ‹©
            self.track = self.track[:-1]

            # å¤§å†™å­—æ¯ï¼Œåšé€‰æ‹©
            self.track += s[index].upper()
            self.backtrack(s, index + 1)
            # æ’¤é”€é€‰æ‹©
            self.track = self.track[:-1]
```

https://leetcode.cn/problems/letter-case-permutation çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/letter-combinations-of-a-phone-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```java
// by labuladong (java)
class Solution {
    // æ¯ä¸ªæ•°å­—åˆ°å­—æ¯çš„æ˜ å°„
    String[] mapping = new String[] {
            "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
    };

    List<String> res = new LinkedList<>();
    StringBuilder sb = new StringBuilder();

    public List<String> letterCombinations(String digits) {
        if (digits.isEmpty()) {
            return res;
        }
        // ä» digits[0] å¼€å§‹è¿›è¡Œå›æº¯
        backtrack(digits, 0);
        return res;
    }

    // å›æº¯ç®—æ³•ä¸»å‡½æ•°
    void backtrack(String digits, int start) {
        if (sb.length() == digits.length()) {
            // åˆ°è¾¾å›æº¯æ ‘åº•éƒ¨
            res.add(sb.toString());
            return;
        }

        // å›æº¯ç®—æ³•æ¡†æ¶
        int digit = digits.charAt(start) - '0';
        for (char c : mapping[digit].toCharArray()) {
            // åšé€‰æ‹©
            sb.append(c);
            // é€’å½’ä¸‹ä¸€å±‚å›æº¯æ ‘
            backtrack(digits, start + 1);
            // æ’¤é”€é€‰æ‹©
            sb.deleteCharAt(sb.length() - 1);
        }
    }
}
```

https://leetcode.cn/problems/letter-combinations-of-a-phone-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/letter-tile-possibilities çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int res = 0;
    vector<bool> used;

    int numTilePossibilities(string s) {
        vector<char> nums(s.begin(), s.end());
        // å…ˆæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·
        sort(nums.begin(), nums.end());
        used = vector<bool>(nums.size(), false);
        backtrack(nums);
        return res - 1;
    }

    void backtrack(vector<char>& nums) {
        res++;

        for (int i = 0; i < nums.size(); i++) {
            if (used[i]) {
                continue;
            }
            // æ–°æ·»åŠ çš„å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½®
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
                continue;
            }
            used[i] = true;
            backtrack(nums);
            used[i] = false;
        }
    }
};
```

```go
// by chatGPT (go)
import (
	"sort"
	"strings"
)

func numTilePossibilities(s string) int {
	nums := strings.Split(s, "")
    // å…ˆæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·
	sort.Strings(nums)

	used := make([]bool, len(nums))
	res := 0

	var backtrack func(nums []string)
	backtrack = func(nums []string) {
		res++

		for i := 0; i < len(nums); i++ {
			if used[i] {
				continue
			}
            // æ–°æ·»åŠ çš„å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½®
			if i > 0 && nums[i] == nums[i-1] && !used[i-1] {
				continue
			}
			used[i] = true
			backtrack(nums)
			used[i] = false
		}
	}
	backtrack(nums)
	return res - 1
}
```

```java
// by labuladong (java)
class Solution {

    int res = 0;
    boolean[] used;

    public int numTilePossibilities(String s) {
        char[] nums = s.toCharArray();
        // å…ˆæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·
        Arrays.sort(nums);
        used = new boolean[nums.length];
        backtrack(nums);
        return res - 1;
    }

    void backtrack(char[] nums) {
        res++;

        for (int i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }
            // æ–°æ·»åŠ çš„å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½®
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
                continue;
            }
            used[i] = true;
            backtrack(nums);
            used[i] = false;
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var numTilePossibilities = function(s) {
    var res = 0;
    var nums = s.split('').sort();
    var used = new Array(nums.length).fill(false);

    function backtrack(nums) {
        res++;

        for (var i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }
            // æ–°æ·»åŠ çš„å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½®
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
                continue;
            }
            // åšé€‰æ‹©
            used[i] = true;
            backtrack(nums);
            // æ’¤é”€é€‰æ‹©
            used[i] = false;
        }
    }
    
    backtrack(nums);
    
    return res - 1;
};
```

```python
# by chatGPT (python)
class Solution:

    def __init__(self):
        self.res = 0
        self.used = []

    def numTilePossibilities(self, s: str) -> int:
        nums = list(s)
        # å…ˆæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·
        nums.sort()
        self.used = [False for _ in range(len(nums))]
        self.backtrack(nums)
        return self.res - 1

    def backtrack(self, nums: list) -> None:
        self.res += 1

        for i in range(len(nums)):
            if self.used[i]:
                continue
            # æ–°æ·»åŠ çš„å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½®
            if i > 0 and nums[i] == nums[i - 1] and not self.used[i - 1]:
                continue
            self.used[i] = True
            self.backtrack(nums)
            self.used[i] = False
```

https://leetcode.cn/problems/letter-tile-possibilities çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/lfu-cache çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class LFUCache {
    // key åˆ° val çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º KV è¡¨
    unordered_map<int, int> keyToVal;
    // key åˆ° freq çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º KF è¡¨
    unordered_map<int, int> keyToFreq;
    // freq åˆ° key åˆ—è¡¨çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º FK è¡¨
    unordered_map<int, unordered_set<int>> freqToKeys;
    // è®°å½•æœ€å°çš„é¢‘æ¬¡
    int minFreq;
    // è®°å½• LFU ç¼“å­˜çš„æœ€å¤§å®¹é‡
    int cap;
public:
    LFUCache(int capacity) {
        keyToVal.clear();
        keyToFreq.clear();
        freqToKeys.clear();
        this->cap = capacity;
        this->minFreq = 0;
    }

    int get(int key) {
        if (!keyToVal.count(key)) {
            return -1;
        }
        // å¢åŠ  key å¯¹åº”çš„ freq
        increaseFreq(key);
        return keyToVal[key];
    }

    void put(int key, int val) {
        if (this->cap <= 0) return;

        /* è‹¥ key å·²å­˜åœ¨ï¼Œä¿®æ”¹å¯¹åº”çš„ val å³å¯ */
        if (keyToVal.count(key)) {
            keyToVal[key] = val;
            // key å¯¹åº”çš„ freq åŠ ä¸€
            increaseFreq(key);
            return;
        }

        /* key ä¸å­˜åœ¨ï¼Œéœ€è¦æ’å…¥ */
        /* å®¹é‡å·²æ»¡çš„è¯éœ€è¦æ·˜æ±°ä¸€ä¸ª freq æœ€å°çš„ key */
        if (this->cap <= keyToVal.size()) {
            removeMinFreqKey();
        }

        /* æ’å…¥ key å’Œ valï¼Œå¯¹åº”çš„ freq ä¸º 1 */
        // æ’å…¥ KV è¡¨
        keyToVal[key] = val;
        // æ’å…¥ KF è¡¨
        keyToFreq[key] = 1;
        // æ’å…¥ FK è¡¨
        freqToKeys[1].insert(key);
        // æ’å…¥æ–° key åæœ€å°çš„ freq è‚¯å®šæ˜¯ 1
        this->minFreq = 1;
    }

private:
    void increaseFreq(int key) {
        int freq = keyToFreq[key];
        /* æ›´æ–° KF è¡¨ */
        keyToFreq[key] = freq + 1;
        /* æ›´æ–° FK è¡¨ */
        // å°† key ä» freq å¯¹åº”çš„åˆ—è¡¨ä¸­åˆ é™¤
        freqToKeys[freq].erase(key);
        // å°† key åŠ å…¥ freq + 1 å¯¹åº”çš„åˆ—è¡¨ä¸­
        freqToKeys[freq + 1].insert(key);
        // å¦‚æœ freq å¯¹åº”çš„åˆ—è¡¨ç©ºäº†ï¼Œç§»é™¤è¿™ä¸ª freq
        if (freqToKeys[freq].empty()) {
            freqToKeys.erase(freq);
            // å¦‚æœè¿™ä¸ª freq æ°å¥½æ˜¯ minFreqï¼Œæ›´æ–° minFreq
            if (freq == this->minFreq) {
                this->minFreq++;
            }
        }
    }

    void removeMinFreqKey() {
        // freq æœ€å°çš„ key åˆ—è¡¨
        unordered_set<int> keyList = freqToKeys[this->minFreq];
        // å…¶ä¸­æœ€å…ˆè¢«æ’å…¥çš„é‚£ä¸ª key å°±æ˜¯è¯¥è¢«æ·˜æ±°çš„ key
        int deletedKey = *keyList.begin();
        /* æ›´æ–° FK è¡¨ */
        keyList.erase(deletedKey);
        if (keyList.empty()) {
            freqToKeys.erase(this->minFreq);
            // é—®ï¼šè¿™é‡Œéœ€è¦æ›´æ–° minFreq çš„å€¼å—ï¼Ÿ
        }
        /* æ›´æ–° KV è¡¨ */
        keyToVal.erase(deletedKey);
        /* æ›´æ–° KF è¡¨ */
        keyToFreq.erase(deletedKey);
    }
};
```

```go
// by chatGPT (go)
type LFUCache struct {
    // key åˆ° val çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º KV è¡¨
    keyToVal map[int]int
    // key åˆ° freq çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º KF è¡¨
    keyToFreq map[int]int
    // freq åˆ° key åˆ—è¡¨çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º FK è¡¨
    freqToKeys map[int]*linkedHashSet
    // è®°å½•æœ€å°çš„é¢‘æ¬¡
    minFreq int
    // è®°å½• LFU ç¼“å­˜çš„æœ€å¤§å®¹é‡
    cap int
}

func Constructor(capacity int) LFUCache {
    return LFUCache{
        keyToVal:   make(map[int]int),
        keyToFreq:  make(map[int]int),
        freqToKeys: make(map[int]*linkedHashSet),
        cap:        capacity,
        minFreq:    0,
    }
}

func (this *LFUCache) Get(key int) int {
    if _, ok := this.keyToVal[key]; !ok {
        return -1
    }
    // å¢åŠ  key å¯¹åº”çš„ freq
    this.increaseFreq(key)
    return this.keyToVal[key]
}

func (this *LFUCache) Put(key int, val int) {
    if this.cap <= 0 {
        return
    }

    /* è‹¥ key å·²å­˜åœ¨ï¼Œä¿®æ”¹å¯¹åº”çš„ val å³å¯ */
    if _, ok := this.keyToVal[key]; ok {
        this.keyToVal[key] = val
        // key å¯¹åº”çš„ freq åŠ ä¸€
        this.increaseFreq(key)
        return
    }

    /* key ä¸å­˜åœ¨ï¼Œéœ€è¦æ’å…¥ */
    /* å®¹é‡å·²æ»¡çš„è¯éœ€è¦æ·˜æ±°ä¸€ä¸ª freq æœ€å°çš„ key */
    if this.cap <= len(this.keyToVal) {
        this.removeMinFreqKey()
    }

    /* æ’å…¥ key å’Œ valï¼Œå¯¹åº”çš„ freq ä¸º 1 */
    // æ’å…¥ KV è¡¨
    this.keyToVal[key] = val
    // æ’å…¥ KF è¡¨
    this.keyToFreq[key] = 1
    // æ’å…¥ FK è¡¨
    this.freqToKeys[1].add(key)
    // æ’å…¥æ–° key åæœ€å°çš„ freq è‚¯å®šæ˜¯ 1
    this.minFreq = 1
}

func (this *LFUCache) increaseFreq(key int) {
    freq := this.keyToFreq[key]
    /* æ›´æ–° KF è¡¨ */
    this.keyToFreq[key] = freq + 1
    /* æ›´æ–° FK è¡¨ */
    // å°† key ä» freq å¯¹åº”çš„åˆ—è¡¨ä¸­åˆ é™¤
    this.freqToKeys[freq].remove(key)
    // å°† key åŠ å…¥ freq + 1 å¯¹åº”çš„åˆ—è¡¨ä¸­
    if this.freqToKeys[freq+1] == nil {
        this.freqToKeys[freq+1] = newLinkedHashSet()
    }
    this.freqToKeys[freq+1].add(key)
    // å¦‚æœ freq å¯¹åº”çš„åˆ—è¡¨ç©ºäº†ï¼Œç§»é™¤è¿™ä¸ª freq
    if this.freqToKeys[freq].size() == 0 {
        delete(this.freqToKeys, freq)
        // å¦‚æœè¿™ä¸ª freq æ°å¥½æ˜¯ minFreqï¼Œæ›´æ–° minFreq
        if freq == this.minFreq {
            this.minFreq++
        }
    }
}

func (this *LFUCache) removeMinFreqKey() {
    // freq æœ€å°çš„ key åˆ—è¡¨
    keyList := this.freqToKeys[this.minFreq]
    // å…¶ä¸­æœ€å…ˆè¢«æ’å…¥çš„é‚£ä¸ª key å°±æ˜¯è¯¥è¢«æ·˜æ±°çš„ key
    deletedKey := keyList.iterator().next()
    /* æ›´æ–° FK è¡¨ */
    keyList.remove(deletedKey)
    if keyList.size() == 0 {
        delete(this.freqToKeys, this.minFreq)
        // é—®ï¼šè¿™é‡Œéœ€è¦æ›´æ–° minFreq çš„å€¼å—ï¼Ÿ
    }
    /* æ›´æ–° KV è¡¨ */
    delete(this.keyToVal, deletedKey)
    /* æ›´æ–° KF è¡¨ */
    delete(this.keyToFreq, deletedKey)
}

// å°è£…ä¸€ä¸ªé“¾è¡¨
type linkedHashSet struct {
    m    map[int]*node
    head *node
    tail *node
}

func newLinkedHashSet() *linkedHashSet {
    head := &node{}
    tail := &node{}
    head.next = tail
    tail.prev = head
    return &linkedHashSet{
        m:    make(map[int]*node),
        head: head,
        tail: tail,
    }
}

func (this *linkedHashSet) size() int {
    return len(this.m)
}

func (this *linkedHashSet) add(key int) {
    if _, ok := this.m[key]; ok {
        return
    }
    n := &node{key: key}
    last := this.tail.prev
    last.next = n
    n.prev = last
    n.next = this.tail
    this.tail.prev = n
    this.m[key] = n
}

func (this *linkedHashSet) remove(key int) {
    if n, ok := this.m[key]; ok {
        n.prev.next = n.next
        n.next.prev = n.prev
        delete(this.m, key)
    }
}

func (this *linkedHashSet) iterator() *keyIterator {
    return &keyIterator{this.head.next}
}

type node struct {
    key  int
    prev *node
    next *node
}

type keyIterator struct {
    n *node
}

func (this *keyIterator) hasNext() bool {
    return this.n.next != nil
}

func (this *keyIterator) next() int {
    this.n = this.n.next
    return this.n.key
}
```

```java
// by labuladong (java)
class LFUCache {

    // key åˆ° val çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º KV è¡¨
    HashMap<Integer, Integer> keyToVal;
    // key åˆ° freq çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º KF è¡¨
    HashMap<Integer, Integer> keyToFreq;
    // freq åˆ° key åˆ—è¡¨çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º FK è¡¨
    HashMap<Integer, LinkedHashSet<Integer>> freqToKeys;
    // è®°å½•æœ€å°çš„é¢‘æ¬¡
    int minFreq;
    // è®°å½• LFU ç¼“å­˜çš„æœ€å¤§å®¹é‡
    int cap;

    public LFUCache(int capacity) {
        keyToVal = new HashMap<>();
        keyToFreq = new HashMap<>();
        freqToKeys = new HashMap<>();
        this.cap = capacity;
        this.minFreq = 0;
    }

    public int get(int key) {
        if (!keyToVal.containsKey(key)) {
            return -1;
        }
        // å¢åŠ  key å¯¹åº”çš„ freq
        increaseFreq(key);
        return keyToVal.get(key);
    }

    public void put(int key, int val) {
        if (this.cap <= 0) return;

        /* è‹¥ key å·²å­˜åœ¨ï¼Œä¿®æ”¹å¯¹åº”çš„ val å³å¯ */
        if (keyToVal.containsKey(key)) {
            keyToVal.put(key, val);
            // key å¯¹åº”çš„ freq åŠ ä¸€
            increaseFreq(key);
            return;
        }

        /* key ä¸å­˜åœ¨ï¼Œéœ€è¦æ’å…¥ */
        /* å®¹é‡å·²æ»¡çš„è¯éœ€è¦æ·˜æ±°ä¸€ä¸ª freq æœ€å°çš„ key */
        if (this.cap <= keyToVal.size()) {
            removeMinFreqKey();
        }

        /* æ’å…¥ key å’Œ valï¼Œå¯¹åº”çš„ freq ä¸º 1 */
        // æ’å…¥ KV è¡¨
        keyToVal.put(key, val);
        // æ’å…¥ KF è¡¨
        keyToFreq.put(key, 1);
        // æ’å…¥ FK è¡¨
        freqToKeys.putIfAbsent(1, new LinkedHashSet<>());
        freqToKeys.get(1).add(key);
        // æ’å…¥æ–° key åæœ€å°çš„ freq è‚¯å®šæ˜¯ 1
        this.minFreq = 1;
    }

    private void increaseFreq(int key) {
        int freq = keyToFreq.get(key);
        /* æ›´æ–° KF è¡¨ */
        keyToFreq.put(key, freq + 1);
        /* æ›´æ–° FK è¡¨ */
        // å°† key ä» freq å¯¹åº”çš„åˆ—è¡¨ä¸­åˆ é™¤
        freqToKeys.get(freq).remove(key);
        // å°† key åŠ å…¥ freq + 1 å¯¹åº”çš„åˆ—è¡¨ä¸­
        freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet<>());
        freqToKeys.get(freq + 1).add(key);
        // å¦‚æœ freq å¯¹åº”çš„åˆ—è¡¨ç©ºäº†ï¼Œç§»é™¤è¿™ä¸ª freq
        if (freqToKeys.get(freq).isEmpty()) {
            freqToKeys.remove(freq);
            // å¦‚æœè¿™ä¸ª freq æ°å¥½æ˜¯ minFreqï¼Œæ›´æ–° minFreq
            if (freq == this.minFreq) {
                this.minFreq++;
            }
        }
    }

    private void removeMinFreqKey() {
        // freq æœ€å°çš„ key åˆ—è¡¨
        LinkedHashSet<Integer> keyList = freqToKeys.get(this.minFreq);
        // å…¶ä¸­æœ€å…ˆè¢«æ’å…¥çš„é‚£ä¸ª key å°±æ˜¯è¯¥è¢«æ·˜æ±°çš„ key
        int deletedKey = keyList.iterator().next();
        /* æ›´æ–° FK è¡¨ */
        keyList.remove(deletedKey);
        if (keyList.isEmpty()) {
            freqToKeys.remove(this.minFreq);
            // é—®ï¼šè¿™é‡Œéœ€è¦æ›´æ–° minFreq çš„å€¼å—ï¼Ÿ
        }
        /* æ›´æ–° KV è¡¨ */
        keyToVal.remove(deletedKey);
        /* æ›´æ–° KF è¡¨ */
        keyToFreq.remove(deletedKey);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} capacity
 */
var LFUCache = function(capacity) {
    // key åˆ° val çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º KV è¡¨
    this.keyToVal = new Map();
    // key åˆ° freq çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º KF è¡¨
    this.keyToFreq = new Map();
    // freq åˆ° key åˆ—è¡¨çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º FK è¡¨
    this.freqToKeys = new Map();
    // è®°å½•æœ€å°çš„é¢‘æ¬¡
    this.minFreq = 0;
    // è®°å½• LFU ç¼“å­˜çš„æœ€å¤§å®¹é‡
    this.cap = capacity;
};

/** 
 * @param {number} key
 * @return {number}
 */
LFUCache.prototype.get = function(key) {
    if (!this.keyToVal.has(key)) {
        return -1;
    }
    // å¢åŠ  key å¯¹åº”çš„ freq
    this.increaseFreq(key);
    return this.keyToVal.get(key);
};

/** 
 * @param {number} key 
 * @param {number} val
 * @return {void}
 */
LFUCache.prototype.put = function(key, val) {
    if (this.cap <= 0) return;

    /* è‹¥ key å·²å­˜åœ¨ï¼Œä¿®æ”¹å¯¹åº”çš„ val å³å¯ */
    if (this.keyToVal.has(key)) {
        this.keyToVal.set(key, val);
        // key å¯¹åº”çš„ freq åŠ ä¸€
        this.increaseFreq(key);
        return;
    }

    /* key ä¸å­˜åœ¨ï¼Œéœ€è¦æ’å…¥ */
    /* å®¹é‡å·²æ»¡çš„è¯éœ€è¦æ·˜æ±°ä¸€ä¸ª freq æœ€å°çš„ key */
    if (this.cap <= this.keyToVal.size) {
        this.removeMinFreqKey();
    }

    /* æ’å…¥ key å’Œ valï¼Œå¯¹åº”çš„ freq ä¸º 1 */
    // æ’å…¥ KV è¡¨
    this.keyToVal.set(key, val);
    // æ’å…¥ KF è¡¨
    this.keyToFreq.set(key, 1);
    // æ’å…¥ FK è¡¨
    if (!this.freqToKeys.has(1)) {
        this.freqToKeys.set(1, new Set());
    }
    this.freqToKeys.get(1).add(key);
    // æ’å…¥æ–° key åæœ€å°çš„ freq è‚¯å®šæ˜¯ 1
    this.minFreq = 1;
};

/**
 * @param {number} key
 * @return {void}
 */
LFUCache.prototype.increaseFreq = function(key) {
    let freq = this.keyToFreq.get(key);
    /* æ›´æ–° KF è¡¨ */
    this.keyToFreq.set(key, freq + 1);
    /* æ›´æ–° FK è¡¨ */
    // å°† key ä» freq å¯¹åº”çš„åˆ—è¡¨ä¸­åˆ é™¤
    this.freqToKeys.get(freq).delete(key);
    // å°† key åŠ å…¥ freq + 1 å¯¹åº”çš„åˆ—è¡¨ä¸­
    if (!this.freqToKeys.has(freq + 1)) {
        this.freqToKeys.set(freq + 1, new Set());
    }
    this.freqToKeys.get(freq + 1).add(key);
    // å¦‚æœ freq å¯¹åº”çš„åˆ—è¡¨ç©ºäº†ï¼Œç§»é™¤è¿™ä¸ª freq
    if (this.freqToKeys.get(freq).size === 0) {
        this.freqToKeys.delete(freq);
        // å¦‚æœè¿™ä¸ª freq æ°å¥½æ˜¯ minFreqï¼Œæ›´æ–° minFreq
        if (freq === this.minFreq) {
            this.minFreq++;
        }
    }
}

/**
 * @return {void}
 */
LFUCache.prototype.removeMinFreqKey = function() {
    // freq æœ€å°çš„ key åˆ—è¡¨
    let keyList = this.freqToKeys.get(this.minFreq);
    // å…¶ä¸­æœ€å…ˆè¢«æ’å…¥çš„é‚£ä¸ª key å°±æ˜¯è¯¥è¢«æ·˜æ±°çš„ key
    let deletedKey = keyList.values().next().value;
    /* æ›´æ–° FK è¡¨ */
    keyList.delete(deletedKey);
    if (keyList.size === 0) {
        this.freqToKeys.delete(this.minFreq);
        // é—®ï¼šè¿™é‡Œéœ€è¦æ›´æ–° minFreq çš„å€¼å—ï¼Ÿ
    }
    /* æ›´æ–° KV è¡¨ */
    this.keyToVal.delete(deletedKey);
    /* æ›´æ–° KF è¡¨ */
    this.keyToFreq.delete(deletedKey);
};
```

```python
# by chatGPT (python)
class LFUCache:

    def __init__(self, capacity: int):
        # key åˆ° val çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º KV è¡¨
        self.keyToVal = {}
        # key åˆ° freq çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º KF è¡¨
        self.keyToFreq = {}
        # freq åˆ° key åˆ—è¡¨çš„æ˜ å°„ï¼Œæˆ‘ä»¬åæ–‡ç§°ä¸º FK è¡¨
        self.freqToKeys = {}
        # è®°å½•æœ€å°çš„é¢‘æ¬¡
        self.minFreq = 0
        # è®°å½• LFU ç¼“å­˜çš„æœ€å¤§å®¹é‡
        self.cap = capacity

    def get(self, key: int) -> int:
        if key not in self.keyToVal:
            return -1
        # å¢åŠ  key å¯¹åº”çš„ freq
        self.__increaseFreq(key)
        return self.keyToVal[key]

    def put(self, key: int, val: int) -> None:
        if self.cap <= 0:
            return

        # è‹¥ key å·²å­˜åœ¨ï¼Œä¿®æ”¹å¯¹åº”çš„ val å³å¯
        if key in self.keyToVal:
            self.keyToVal[key] = val
            # key å¯¹åº”çš„ freq åŠ ä¸€
            self.__increaseFreq(key)
            return

        # key ä¸å­˜åœ¨ï¼Œéœ€è¦æ’å…¥
        # å®¹é‡å·²æ»¡çš„è¯éœ€è¦æ·˜æ±°ä¸€ä¸ª freq æœ€å°çš„ key
        if self.cap <= len(self.keyToVal):
            self.__removeMinFreqKey()

        # æ’å…¥ key å’Œ valï¼Œå¯¹åº”çš„ freq ä¸º 1
        # æ’å…¥ KV è¡¨
        self.keyToVal[key] = val
        # æ’å…¥ KF è¡¨
        self.keyToFreq[key] = 1
        # æ’å…¥ FK è¡¨
        self.freqToKeys.setdefault(1, set())
        self.freqToKeys[1].add(key)
        # æ’å…¥æ–° key åæœ€å°çš„ freq è‚¯å®šæ˜¯ 1
        self.minFreq = 1

    def __increaseFreq(self, key: int):
        freq = self.keyToFreq[key]
        # æ›´æ–° KF è¡¨
        self.keyToFreq[key] = freq + 1
        # æ›´æ–° FK è¡¨
        # å°† key ä» freq å¯¹åº”çš„åˆ—è¡¨ä¸­åˆ é™¤
        self.freqToKeys[freq].remove(key)
        # å°† key åŠ å…¥ freq + 1 å¯¹åº”çš„åˆ—è¡¨ä¸­
        self.freqToKeys.setdefault(freq + 1, set())
        self.freqToKeys[freq + 1].add(key)
        # å¦‚æœ freq å¯¹åº”çš„åˆ—è¡¨ç©ºäº†ï¼Œç§»é™¤è¿™ä¸ª freq
        if not self.freqToKeys[freq]:
            del self.freqToKeys[freq]
            # å¦‚æœè¿™ä¸ª freq æ°å¥½æ˜¯ minFreqï¼Œæ›´æ–° minFreq
            if freq == self.minFreq:
                self.minFreq += 1

    def __removeMinFreqKey(self):
        # freq æœ€å°çš„ key åˆ—è¡¨
        keyList = self.freqToKeys[self.minFreq]
        # å…¶ä¸­æœ€å…ˆè¢«æ’å…¥çš„é‚£ä¸ª key å°±æ˜¯è¯¥è¢«æ·˜æ±°çš„ key
        deletedKey = keyList.pop()
        # æ›´æ–° FK è¡¨
        if not keyList:
            del self.freqToKeys[self.minFreq]
        # æ›´æ–° KV è¡¨
        del self.keyToVal[deletedKey]
        # æ›´æ–° KF è¡¨
        del self.keyToFreq[deletedKey]
```

https://leetcode.cn/problems/lfu-cache çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));

        /**** base case ****/
        dp[0][0] = grid[0][0];
        for (int i = 1; i < m; i++)
            dp[i][0] = dp[i - 1][0] + grid[i][0];

        for (int j = 1; j < n; j++)
            dp[0][j] = dp[0][j - 1] + grid[0][j];

        // çŠ¶æ€è½¬ç§»
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = max(
                    dp[i - 1][j],
                    dp[i][j - 1]
                ) + grid[i][j];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

```go
// by chatGPT (go)
func maxValue(grid [][]int) int {
    m := len(grid)
    n := len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    /**** base case ****/
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }

    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }

    // çŠ¶æ€è½¬ç§»
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = max(
                dp[i-1][j],
                dp[i][j-1],
            ) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func max(nums ...int) int {
    res := nums[0]
    for _, num := range nums[1:] {
        if num > res {
            res = num
        }
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int maxValue(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];

        /**** base case ****/
        dp[0][0] = grid[0][0];
        for (int i = 1; i < m; i++)
            dp[i][0] = dp[i - 1][0] + grid[i][0];

        for (int j = 1; j < n; j++)
            dp[0][j] = dp[0][j - 1] + grid[0][j];

        // çŠ¶æ€è½¬ç§»
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.max(
                    dp[i - 1][j],
                    dp[i][j - 1]
                ) + grid[i][j];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

```javascript
// by chatGPT (javascript)
var maxValue = function(grid) {
    let m = grid.length;
    let n = grid[0].length;
    let dp = new Array(m).fill().map(() => new Array(n).fill(0));

    /**** base case ****/
    dp[0][0] = grid[0][0];
    for (let i = 1; i < m; i++)
        dp[i][0] = dp[i - 1][0] + grid[i][0];

    for (let j = 1; j < n; j++)
        dp[0][j] = dp[0][j - 1] + grid[0][j];

    // çŠ¶æ€è½¬ç§»
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = Math.max(
                dp[i - 1][j],
                dp[i][j - 1]
            ) + grid[i][j];
        }
    }
    return dp[m - 1][n - 1];
};
```

```python
# by chatGPT (python)
class Solution:
    def maxValue(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        dp = [[0] * n for _ in range(m)]

        # base case
        dp[0][0] = grid[0][0]
        for i in range(1, m):
            dp[i][0] = dp[i - 1][0] + grid[i][0]

        for j in range(1, n):
            dp[0][j] = dp[0][j - 1] + grid[0][j]

        # çŠ¶æ€è½¬ç§»
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = max(
                    dp[i - 1][j],
                    dp[i][j - 1]
                ) + grid[i][j]

        return dp[m - 1][n - 1]
```

https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        vector<int> dp(n);
        // base case
        // ç¬¬ä¸€ä¸ªå…ƒç´ å‰é¢æ²¡æœ‰å­æ•°ç»„
        dp[0] = nums[0];
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        for (int i = 1; i < n; i++) {
            dp[i] = max(nums[i], nums[i] + dp[i - 1]);
        }
        // å¾—åˆ° nums çš„æœ€å¤§å­æ•°ç»„
        int res = INT_MIN;
        for (int i = 0; i < n; i++) {
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func maxSubArray(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }

    dp := make([]int, n)

    // base case
    dp[0] = nums[0]

    // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
    for i := 1; i < n; i++ {
        dp[i] = func() int {
            if nums[i] > nums[i]+dp[i-1] {
                return nums[i]
            }
            return nums[i] + dp[i-1]
        }()
    }

    // å¾—åˆ° nums çš„æœ€å¤§å­æ•°ç»„
    res := math.MinInt32
    for i := 0; i < n; i++ {
        res = func() int {
            if res > dp[i] {
                return res
            }
            return dp[i]
        }()
    }

    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        int[] dp = new int[n];
        // base case
        // ç¬¬ä¸€ä¸ªå…ƒç´ å‰é¢æ²¡æœ‰å­æ•°ç»„
        dp[0] = nums[0];
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
        }
        // å¾—åˆ° nums çš„æœ€å¤§å­æ•°ç»„
        int res = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var maxSubArray = function(nums) {
    const n = nums.length;
    if (n == 0) return 0;
    const dp = new Array(n).fill(0);
    // base case
    // ç¬¬ä¸€ä¸ªå…ƒç´ å‰é¢æ²¡æœ‰å­æ•°ç»„
    dp[0] = nums[0];
    // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
    for (let i = 1; i < n; i++) {
        dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
    }
    // å¾—åˆ° nums çš„æœ€å¤§å­æ•°ç»„
    let res = Number.MIN_SAFE_INTEGER;
    for (let i = 0; i < n; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        dp = [0] * n
        # base case
        # ç¬¬ä¸€ä¸ªå…ƒç´ å‰é¢æ²¡æœ‰å­æ•°ç»„
        dp[0] = nums[0]
        # çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        for i in range(1, n):
            dp[i] = max(nums[i], nums[i] + dp[i - 1])
        # å¾—åˆ° nums çš„æœ€å¤§å­æ•°ç»„
        res = float('-inf')
        for i in range(n):
            res = max(res, dp[i])
        return res
```

https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        // p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
        ListNode* p1 = headA;
        ListNode* p2 = headB;
        while (p1 != p2) {
            // p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
            if (p1 == nullptr) {
                p1 = headB;
            } else {
                p1 = p1->next;
            }
            // p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
            if (p2 == nullptr) {
                p2 = headA;
            } else {
                p2 = p2->next;
            }
        }
        return p1;
    }
};
```

```go
// by chatGPT (go)
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    // p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
    p1, p2 := headA, headB
    for p1 != p2 {
        // p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
        if p1 == nil {
            p1 = headB
        } else {
            p1 = p1.Next
        }
        // p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
        if p2 == nil {
            p2 = headA
        } else {
            p2 = p2.Next
        }
    }
    return p1
}
```

```java
// by labuladong (java)
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
        ListNode p1 = headA, p2 = headB;
        while (p1 != p2) {
            // p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
            if (p1 == null) p1 = headB;
            else            p1 = p1.next;
            // p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
            if (p2 == null) p2 = headA;
            else            p2 = p2.next;
        }
        return p1;
    }
}
```

```javascript
// by chatGPT (javascript)
var getIntersectionNode = function(headA, headB) {
    // p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
    let p1 = headA, p2 = headB;
    while (p1 != p2) {
        // p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
        if (p1 == null) {
            p1 = headB;
        } else {
            p1 = p1.next;
        }
        // p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
        if (p2 == null) {
            p2 = headA;
        } else {
            p2 = p2.next;
        }
    }
    return p1;
};
```

```python
# by chatGPT (python)
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        # p1 æŒ‡å‘ A é“¾è¡¨å¤´ç»“ç‚¹ï¼Œp2 æŒ‡å‘ B é“¾è¡¨å¤´ç»“ç‚¹
        p1, p2 = headA, headB
        while p1 != p2:
            # p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨
            if p1 == None:
                p1 = headB
            else:
                p1 = p1.next
            # p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨
            if p2 == None:
                p2 = headA
            else:
                p2 = p2.next
        return p1
```

https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/linked-list-cycle çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool hasCycle(ListNode *head) {
        // å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
        ListNode *slow = head, *fast = head;
        // å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢
        while (fast != nullptr && fast->next != nullptr) {
            // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
            slow = slow->next;
            fast = fast->next->next;
            // å¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œè¯´æ˜å«æœ‰ç¯
            if (slow == fast) {
                return true;
            }
        }
        // ä¸åŒ…å«ç¯
        return false;
    }
};
```

```go
// by chatGPT (go)
func hasCycle(head *ListNode) bool {
    // å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
    slow, fast := head, head
    // å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢
    for fast != nil && fast.Next != nil {
        // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
        slow = slow.Next
        fast = fast.Next.Next
        // å¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œè¯´æ˜å«æœ‰ç¯
        if slow == fast {
            return true
        }
    }
    // ä¸åŒ…å«ç¯
    return false
}
```

```java
// by labuladong (java)
public class Solution {
    public boolean hasCycle(ListNode head) {
        // å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
        ListNode slow = head, fast = head;
        // å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢
        while (fast != null && fast.next != null) {
            // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
            slow = slow.next;
            fast = fast.next.next;
            // å¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œè¯´æ˜å«æœ‰ç¯
            if (slow == fast) {
                return true;
            }
        }
        // ä¸åŒ…å«ç¯
        return false;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    // å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
    let slow = head, fast = head;
    // å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢
    while (fast !== null && fast.next !== null) {
        // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
        slow = slow.next;
        fast = fast.next.next;
        // å¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œè¯´æ˜å«æœ‰ç¯
        if (slow === fast) {
            return true;
        }
    }
    // ä¸åŒ…å«ç¯
    return false;
};
```

```python
# by chatGPT (python)
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        # å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
        slow, fast = head, head
        # å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢
        while fast and fast.next:
            # æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
            slow = slow.next
            fast = fast.next.next
            # å¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œè¯´æ˜å«æœ‰ç¯
            if slow == fast:
                return True
        # ä¸åŒ…å«ç¯
        return False
```

https://leetcode.cn/problems/linked-list-cycle çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/linked-list-cycle-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fast, *slow;
        fast = slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) break;
            /**<extend down -200>
            ![](../pictures/åŒæŒ‡é’ˆ/3.jpeg)
            */
        }
        // ä¸Šé¢çš„ä»£ç ç±»ä¼¼ hasCycle å‡½æ•°
        if (fast == nullptr || fast->next == nullptr) {
            // fast é‡åˆ°ç©ºæŒ‡é’ˆè¯´æ˜æ²¡æœ‰ç¯
            return nullptr;
        }

        // é‡æ–°æŒ‡å‘å¤´ç»“ç‚¹
        slow = head;
        /**<extend up -100>
        ![](../pictures/åŒæŒ‡é’ˆ/2.jpeg)
        */
        // å¿«æ…¢æŒ‡é’ˆåŒæ­¥å‰è¿›ï¼Œç›¸äº¤ç‚¹å°±æ˜¯ç¯èµ·ç‚¹
        while (slow != fast) {
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

```go
// by chatGPT (go)
func detectCycle(head *ListNode) *ListNode {
    fast, slow := head, head
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        slow = slow.Next
        if fast == slow {
            break
            /**<extend down -200>
            ![](../pictures/åŒæŒ‡é’ˆ/3.jpeg)
            */
        }
    }
    if fast == nil || fast.Next == nil {
        return nil
    }
    slow = head
    /**<extend up -100>
    ![](../pictures/åŒæŒ‡é’ˆ/2.jpeg)
    */
    for slow != fast {
        slow = slow.Next
        fast = fast.Next
    }
    return slow
}
```

```java
// by labuladong (java)
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
            /**<extend down -200>
            ![](../pictures/åŒæŒ‡é’ˆ/3.jpeg)
            */
        }
        // ä¸Šé¢çš„ä»£ç ç±»ä¼¼ hasCycle å‡½æ•°
        if (fast == null || fast.next == null) {
            // fast é‡åˆ°ç©ºæŒ‡é’ˆè¯´æ˜æ²¡æœ‰ç¯
            return null;
        }

        // é‡æ–°æŒ‡å‘å¤´ç»“ç‚¹
        slow = head;
        /**<extend up -100>
        ![](../pictures/åŒæŒ‡é’ˆ/2.jpeg)
        */
        // å¿«æ…¢æŒ‡é’ˆåŒæ­¥å‰è¿›ï¼Œç›¸äº¤ç‚¹å°±æ˜¯ç¯èµ·ç‚¹
        while (slow != fast) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    let fast = head, slow = head;
    while (fast !== null && fast.next !== null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast === slow) {
            break;
            /**<extend down -200>
            ![](../pictures/åŒæŒ‡é’ˆ/3.jpeg)
            */
        }
    }
    // ä¸Šé¢çš„ä»£ç ç±»ä¼¼ hasCycle å‡½æ•°
    if (fast === null || fast.next === null) {
        // fast é‡åˆ°ç©ºæŒ‡é’ˆè¯´æ˜æ²¡æœ‰ç¯
        return null;
    }

    // é‡æ–°æŒ‡å‘å¤´ç»“ç‚¹
    slow = head;
    /**<extend up -100>
    ![](../pictures/åŒæŒ‡é’ˆ/2.jpeg)
    */
    // å¿«æ…¢æŒ‡é’ˆåŒæ­¥å‰è¿›ï¼Œç›¸äº¤ç‚¹å°±æ˜¯ç¯èµ·ç‚¹
    while (slow !== fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
};
```

```python
# by chatGPT (python)
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                break
            """
            <extend down -200>
            ![](../pictures/åŒæŒ‡é’ˆ/3.jpeg)
            """
        if not fast or not fast.next:
            return None
        
        slow = head
        """
        <extend up -100>
        ![](../pictures/åŒæŒ‡é’ˆ/2.jpeg)
        """
        while slow != fast:
            slow = slow.next
            fast = fast.next
        
        return slow
```

https://leetcode.cn/problems/linked-list-cycle-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/linked-list-random-node çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
private:
    ListNode* head;
    std::random_device rd;
public:
    Solution(ListNode* head) {
        this->head = head;
    }
    
    /* è¿”å›é“¾è¡¨ä¸­ä¸€ä¸ªéšæœºèŠ‚ç‚¹çš„å€¼ */
    int getRandom() {
        int i = 0, res = 0;
        ListNode* p = head;
        // while å¾ªç¯éå†é“¾è¡¨
        while (p != nullptr) {
            i++;
            // ç”Ÿæˆä¸€ä¸ª [0, i) ä¹‹é—´çš„æ•´æ•°
            // è¿™ä¸ªæ•´æ•°ç­‰äº 0 çš„æ¦‚ç‡å°±æ˜¯ 1/i
            if (0 == rd() % i) {
                res = p->val;
            }
            p = p->next;
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
type Solution struct {
    head *ListNode
    r    *rand.Rand
}

/** @param head The linked list's head.
  Note that the head is guaranteed to be not null, so it contains at least one node. */
func Constructor(head *ListNode) Solution {
    return Solution{
        head: head,
        r:    rand.New(rand.NewSource(time.Now().UnixNano())),
    }
}

/** Returns a random node's value. */
func (this *Solution) GetRandom() int {
    i := 0
    res := 0
    p := this.head
    // while å¾ªç¯éå†é“¾è¡¨
    for p != nil {
        i++
        // ç”Ÿæˆä¸€ä¸ª [0, i) ä¹‹é—´çš„æ•´æ•°
        // è¿™ä¸ªæ•´æ•°ç­‰äº 0 çš„æ¦‚ç‡å°±æ˜¯ 1/i
        if 0 == this.r.Intn(i) {
            res = p.Val
        }
        p = p.Next
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {

    ListNode head;
    Random r = new Random();

    public Solution(ListNode head) {
        this.head = head;
    }
    
    /* è¿”å›é“¾è¡¨ä¸­ä¸€ä¸ªéšæœºèŠ‚ç‚¹çš„å€¼ */
    int getRandom() {
        int i = 0, res = 0;
        ListNode p = head;
        // while å¾ªç¯éå†é“¾è¡¨
        while (p != null) {
            i++;
            // ç”Ÿæˆä¸€ä¸ª [0, i) ä¹‹é—´çš„æ•´æ•°
            // è¿™ä¸ªæ•´æ•°ç­‰äº 0 çš„æ¦‚ç‡å°±æ˜¯ 1/i
            if (0 == r.nextInt(i)) {
                res = p.val;
            }
            p = p.next;
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {ListNode} head
 * @return {number}
 */
var Solution = function(head) {
    this.head = head;
    this.r = new Random();
};

/**
 * Returns a random node's value.
 * @return {number}
 */
Solution.prototype.getRandom = function() {
    let i = 0;
    let res = 0;
    let p = this.head;
    // while å¾ªç¯éå†é“¾è¡¨
    while (p !== null) {
        i++;
        // ç”Ÿæˆä¸€ä¸ª [0, i) ä¹‹é—´çš„æ•´æ•°
        // è¿™ä¸ªæ•´æ•°ç­‰äº 0 çš„æ¦‚ç‡å°±æ˜¯ 1/i
        if (0 === this.r.nextInt(i)) {
            res = p.val;
        }
        p = p.next;
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:

    def __init__(self, head: ListNode):
        self.head = head
        self.r = random.Random()

    def getRandom(self) -> int:
        i, res = 0, 0
        p = self.head
        # while å¾ªç¯éå†é“¾è¡¨
        while p:
            i += 1
            # ç”Ÿæˆä¸€ä¸ª [0, i) ä¹‹é—´çš„æ•´æ•°
            # è¿™ä¸ªæ•´æ•°ç­‰äº 0 çš„æ¦‚ç‡å°±æ˜¯ 1/i
            if 0 == self.r.randint(0, i-1):
                res = p.val
            p = p.next
        return res
```

https://leetcode.cn/problems/linked-list-random-node çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/longest-common-prefix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        int m = strs.size();
        int n = strs[0].length();
        for (int col = 0; col < n; col++) {
            for (int row = 1; row < m; row++) {
                string thisStr = strs[row], prevStr = strs[row - 1];
                // åˆ¤æ–­æ¯ä¸ªå­—ç¬¦ä¸²çš„ col ç´¢å¼•æ˜¯å¦éƒ½ç›¸åŒ
                if (col >= thisStr.length() || col >= prevStr.length() ||
                        thisStr.at(col) != prevStr.at(col)) {
                    // å‘ç°ä¸åŒ¹é…çš„å­—ç¬¦ï¼Œåªæœ‰ strs[row][0..col-1] æ˜¯å…¬å…±å‰ç¼€
                    return strs[row].substr(0, col);
                }
            }
        }
        return strs[0];
    }
};
```

```go
// by chatGPT (go)
func longestCommonPrefix(strs []string) string {
    m := len(strs)
    // ä»¥ç¬¬ä¸€è¡Œçš„åˆ—æ•°ä¸ºåŸºå‡†
    n := len(strs[0])
    for col := 0; col < n; col++ {
        for row := 1; row < m; row++ {
            thisStr, prevStr := strs[row], strs[row-1]
            // åˆ¤æ–­æ¯ä¸ªå­—ç¬¦ä¸²çš„ col ç´¢å¼•æ˜¯å¦éƒ½ç›¸åŒ
            if col >= len(thisStr) || col >= len(prevStr) ||
                thisStr[col] != prevStr[col] {
                // å‘ç°ä¸åŒ¹é…çš„å­—ç¬¦ï¼Œåªæœ‰ strs[row][0..col-1] æ˜¯å…¬å…±å‰ç¼€
                return strs[row][:col]
            }
        }
    }
    return strs[0]
}
```

```java
// by labuladong (java)
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int m = strs.length;
        // ä»¥ç¬¬ä¸€è¡Œçš„åˆ—æ•°ä¸ºåŸºå‡†
        int n = strs[0].length();
        for (int col = 0; col < n; col++) {
            for (int row = 1; row < m; row++) {
                String thisStr = strs[row], prevStr = strs[row - 1];
                // åˆ¤æ–­æ¯ä¸ªå­—ç¬¦ä¸²çš„ col ç´¢å¼•æ˜¯å¦éƒ½ç›¸åŒ
                if (col >= thisStr.length() || col >= prevStr.length() ||
                        thisStr.charAt(col) != prevStr.charAt(col)) {
                    // å‘ç°ä¸åŒ¹é…çš„å­—ç¬¦ï¼Œåªæœ‰ strs[row][0..col-1] æ˜¯å…¬å…±å‰ç¼€
                    return strs[row].substring(0, col);
                }
            }
        }
        return strs[0];
    }
}
```

```javascript
// by chatGPT (javascript)
var longestCommonPrefix = function(strs) {
    let m = strs.length;
    // ä»¥ç¬¬ä¸€è¡Œçš„åˆ—æ•°ä¸ºåŸºå‡†
    let n = strs[0].length;
    for (let col = 0; col < n; col++) {
        for (let row = 1; row < m; row++) {
            let thisStr = strs[row], prevStr = strs[row - 1];
            // åˆ¤æ–­æ¯ä¸ªå­—ç¬¦ä¸²çš„ col ç´¢å¼•æ˜¯å¦éƒ½ç›¸åŒ
            if (col >= thisStr.length || col >= prevStr.length ||
                    thisStr.charAt(col) != prevStr.charAt(col)) {
                    // å‘ç°ä¸åŒ¹é…çš„å­—ç¬¦ï¼Œåªæœ‰ strs[row][0..col-1] æ˜¯å…¬å…±å‰ç¼€
                return strs[row].substring(0, col);
            }
        }
    }
    return strs[0];
};
```

```python
# by chatGPT (python)
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        m = len(strs)
        # ä»¥ç¬¬ä¸€è¡Œçš„åˆ—æ•°ä¸ºåŸºå‡†
        n = len(strs[0])
        for col in range(n):
            for row in range(1, m):
                thisStr, prevStr = strs[row], strs[row - 1]
                # åˆ¤æ–­æ¯ä¸ªå­—ç¬¦ä¸²çš„ col ç´¢å¼•æ˜¯å¦éƒ½ç›¸åŒ
                if col >= len(thisStr) or col >= len(prevStr) or thisStr[col] != prevStr[col]:
                    # å‘ç°ä¸åŒ¹é…çš„å­—ç¬¦ï¼Œåªæœ‰ strs[row][0..col-1] æ˜¯å…¬å…±å‰ç¼€
                    return strs[row][:col]
        return strs[0]
```

https://leetcode.cn/problems/longest-common-prefix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/longest-common-subsequence çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int longestCommonSubsequence(string s1, string s2) {
        int m = s1.length(), n = s2.length();
        // å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
        int dp[m + 1][n + 1];
        // ç›®æ ‡ï¼šs1[0..m-1] å’Œ s2[0..n-1] çš„ lcs é•¿åº¦ï¼Œå³ dp[m][n]
        // base case: dp[0][..] = dp[..][0] = 0
        memset(dp, 0, sizeof(dp));
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
                if (s1[i - 1] == s2[j - 1]) {
                    // s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    // s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }

        return dp[m][n];
    }
};
```

```go
// by chatGPT (go)
func longestCommonSubsequence(s1 string, s2 string) int {
    m, n := len(s1), len(s2)
    //å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    //ç›®æ ‡ï¼šs1[0..m-1] å’Œ s2[0..n-1] çš„ lcs é•¿åº¦ï¼Œå³ dp[m][n]
    //base case: dp[0][..] = dp[..][0] = 0

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            //ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
            if s1[i-1] == s2[j-1] {
                //s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                dp[i][j] = 1 + dp[i-1][j-1]
            } else {
                //s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                dp[i][j] = max(dp[i][j-1], dp[i-1][j])
            }
        }
    }

    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int longestCommonSubsequence(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
        int[][] dp = new int[m + 1][n + 1];
        // ç›®æ ‡ï¼šs1[0..m-1] å’Œ s2[0..n-1] çš„ lcs é•¿åº¦ï¼Œå³ dp[m][n]
        // base case: dp[0][..] = dp[..][0] = 0

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    // s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    // s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }

        return dp[m][n];
    }
}
```

```javascript
// by chatGPT (javascript)
var longestCommonSubsequence = function(s1, s2) {
    const m = s1.length, n = s2.length;
    // å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
    // ç›®æ ‡ï¼šs1[0..m-1] å’Œ s2[0..n-1] çš„ lcs é•¿åº¦ï¼Œå³ dp[m][n]
    // base case: dp[0][..] = dp[..][0] = 0

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            // ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
            if (s1.charAt(i - 1) === s2.charAt(j - 1)) {
                // s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                // s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
            }
        }
    }

    return dp[m][n];
};
```

```python
# by chatGPT (python)
class Solution:
    def longestCommonSubsequence(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
        # å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        # ç›®æ ‡ï¼šs1[0..m-1] å’Œ s2[0..n-1] çš„ lcs é•¿åº¦ï¼Œå³ dp[m][n]
        # base case: dp[0][..] = dp[..][0] = 0

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
                if s1[i - 1] == s2[j - 1]:
                    # s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                    dp[i][j] = 1 + dp[i - 1][j - 1]
                else:
                    # s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])

        return dp[m][n]
```

https://leetcode.cn/problems/longest-common-subsequence çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/longest-consecutive-sequence çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        // è½¬åŒ–æˆå“ˆå¸Œé›†åˆï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨æŸä¸ªå…ƒç´ 
        unordered_set<int> set;
        for (int num : nums) {
            set.insert(num);
        }

        int res = 0;

        for (int num : set) {
            if (set.count(num - 1)) {
                // num ä¸æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œè·³è¿‡
                continue;
            }
            // num æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œå¼€å§‹å‘ä¸Šè®¡ç®—è¿ç»­å­åºåˆ—çš„é•¿åº¦
            int curNum = num;
            int curLen = 1;

            while (set.count(curNum + 1)) {
                curNum += 1;
                curLen += 1;
            }
            // æ›´æ–°æœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦
            res = max(res, curLen);
        }

        return res;
    }
};
```

```go
// by chatGPT (go)
func longestConsecutive(nums []int) int {
    // è½¬åŒ–æˆå“ˆå¸Œé›†åˆï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨æŸä¸ªå…ƒç´ 
    set := make(map[int]bool)
    for _, num := range nums {
        set[num] = true
    }

    res := 0

    for num := range set {
        if set[num-1] {
            // num ä¸æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œè·³è¿‡
            continue
        }
        // num æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œå¼€å§‹å‘ä¸Šè®¡ç®—è¿ç»­å­åºåˆ—çš„é•¿åº¦
        curNum := num
        curLen := 1

        for set[curNum+1] {
            curNum += 1
            curLen += 1
        }
        // æ›´æ–°æœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦
        res = max(res, curLen)
    }

    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int longestConsecutive(int[] nums) {
        // è½¬åŒ–æˆå“ˆå¸Œé›†åˆï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨æŸä¸ªå…ƒç´ 
        HashSet<Integer> set = new HashSet<Integer>();
        for (int num : nums) {
            set.add(num);
        }

        int res = 0;

        for (int num : set) {
            if (set.contains(num - 1)) {
                // num ä¸æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œè·³è¿‡
                continue;
            }
            // num æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œå¼€å§‹å‘ä¸Šè®¡ç®—è¿ç»­å­åºåˆ—çš„é•¿åº¦
            int curNum = num;
            int curLen = 1;

            while (set.contains(curNum + 1)) {
                curNum += 1;
                curLen += 1;
            }
            // æ›´æ–°æœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦
            res = Math.max(res, curLen);
        }

        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var longestConsecutive = function(nums) {
    // è½¬åŒ–æˆå“ˆå¸Œé›†åˆï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨æŸä¸ªå…ƒç´ 
    let set = new Set(nums);

    let res = 0;

    for (let num of set) {
        if (set.has(num - 1)) {
            // num ä¸æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œè·³è¿‡
            continue;
        }
        // num æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œå¼€å§‹å‘ä¸Šè®¡ç®—è¿ç»­å­åºåˆ—çš„é•¿åº¦
        let curNum = num;
        let curLen = 1;

        while (set.has(curNum + 1)) {
            curNum += 1;
            curLen += 1;
        }
        // æ›´æ–°æœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦
        res = Math.max(res, curLen);
    }

    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        # è½¬åŒ–æˆå“ˆå¸Œé›†åˆï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨æŸä¸ªå…ƒç´ 
        set_num = set(nums)

        res = 0

        for num in set_num:
            if num - 1 in set_num:
                # num ä¸æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œè·³è¿‡
                continue
            # num æ˜¯è¿ç»­å­åºåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œå¼€å§‹å‘ä¸Šè®¡ç®—è¿ç»­å­åºåˆ—çš„é•¿åº¦
            cur_num = num
            cur_len = 1

            while cur_num + 1 in set_num:
                cur_num += 1
                cur_len += 1
            # æ›´æ–°æœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦
            res = max(res, cur_len)

        return res
```

https://leetcode.cn/problems/longest-consecutive-sequence çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/longest-increasing-subsequence çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // dp[i] è¡¨ç¤ºä»¥ nums[i] è¿™ä¸ªæ•°ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
        vector<int> dp(nums.size(), 1);
        /**<extend down -200>
        ![](../pictures/æœ€é•¿é€’å¢å­åºåˆ—/5.jpeg)
        */
        // base caseï¼šdp æ•°ç»„å…¨éƒ½åˆå§‹åŒ–ä¸º 1

        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j])
                    dp[i] = max(dp[i], dp[j] + 1);
            }
        }

        int res = 0;
        for (int i = 0; i < dp.size(); i++) {
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func lengthOfLIS(nums []int) int {
    // dp[i] è¡¨ç¤ºä»¥ nums[i] è¿™ä¸ªæ•°ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
    dp := make([]int, len(nums))
    // base caseï¼šdp æ•°ç»„å…¨éƒ½åˆå§‹åŒ–ä¸º 1
    for i := 0; i < len(dp); i++ {
        dp[i] = 1
    }

    for i := 0; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }

    res := 0
    for i := 0; i < len(dp); i++ {
        res = max(res, dp[i])
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int lengthOfLIS(int[] nums) {
        // dp[i] è¡¨ç¤ºä»¥ nums[i] è¿™ä¸ªæ•°ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
        int[] dp = new int[nums.length];
        /**<extend down -200>
        ![](../pictures/æœ€é•¿é€’å¢å­åºåˆ—/5.jpeg)
        */
        // base caseï¼šdp æ•°ç»„å…¨éƒ½åˆå§‹åŒ–ä¸º 1
        Arrays.fill(dp, 1);

        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j])
                    dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }

        int res = 0;
        for (int i = 0; i < dp.length; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var lengthOfLIS = function(nums) {
    // dp[i] è¡¨ç¤ºä»¥ nums[i] è¿™ä¸ªæ•°ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
    let dp = new Array(nums.length).fill(1);
    /**<extend down -200>
    ![](../pictures/æœ€é•¿é€’å¢å­åºåˆ—/5.jpeg)
    */
    // base caseï¼šdp æ•°ç»„å…¨éƒ½åˆå§‹åŒ–ä¸º 1

    for (let i = 0; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] > nums[j])
                dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }

    let res = 0;
    for (let i = 0; i < dp.length; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        # dp[i] è¡¨ç¤ºä»¥ nums[i] è¿™ä¸ªæ•°ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
        dp = [1] * len(nums)

        for i in range(len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)

        return max(dp)
```

https://leetcode.cn/problems/longest-increasing-subsequence çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/longest-palindromic-subsequence çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.length();
        // dp æ•°ç»„å…¨éƒ¨åˆå§‹åŒ–ä¸º 0
        vector<vector<int>> dp(n, vector<int>(n, 0));
        // base case
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        // åç€éå†ä¿è¯æ­£ç¡®çš„çŠ¶æ€è½¬ç§»
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        // æ•´ä¸ª s çš„æœ€é•¿å›æ–‡å­ä¸²é•¿åº¦
        return dp[0][n - 1];
    }
};
```

```go
// by chatGPT (go)
func longestPalindromeSubseq(s string) int {
    n := len(s)
    // dp æ•°ç»„å…¨éƒ¨åˆå§‹åŒ–ä¸º 0
    dp := make([][]int, n)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    // base case
    for i := 0; i < n; i++ {
        dp[i][i] = 1
    }

    // åç€éå†ä¿è¯æ­£ç¡®çš„çŠ¶æ€è½¬ç§»
    for i := n - 1; i >= 0; i-- {
        for j := i + 1; j < n; j++ {
            // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
            if s[i] == s[j] {
                dp[i][j] = dp[i+1][j-1] + 2
            } else {
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
            }
        }
    }

    // æ•´ä¸ª s çš„æœ€é•¿å›æ–‡å­ä¸²é•¿åº¦
    return dp[0][n-1]
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        // dp æ•°ç»„å…¨éƒ¨åˆå§‹åŒ–ä¸º 0
        int[][] dp = new int[n][n];
        // base case
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        // åç€éå†ä¿è¯æ­£ç¡®çš„çŠ¶æ€è½¬ç§»
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        // æ•´ä¸ª s çš„æœ€é•¿å›æ–‡å­ä¸²é•¿åº¦
        return dp[0][n - 1];
    }
}
```

```javascript
// by chatGPT (javascript)
var longestPalindromeSubseq = function(s) {
    const n = s.length;
    // dp æ•°ç»„å…¨éƒ¨åˆå§‹åŒ–ä¸º 0
    const dp = new Array(n).fill(0).map(() => new Array(n).fill(0));
    // base case
    for (let i = 0; i < n; i++) {
        dp[i][i] = 1;
    }
    // åç€éå†ä¿è¯æ­£ç¡®çš„çŠ¶æ€è½¬ç§»
    for (let i = n - 1; i >= 0; i--) {
        for (let j = i + 1; j < n; j++) {
            // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
            if (s.charAt(i) === s.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    // æ•´ä¸ª s çš„æœ€é•¿å›æ–‡å­ä¸²é•¿åº¦
    return dp[0][n - 1];
};
```

```python
# by chatGPT (python)
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        # dp æ•°ç»„å…¨éƒ¨åˆå§‹åŒ–ä¸º 0
        dp = [[0 for _ in range(n)] for _ in range(n)]
        # base case
        for i in range(n):
            dp[i][i] = 1
        # åç€éå†ä¿è¯æ­£ç¡®çš„çŠ¶æ€è½¬ç§»
        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                # çŠ¶æ€è½¬ç§»æ–¹ç¨‹
                if s[i] == s[j]:
                    dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
        # æ•´ä¸ª s çš„æœ€é•¿å›æ–‡å­ä¸²é•¿åº¦
        return dp[0][n - 1]
```

https://leetcode.cn/problems/longest-palindromic-subsequence çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/longest-palindromic-substring çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    string longestPalindrome(string s) {
        string res = "";
        for (int i = 0; i < s.length(); i++) {
            // ä»¥ s[i] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²
            string s1 = palindrome(s, i, i);
            // ä»¥ s[i] å’Œ s[i+1] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²
            string s2 = palindrome(s, i, i + 1);
            // res = longest(res, s1, s2)
            res = res.length() > s1.length() ? res : s1;
            res = res.length() > s2.length() ? res : s2;
        }
        return res;
    }

    string palindrome(string s, int l, int r) {
        // é˜²æ­¢ç´¢å¼•è¶Šç•Œ
        while (l >= 0 && r < s.length()
                && s[l] == s[r]) {
            // å‘ä¸¤è¾¹å±•å¼€
            l--;
            r++;
        }
        // è¿”å›ä»¥ s[l] å’Œ s[r] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡ä¸²
        return s.substr(l + 1, r - l - 1);
    }
};
```

```go
// by chatGPT (go)
func longestPalindrome(s string) string {
    res := ""
    for i := 0; i < len(s); i++ {
        // ä»¥ s[i] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²
        s1 := palindrome(s, i, i)
        // ä»¥ s[i] å’Œ s[i+1] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²
        s2 := palindrome(s, i, i+1)
        // res = longest(res, s1, s2)
        if len(s1) > len(res) {
            res = s1
        }
        if len(s2) > len(res) {
            res = s2
        }
    }
    return res
}

func palindrome(s string, l, r int) string {
    // é˜²æ­¢ç´¢å¼•è¶Šç•Œ
    for l >= 0 && r < len(s) && s[l] == s[r] {
        // å‘ä¸¤è¾¹å±•å¼€
        l--
        r++
    }
    // è¿”å›ä»¥ s[l] å’Œ s[r] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡ä¸²
    return s[l+1 : r]
}
```

```java
// by labuladong (java)
class Solution {
    public String longestPalindrome(String s) {
        String res = "";
        for (int i = 0; i < s.length(); i++) {
            // ä»¥ s[i] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²
            String s1 = palindrome(s, i, i);
            // ä»¥ s[i] å’Œ s[i+1] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²
            String s2 = palindrome(s, i, i + 1);
            // res = longest(res, s1, s2)
            res = res.length() > s1.length() ? res : s1;
            res = res.length() > s2.length() ? res : s2;
        }
        return res;
    }

    String palindrome(String s, int l, int r) {
        // é˜²æ­¢ç´¢å¼•è¶Šç•Œ
        while (l >= 0 && r < s.length()
                && s.charAt(l) == s.charAt(r)) {
            // å‘ä¸¤è¾¹å±•å¼€
            l--;
            r++;
        }
        // è¿”å›ä»¥ s[l] å’Œ s[r] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡ä¸²
        return s.substring(l + 1, r);
    }
}
```

```javascript
// by chatGPT (javascript)
var longestPalindrome = function(s) {
    let res = "";
    for (let i = 0; i < s.length; i++) {
        // ä»¥ s[i] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²
        let s1 = palindrome(s, i, i);
        // ä»¥ s[i] å’Œ s[i+1] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²
        let s2 = palindrome(s, i, i + 1);
        // res = longest(res, s1, s2)
        res = res.length > s1.length ? res : s1;
        res = res.length > s2.length ? res : s2;
    }
    return res;

    function palindrome(s, l, r) {
        // é˜²æ­¢ç´¢å¼•è¶Šç•Œ
        while (l >= 0 && r < s.length
                && s.charAt(l) == s.charAt(r)) {
            // å‘ä¸¤è¾¹å±•å¼€
            l--;
            r++;
        }
        // è¿”å›ä»¥ s[l] å’Œ s[r] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡ä¸²
        return s.substring(l + 1, r);
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res = ""
        for i in range(len(s)):
            # ä»¥ s[i] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²
            s1 = self.palindrome(s, i, i)
            # ä»¥ s[i] å’Œ s[i+1] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²
            s2 = self.palindrome(s, i, i + 1)
            # res = longest(res, s1, s2)
            res = res if len(res) > len(s1) else s1
            res = res if len(res) > len(s2) else s2
        return res

    def palindrome(self, s: str, l: int, r: int) -> str:
        # é˜²æ­¢ç´¢å¼•è¶Šç•Œ
        while l >= 0 and r < len(s) and s[l] == s[r]:
            # å‘ä¸¤è¾¹å±•å¼€
            l -= 1
            r += 1
        # è¿”å›ä»¥ s[l] å’Œ s[r] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡ä¸²
        return s[l+1:r]
```

https://leetcode.cn/problems/longest-palindromic-substring çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/longest-substring-without-repeating-characters çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> window;

        int left = 0, right = 0;
        int res = 0; // è®°å½•ç»“æœ
        while (right < s.size()) {
            char c = s[right];
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            window[c]++;
            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (window[c] > 1) {
                char d = s[left];
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                window[d]--;
            }
            // åœ¨è¿™é‡Œæ›´æ–°ç­”æ¡ˆ
            res = max(res, right - left);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func lengthOfLongestSubstring(s string) int {
    window := make(map[byte]int)

    left, right := 0, 0
    res := 0 // è®°å½•ç»“æœ
    for right < len(s) {
        c := s[right]
        right++
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        window[c]++
        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        for window[c] > 1 {
            d := s[left]
            left++
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            window[d]--
        }
        // åœ¨è¿™é‡Œæ›´æ–°ç­”æ¡ˆ
        res = max(res, right - left)
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by chatGPT (java)
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> window = new HashMap<>();

        int left = 0, right = 0;
        int res = 0; // è®°å½•ç»“æœ
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            window.put(c, window.getOrDefault(c, 0) + 1);
            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (window.get(c) > 1) {
                char d = s.charAt(left);
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                window.put(d, window.get(d) - 1);
            }
            // åœ¨è¿™é‡Œæ›´æ–°ç­”æ¡ˆ
            res = Math.max(res, right - left);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var lengthOfLongestSubstring = function(s) {
    let window = new Map();
    let left = 0, right = 0, res = 0;
    while (right < s.length) {
        let c = s[right];
        right++;
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        window.set(c, (window.get(c) || 0) + 1);
        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        while (window.get(c) > 1) {
            let d = s[left];
            left++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            window.set(d, window.get(d) - 1);
        }
        // åœ¨è¿™é‡Œæ›´æ–°ç­”æ¡ˆ
        res = Math.max(res, right - left);
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        window = {}

        left = right = 0
        res = 0 # è®°å½•ç»“æœ
        while right < len(s):
            c = s[right]
            right += 1
            # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            window[c] = window.get(c, 0) + 1
            # åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while window[c] > 1:
                d = s[left]
                left += 1
                # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                window[d] -= 1
            # åœ¨è¿™é‡Œæ›´æ–°ç­”æ¡ˆ
            res = max(res, right - left)
        return res
```

https://leetcode.cn/problems/longest-substring-without-repeating-characters çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/longest-valid-parentheses çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> stk;
        // dp[i] çš„å®šä¹‰ï¼šè®°å½•ä»¥ s[i-1] ç»“å°¾çš„æœ€é•¿åˆæ³•æ‹¬å·å­ä¸²é•¿åº¦
        vector<int> dp(s.length() + 1, 0);
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(') {
                // é‡åˆ°å·¦æ‹¬å·ï¼Œè®°å½•ç´¢å¼•
                stk.push(i);
                // å·¦æ‹¬å·ä¸å¯èƒ½æ˜¯åˆæ³•æ‹¬å·å­ä¸²çš„ç»“å°¾
                dp[i + 1] = 0;
            } else {
                // é‡åˆ°å³æ‹¬å·
                if (!stk.empty()) {
                    // é…å¯¹çš„å·¦æ‹¬å·å¯¹åº”ç´¢å¼•
                    int leftIndex = stk.top();
                    stk.pop();
                    // ä»¥è¿™ä¸ªå³æ‹¬å·ç»“å°¾çš„æœ€é•¿å­ä¸²é•¿åº¦
                    int len = 1 + i - leftIndex + dp[leftIndex];
                    dp[i + 1] = len;
                } else {
                    // æ²¡æœ‰é…å¯¹çš„å·¦æ‹¬å·
                    dp[i + 1] = 0;
                }
            }
        }
        // è®¡ç®—æœ€é•¿å­ä¸²çš„é•¿åº¦
        int res = 0;
        for (int i = 0; i < dp.size(); i++) {
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func longestValidParentheses(s string) int {
    stk := make([]int, 0)
    // dp[i] çš„å®šä¹‰ï¼šè®°å½•ä»¥ s[i-1] ç»“å°¾çš„æœ€é•¿åˆæ³•æ‹¬å·å­ä¸²é•¿åº¦
    dp := make([]int, len(s)+1)
    for i := 0; i < len(s); i++ {
        if s[i] == '(' {
            // é‡åˆ°å·¦æ‹¬å·ï¼Œè®°å½•ç´¢å¼•
            stk = append(stk, i)
            // å·¦æ‹¬å·ä¸å¯èƒ½æ˜¯åˆæ³•æ‹¬å·å­ä¸²çš„ç»“å°¾
            dp[i+1] = 0
        } else {
            // é‡åˆ°å³æ‹¬å·
            if len(stk) != 0 {
                // é…å¯¹çš„å·¦æ‹¬å·å¯¹åº”ç´¢å¼•
                leftIndex := stk[len(stk)-1]
                stk = stk[:len(stk)-1]
                // ä»¥è¿™ä¸ªå³æ‹¬å·ç»“å°¾çš„æœ€é•¿å­ä¸²é•¿åº¦
                len := 1 + i - leftIndex + dp[leftIndex]
                dp[i+1] = len
            } else {
                // æ²¡æœ‰é…å¯¹çš„å·¦æ‹¬å·
                dp[i+1] = 0
            }
        }
    }
    // è®¡ç®—æœ€é•¿å­ä¸²çš„é•¿åº¦
    res := 0
    for i := 0; i < len(dp); i++ {
        res = max(res, dp[i])
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> stk = new Stack<>();
        // dp[i] çš„å®šä¹‰ï¼šè®°å½•ä»¥ s[i-1] ç»“å°¾çš„æœ€é•¿åˆæ³•æ‹¬å·å­ä¸²é•¿åº¦
        int[] dp = new int[s.length() + 1];
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                // é‡åˆ°å·¦æ‹¬å·ï¼Œè®°å½•ç´¢å¼•
                stk.push(i);
                // å·¦æ‹¬å·ä¸å¯èƒ½æ˜¯åˆæ³•æ‹¬å·å­ä¸²çš„ç»“å°¾
                dp[i + 1] = 0;
            } else {
                // é‡åˆ°å³æ‹¬å·
                if (!stk.isEmpty()) {
                    // é…å¯¹çš„å·¦æ‹¬å·å¯¹åº”ç´¢å¼•
                    int leftIndex = stk.pop();
                    // ä»¥è¿™ä¸ªå³æ‹¬å·ç»“å°¾çš„æœ€é•¿å­ä¸²é•¿åº¦
                    int len = 1 + i - leftIndex + dp[leftIndex];
                    dp[i + 1] = len;
                } else {
                    // æ²¡æœ‰é…å¯¹çš„å·¦æ‹¬å·
                    dp[i + 1] = 0;
                }
            }
        }
        // è®¡ç®—æœ€é•¿å­ä¸²çš„é•¿åº¦
        int res = 0;
        for (int i = 0; i < dp.length; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var longestValidParentheses = function(s) {
    let stk = [];
    // dp[i] çš„å®šä¹‰ï¼šè®°å½•ä»¥ s[i-1] ç»“å°¾çš„æœ€é•¿åˆæ³•æ‹¬å·å­ä¸²é•¿åº¦
    let dp = new Array(s.length + 1).fill(0);
    for (let i = 0; i < s.length; i++) {
        if (s.charAt(i) === '(') {
            // é‡åˆ°å·¦æ‹¬å·ï¼Œè®°å½•ç´¢å¼•
            stk.push(i);
            // å·¦æ‹¬å·ä¸å¯èƒ½æ˜¯åˆæ³•æ‹¬å·å­ä¸²çš„ç»“å°¾
            dp[i + 1] = 0;
        } else {
            // é‡åˆ°å³æ‹¬å·
            if (stk.length > 0) {
                // é…å¯¹çš„å·¦æ‹¬å·å¯¹åº”ç´¢å¼•
                let leftIndex = stk.pop();
                // ä»¥è¿™ä¸ªå³æ‹¬å·ç»“å°¾çš„æœ€é•¿å­ä¸²é•¿åº¦
                let len = 1 + i - leftIndex + dp[leftIndex];
                dp[i + 1] = len;
            } else {
                // æ²¡æœ‰é…å¯¹çš„å·¦æ‹¬å·
                dp[i + 1] = 0;
            }
        }
    }
    // è®¡ç®—æœ€é•¿å­ä¸²çš„é•¿åº¦
    let res = 0;
    for (let i = 0; i < dp.length; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stk = []
        # dp[i] çš„å®šä¹‰ï¼šè®°å½•ä»¥ s[i-1] ç»“å°¾çš„æœ€é•¿åˆæ³•æ‹¬å·å­ä¸²é•¿åº¦
        dp = [0] * (len(s) + 1)
        for i in range(len(s)):
            if s[i] == '(':
                # é‡åˆ°å·¦æ‹¬å·ï¼Œè®°å½•ç´¢å¼•
                stk.append(i)
                # å·¦æ‹¬å·ä¸å¯èƒ½æ˜¯åˆæ³•æ‹¬å·å­ä¸²çš„ç»“å°¾
                dp[i + 1] = 0
            else:
                # é‡åˆ°å³æ‹¬å·
                if stk:
                    # é…å¯¹çš„å·¦æ‹¬å·å¯¹åº”ç´¢å¼•
                    leftIndex = stk.pop()
                    # ä»¥è¿™ä¸ªå³æ‹¬å·ç»“å°¾çš„æœ€é•¿å­ä¸²é•¿åº¦
                    length = 1 + i - leftIndex + dp[leftIndex]
                    dp[i + 1] = length
                else:
                    # æ²¡æœ‰é…å¯¹çš„å·¦æ‹¬å·
                    dp[i + 1] = 0
        # è®¡ç®—æœ€é•¿å­ä¸²çš„é•¿åº¦
        res = 0
        for i in range(len(dp)):
            res = max(res, dp[i])
        return res
```

https://leetcode.cn/problems/longest-valid-parentheses çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // base case
        if (root == nullptr) return nullptr;
        if (root == p || root == q) return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        // æƒ…å†µ 1
        if (left != nullptr && right != nullptr) {
            return root;
        }
        // æƒ…å†µ 2
        if (left == nullptr && right == nullptr) {
            return nullptr;
        }
        // æƒ…å†µ 3
        return left == nullptr ? right : left;
    }
};
```

```go
// by chatGPT (go)
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    // base case
    if root == nil {
        return nil
    }
    if root == p || root == q {
        return root
    }

    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    // æƒ…å†µ 1
    if left != nil && right != nil {
        return root
    }
    // æƒ…å†µ 2
    if left == nil && right == nil {
        return nil
    }
    // æƒ…å†µ 3
    if left == nil {
        return right
    }
    return left
}
```

```java
// by labuladong (java)
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // base case
        if (root == null) return null;
        if (root == p || root == q) return root;

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // æƒ…å†µ 1
        if (left != null && right != null) {
            return root;
        }
        // æƒ…å†µ 2
        if (left == null && right == null) {
            return null;
        }
        // æƒ…å†µ 3
        return left == null ? right : left;
    }
}
```

```javascript
// by chatGPT (javascript)
var lowestCommonAncestor = function(root, p, q) {
    // base case
    if (root === null) return null;
    if (root === p || root === q) return root;

    var left = lowestCommonAncestor(root.left, p, q);
    var right = lowestCommonAncestor(root.right, p, q);
    // æƒ…å†µ 1
    if (left !== null && right !== null) {
        return root;
    }
    // æƒ…å†µ 2
    if (left === null && right === null) {
        return null;
    }
    // æƒ…å†µ 3
    return left === null ? right : left;
};
```

```python
# by chatGPT (python)
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # base case
        if not root:
            return None
        if root == p or root == q:
            return root

        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        # æƒ…å†µ 1
        if left and right:
            return root
        # æƒ…å†µ 2
        if not left and not right:
            return None
        # æƒ…å†µ 3
        return right if not left else left
```

https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/lru-cache çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class LRUCache {
private:
    int cap;
    unordered_map<int, int> cache;

public:
    LRUCache(int capacity) {
        this->cap = capacity;
    }

    int get(int key) {
        if (cache.find(key) == cache.end()) {
            return -1;
        }
        // å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
        makeRecently(key);
        return cache[key];
    }

    void put(int key, int val) {
        if (cache.find(key) != cache.end()) {
            // ä¿®æ”¹ key çš„å€¼
            cache[key] = val;
            // å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
            makeRecently(key);
            return;
        }

        if (cache.size() >= this->cap) {
            // é“¾è¡¨å¤´éƒ¨å°±æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ key
            int oldestKey = cache.begin()->first;
            cache.erase(oldestKey);
        }
        // å°†æ–°çš„ key æ·»åŠ é“¾è¡¨å°¾éƒ¨
        cache[key] = val;
    }

private:
    void makeRecently(int key) {
        int val = cache[key];
        // åˆ é™¤ keyï¼Œé‡æ–°æ’å…¥åˆ°é˜Ÿå°¾
        cache.erase(key);
        cache[key] = val;
    }
};
```

```go
// by chatGPT (go)
type LRUCache struct {
    cap  int
    cache map[int]int
    list  *list.List
}

func Constructor(capacity int) LRUCache {
    return LRUCache{
        cap:   capacity,
        cache: make(map[int]int),
        list:  list.New(),
    }
}

func (this *LRUCache) Get(key int) int {
    if val, ok := this.cache[key]; ok {
        // å°† key ç§»åŠ¨åˆ°é“¾è¡¨å°¾éƒ¨è¡¨ç¤ºæœ€è¿‘è®¿é—®
        this.makeRecently(key)
        return val
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if _, ok := this.cache[key]; ok {
        // ä¿®æ”¹ key çš„å€¼ï¼Œå°† key ç§»åŠ¨åˆ°é“¾è¡¨å°¾éƒ¨è¡¨ç¤ºæœ€è¿‘è®¿é—®
        this.cache[key] = value
        this.makeRecently(key)
        return
    }

    if len(this.cache) >= this.cap {
        // é“¾è¡¨å¤´éƒ¨å°±æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ key
        this.removeOldest()
    }
    // å°†æ–°çš„ key-value æ·»åŠ é“¾è¡¨å°¾éƒ¨
    this.cache[key] = value
    this.list.PushBack(key)
}

func (this *LRUCache) makeRecently(key int) {
    // å°† key ç§»åŠ¨åˆ°é“¾è¡¨å°¾éƒ¨è¡¨ç¤ºæœ€è¿‘è®¿é—®
    for e := this.list.Front(); e != nil; e = e.Next() {
        if e.Value.(int) == key {
            this.list.MoveToBack(e)
            break
        }
    }
}

func (this *LRUCache) removeOldest() {
    // åˆ é™¤é“¾è¡¨å¤´éƒ¨è¡¨ç¤ºæœ€ä¹…æœªä½¿ç”¨çš„ key
    e := this.list.Front()
    delete(this.cache, e.Value.(int))
    this.list.Remove(e)
}
```

```java
// by labuladong (java)
class LRUCache {
    int cap;
    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();
    public LRUCache(int capacity) {
        this.cap = capacity;
    }

    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        // å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
        makeRecently(key);
        return cache.get(key);
    }

    public void put(int key, int val) {
        if (cache.containsKey(key)) {
            // ä¿®æ”¹ key çš„å€¼
            cache.put(key, val);
            // å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
            makeRecently(key);
            return;
        }

        if (cache.size() >= this.cap) {
            // é“¾è¡¨å¤´éƒ¨å°±æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ key
            int oldestKey = cache.keySet().iterator().next();
            cache.remove(oldestKey);
        }
        // å°†æ–°çš„ key æ·»åŠ é“¾è¡¨å°¾éƒ¨
        cache.put(key, val);
    }

    private void makeRecently(int key) {
        int val = cache.get(key);
        // åˆ é™¤ keyï¼Œé‡æ–°æ’å…¥åˆ°é˜Ÿå°¾
        cache.remove(key);
        cache.put(key, val);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.cap = capacity;
    this.cache = new Map();
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if (!this.cache.has(key)) {
        return -1;
    }
    // å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
    this.makeRecently(key);
    return this.cache.get(key);
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    if (this.cache.has(key)) {
        // ä¿®æ”¹ key çš„å€¼
        this.cache.set(key, value);
        // å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
        this.makeRecently(key);
        return;
    }

    if (this.cache.size >= this.cap) {
        // é“¾è¡¨å¤´éƒ¨å°±æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ key
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
    }
    // å°†æ–°çš„ key æ·»åŠ é“¾è¡¨å°¾éƒ¨
    this.cache.set(key, value);
};

/**
 * @param {number} key
 * @return {void}
 */
LRUCache.prototype.makeRecently = function(key) {
    const val = this.cache.get(key);
    // åˆ é™¤ keyï¼Œé‡æ–°æ’å…¥åˆ°é˜Ÿå°¾
    this.cache.delete(key);
    this.cache.set(key, val);
};
```

```python
# by chatGPT (python)
class LRUCache:
    def __init__(self, capacity: int):
        self.cap = capacity
        self.cache = collections.OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        # å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            # ä¿®æ”¹ key çš„å€¼
            self.cache[key] = value
            # å°† key å˜ä¸ºæœ€è¿‘ä½¿ç”¨
            self.cache.move_to_end(key)
            return

        if len(self.cache) >= self.cap:
            # é“¾è¡¨å¤´éƒ¨å°±æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ key
            self.cache.popitem(last=False)
        # å°†æ–°çš„ key æ·»åŠ é“¾è¡¨å°¾éƒ¨
        self.cache[key] = value
```

https://leetcode.cn/problems/lru-cache çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/majority-element çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        // æˆ‘ä»¬æƒ³å¯»æ‰¾çš„é‚£ä¸ªä¼—æ•°
        int target = 0;
        // è®¡æ•°å™¨ï¼ˆç±»æ¯”å¸¦ç”µç²’å­ä¾‹å­ä¸­çš„å¸¦ç”µæ€§ï¼‰
        int count = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (count == 0) {
                // å½“è®¡æ•°å™¨ä¸º 0 æ—¶ï¼Œå‡è®¾ nums[i] å°±æ˜¯ä¼—æ•°
                target = nums[i];
                // ä¼—æ•°å‡ºç°äº†ä¸€æ¬¡
                count = 1;
            } else if (nums[i] == target) {
                // å¦‚æœé‡åˆ°çš„æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨ç´¯åŠ 
                count++;
            } else {
                // å¦‚æœé‡åˆ°çš„ä¸æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨é€’å‡
                count--;
            }
        }
        // å›æƒ³å¸¦ç”µç²’å­çš„ä¾‹å­
        // æ­¤æ—¶çš„ count å¿…ç„¶å¤§äº 0ï¼Œæ­¤æ—¶çš„ target å¿…ç„¶å°±æ˜¯ç›®æ ‡ä¼—æ•°
        return target;
    }
};
```

```go
// by chatGPT (go)
func majorityElement(nums []int) int {
    // æˆ‘ä»¬æƒ³å¯»æ‰¾çš„é‚£ä¸ªä¼—æ•°
    target := 0
    // è®¡æ•°å™¨ï¼ˆç±»æ¯”å¸¦ç”µç²’å­ä¾‹å­ä¸­çš„å¸¦ç”µæ€§ï¼‰
    count := 0
    for i := 0; i < len(nums); i++ {
        if count == 0 {
            // å½“è®¡æ•°å™¨ä¸º 0 æ—¶ï¼Œå‡è®¾ nums[i] å°±æ˜¯ä¼—æ•°
            target = nums[i]
            // ä¼—æ•°å‡ºç°äº†ä¸€æ¬¡
            count = 1
        } else if nums[i] == target {
            // å¦‚æœé‡åˆ°çš„æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨ç´¯åŠ 
            count++
        } else {
            // å¦‚æœé‡åˆ°çš„ä¸æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨é€’å‡
            count--
        }
    }
    // å›æƒ³å¸¦ç”µç²’å­çš„ä¾‹å­
    // æ­¤æ—¶çš„ count å¿…ç„¶å¤§äº 0ï¼Œæ­¤æ—¶çš„ target å¿…ç„¶å°±æ˜¯ç›®æ ‡ä¼—æ•°
    return target
}
```

```java
// by labuladong (java)
class Solution {
    public int majorityElement(int[] nums) {
        // æˆ‘ä»¬æƒ³å¯»æ‰¾çš„é‚£ä¸ªä¼—æ•°
        int target = 0;
        // è®¡æ•°å™¨ï¼ˆç±»æ¯”å¸¦ç”µç²’å­ä¾‹å­ä¸­çš„å¸¦ç”µæ€§ï¼‰
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            if (count == 0) {
                // å½“è®¡æ•°å™¨ä¸º 0 æ—¶ï¼Œå‡è®¾ nums[i] å°±æ˜¯ä¼—æ•°
                target = nums[i];
                // ä¼—æ•°å‡ºç°äº†ä¸€æ¬¡
                count = 1;
            } else if (nums[i] == target) {
                // å¦‚æœé‡åˆ°çš„æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨ç´¯åŠ 
                count++;
            } else {
                // å¦‚æœé‡åˆ°çš„ä¸æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨é€’å‡
                count--;
            }
        }
        // å›æƒ³å¸¦ç”µç²’å­çš„ä¾‹å­
        // æ­¤æ—¶çš„ count å¿…ç„¶å¤§äº 0ï¼Œæ­¤æ—¶çš„ target å¿…ç„¶å°±æ˜¯ç›®æ ‡ä¼—æ•°
        return target;
    }
}
```

```javascript
// by chatGPT (javascript)
var majorityElement = function(nums) {
    // æˆ‘ä»¬æƒ³å¯»æ‰¾çš„é‚£ä¸ªä¼—æ•°
    let target = 0;
    // è®¡æ•°å™¨ï¼ˆç±»æ¯”å¸¦ç”µç²’å­ä¾‹å­ä¸­çš„å¸¦ç”µæ€§ï¼‰
    let count = 0;
    for (let i = 0; i < nums.length; i++) {
        if (count === 0) {
            // å½“è®¡æ•°å™¨ä¸º 0 æ—¶ï¼Œå‡è®¾ nums[i] å°±æ˜¯ä¼—æ•°
            target = nums[i];
            // ä¼—æ•°å‡ºç°äº†ä¸€æ¬¡
            count = 1;
        } else if (nums[i] === target) {
            // å¦‚æœé‡åˆ°çš„æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨ç´¯åŠ 
            count++;
        } else {
            // å¦‚æœé‡åˆ°çš„ä¸æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨é€’å‡
            count--;
        }
    }
    // å›æƒ³å¸¦ç”µç²’å­çš„ä¾‹å­
    // æ­¤æ—¶çš„ count å¿…ç„¶å¤§äº 0ï¼Œæ­¤æ—¶çš„ target å¿…ç„¶å°±æ˜¯ç›®æ ‡ä¼—æ•°
    return target;
};
```

```python
# by chatGPT (python)
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        # æˆ‘ä»¬æƒ³å¯»æ‰¾çš„é‚£ä¸ªä¼—æ•°
        target = 0
        # è®¡æ•°å™¨ï¼ˆç±»æ¯”å¸¦ç”µç²’å­ä¾‹å­ä¸­çš„å¸¦ç”µæ€§ï¼‰
        count = 0
        for i in range(len(nums)):
            if count == 0:
                # å½“è®¡æ•°å™¨ä¸º 0 æ—¶ï¼Œå‡è®¾ nums[i] å°±æ˜¯ä¼—æ•°
                target = nums[i]
                # ä¼—æ•°å‡ºç°äº†ä¸€æ¬¡
                count = 1
            elif nums[i] == target:
                # å¦‚æœé‡åˆ°çš„æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨ç´¯åŠ 
                count += 1
            else:
                # å¦‚æœé‡åˆ°çš„ä¸æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨é€’å‡
                count -= 1
        # å›æƒ³å¸¦ç”µç²’å­çš„ä¾‹å­
        # æ­¤æ—¶çš„ count å¿…ç„¶å¤§äº 0ï¼Œæ­¤æ—¶çš„ target å¿…ç„¶å°±æ˜¯ç›®æ ‡ä¼—æ•°
        return target
```

https://leetcode.cn/problems/majority-element çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/matrix-block-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class NumMatrix {
private:
    vector<vector<int>> preSum;
public:
    NumMatrix(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        if (m == 0 || n == 0) return;
        // æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
        preSum = vector<vector<int>>(m + 1, vector<int>(n + 1));
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
                preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] + matrix[i - 1][j - 1] - preSum[i - 1][j - 1];
            }
        }
    }

    // è®¡ç®—å­çŸ©é˜µ [x1, y1, x2, y2] çš„å…ƒç´ å’Œ
    int sumRegion(int x1, int y1, int x2, int y2) {
        // ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
        return preSum[x2 + 1][y2 + 1] - preSum[x1][y2 + 1] - preSum[x2 + 1][y1] + preSum[x1][y1];
    }
};

class Solution {
public:
    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
        int m = mat.size(), n = mat[0].size();
        NumMatrix numMatrix(mat);
        vector<vector<int>> res(m, vector<int>(n));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // å·¦ä¸Šè§’çš„åæ ‡
                int x1 = max(i - k, 0);
                int y1 = max(j - k, 0);
                // å³ä¸‹è§’åæ ‡
                int x2 = min(i + k, m - 1);
                int y2 = min(j + k, n - 1);
                res[i][j] = numMatrix.sumRegion(x1, y1, x2, y2);
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
type NumMatrix struct {
    // å®šä¹‰ï¼špreSum[i][j] è®°å½• matrix ä¸­å­çŸ©é˜µ [0, 0, i-1, j-1] çš„å…ƒç´ å’Œ
    preSum [][]int
}

func Constructor(matrix [][]int) NumMatrix {
    m, n := len(matrix), len(matrix[0])
    // æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
    preSum := make([][]int, m+1)
    for i := range preSum {
        preSum[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            // è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
            preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i-1][j-1] - preSum[i-1][j-1]
        }
    }
    return NumMatrix{preSum: preSum}
}

// è®¡ç®—å­çŸ©é˜µ [x1, y1, x2, y2] çš„å…ƒç´ å’Œ
func (n *NumMatrix) SumRegion(x1 int, y1 int, x2 int, y2 int) int {
    // ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
    return n.preSum[x2+1][y2+1] - n.preSum[x1][y2+1] - n.preSum[x2+1][y1] + n.preSum[x1][y1]
}

func matrixBlockSum(mat [][]int, k int) [][]int {
    m, n := len(mat), len(mat[0])
    numMatrix := Constructor(mat)
    res := make([][]int, m)
    for i := range res {
        res[i] = make([]int, n)
    }
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            // å·¦ä¸Šè§’çš„åæ ‡
            x1 := max(i-k, 0)
            y1 := max(j-k, 0)
            // å³ä¸‹è§’åæ ‡
            x2 := min(i+k, m-1)
            y2 := min(j+k, n-1)

            res[i][j] = numMatrix.SumRegion(x1, y1, x2, y2)
        }
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int m = mat.length, n = mat[0].length;
        NumMatrix numMatrix = new NumMatrix(mat);
        int[][] res = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // å·¦ä¸Šè§’çš„åæ ‡
                int x1 = Math.max(i - k, 0);
                int y1 = Math.max(j - k, 0);
                // å³ä¸‹è§’åæ ‡
                int x2 = Math.min(i + k, m - 1);
                int y2 = Math.min(j + k, n - 1);

                res[i][j] = numMatrix.sumRegion(x1, y1, x2, y2);
            }
        }
        return res;
    }
}

class NumMatrix {
    // å®šä¹‰ï¼špreSum[i][j] è®°å½• matrix ä¸­å­çŸ©é˜µ [0, 0, i-1, j-1] çš„å…ƒç´ å’Œ
    private int[][] preSum;

    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        if (m == 0 || n == 0) return;
        // æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
        preSum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
                preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] + matrix[i - 1][j - 1] - preSum[i - 1][j - 1];
            }
        }
    }

    // è®¡ç®—å­çŸ©é˜µ [x1, y1, x2, y2] çš„å…ƒç´ å’Œ
    public int sumRegion(int x1, int y1, int x2, int y2) {
        // ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
        return preSum[x2 + 1][y2 + 1] - preSum[x1][y2 + 1] - preSum[x2 + 1][y1] + preSum[x1][y1];
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} mat
 * @param {number} k
 * @return {number[][]}
 */
var matrixBlockSum = function(mat, k) {
    const m = mat.length, n = mat[0].length;
    const numMatrix = new NumMatrix(mat);
    const res = new Array(m);
    for (let i = 0; i < m; i++) {
        res[i] = new Array(n);
        for (let j = 0; j < n; j++) {
            // å·¦ä¸Šè§’çš„åæ ‡
            const x1 = Math.max(i - k, 0);
            const y1 = Math.max(j - k, 0);
            // å³ä¸‹è§’åæ ‡
            const x2 = Math.min(i + k, m - 1);
            const y2 = Math.min(j + k, n - 1);

            res[i][j] = numMatrix.sumRegion(x1, y1, x2, y2);
        }
    }
    return res;
};

class NumMatrix {
    /**
     * @param {number[][]} matrix
     */
    constructor(matrix) {
        const m = matrix.length, n = matrix[0].length;
        if (m === 0 || n === 0) return;
        // æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
        this.preSum = new Array(m + 1);
        for (let i = 0; i <= m; i++) {
            this.preSum[i] = new Array(n + 1).fill(0);
        }
        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                // è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
                this.preSum[i][j] = this.preSum[i - 1][j] + this.preSum[i][j - 1] + matrix[i - 1][j - 1] - this.preSum[i - 1][j - 1];
            }
        }
    }

    /**
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @return {number}
     */
    sumRegion(x1, y1, x2, y2) {
        // ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
        return this.preSum[x2 + 1][y2 + 1] - this.preSum[x1][y2 + 1] - this.preSum[x2 + 1][y1] + this.preSum[x1][y1];
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        numMatrix = NumMatrix(mat)
        res = [[0]*n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                # å·¦ä¸Šè§’çš„åæ ‡
                x1, y1 = max(i - k, 0), max(j - k, 0)
                # å³ä¸‹è§’åæ ‡
                x2, y2 = min(i + k, m - 1), min(j + k, n - 1)

                res[i][j] = numMatrix.sumRegion(x1, y1, x2, y2)
        return res

class NumMatrix:
    def __init__(self, matrix: List[List[int]]):
        m, n = len(matrix), len(matrix[0])
        if m == 0 or n == 0:
            return
        # æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
        self.preSum = [[0]*(n+1) for _ in range(m+1)]
        for i in range(1, m+1):
            for j in range(1, n+1):
                # è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
                self.preSum[i][j] = self.preSum[i-1][j] + self.preSum[i][j-1] + matrix[i-1][j-1] - self.preSum[i-1][j-1]

    # è®¡ç®—å­çŸ©é˜µ [x1, y1, x2, y2] çš„å…ƒç´ å’Œ
    def sumRegion(self, x1: int, y1: int, x2: int, y2: int) -> int:
        # ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
        return self.preSum[x2+1][y2+1] - self.preSum[x1][y2+1] - self.preSum[x2+1][y1] + self.preSum[x1][y1]
```

https://leetcode.cn/problems/matrix-block-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/max-area-of-island çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        // è®°å½•å²›å±¿çš„æœ€å¤§é¢ç§¯
        int res = 0;
        int m = grid.size(), n = grid[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // æ·¹æ²¡å²›å±¿ï¼Œå¹¶æ›´æ–°æœ€å¤§å²›å±¿é¢ç§¯
                    res = max(res, dfs(grid, i, j));
                }
            }
        }
        return res;
    }

    // æ·¹æ²¡ä¸ (i, j) ç›¸é‚»çš„é™†åœ°ï¼Œå¹¶è¿”å›æ·¹æ²¡çš„é™†åœ°é¢ç§¯
    int dfs(vector<vector<int>>& grid, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return 0;
        }
        if (grid[i][j] == 0) {
            // å·²ç»æ˜¯æµ·æ°´äº†
            return 0;
        }
        // å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = 0;

        return dfs(grid, i + 1, j)
                + dfs(grid, i, j + 1)
                + dfs(grid, i - 1, j)
                + dfs(grid, i, j - 1) + 1;
    }
};
```

```go
// by chatGPT (go)
func maxAreaOfIsland(grid [][]int) int {
    // è®°å½•å²›å±¿çš„æœ€å¤§é¢ç§¯
    res := 0
    m, n := len(grid), len(grid[0])
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if grid[i][j] == 1 {
                // æ·¹æ²¡å²›å±¿ï¼Œå¹¶æ›´æ–°æœ€å¤§å²›å±¿é¢ç§¯
                res = Max(res, dfs(grid, i, j))
            }
        }
    }
    return res
}

// æ·¹æ²¡ä¸ (i, j) ç›¸é‚»çš„é™†åœ°ï¼Œå¹¶è¿”å›æ·¹æ²¡çš„é™†åœ°é¢ç§¯
func dfs(grid [][]int, i int, j int) int {
    m, n := len(grid), len(grid[0])
    if i < 0 || j < 0 || i >= m || j >= n {
        // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
        return 0
    }
    if grid[i][j] == 0 {
        // å·²ç»æ˜¯æµ·æ°´äº†
        return 0
    }
    // å°† (i, j) å˜æˆæµ·æ°´
    grid[i][j] = 0

    return dfs(grid, i+1, j) +
           dfs(grid, i, j+1) +
           dfs(grid, i-1, j) +
           dfs(grid, i, j-1) + 1
}

// Max è·å–ä¸¤ä¸ªæ•°çš„æœ€å¤§å€¼
func Max(x int, y int) int {
    if x > y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        // è®°å½•å²›å±¿çš„æœ€å¤§é¢ç§¯
        int res = 0;
        int m = grid.length, n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // æ·¹æ²¡å²›å±¿ï¼Œå¹¶æ›´æ–°æœ€å¤§å²›å±¿é¢ç§¯
                    res = Math.max(res, dfs(grid, i, j));
                }
            }
        }
        return res;
    }

    // æ·¹æ²¡ä¸ (i, j) ç›¸é‚»çš„é™†åœ°ï¼Œå¹¶è¿”å›æ·¹æ²¡çš„é™†åœ°é¢ç§¯
    int dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return 0;
        }
        if (grid[i][j] == 0) {
            // å·²ç»æ˜¯æµ·æ°´äº†
            return 0;
        }
        // å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = 0;

        return dfs(grid, i + 1, j)
                + dfs(grid, i, j + 1)
                + dfs(grid, i - 1, j)
                + dfs(grid, i, j - 1) + 1;
    }
}
```

```javascript
// by chatGPT (javascript)
var maxAreaOfIsland = function(grid) {
    // è®°å½•å²›å±¿çš„æœ€å¤§é¢ç§¯
    let res = 0;
    const m = grid.length, n = grid[0].length;
    
    // æ·¹æ²¡ä¸ (i, j) ç›¸é‚»çš„é™†åœ°ï¼Œå¹¶è¿”å›æ·¹æ²¡çš„é™†åœ°é¢ç§¯
    const dfs = (grid, i, j) => {
        const m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return 0;
        }
        if (grid[i][j] === 0) {
            // å·²ç»æ˜¯æµ·æ°´äº†
            return 0;
        }
        // å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = 0;

        return dfs(grid, i + 1, j)
                + dfs(grid, i, j + 1)
                + dfs(grid, i - 1, j)
                + dfs(grid, i, j - 1) + 1;
    };
    
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] === 1) {
                // æ·¹æ²¡å²›å±¿ï¼Œå¹¶æ›´æ–°æœ€å¤§å²›å±¿é¢ç§¯
                res = Math.max(res, dfs(grid, i, j));
            }
        }
    }
    
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        # è®°å½•å²›å±¿çš„æœ€å¤§é¢ç§¯
        res = 0
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    # æ·¹æ²¡å²›å±¿ï¼Œå¹¶æ›´æ–°æœ€å¤§å²›å±¿é¢ç§¯
                    res = max(res, self.dfs(grid, i, j))
        return res
    
    # æ·¹æ²¡ä¸ (i, j) ç›¸é‚»çš„é™†åœ°ï¼Œå¹¶è¿”å›æ·¹æ²¡çš„é™†åœ°é¢ç§¯
    def dfs(self, grid: List[List[int]], i: int, j: int) -> int:
        m, n = len(grid), len(grid[0])
        if i < 0 or j < 0 or i >= m or j >= n:
            # è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return 0
        if grid[i][j] == 0:
            # å·²ç»æ˜¯æµ·æ°´äº†
            return 0
        # å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = 0

        return self.dfs(grid, i + 1, j) \
               + self.dfs(grid, i - 1, j) \
               + self.dfs(grid, i, j + 1) \
               + self.dfs(grid, i, j - 1) \
               + 1
```

https://leetcode.cn/problems/max-area-of-island çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/maximum-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    /* ä¸»å‡½æ•° */
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return build(nums, 0, nums.size() - 1);
    }

    /* å®šä¹‰ï¼šå°† nums[lo..hi] æ„é€ æˆç¬¦åˆæ¡ä»¶çš„æ ‘ï¼Œè¿”å›æ ¹èŠ‚ç‚¹ */
    TreeNode* build(vector<int>& nums, int lo, int hi) {
        /* base case */
        if (lo > hi) {
            return nullptr;
        }

        /* æ‰¾åˆ°æ•°ç»„ä¸­çš„æœ€å¤§å€¼å’Œå¯¹åº”çš„ç´¢å¼• */
        int index = -1, maxVal = INT_MIN;
        for (int i = lo; i <= hi; i++) {
            if (maxVal < nums[i]) {
                index = i;
                maxVal = nums[i];
            }
        }

        TreeNode* root = new TreeNode(maxVal);
        /* é€’å½’è°ƒç”¨æ„é€ å·¦å³å­æ ‘ */
        root->left = build(nums, lo, index - 1);
        root->right = build(nums, index + 1, hi);

        return root;
    }
};
```

```go
// by chatGPT (go)
func constructMaximumBinaryTree(nums []int) *TreeNode {
    return build(nums, 0, len(nums)-1)
}

func build(nums []int, lo int, hi int) *TreeNode {
    // base case
    if lo > hi {
        return nil
    }

    // æ‰¾åˆ°æ•°ç»„ä¸­çš„æœ€å¤§å€¼å’Œå¯¹åº”çš„ç´¢å¼•
    index, maxVal := -1, math.MinInt32
    for i := lo; i <= hi; i++ {
        if maxVal < nums[i] {
            index = i
            maxVal = nums[i]
        }
    }

    root := &TreeNode{Val: maxVal}
    // é€’å½’è°ƒç”¨æ„é€ å·¦å³å­æ ‘
    root.Left = build(nums, lo, index-1)
    root.Right = build(nums, index+1, hi)

    return root
}
```

```java
// by labuladong (java)
class Solution {
    /* ä¸»å‡½æ•° */
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return build(nums, 0, nums.length - 1);
    }

    /* å®šä¹‰ï¼šå°† nums[lo..hi] æ„é€ æˆç¬¦åˆæ¡ä»¶çš„æ ‘ï¼Œè¿”å›æ ¹èŠ‚ç‚¹ */
    TreeNode build(int[] nums, int lo, int hi) {
        // base case
        if (lo > hi) {
            return null;
        }

        // æ‰¾åˆ°æ•°ç»„ä¸­çš„æœ€å¤§å€¼å’Œå¯¹åº”çš„ç´¢å¼•
        int index = -1, maxVal = Integer.MIN_VALUE;
        for (int i = lo; i <= hi; i++) {
            if (maxVal < nums[i]) {
                index = i;
                maxVal = nums[i];
            }
        }

        TreeNode root = new TreeNode(maxVal);
        // é€’å½’è°ƒç”¨æ„é€ å·¦å³å­æ ‘
        root.left = build(nums, lo, index - 1);
        root.right = build(nums, index + 1, hi);

        return root;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var constructMaximumBinaryTree = function(nums) {
  return build(nums, 0, nums.length - 1);
}

/**
 * Define: å°† nums[lo..hi] æ„é€ æˆç¬¦åˆæ¡ä»¶çš„æ ‘ï¼Œè¿”å›æ ¹èŠ‚ç‚¹ 
 */
var build = function(nums, lo, hi) {
  // base case
  if (lo > hi) {
    return null;
  }

  // æ‰¾åˆ°æ•°ç»„ä¸­çš„æœ€å¤§å€¼å’Œå¯¹åº”çš„ç´¢å¼•
  var index = -1, maxVal = -Infinity;
  for (var i = lo; i <= hi; i++) {
    if (maxVal < nums[i]) {
      index = i;
      maxVal = nums[i];
    }
  }

  var root = new TreeNode(maxVal);
  // é€’å½’è°ƒç”¨æ„é€ å·¦å³å­æ ‘
  root.left = build(nums, lo, index - 1);
  root.right = build(nums, index + 1, hi);

  return root;
}
```

```python
# by chatGPT (python)
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        def build(nums, lo, hi):
            # base case
            if lo > hi:
                return None

            # æ‰¾åˆ°æ•°ç»„ä¸­çš„æœ€å¤§å€¼å’Œå¯¹åº”çš„ç´¢å¼•
            index, maxVal = lo, nums[lo]
            for i in range(lo, hi+1):
                if nums[i] > maxVal:
                    index, maxVal = i, nums[i]

            # åˆ›å»ºæ ¹èŠ‚ç‚¹
            root = TreeNode(maxVal)
            # é€’å½’æ„å»ºå·¦å³å­æ ‘
            root.left = build(nums, lo, index - 1)
            root.right = build(nums, index + 1, hi)

            return root

        # è°ƒç”¨ build å‡½æ•°
        return build(nums, 0, len(nums)-1)
```

https://leetcode.cn/problems/maximum-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/maximum-depth-of-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
/***** è§£æ³•ä¸€ï¼Œå›æº¯ç®—æ³•æ€è·¯ *****/
class Solution {
public:
    int depth = 0;
    int res = 0;

    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }

    // éå†äºŒå‰æ ‘
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }

        // å‰åºéå†ä½ç½®
        depth++;
        // éå†çš„è¿‡ç¨‹ä¸­è®°å½•æœ€å¤§æ·±åº¦
        res = max(res, depth);
        traverse(root->left);
        traverse(root->right);
        // ååºéå†ä½ç½®
        depth--;
    }
};

/***** è§£æ³•äºŒï¼ŒåŠ¨æ€è§„åˆ’æ€è·¯ *****/
class Solution2 {
public:
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
    int maxDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        // æ ¹æ®å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦æ¨å‡ºåŸäºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
        return 1 + max(leftMax, rightMax);
    }
};
```

```go
// by chatGPT (go)
/***** è§£æ³•ä¸€ï¼Œå›æº¯ç®—æ³•æ€è·¯ *****/
func maxDepth(root *TreeNode) int {
    var depth int
    var res int
    traverse(root, &depth, &res)
    return res
}

// éå†äºŒå‰æ ‘
func traverse(root *TreeNode, depth *int, res *int) {
    if root == nil {
        return
    }
    // å‰åºéå†ä½ç½®
    *depth++
    // éå†çš„è¿‡ç¨‹ä¸­è®°å½•æœ€å¤§æ·±åº¦
    *res = max(*res,*depth)
    traverse(root.Left, depth, res)
    traverse(root.Right, depth, res)
    // ååºéå†ä½ç½®
    *depth--
}

/***** è§£æ³•äºŒï¼ŒåŠ¨æ€è§„åˆ’æ€è·¯ *****/
func maxDepth2(root *TreeNode) int {
    if root == nil {
        return 0
    }
    leftMax := maxDepth2(root.Left)
    rightMax := maxDepth2(root.Right)
    // æ ¹æ®å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦æ¨å‡ºåŸäºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
    return 1 + max(leftMax, rightMax)
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
/***** è§£æ³•ä¸€ï¼Œå›æº¯ç®—æ³•æ€è·¯ *****/
class Solution {

    int depth = 0;
    int res = 0;

    public int maxDepth(TreeNode root) {
        traverse(root);
        return res;
    }

    // éå†äºŒå‰æ ‘
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }

        // å‰åºéå†ä½ç½®
        depth++;
        // éå†çš„è¿‡ç¨‹ä¸­è®°å½•æœ€å¤§æ·±åº¦
        res = Math.max(res, depth);
        traverse(root.left);
        traverse(root.right);
        // ååºéå†ä½ç½®
        depth--;
    }
}

/***** è§£æ³•äºŒï¼ŒåŠ¨æ€è§„åˆ’æ€è·¯ *****/
class Solution2 {
    // å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftMax = maxDepth(root.left);
        int rightMax = maxDepth(root.right);
        // æ ¹æ®å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦æ¨å‡ºåŸäºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
        return 1 + Math.max(leftMax, rightMax);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * è§£æ³•ä¸€ï¼Œå›æº¯ç®—æ³•æ€è·¯
 */
function maxDepth(root) {
    let depth = 0;
    let res = 0;
    // éå†äºŒå‰æ ‘
    function traverse(root) {
        if (root === null) {
        return;
        }

        // å‰åºéå†ä½ç½®
        depth++;
        // éå†çš„è¿‡ç¨‹ä¸­è®°å½•æœ€å¤§æ·±åº¦
        res = Math.max(res, depth);
        traverse(root.left);
        traverse(root.right);
        // ååºéå†ä½ç½®
        depth--;
    }
    traverse(root);
    return res;
}

/**
 * è§£æ³•äºŒï¼ŒåŠ¨æ€è§„åˆ’æ€è·¯
 */

// å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
function maxDepth2(root) {
    if (root === null) {
        return 0;
    }
    const leftMax = maxDepth2(root.left);
    const rightMax = maxDepth2(root.right);
    // æ ¹æ®å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦æ¨å‡ºåŸäºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
    return 1 + Math.max(leftMax, rightMax);
}
```

```python
# by chatGPT (python)
# è§£æ³•ä¸€ï¼Œå›æº¯ç®—æ³•æ€è·¯

class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        self.res = 0
        self.traverse(root, 0)
        return self.res

    # éå†äºŒå‰æ ‘
    def traverse(self, root: TreeNode, depth: int) -> None:
        if not root:
            return
        # å‰åºéå†ä½ç½®
        depth += 1
        # éå†çš„è¿‡ç¨‹ä¸­è®°å½•æœ€å¤§æ·±åº¦
        self.res = max(self.res, depth)
        self.traverse(root.left, depth)
        self.traverse(root.right, depth)
        # ååºéå†ä½ç½®
        depth -= 1


# è§£æ³•äºŒï¼ŒåŠ¨æ€è§„åˆ’æ€è·¯

class Solution:
    # å®šä¹‰ï¼šè¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        leftMax = self.maxDepth(root.left)
        rightMax = self.maxDepth(root.right)
        # æ ¹æ®å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦æ¨å‡ºåŸäºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
        return 1 + max(leftMax, rightMax)
```

https://leetcode.cn/problems/maximum-depth-of-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/maximum-depth-of-n-ary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
// åˆ†è§£é—®é¢˜çš„æ€è·¯
class Solution {
public:
    int maxDepth(Node* root) {
        if (root == nullptr) {
            return 0;
        }
        int subTreeMaxDepth = 0;
        for (Node* child : root->children) {
            subTreeMaxDepth = max(subTreeMaxDepth, maxDepth(child));
        }
        return 1 + subTreeMaxDepth;
    }
};

// éå†çš„æ€è·¯
class Solution2 {
public:
    int maxDepth(Node* root) {
        traverse(root);
        return res;
    }

private:
    // è®°å½•é€’å½’éå†åˆ°çš„æ·±åº¦
    int depth = 0;
    // è®°å½•æœ€å¤§çš„æ·±åº¦
    int res = 0;

    void traverse(Node* root) {
        if (root == nullptr) {
            return;
        }
        // å‰åºéå†ä½ç½®
        depth++;
        res = max(res, depth);

        for (Node* child : root->children) {
            traverse(child);
        }
        // ååºéå†ä½ç½®
        depth--;
    }
};
```

```go
// by chatGPT (go)
// åˆ†è§£é—®é¢˜çš„æ€è·¯
func maxDepth(root *Node) int {
    if root == nil {
        return 0
    }
    subTreeMaxDepth := 0
    for _, child := range root.Children {
        subTreeMaxDepth = max(subTreeMaxDepth, maxDepth(child))
    }
    return 1 + subTreeMaxDepth
}

// éå†çš„æ€è·¯
func maxDepth(root *Node) int {
    // è®°å½•é€’å½’éå†åˆ°çš„æ·±åº¦
    depth := 0
    // è®°å½•æœ€å¤§çš„æ·±åº¦
    res := 0
    
    traverse(root, &depth, &res)
    return res
}

func traverse(root *Node, depth *int, res *int) {
    if root == nil {
        return
    }
    // å‰åºéå†ä½ç½®
    (*depth)++
    *res = max(*res, *depth)

    for _, child := range root.Children {
        traverse(child, depth, res)
    }
    // ååºéå†ä½ç½®
    (*depth)--
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
// åˆ†è§£é—®é¢˜çš„æ€è·¯
class Solution {
    public int maxDepth(Node root) {
        if (root == null) {
            return 0;
        }
        int subTreeMaxDepth = 0;
        for (Node child : root.children) {
            subTreeMaxDepth = Math.max(subTreeMaxDepth, maxDepth(child));
        }
        return 1 + subTreeMaxDepth;
    }
}

// éå†çš„æ€è·¯
class Solution2 {
    public int maxDepth(Node root) {
        traverse(root);
        return res;
    }

    // è®°å½•é€’å½’éå†åˆ°çš„æ·±åº¦
    int depth = 0;
    // è®°å½•æœ€å¤§çš„æ·±åº¦
    int res = 0;

    void traverse(Node root) {
        if (root == null) {
            return;
        }
        // å‰åºéå†ä½ç½®
        depth++;
        res = Math.max(res, depth);

        for (Node child : root.children) {
            traverse(child);
        }
        // ååºéå†ä½ç½®
        depth--;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * åˆ†è§£é—®é¢˜çš„æ€è·¯
 */
var maxDepth = function(root) {
    // è‹¥æ ¹ç»“ç‚¹ä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿”å› 0
    if (!root) {
        return 0;
    }
    // è®¾å®šå­æ ‘æœ€å¤§æ·±åº¦
    let subTreeMaxDepth = 0;
    // éå†æ¯ä¸ªå­ç»“ç‚¹
    for (let i = 0; i < root.children.length; i++) {
        subTreeMaxDepth = Math.max(subTreeMaxDepth, maxDepth(root.children[i]));
    }
    // å½“å‰ç»“ç‚¹æ·±åº¦ä¸ºæœ€å¤§å­ç»“ç‚¹æ·±åº¦+1
    return 1 + subTreeMaxDepth;
};

/**
 * éå†çš„æ€è·¯
 */
var maxDepth2 = function(root) {
    // è®°å½•é€’å½’éå†åˆ°çš„æ·±åº¦
    let depth = 0;
    // è®°å½•æœ€å¤§çš„æ·±åº¦
    let res = 0;

    /**
     * é€’å½’éå†
     */
    function traverse(root) {
        if (!root) {
            return;
        }
        // å‰åºéå†ä½ç½®
        depth++;
        res = Math.max(res, depth);

        // éå†æ¯ä¸ªå­èŠ‚ç‚¹
        for (let i = 0; i < root.children.length; i++) {
            traverse(root.children[i]);
        }
        // ååºéå†ä½ç½®
        depth--;
    }

    // é€’å½’éå†è·å–æœ€å¤§æ·±åº¦
    traverse(root);
    return res;
}
```

```python
# by chatGPT (python)
# åˆ†è§£é—®é¢˜çš„æ€è·¯
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if not root:
            return 0
        subTreeMaxDepth = 0
        for child in root.children:
            subTreeMaxDepth = max(subTreeMaxDepth, self.maxDepth(child))
        return 1 + subTreeMaxDepth

# éå†çš„æ€è·¯
class Solution2:
    def maxDepth(self, root: 'Node') -> int:
        self.traverse(root)
        return self.res

    # è®°å½•é€’å½’éå†åˆ°çš„æ·±åº¦
    def __init__(self):
        self.depth = 0
        # è®°å½•æœ€å¤§çš„æ·±åº¦
        self.res = 0

    def traverse(self, root):
        if not root:
            return
        # å‰åºéå†ä½ç½®
        self.depth += 1
        self.res = max(self.res, self.depth)

        for child in root.children:
            self.traverse(child)
        # ååºéå†ä½ç½®
        self.depth -= 1
```

https://leetcode.cn/problems/maximum-depth-of-n-ary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/maximum-frequency-stack çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class FreqStack {
    // è®°å½• FreqStack ä¸­å…ƒç´ çš„æœ€å¤§é¢‘ç‡
    int maxFreq = 0;
    // è®°å½• FreqStack ä¸­æ¯ä¸ª val å¯¹åº”çš„å‡ºç°é¢‘ç‡ï¼Œåæ–‡å°±ç§°ä¸º VF è¡¨
    unordered_map<int, int> valToFreq;
    // è®°å½•é¢‘ç‡ freq å¯¹åº”çš„ val åˆ—è¡¨ï¼Œåæ–‡å°±ç§°ä¸º FV è¡¨
    unordered_map<int, stack<int>> freqToVals;

public:
    void push(int val) {
        // ä¿®æ”¹ VF è¡¨ï¼šval å¯¹åº”çš„ freq åŠ ä¸€
        int freq = valToFreq[val] + 1;
        valToFreq[val] = freq;
        // ä¿®æ”¹ FV è¡¨ï¼šåœ¨ freq å¯¹åº”çš„åˆ—è¡¨åŠ ä¸Š val
        freqToVals[freq].push(val);
        // æ›´æ–° maxFreq
        maxFreq = max(maxFreq, freq);
    }

    int pop() {
        // ä¿®æ”¹ FV è¡¨ï¼špop å‡ºä¸€ä¸ª maxFreq å¯¹åº”çš„å…ƒç´  v
        stack<int> &vals = freqToVals[maxFreq];
        int v = vals.top(); vals.pop();
        // ä¿®æ”¹ VF è¡¨ï¼šv å¯¹åº”çš„ freq å‡ä¸€
        int freq = --valToFreq[v];
        // æ›´æ–° maxFreq
        if (vals.empty()) {
            // å¦‚æœ maxFreq å¯¹åº”çš„å…ƒç´ ç©ºäº†
            maxFreq--;
        }
        return v;
    }
};
```

```go
// by chatGPT (go)
type FreqStack struct {
    // è®°å½• FreqStack ä¸­å…ƒç´ çš„æœ€å¤§é¢‘ç‡
    maxFreq int
    // è®°å½• FreqStack ä¸­æ¯ä¸ª val å¯¹åº”çš„å‡ºç°é¢‘ç‡ï¼Œåæ–‡å°±ç§°ä¸º VF è¡¨
    valToFreq map[int]int
    // è®°å½•é¢‘ç‡ freq å¯¹åº”çš„ val åˆ—è¡¨ï¼Œåæ–‡å°±ç§°ä¸º FV è¡¨
    freqToVals map[int]*stack.Stack
}

func Constructor() FreqStack {
    return FreqStack{0, make(map[int]int), make(map[int]*stack.Stack)}
}

func (this *FreqStack) Push(val int) {
    // ä¿®æ”¹ VF è¡¨ï¼šval å¯¹åº”çš„ freq åŠ ä¸€
    freq := this.valToFreq[val] + 1
    this.valToFreq[val] = freq
    // ä¿®æ”¹ FV è¡¨ï¼šåœ¨ freq å¯¹åº”çš„åˆ—è¡¨åŠ ä¸Š val
    if this.freqToVals[freq] == nil {
        this.freqToVals[freq] = stack.New()
    }
    this.freqToVals[freq].Push(val)
    // æ›´æ–° maxFreq
    if freq > this.maxFreq {
        this.maxFreq = freq
    }
}

func (this *FreqStack) Pop() int {
    // ä¿®æ”¹ FV è¡¨ï¼špop å‡ºä¸€ä¸ª maxFreq å¯¹åº”çš„å…ƒç´  v
    vals := this.freqToVals[this.maxFreq]
    v := vals.Pop().(int)
    // ä¿®æ”¹ VF è¡¨ï¼šv å¯¹åº”çš„ freq å‡ä¸€
    freq := this.valToFreq[v] - 1
    this.valToFreq[v] = freq
    // æ›´æ–° maxFreq
    if vals.Len() == 0 {
        // å¦‚æœ maxFreq å¯¹åº”çš„å…ƒç´ ç©ºäº†
        this.maxFreq--
    }
    return v
}
```

```java
// by labuladong (java)
class FreqStack {
    // è®°å½• FreqStack ä¸­å…ƒç´ çš„æœ€å¤§é¢‘ç‡
    int maxFreq = 0;
    // è®°å½• FreqStack ä¸­æ¯ä¸ª val å¯¹åº”çš„å‡ºç°é¢‘ç‡ï¼Œåæ–‡å°±ç§°ä¸º VF è¡¨
    HashMap<Integer, Integer> valToFreq = new HashMap<>();
    // è®°å½•é¢‘ç‡ freq å¯¹åº”çš„ val åˆ—è¡¨ï¼Œåæ–‡å°±ç§°ä¸º FV è¡¨
    HashMap<Integer, Stack<Integer>> freqToVals = new HashMap<>();

    public void push(int val) {
        // ä¿®æ”¹ VF è¡¨ï¼šval å¯¹åº”çš„ freq åŠ ä¸€
        int freq = valToFreq.getOrDefault(val, 0) + 1;
        valToFreq.put(val, freq);
        // ä¿®æ”¹ FV è¡¨ï¼šåœ¨ freq å¯¹åº”çš„åˆ—è¡¨åŠ ä¸Š val
        freqToVals.putIfAbsent(freq, new Stack<>());
        freqToVals.get(freq).push(val);
        // æ›´æ–° maxFreq
        maxFreq = Math.max(maxFreq, freq);
    }

    public int pop() {
        // ä¿®æ”¹ FV è¡¨ï¼špop å‡ºä¸€ä¸ª maxFreq å¯¹åº”çš„å…ƒç´  v
        Stack<Integer> vals = freqToVals.get(maxFreq);
        int v = vals.pop();
        // ä¿®æ”¹ VF è¡¨ï¼šv å¯¹åº”çš„ freq å‡ä¸€
        int freq = valToFreq.get(v) - 1;
        valToFreq.put(v, freq);
        // æ›´æ–° maxFreq
        if (vals.isEmpty()) {
            // å¦‚æœ maxFreq å¯¹åº”çš„å…ƒç´ ç©ºäº†
            maxFreq--;
        }
        return v;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} val
 * @return {void}
 */
var FreqStack = function() {
    // è®°å½• FreqStack ä¸­å…ƒç´ çš„æœ€å¤§é¢‘ç‡
    this.maxFreq = 0;
    // è®°å½• FreqStack ä¸­æ¯ä¸ª val å¯¹åº”çš„å‡ºç°é¢‘ç‡ï¼Œåæ–‡å°±ç§°ä¸º VF è¡¨
    this.valToFreq = new Map();
    // è®°å½•é¢‘ç‡ freq å¯¹åº”çš„ val åˆ—è¡¨ï¼Œåæ–‡å°±ç§°ä¸º FV è¡¨
    this.freqToVals = new Map();
};

/**
 * @param {number} val
 * @return {void}
 */
FreqStack.prototype.push = function(val) {
    // ä¿®æ”¹ VF è¡¨ï¼šval å¯¹åº”çš„ freq åŠ ä¸€
    const freq = this.valToFreq.get(val) + 1 || 1;
    this.valToFreq.set(val, freq);
    // ä¿®æ”¹ FV è¡¨ï¼šåœ¨ freq å¯¹åº”çš„åˆ—è¡¨åŠ ä¸Š val
    this.freqToVals.set(freq, this.freqToVals.get(freq) || []);
    this.freqToVals.get(freq).push(val);
    // æ›´æ–° maxFreq
    this.maxFreq = Math.max(this.maxFreq, freq);
};

/**
 * @return {number}
 */
FreqStack.prototype.pop = function() {
    // ä¿®æ”¹ FV è¡¨ï¼špop å‡ºä¸€ä¸ª maxFreq å¯¹åº”çš„å…ƒç´  v
    const vals = this.freqToVals.get(this.maxFreq);
    const v = vals.pop();
    // ä¿®æ”¹ VF è¡¨ï¼šv å¯¹åº”çš„ freq å‡ä¸€
    const freq = this.valToFreq.get(v) - 1;
    this.valToFreq.set(v, freq);
    // æ›´æ–° maxFreq
    if (vals.length === 0) {
        // å¦‚æœ maxFreq å¯¹åº”çš„å…ƒç´ ç©ºäº†
        this.maxFreq--;
    }
    return v;
};
```

```python
# by chatGPT (python)
class FreqStack:
    def __init__(self):
        # è®°å½• FreqStack ä¸­å…ƒç´ çš„æœ€å¤§é¢‘ç‡
        self.maxFreq = 0
        # è®°å½• FreqStack ä¸­æ¯ä¸ª val å¯¹åº”çš„å‡ºç°é¢‘ç‡ï¼Œåæ–‡å°±ç§°ä¸º VF è¡¨
        self.valToFreq = {}
        # è®°å½•é¢‘ç‡ freq å¯¹åº”çš„ val åˆ—è¡¨ï¼Œåæ–‡å°±ç§°ä¸º FV è¡¨
        self.freqToVals = {}

    def push(self, val: int) -> None:
        # ä¿®æ”¹ VF è¡¨ï¼šval å¯¹åº”çš„ freq åŠ ä¸€
        freq = self.valToFreq.get(val, 0) + 1
        self.valToFreq[val] = freq
        # ä¿®æ”¹ FV è¡¨ï¼šåœ¨ freq å¯¹åº”çš„åˆ—è¡¨åŠ ä¸Š val
        self.freqToVals.setdefault(freq, [])
        self.freqToVals[freq].append(val)
        # æ›´æ–° maxFreq
        self.maxFreq = max(self.maxFreq, freq)

    def pop(self) -> int:
        # ä¿®æ”¹ FV è¡¨ï¼špop å‡ºä¸€ä¸ª maxFreq å¯¹åº”çš„å…ƒç´  v
        vals = self.freqToVals[self.maxFreq]
        v = vals.pop()
        # ä¿®æ”¹ VF è¡¨ï¼šv å¯¹åº”çš„ freq å‡ä¸€
        freq = self.valToFreq[v] - 1
        self.valToFreq[v] = freq
        # æ›´æ–° maxFreq
        if not vals:
            # å¦‚æœ maxFreq å¯¹åº”çš„å…ƒç´ ç©ºäº†
            self.maxFreq -= 1
        return v
```

https://leetcode.cn/problems/maximum-frequency-stack çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxSubArrayLen(vector<int>& nums, int k) {
        int n = nums.size();
        // preSum ä¸­çš„å€¼ -> å¯¹åº”çš„æœ€å°ç´¢å¼•
        // æ¯”å¦‚ preSum = [2,4,1,3,4]ï¼ŒpreSumToIndex[4] = 1
        unordered_map<int, int> preSumToIndex;
        int maxLen = 0;
        // å‰ç¼€å’Œæ•°ç»„
        int preSum = 0;
        // base caseï¼Œè¿™æ ·ç´¢å¼•ç›¸å‡çš„æ—¶å€™å¯ä»¥ç®—å‡ºæ­£ç¡®çš„å­æ•°ç»„é•¿åº¦
        preSumToIndex[0] = -1;
        for (int i = 0; i < n; i++) {
            // è®¡ç®—å‰ç¼€å’Œï¼Œç»´æŠ¤ preSum = sum(nums[0..i])
            preSum += nums[i];
            // ç¡®ä¿ preSumToIndex ä¸­è®°å½•çš„ç´¢å¼•æ˜¯ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
            preSumToIndex.emplace(preSum, i);
            int need = preSum - k;
            if (preSumToIndex.contains(need)) {
                int j = preSumToIndex[need];
                // nums[j + 1..i] æ˜¯å’Œä¸º k çš„å­æ•°ç»„
                maxLen = max(maxLen, i - j);
            }
        }
        return maxLen;
    }
};
```

```go
// by chatGPT (go)
// 
// MaxSubArrayLen returns the maximum length of a contiguous subarray with sum equal to k.
func MaxSubArrayLen(nums []int, k int) int {
	n := len(nums)
	// preSum ä¸­çš„å€¼ -> å¯¹åº”çš„æœ€å°ç´¢å¼•
	// æ¯”å¦‚ preSum = [2,4,1,3,4]ï¼ŒpreSumToIndex[4] = 1
	preSumToIndex := make(map[int]int, n)
	maxLen := 0
	// å‰ç¼€å’Œæ•°ç»„ï¼ˆåœ¨è¿™é“é¢˜ä¸­å¯ä»¥ä¼˜åŒ–ä¸ºä¸€ä¸ªå˜é‡ï¼‰
	preSum := 0
	// base caseï¼Œè¿™æ ·ç´¢å¼•ç›¸å‡çš„æ—¶å€™å¯ä»¥ç®—å‡ºæ­£ç¡®çš„å­æ•°ç»„é•¿åº¦
	preSumToIndex[0] = -1
	for i := 0; i < n; i++ {
		// è®¡ç®—å‰ç¼€å’Œï¼Œç»´æŠ¤ preSum = sum(nums[0..i])
		preSum += nums[i]
		// ç¡®ä¿ preSumToIndex ä¸­è®°å½•çš„ç´¢å¼•æ˜¯ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
		if _, ok := preSumToIndex[preSum]; !ok {
			preSumToIndex[preSum] = i
		}
		need := preSum - k
		if j, ok := preSumToIndex[need]; ok {
			// nums[j..i] æ˜¯å’Œä¸º k çš„å­æ•°ç»„
			maxLen = max(maxLen, i-j)
		}
	}
	return maxLen
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

```java
// by labuladong (java)
class Solution {
    public static int maxSubArrayLen(int[] nums, int k) {
        int n = nums.length;
        // preSum ä¸­çš„å€¼ -> å¯¹åº”çš„æœ€å°ç´¢å¼•
        // æ¯”å¦‚ preSum = [2,4,1,3,4]ï¼ŒpreSumToIndex[4] = 1
        HashMap<Integer, Integer> preSumToIndex = new HashMap<>();
        int maxLen = 0;
        // å‰ç¼€å’Œæ•°ç»„ï¼ˆåœ¨è¿™é“é¢˜ä¸­å¯ä»¥ä¼˜åŒ–ä¸ºä¸€ä¸ªå˜é‡ï¼‰
        int preSum = 0;
        // base caseï¼Œè¿™æ ·ç´¢å¼•ç›¸å‡çš„æ—¶å€™å¯ä»¥ç®—å‡ºæ­£ç¡®çš„å­æ•°ç»„é•¿åº¦
        preSumToIndex.put(0, -1);
        for (int i = 0; i < n; i++) {
            // è®¡ç®—å‰ç¼€å’Œï¼Œç»´æŠ¤ preSum = sum(nums[0..i])
            preSum += nums[i];
            // ç¡®ä¿ preSumToIndex ä¸­è®°å½•çš„ç´¢å¼•æ˜¯ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
            preSumToIndex.putIfAbsent(preSum, i);
            int need = preSum[i] - k;
            if (preSumToIndex.containsKey(need)) {
                int j = preSumToIndex.get(need);
                // nums[j..i] æ˜¯å’Œä¸º k çš„å­æ•°ç»„
                maxLen = Math.max(maxLen, i - j);
            }
        }
        return maxLen;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maxSubArrayLen = function(nums, k) {
    let n = nums.length;
    // preSum ä¸­çš„å€¼ -> å¯¹åº”çš„æœ€å°ç´¢å¼•
    // æ¯”å¦‚ preSum = [2,4,1,3,4]ï¼ŒpreSumToIndex[4] = 1
    let preSumToIndex = new Map();
    let maxLen = 0;
    // å‰ç¼€å’Œæ•°ç»„ï¼ˆåœ¨è¿™é“é¢˜ä¸­å¯ä»¥ä¼˜åŒ–ä¸ºä¸€ä¸ªå˜é‡ï¼‰
    let preSum = 0;
    // base caseï¼Œè¿™æ ·ç´¢å¼•ç›¸å‡çš„æ—¶å€™å¯ä»¥ç®—å‡ºæ­£ç¡®çš„å­æ•°ç»„é•¿åº¦
    preSumToIndex.set(0, -1);
    for (let i = 0; i < n; i++) {
        // è®¡ç®—å‰ç¼€å’Œï¼Œç»´æŠ¤ preSum = sum(nums[0..i])
        preSum += nums[i];
        // ç¡®ä¿ preSumToIndex ä¸­è®°å½•çš„ç´¢å¼•æ˜¯ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
        if (!preSumToIndex.has(preSum)) {
            preSumToIndex.set(preSum, i);
        }
        let need = preSum - k;
        if (preSumToIndex.has(need)) {
            let j = preSumToIndex.get(need);
            // nums[j..i] æ˜¯å’Œä¸º k çš„å­æ•°ç»„
            maxLen = Math.max(maxLen, i - j);
        }
    }
    return maxLen;
};
```

```python
# by chatGPT (python)
class Solution:
    def maxSubArrayLen(self, nums: List[int], k: int) -> int:
        n = len(nums)
        # preSum ä¸­çš„å€¼ -> å¯¹åº”çš„æœ€å°ç´¢å¼•
        # æ¯”å¦‚ preSum = [2,4,1,3,4]ï¼ŒpreSumToIndex[4] = 1
        preSumToIndex = {}
        maxLen = 0
        # å‰ç¼€å’Œæ•°ç»„ï¼ˆåœ¨è¿™é“é¢˜ä¸­å¯ä»¥ä¼˜åŒ–ä¸ºä¸€ä¸ªå˜é‡ï¼‰
        preSum = 0
        # base caseï¼Œè¿™æ ·ç´¢å¼•ç›¸å‡çš„æ—¶å€™å¯ä»¥ç®—å‡ºæ­£ç¡®çš„å­æ•°ç»„é•¿åº¦
        preSumToIndex[0] = -1
        for i in range(n):
            # è®¡ç®—å‰ç¼€å’Œï¼Œç»´æŠ¤ preSum = sum(nums[0..i])
            preSum += nums[i]
            # ç¡®ä¿ preSumToIndex ä¸­è®°å½•çš„ç´¢å¼•æ˜¯ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
            preSumToIndex.setdefault(preSum, i)
            need = preSum - k
            if need in preSumToIndex:
                j = preSumToIndex[need]
                # nums[j..i] æ˜¯å’Œä¸º k çš„å­æ•°ç»„
                maxLen = max(maxLen, i - j)
        return maxLen
```

https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/maximum-subarray çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        vector<int> dp(n);
        // base case
        // ç¬¬ä¸€ä¸ªå…ƒç´ å‰é¢æ²¡æœ‰å­æ•°ç»„
        dp[0] = nums[0];
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        for (int i = 1; i < n; i++) {
            dp[i] = max(nums[i], nums[i] + dp[i - 1]);
        }
        // å¾—åˆ° nums çš„æœ€å¤§å­æ•°ç»„
        int res = INT_MIN;
        for (int i = 0; i < n; i++) {
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func maxSubArray(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    dp := make([]int, n)
    // base case
    // ç¬¬ä¸€ä¸ªå…ƒç´ å‰é¢æ²¡æœ‰å­æ•°ç»„
    dp[0] = nums[0]
    // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
    for i := 1; i < n; i++ {
        dp[i] = max(nums[i], nums[i] + dp[i - 1])
    }
    // å¾—åˆ° nums çš„æœ€å¤§å­æ•°ç»„
    res := math.MinInt32
    for i := 0; i < n; i++ {
        res = max(res, dp[i])
    }
    return res
}
   
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        int[] dp = new int[n];
        // base case
        // ç¬¬ä¸€ä¸ªå…ƒç´ å‰é¢æ²¡æœ‰å­æ•°ç»„
        dp[0] = nums[0];
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
        }
        // å¾—åˆ° nums çš„æœ€å¤§å­æ•°ç»„
        int res = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    const n = nums.length;
    if (n === 0) return 0;
    const dp = new Array(n);
    // base case
    // ç¬¬ä¸€ä¸ªå…ƒç´ å‰é¢æ²¡æœ‰å­æ•°ç»„
    dp[0] = nums[0];
    // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
    for (let i = 1; i < n; i++) {
        dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
    }
    // å¾—åˆ° nums çš„æœ€å¤§å­æ•°ç»„
    let res = -Infinity;
    for (let i = 0; i < n; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        dp = [0] * n
        # base case
        # ç¬¬ä¸€ä¸ªå…ƒç´ å‰é¢æ²¡æœ‰å­æ•°ç»„
        dp[0] = nums[0]
        # çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        for i in range(1, n):
            dp[i] = max(nums[i], nums[i] + dp[i - 1])
        # å¾—åˆ° nums çš„æœ€å¤§å­æ•°ç»„
        res = float('-inf')
        for i in range(n):
            res = max(res, dp[i])
        return res
```

https://leetcode.cn/problems/maximum-subarray çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    int maxSum = 0;
public:
    /* ä¸»å‡½æ•° */
    int maxSumBST(TreeNode* root) {
        traverse(root);
        return maxSum;
    }

    vector<int> findMaxMinSum(TreeNode* root) {
        // base case
        if (root == nullptr) {
            return {
                    1, INT_MAX, INT_MIN, 0
            };
        }

        // é€’å½’è®¡ç®—å·¦å³å­æ ‘
        vector<int> left = findMaxMinSum(root->left);
        vector<int> right = findMaxMinSum(root->right);

        /*******ååºéå†ä½ç½®*******/
        vector<int> res(4);
        // è¿™ä¸ª if åœ¨åˆ¤æ–­ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘æ˜¯ä¸æ˜¯ BST
        if (left[0] == 1 && right[0] == 1 &&
                root->val > left[2] && root->val < right[1]) {
            // ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘æ˜¯ BST
            res[0] = 1;
            // è®¡ç®—ä»¥ root ä¸ºæ ¹çš„è¿™æ£µ BST çš„æœ€å°å€¼
            res[1] = min(left[1], root->val);
            // è®¡ç®—ä»¥ root ä¸ºæ ¹çš„è¿™æ£µ BST çš„æœ€å¤§å€¼
            res[2] = max(right[2], root->val);
            // è®¡ç®—ä»¥ root ä¸ºæ ¹çš„è¿™æ£µ BST æ‰€æœ‰èŠ‚ç‚¹ä¹‹å’Œ
            res[3] = left[3] + right[3] + root->val;
            // æ›´æ–°å…¨å±€å˜é‡
            maxSum = max(maxSum, res[3]);
        } else {
            // ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘ä¸æ˜¯ BST
            res[0] = 0;
            // å…¶ä»–çš„å€¼éƒ½æ²¡å¿…è¦è®¡ç®—äº†ï¼Œå› ä¸ºç”¨ä¸åˆ°
        }
        /**************************/

        return res;
    }

    void traverse(TreeNode* root) {
        if(root == nullptr) {
            return;
        }
        vector<int> res = findMaxMinSum(root);
        traverse(root->left);
        traverse(root->right);
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

/* ä¸»å‡½æ•° */
func maxSumBST(root *TreeNode) int {
    // å…¨å±€å˜é‡ï¼Œè®°å½• BST æœ€å¤§èŠ‚ç‚¹ä¹‹å’Œ
    maxSum := 0
    traverse(root, &maxSum)
    return maxSum
}

func findMaxMinSum(root *TreeNode, maxSum *int) []int {
    // base case
    if root == nil {
        return []int{1, math.MaxInt64, math.MinInt64, 0}
    }

    // é€’å½’è®¡ç®—å·¦å³å­æ ‘
    left := findMaxMinSum(root.Left, maxSum)
    right := findMaxMinSum(root.Right, maxSum)

    /*******ååºéå†ä½ç½®*******/
    res := make([]int, 4)
    // è¿™ä¸ª if åœ¨åˆ¤æ–­ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘æ˜¯ä¸æ˜¯ BST
    if left[0] == 1 && right[0] == 1 &&
        root.Val > left[2] && root.Val < right[1] {
        // ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘æ˜¯ BST
        res[0] = 1
        // è®¡ç®—ä»¥ root ä¸ºæ ¹çš„è¿™æ£µ BST çš„æœ€å°å€¼
        res[1] = int(math.Min(float64(left[1]), float64(root.Val)))
        // è®¡ç®—ä»¥ root ä¸ºæ ¹çš„è¿™æ£µ BST çš„æœ€å¤§å€¼
        res[2] = int(math.Max(float64(right[2]), float64(root.Val)))
        // è®¡ç®—ä»¥ root ä¸ºæ ¹çš„è¿™æ£µ BST æ‰€æœ‰èŠ‚ç‚¹ä¹‹å’Œ
        res[3] = left[3] + right[3] + root.Val
        // æ›´æ–°å…¨å±€å˜é‡
        *maxSum = int(math.Max(float64(*maxSum), float64(res[3])))
    } else {
        // ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘ä¸æ˜¯ BST
        res[0] = 0
        // å…¶ä»–çš„å€¼éƒ½æ²¡å¿…è¦è®¡ç®—äº†ï¼Œå› ä¸ºç”¨ä¸åˆ°
    }
    /**************************/

    return res
}

func traverse(root *TreeNode, maxSum *int) {
    if root == nil {
        return
    }

    findMaxMinSum(root, maxSum)
    traverse(root.Left, maxSum)
    traverse(root.Right, maxSum)
}
```

```java
// by labuladong (java)
class Solution {
    // å…¨å±€å˜é‡ï¼Œè®°å½• BST æœ€å¤§èŠ‚ç‚¹ä¹‹å’Œ
    int maxSum = 0;

    /* ä¸»å‡½æ•° */
    public int maxSumBST(TreeNode root) {
        traverse(root);
        return maxSum;
    }

    int[] findMaxMinSum(TreeNode root) {
        // base case
        if (root == null) {
            return new int[] {
                    1, Integer.MAX_VALUE, Integer.MIN_VALUE, 0
            };
        }

        // é€’å½’è®¡ç®—å·¦å³å­æ ‘
        int[] left = findMaxMinSum(root.left);
        int[] right = findMaxMinSum(root.right);

        /*******ååºéå†ä½ç½®*******/
        int[] res = new int[4];
        // è¿™ä¸ª if åœ¨åˆ¤æ–­ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘æ˜¯ä¸æ˜¯ BST
        if (left[0] == 1 && right[0] == 1 &&
                root.val > left[2] && root.val < right[1]) {
            // ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘æ˜¯ BST
            res[0] = 1;
            // è®¡ç®—ä»¥ root ä¸ºæ ¹çš„è¿™æ£µ BST çš„æœ€å°å€¼
            res[1] = Math.min(left[1], root.val);
            // è®¡ç®—ä»¥ root ä¸ºæ ¹çš„è¿™æ£µ BST çš„æœ€å¤§å€¼
            res[2] = Math.max(right[2], root.val);
            // è®¡ç®—ä»¥ root ä¸ºæ ¹çš„è¿™æ£µ BST æ‰€æœ‰èŠ‚ç‚¹ä¹‹å’Œ
            res[3] = left[3] + right[3] + root.val;
            // æ›´æ–°å…¨å±€å˜é‡
            maxSum = Math.max(maxSum, res[3]);
        } else {
            // ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘ä¸æ˜¯ BST
            res[0] = 0;
            // å…¶ä»–çš„å€¼éƒ½æ²¡å¿…è¦è®¡ç®—äº†ï¼Œå› ä¸ºç”¨ä¸åˆ°
        }
        /**************************/

        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var maxSumBST = function(root) {
      
    let maxSum = 0;

    const findMaxMinSum = node => { 
        if (node === null) {
            return [1, Infinity, -Infinity, 0];
        }

        let left = findMaxMinSum(node.left);
        let right = findMaxMinSum(node.right);
        
    /*******ååºéå†ä½ç½®*******/
        let res = new Array(4);
        if (left[0] === 1 && right[0] === 1 && node.val > left[2] && node.val < right[1]) { 
            res[0] = 1;
            res[1] = Math.min(left[1], node.val);
            res[2] = Math.max(right[2], node.val);
            res[3] = left[3] + right[3] + node.val;
            maxSum = Math.max(maxSum, res[3]);
        } else { 
            res[0] = 0;
        }
    /**************************/
        return res;
    }
    findMaxMinSum(root);

    return maxSum;
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        # å…¨å±€å˜é‡ï¼Œè®°å½• BST æœ€å¤§èŠ‚ç‚¹ä¹‹å’Œ
        self.maxSum = 0
    
    def maxSumBST(self, root: TreeNode) -> int:
        self.traverse(root)
        return self.maxSum
    
    def findMaxMinSum(self, root: TreeNode) -> List[int]:
        # base case
        if not root:
            return [1, float('inf'), float('-inf'), 0]
        
        # é€’å½’è®¡ç®—å·¦å³å­æ ‘
        left = self.findMaxMinSum(root.left)
        right = self.findMaxMinSum(root.right)
        
        /*******ååºéå†ä½ç½®*******/
        res = [0] * 4
        # è¿™ä¸ª if åœ¨åˆ¤æ–­ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘æ˜¯ä¸æ˜¯ BST
        if left[0] == 1 and right[0] == 1 and root.val > left[2] and root.val < right[1]:
            # ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘æ˜¯ BST
            res[0] = 1
            # è®¡ç®—ä»¥ root ä¸ºæ ¹çš„è¿™æ£µ BST çš„æœ€å°å€¼
            res[1] = min(left[1], root.val)
            # è®¡ç®—ä»¥ root ä¸ºæ ¹çš„è¿™æ£µ BST çš„æœ€å¤§å€¼
            res[2] = max(right[2], root.val)
            # è®¡ç®—ä»¥ root ä¸ºæ ¹çš„è¿™æ£µ BST æ‰€æœ‰èŠ‚ç‚¹ä¹‹å’Œ
            res[3] = left[3] + right[3] + root.val
            # æ›´æ–°å…¨å±€å˜é‡
            self.maxSum = max(self.maxSum, res[3])
        else:
            # ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘ä¸æ˜¯ BST
            res[0] = 0
            # å…¶ä»–çš„å€¼éƒ½æ²¡å¿…è¦è®¡ç®—äº†ï¼Œå› ä¸ºç”¨ä¸åˆ°
        /**************************/
        return res
```

https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/merge-intervals çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        // æŒ‰åŒºé—´çš„ start å‡åºæ’åˆ—
        sort(intervals.begin(), intervals.end(), [](auto& a, auto& b){
            return a[0] < b[0];
        });

        res.push_back(intervals[0]);
        for (int i = 1; i < intervals.size(); i++) {
            auto& curr = intervals[i];
            // res ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨
            auto& last = res.back();
            if (curr[0] <= last[1]) {
                last[1] = max(last[1], curr[1]);
            } else {
                // å¤„ç†ä¸‹ä¸€ä¸ªå¾…åˆå¹¶åŒºé—´
                res.push_back(curr);
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func merge(intervals [][]int) [][]int {
    res := [][]int{}
    // æŒ‰åŒºé—´çš„ start å‡åºæ’åˆ—
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    res = append(res, intervals[0])
    for i := 1; i < len(intervals); i++ {
        curr := intervals[i]
        // res ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨
        last := res[len(res) - 1]
        if curr[0] <= last[1] {
            last[1] = max(last[1], curr[1])
        } else {
            // å¤„ç†ä¸‹ä¸€ä¸ªå¾…åˆå¹¶åŒºé—´
            res = append(res, curr)
        }
    }
    return res
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {
    public int[][] merge(int[][] intervals) {
        LinkedList<int[]> res = new LinkedList<>();
        // æŒ‰åŒºé—´çš„ start å‡åºæ’åˆ—
        Arrays.sort(intervals, (a, b) -> {
            return a[0] - b[0];
        });

        res.add(intervals[0]);
        for (int i = 1; i < intervals.length; i++) {
            int[] curr = intervals[i];
            // res ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨
            int[] last = res.getLast();
            if (curr[0] <= last[1]) {
                last[1] = Math.max(last[1], curr[1]);
            } else {
                // å¤„ç†ä¸‹ä¸€ä¸ªå¾…åˆå¹¶åŒºé—´
                res.add(curr);
            }
        }
        return res.toArray(new int[0][0]);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    const res = [];
    // æŒ‰åŒºé—´çš„ start å‡åºæ’åˆ—
    intervals.sort((a, b) => {
        return a[0] - b[0];
    });

    res.push(intervals[0]);
    for (let i = 1; i < intervals.length; i++) {
        const curr = intervals[i];
        // res ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨
        const last = res[res.length - 1];
        if (curr[0] <= last[1]) {
            last[1] = Math.max(last[1], curr[1]);
        } else {
            // å¤„ç†ä¸‹ä¸€ä¸ªå¾…åˆå¹¶åŒºé—´
            res.push(curr);
        }
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        res = []
        # æŒ‰åŒºé—´çš„ start å‡åºæ’åˆ—
        intervals.sort(key=lambda a: a[0])

        res.append(intervals[0])
        for curr in intervals[1:]:
            # res ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨
            last = res[-1]
            if curr[0] <= last[1]:
                last[1] = max(last[1], curr[1])
            else:
                # å¤„ç†ä¸‹ä¸€ä¸ªå¾…åˆå¹¶åŒºé—´
                res.append(curr)
        return res
```

https://leetcode.cn/problems/merge-intervals çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/merge-k-sorted-lists çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int size = lists.size();
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy;
        // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å †
        priority_queue<ListNode*, vector<ListNode*>, compare > pq;
        // å°† k ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥æœ€å°å †
        for (auto head : lists) {
            if (head) pq.push(head);
        }

        while (!pq.empty()) {
            // è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­
            auto node = pq.top();
            pq.pop();
            p->next = node;
            if (node->next) {
                pq.push(node->next);
            }
            // p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p->next;
        }
        return dummy->next;
    }
private:
    // è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°
    struct compare {
        bool operator() (ListNode* a, ListNode* b) {
            return a->val > b->val;
        }
    };
};
```

```go
// by chatGPT (go)
//Definition for singly-linked list.

func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    // è™šæ‹Ÿå¤´èŠ‚ç‚¹
    dummy := &ListNode{Val: -1}
    p := dummy
    // ä¼˜å…ˆé˜Ÿåˆ—,æœ€å°å †, ç”¨golangçš„heap
    pq := make(Queue, len(lists))
    for i, head := range lists {
        if head != nil {
            pq[i] = head
        }
    }
    heap.Init(&pq)

    for pq.Len() != 0 {
        // è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­
        node := heap.Pop(&pq).(*ListNode)
        p.Next = node
        if node.Next != nil {
            heap.Push(&pq, node.Next)
        }
        // p æŒ‡é’ˆä¸æ–­å‰è¿›
        p = p.Next
    }
    return dummy.Next
}

// golangçš„å †æ’åºQueue
type Queue []*ListNode

func (q Queue) Len() int { return len(q) }

func (q Queue) Less(i, j int) bool {
    return q[i].Val < q[j].Val
}

func (q Queue) Swap(i, j int) {
    q[i], q[j] = q[j], q[i]
}

func (q *Queue) Push(x interface{}) {
    *q = append(*q, x.(*ListNode))
}

func (q *Queue) Pop() interface{} {
    old := *q
    n := len(old)
    x := old[n-1]
    *q = old[:n-1]
    return x
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å †
        PriorityQueue<ListNode> pq = new PriorityQueue<>(
            lists.length, (a, b)->(a.val - b.val));
        // å°† k ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥æœ€å°å †
        for (ListNode head : lists) {
            if (head != null)
                pq.add(head);
        }

        while (!pq.isEmpty()) {
            // è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­
            ListNode node = pq.poll();
            p.next = node;
            if (node.next != null) {
                pq.add(node.next);
            }
            // p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p.next;
        }
        return dummy.next;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
* @param {ListNode[]} lists
* @return {ListNode}
*/
var mergeKLists = function(lists) {
    if (lists.length == 0) return null;
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    let dummy = new ListNode(-1);
    let p = dummy;
    // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å †
    let pq = new PriorityQueue({
        compare: (a, b) => (a.val - b.val)
    });
    // å°† k ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥æœ€å°å †
    for (let head of lists) {
        if (head != null)
            pq.enqueue(head);
    }

    while (!pq.isEmpty()) {
        // è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­
        let node = pq.dequeue();
        p.next = node;
        if (node.next != null) {
            pq.enqueue(node.next);
        }
        // p æŒ‡é’ˆä¸æ–­å‰è¿›
        p = p.next;
    }
    return dummy.next;
};
```

```python
# by chatGPT (python)
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists:
            return None
        # è™šæ‹Ÿå¤´ç»“ç‚¹
        dummy = ListNode(-1)
        p = dummy
        # ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å †
        pq = []
        for head in lists:
            if head:
                heapq.heappush(pq, (head.val, id(head), head))
        # å°† k ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥æœ€å°å †
        while pq:
            # è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­
            node = heapq.heappop(pq)[2]
            p.next = node
            if node.next:
                heapq.heappush(pq, (node.next.val, id(node.next), node.next))
            # p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p.next
        return dummy.next
```

https://leetcode.cn/problems/merge-k-sorted-lists çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/merge-sorted-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        // ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«åˆå§‹åŒ–åœ¨ä¸¤ä¸ªæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼ˆç±»ä¼¼æ‹‰é“¾ä¸¤ç«¯çš„é”¯é½¿ï¼‰
        int i = m - 1, j = n - 1;
        // ç”Ÿæˆæ’åºçš„ç»“æœï¼ˆç±»ä¼¼æ‹‰é“¾çš„æ‹‰é”ï¼‰
        int p = nums1.size() - 1;
        // ä»åå‘å‰ç”Ÿæˆç»“æœæ•°ç»„ï¼Œç±»ä¼¼åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[p] = nums1[i];
                i--;
            } else {
                nums1[p] = nums2[j];
                j--;
            }
            p--;
        }
        // å¯èƒ½å…¶ä¸­ä¸€ä¸ªæ•°ç»„çš„æŒ‡é’ˆèµ°åˆ°å°½å¤´äº†ï¼Œè€Œå¦ä¸€ä¸ªè¿˜æ²¡èµ°å®Œ
        // å› ä¸ºæˆ‘ä»¬æœ¬èº«å°±æ˜¯åœ¨å¾€ nums1 ä¸­æ”¾å…ƒç´ ï¼Œæ‰€ä»¥åªéœ€è€ƒè™‘ nums2 æ˜¯å¦å‰©å…ƒç´ å³å¯
        while (j >= 0) {
            nums1[p] = nums2[j];
            j--;
            p--;
        }
    }
};
```

```go
// by chatGPT (go)
func merge(nums1 []int, m int, nums2 []int, n int)  {
    i, j, p := m-1, n-1, len(nums1)-1 // åˆå§‹åŒ–æŒ‡é’ˆ
    for i >= 0 && j >= 0 { // ä¸¤ä¸ªæ•°ç»„éƒ½æœªéå†å®Œæ—¶è¿›è¡Œæ¯”è¾ƒ
        if nums1[i] > nums2[j] { // æŒ‘é€‰å¤§çš„å…ƒç´ æ”¾å…¥ nums1 çš„æœ«ä½
            nums1[p] = nums1[i]
            i--
        } else {
            nums1[p] = nums2[j]
            j--
        }
        p-- // ä»åå¾€å‰ç”Ÿæˆç»“æœ
    }
    for j >= 0 { // nums2 å‰©ä½™å…ƒç´ æ”¾å…¥ nums1
        nums1[p] = nums2[j]
        j--
        p--
    }
}
```

```java
// by labuladong (java)
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«åˆå§‹åŒ–åœ¨ä¸¤ä¸ªæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼ˆç±»ä¼¼æ‹‰é“¾ä¸¤ç«¯çš„é”¯é½¿ï¼‰
        int i = m - 1, j = n - 1;
        // ç”Ÿæˆæ’åºçš„ç»“æœï¼ˆç±»ä¼¼æ‹‰é“¾çš„æ‹‰é”ï¼‰
        int p = nums1.length - 1;
        // ä»åå‘å‰ç”Ÿæˆç»“æœæ•°ç»„ï¼Œç±»ä¼¼åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[p] = nums1[i];
                i--;
            } else {
                nums1[p] = nums2[j];
                j--;
            }
            p--;
        }
        // å¯èƒ½å…¶ä¸­ä¸€ä¸ªæ•°ç»„çš„æŒ‡é’ˆèµ°åˆ°å°½å¤´äº†ï¼Œè€Œå¦ä¸€ä¸ªè¿˜æ²¡èµ°å®Œ
        // å› ä¸ºæˆ‘ä»¬æœ¬èº«å°±æ˜¯åœ¨å¾€ nums1 ä¸­æ”¾å…ƒç´ ï¼Œæ‰€ä»¥åªéœ€è€ƒè™‘ nums2 æ˜¯å¦å‰©å…ƒç´ å³å¯
        while (j >= 0) {
            nums1[p] = nums2[j];
            j--;
            p--;
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var merge = function(nums1, m, nums2, n) {
    // ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«åˆå§‹åŒ–åœ¨ä¸¤ä¸ªæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼ˆç±»ä¼¼æ‹‰é“¾ä¸¤ç«¯çš„é”¯é½¿ï¼‰
    var i = m - 1, j = n - 1;
    // ç”Ÿæˆæ’åºçš„ç»“æœï¼ˆç±»ä¼¼æ‹‰é“¾çš„æ‹‰é”ï¼‰
    var p = nums1.length - 1;
    // ä»åå‘å‰ç”Ÿæˆç»“æœæ•°ç»„ï¼Œç±»ä¼¼åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[p] = nums1[i];
            i--;
        } else {
            nums1[p] = nums2[j];
            j--;
        }
        p--;
    }
    // å¯èƒ½å…¶ä¸­ä¸€ä¸ªæ•°ç»„çš„æŒ‡é’ˆèµ°åˆ°å°½å¤´äº†ï¼Œè€Œå¦ä¸€ä¸ªè¿˜æ²¡èµ°å®Œ
    // å› ä¸ºæˆ‘ä»¬æœ¬èº«å°±æ˜¯åœ¨å¾€ nums1 ä¸­æ”¾å…ƒç´ ï¼Œæ‰€ä»¥åªéœ€è€ƒè™‘ nums2 æ˜¯å¦å‰©å…ƒç´ å³å¯
    while (j >= 0) {
        nums1[p] = nums2[j];
        j--;
        p--;
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«åˆå§‹åŒ–åœ¨ä¸¤ä¸ªæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼ˆç±»ä¼¼æ‹‰é“¾ä¸¤ç«¯çš„é”¯é½¿ï¼‰
        i, j = m - 1, n - 1
        # ç”Ÿæˆæ’åºçš„ç»“æœï¼ˆç±»ä¼¼æ‹‰é“¾çš„æ‹‰é”ï¼‰
        p = len(nums1) - 1
        # ä»åå‘å‰ç”Ÿæˆç»“æœæ•°ç»„ï¼Œç±»ä¼¼åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[p] = nums1[i]
                i -= 1
            else:
                nums1[p] = nums2[j]
                j -= 1
            p -= 1
        # å¯èƒ½å…¶ä¸­ä¸€ä¸ªæ•°ç»„çš„æŒ‡é’ˆèµ°åˆ°å°½å¤´äº†ï¼Œè€Œå¦ä¸€ä¸ªè¿˜æ²¡èµ°å®Œ
        # å› ä¸ºæˆ‘ä»¬æœ¬èº«å°±æ˜¯åœ¨å¾€ nums1 ä¸­æ”¾å…ƒç´ ï¼Œæ‰€ä»¥åªéœ€è€ƒè™‘ nums2 æ˜¯å¦å‰©å…ƒç´ å³å¯
        while j >= 0:
            nums1[p] = nums2[j]
            j -= 1
            p -= 1
```

https://leetcode.cn/problems/merge-sorted-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/merge-two-sorted-lists çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode* dummy = new ListNode(-1), *p = dummy;
        ListNode* p1 = l1, *p2 = l2;

        while (p1 != nullptr && p2 != nullptr) {
            /**<extend down -200>
            ![](../pictures/é“¾è¡¨æŠ€å·§/1.gif)
            */
            // æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ
            // å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ
            if (p1->val > p2->val) {
                p->next = p2;
                p2 = p2->next;
            } else {
                p->next = p1;
                p1 = p1->next;
            }
            // p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p->next;
        }

        if (p1 != nullptr) {
            p->next = p1;
        }

        if (p2 != nullptr) {
            p->next = p2;
        }

        return dummy->next;
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    dummy := &ListNode{-1, nil}
    p := dummy
    p1 := l1
    p2 := l2

    for p1 != nil && p2 != nil {
        /**<extend down -200>
        ![](../pictures/é“¾è¡¨æŠ€å·§/1.gif)
        */
        // æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ
        // å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ
        if p1.Val > p2.Val {
            p.Next = p2
            p2 = p2.Next
        } else {
            p.Next = p1
            p1 = p1.Next
        }
        // p æŒ‡é’ˆä¸æ–­å‰è¿›
        p = p.Next
    }

    if p1 != nil {
        p.Next = p1
    }

    if p2 != nil {
        p.Next = p2
    }

    return dummy.Next
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode dummy = new ListNode(-1), p = dummy;
        ListNode p1 = l1, p2 = l2;

        while (p1 != null && p2 != null) {
            /**<extend down -200>
            ![](../pictures/é“¾è¡¨æŠ€å·§/1.gif)
            */
            // æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ
            // å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ
            if (p1.val > p2.val) {
                p.next = p2;
                p2 = p2.next;
            } else {
                p.next = p1;
                p1 = p1.next;
            }
            // p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p.next;
        }

        if (p1 != null) {
            p.next = p1;
        }

        if (p2 != null) {
            p.next = p2;
        }

        return dummy.next;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    var dummy = new ListNode(-1), p = dummy;
    var p1 = l1, p2 = l2;

    while (p1 !== null && p2 !== null) {
        /**<extend down -200>
        ![](../pictures/é“¾è¡¨æŠ€å·§/1.gif)
        */
        // æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ
        // å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ
        if (p1.val > p2.val) {
            p.next = p2;
            p2 = p2.next;
        } else {
            p.next = p1;
            p1 = p1.next;
        }
        // p æŒ‡é’ˆä¸æ–­å‰è¿›
        p = p.next;
    }

    if (p1 !== null) {
        p.next = p1;
    }

    if (p2 !== null) {
        p.next = p2;
    }

    return dummy.next;
};
```

```python
# by chatGPT (python)
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        # è™šæ‹Ÿå¤´ç»“ç‚¹
        dummy = ListNode(-1)
        p = dummy
        p1 = l1
        p2 = l2

        while p1 and p2:
            """
            <extend down -200>
            ![](../pictures/é“¾è¡¨æŠ€å·§/1.gif)
            """
            # æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ
            # å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ
            if p1.val > p2.val:
                p.next = p2
                p2 = p2.next
            else:
                p.next = p1
                p1 = p1.next
            # p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p.next

        if p1:
            p.next = p1

        if p2:
            p.next = p2

        return dummy.next
```

https://leetcode.cn/problems/merge-two-sorted-lists çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/middle-of-the-linked-list çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        // å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
        ListNode* slow = head;
        ListNode* fast = head;
        // å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢
        while (fast != nullptr && fast->next != nullptr) {
            // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
            slow = slow->next;
            fast = fast->next->next;
        }
        // æ…¢æŒ‡é’ˆæŒ‡å‘ä¸­ç‚¹
        return slow;
    }
};
```

```go
// by chatGPT (go)
func middleNode(head *ListNode) *ListNode {
    // å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
    slow, fast := head, head
    // å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢
    for fast != nil && fast.Next != nil {
        // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
        slow = slow.Next
        fast = fast.Next.Next
    }
    // æ…¢æŒ‡é’ˆæŒ‡å‘ä¸­ç‚¹
    return slow
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode middleNode(ListNode head) {
        // å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
        ListNode slow = head, fast = head;
        // å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢
        while (fast != null && fast.next != null) {
            // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
            slow = slow.next;
            fast = fast.next.next;
        }
        // æ…¢æŒ‡é’ˆæŒ‡å‘ä¸­ç‚¹
        return slow;
    }
}
```

```javascript
// by chatGPT (javascript)
var middleNode = function(head) {
  // å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
  let slow = head, fast = head;
  // å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢
  while (fast != null && fast.next != null) {
    // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
    slow = slow.next;
    fast = fast.next.next;
  }
  // æ…¢æŒ‡é’ˆæŒ‡å‘ä¸­ç‚¹
  return slow;
};
```

```python
# by chatGPT (python)
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        # å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
        slow = fast = head
        # å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢
        while fast and fast.next:
            # æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
            slow = slow.next
            fast = fast.next.next
        # æ…¢æŒ‡é’ˆæŒ‡å‘ä¸­ç‚¹
        return slow
```

https://leetcode.cn/problems/middle-of-the-linked-list çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/min-cost-to-connect-all-points çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class UF {
public:
    // è¿é€šåˆ†é‡ä¸ªæ•°
    int count;
    // å­˜å‚¨ä¸€æ£µæ ‘
    vector<int> parent;
    // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
    vector<int> size;

    // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
    UF(int n) {
        this->count = n;
        parent.resize(n);
        size.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    void unionn(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        count--;
    }

    // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    // è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
    int find(int x) {
        while (parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    // è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
    int getCount() {
        return this->count;
    }
};

class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        int n = points.size();
        // ç”Ÿæˆæ‰€æœ‰è¾¹åŠæƒé‡
        vector<vector<int>> edges;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int xi = points[i][0], yi = points[i][1];
                int xj = points[j][0], yj = points[j][1];
                // ç”¨åæ ‡ç‚¹åœ¨ points ä¸­çš„ç´¢å¼•è¡¨ç¤ºåæ ‡ç‚¹
                edges.push_back({i, j, abs(xi - xj) + abs(yi - yj)});
            }
        }
        // å°†è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
        sort(edges.begin(), edges.end(), [](auto& a, auto& b){
            return a[2] < b[2];
        });
        // æ‰§è¡Œ Kruskal ç®—æ³•
        int mst = 0;
        UF uf(n);
        for (auto& edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];
            // è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
            if (uf.connected(u, v)) {
                continue;
            }
            // è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
            mst += weight;
            uf.unionn(u, v);
        }
        return mst;
    }
};
```

```go
// by chatGPT (go)
func minCostConnectPoints(points [][]int) int {
    n := len(points)
    // ç”Ÿæˆæ‰€æœ‰è¾¹åŠæƒé‡
    edges := make([][]int, 0)
    for i := 0; i < n; i++ {
        for j := i + 1; j < n; j++ {
            xi, yi := points[i][0], points[i][1]
            xj, yj := points[j][0], points[j][1]
            // ç”¨åæ ‡ç‚¹åœ¨ points ä¸­çš„ç´¢å¼•è¡¨ç¤ºåæ ‡ç‚¹
            edges = append(edges, []int{i, j, abs(xi - xj) + abs(yi - yj)})
        }
    }
    // å°†è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
    sort.Slice(edges, func(i, j int) bool {
        return edges[i][2] < edges[j][2]
    })
    // æ‰§è¡Œ Kruskal ç®—æ³•
    mst := 0
    uf := NewUF(n)
    for _, edge := range edges {
        u, v, weight := edge[0], edge[1], edge[2]
        // è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
        if uf.connected(u, v) {
            continue
        }
        // è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
        mst += weight
        uf.union(u, v)
    }
    return mst
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}

type UF struct {
    // è¿é€šåˆ†é‡ä¸ªæ•°
    count int
    // å­˜å‚¨ä¸€æ£µæ ‘
    parent []int
    // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
    size []int
}

// NewUF returns a new UF with n nodes
func NewUF(n int) *UF {
    uf := &UF{}
    uf.count = n
    uf.parent = make([]int, n)
    uf.size = make([]int, n)
    for i := 0; i < n; i++ {
        uf.parent[i] = i
        uf.size[i] = 1
    }
    return uf
}

func (uf *UF) union(p, q int) {
    rootP := uf.find(p)
    rootQ := uf.find(q)
    if rootP == rootQ {
        return
    }
    // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
    if uf.size[rootP] > uf.size[rootQ] {
        uf.parent[rootQ] = rootP
        uf.size[rootP] += uf.size[rootQ]
    } else {
        uf.parent[rootP] = rootQ
        uf.size[rootQ] += uf.size[rootP]
    }
    // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
    uf.count--
}

func (uf *UF) connected(p, q int) bool {
    rootP := uf.find(p)
    rootQ := uf.find(q)
    return rootP == rootQ
}

func (uf *UF) find(x int) int {
    for uf.parent[x] != x {
        // è¿›è¡Œè·¯å¾„å‹ç¼©
        uf.parent[x], x = uf.parent[uf.parent[x]], uf.parent[uf.parent[x]]
    }
    return x
}

func (uf *UF) Count() int {
    return uf.count
}
```

```java
// by labuladong (java)
class Solution {
    public int minCostConnectPoints(int[][] points) {
        int n = points.length;
        // ç”Ÿæˆæ‰€æœ‰è¾¹åŠæƒé‡
        List<int[]> edges = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int xi = points[i][0], yi = points[i][1];
                int xj = points[j][0], yj = points[j][1];
                // ç”¨åæ ‡ç‚¹åœ¨ points ä¸­çš„ç´¢å¼•è¡¨ç¤ºåæ ‡ç‚¹
                edges.add(new int[]{
                        i, j, Math.abs(xi - xj) + Math.abs(yi - yj)
                });
            }
        }
        // å°†è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
        Collections.sort(edges, (a, b) -> {
            return a[2] - b[2];
        });
        // æ‰§è¡Œ Kruskal ç®—æ³•
        int mst = 0;
        UF uf = new UF(n);
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];
            // è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
            if (uf.connected(u, v)) {
                continue;
            }
            // è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
            mst += weight;
            uf.union(u, v);
        }
        return mst;
    }

    class UF {
        // è¿é€šåˆ†é‡ä¸ªæ•°
        private int count;
        // å­˜å‚¨ä¸€æ£µæ ‘
        private int[] parent;
        // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
        private int[] size;

        // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
        public UF(int n) {
            this.count = n;
            parent = new int[n];
            size = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }

        // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
        public void union(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ)
                return;

            // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
            if (size[rootP] > size[rootQ]) {
                parent[rootQ] = rootP;
                size[rootP] += size[rootQ];
            } else {
                parent[rootP] = rootQ;
                size[rootQ] += size[rootP];
            }
            // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
            count--;
        }

        // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
        public boolean connected(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            return rootP == rootQ;
        }

        // è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
        private int find(int x) {
            while (parent[x] != x) {
                // è¿›è¡Œè·¯å¾„å‹ç¼©
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }

        // è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
        public int count() {
            return count;
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var minCostConnectPoints = function(points) {
    const n = points.length;
    // ç”Ÿæˆæ‰€æœ‰è¾¹åŠæƒé‡
    let edges = [];
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const xi = points[i][0], yi = points[i][1];
            const xj = points[j][0], yj = points[j][1];
            // ç”¨åæ ‡ç‚¹åœ¨ points ä¸­çš„ç´¢å¼•è¡¨ç¤ºåæ ‡ç‚¹
            edges.push([i, j, Math.abs(xi - xj) + Math.abs(yi - yj)]);
        }
    }
    // å°†è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
    edges.sort((a, b) => {
        return a[2] - b[2];
    });
    // æ‰§è¡Œ Kruskal ç®—æ³•
    let mst = 0;
    const uf = new UF(n);
    for (let i = 0; i < edges.length; i++) {
        const u = edges[i][0];
        const v = edges[i][1];
        const weight = edges[i][2];
        // è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
        if (uf.connected(u, v)) {
            continue;
        }
        // è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
        mst += weight;
        uf.union(u, v);
    }
    return mst;
};

class UF {
    // è¿é€šåˆ†é‡ä¸ªæ•°
    count = 0;
    // å­˜å‚¨ä¸€æ£µæ ‘
    parent = [];
    // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
    size = [];

    // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
    constructor(n) {
        this.count = n;
        this.parent = new Array(n).fill(0).map((_, index) => index);
        this.size = new Array(n).fill(1);
    }

    // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    union(p, q) {
        let rootP = this.find(p);
        let rootQ = this.find(q);
        if (rootP == rootQ)
            return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (this.size[rootP] > this.size[rootQ]) {
            this.parent[rootQ] = rootP;
            this.size[rootP] += this.size[rootQ];
        } else {
            this.parent[rootP] = rootQ;
            this.size[rootQ] += this.size[rootP];
        }
        // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        this.count--;
    }

    // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    connected(p, q) {
        let rootP = this.find(p);
        let rootQ = this.find(q);
        return rootP == rootQ;
    }

    // è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
    find(x) {
        while (this.parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            this.parent[x] = this.parent[this.parent[x]];
            x = this.parent[x];
        }
        return x;
    }

    // è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
    count() {
        return this.count;
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        # ç”Ÿæˆæ‰€æœ‰è¾¹åŠæƒé‡
        edges = []
        for i in range(n):
            for j in range(i + 1, n):
                xi, yi = points[i][0], points[i][1]
                xj, yj = points[j][0], points[j][1]
                # ç”¨åæ ‡ç‚¹åœ¨ points ä¸­çš„ç´¢å¼•è¡¨ç¤ºåæ ‡ç‚¹
                edges.append([i, j, abs(xi - xj) + abs(yi - yj)])
        # å°†è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
        edges.sort(key=lambda x: x[2])
        # æ‰§è¡Œ Kruskal ç®—æ³•
        mst = 0
        uf = UF(n)
        for edge in edges:
            u = edge[0]
            v = edge[1]
            weight = edge[2]
            # è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
            if uf.connected(u, v):
                continue
            # è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
            mst += weight
            uf.union(u, v)
        return mst

class UF:
    # è¿é€šåˆ†é‡ä¸ªæ•°
    count = 0
    # å­˜å‚¨ä¸€æ£µæ ‘
    parent = []
    # è®°å½•æ ‘çš„ã€Œé‡é‡ã€
    size = []

    def __init__(self, n: int):
        # n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
        self.count = n
        self.parent = [i for i in range(n)]
        self.size = [1] * n

    # å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    def union(self, p: int, q: int) -> None:
        root_p = self.find(p)
        root_q = self.find(q)
        if root_p == root_q:
            return

        # å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if self.size[root_p] > self.size[root_q]:
            self.parent[root_q] = root_p
            self.size[root_p] += self.size[root_q]
        else:
            self.parent[root_p] = root_q
            self.size[root_q] += self.size[root_p]

        # ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        self.count -= 1

    # åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    def connected(self, p: int, q: int) -> bool:
        root_p = self.find(p)
        root_q = self.find(q)
        return root_p == root_q

    # è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
    def find(self, x: int) -> int:
        while self.parent[x] != x:
            # è¿›è¡Œè·¯å¾„å‹ç¼©
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    # è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
    def count(self) -> int:
        return self.count
```

https://leetcode.cn/problems/min-cost-to-connect-all-points çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/min-stack çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class MinStack {
    // è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    stack<int> stk;
    // é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
    stack<int> minStk;

public:
    void push(int val) {
        stk.push(val);
        // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        if (minStk.empty() || val <= minStk.top()) {
            // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
            minStk.push(val);
        }
    }

    void pop() {
        // å¼¹å‡ºçš„å…ƒç´ æ˜¯å…¨æ ˆæœ€å°çš„
        if (stk.top() == minStk.top()) {
            minStk.pop();
        }
        stk.pop();
    }

    int top() {
        return stk.top();
    }

    int getMin() {
        // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        return minStk.top();
    }
};
```

```go
// by chatGPT (go)
// åŸå§‹æ€è·¯
type MinStack1 struct {
    // è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    stk     []int
    // é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
    minStk  []int
}

/** initialize your data structure here. */
func Constructor1() MinStack1 {
    return MinStack1{}
}

func (this *MinStack1) Push(val int)  {
    this.stk = append(this.stk, val)
    // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    if len(this.minStk) == 0 || val <= this.minStk[len(this.minStk)-1] {
        // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
        this.minStk = append(this.minStk, val)
    } else {
        // æ’å…¥çš„è¿™ä¸ªå…ƒç´ æ¯”è¾ƒå¤§
        this.minStk = append(this.minStk, this.minStk[len(this.minStk)-1])
    }
}

func (this *MinStack1) Pop()  {
    this.stk = this.stk[:len(this.stk)-1]
    this.minStk = this.minStk[:len(this.minStk)-1]
}

func (this *MinStack1) Top() int {
    return this.stk[len(this.stk)-1]
}

func (this *MinStack1) GetMin() int {
    // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    return this.minStk[len(this.minStk)-1]
}

// ä¼˜åŒ–ç‰ˆ
type MinStack struct {
    // è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    stk     []int
    // é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
    minStk  []int
}

/** initialize your data structure here. */
func Constructor() MinStack {
    return MinStack{}
}

func (this *MinStack) Push(val int)  {
    this.stk = append(this.stk, val)
    // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    if len(this.minStk) == 0 || val <= this.minStk[len(this.minStk)-1] {
        // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
        this.minStk = append(this.minStk, val)
    }
}

func (this *MinStack) Pop()  {
    // æ³¨æ„ Go è¯­è¨€çš„è¯­è¨€ç‰¹æ€§ï¼Œæ¯”è¾ƒ int ç›¸ç­‰ç›´æ¥ç”¨ ==
    if this.stk[len(this.stk)-1] == this.minStk[len(this.minStk)-1] {
        // å¼¹å‡ºçš„å…ƒç´ æ˜¯å…¨æ ˆæœ€å°çš„
        this.minStk = this.minStk[:len(this.minStk)-1]
    }
    this.stk = this.stk[:len(this.stk)-1]
}

func (this *MinStack) Top() int {
    return this.stk[len(this.stk)-1]
}

func (this *MinStack) GetMin() int {
    // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    return this.minStk[len(this.minStk)-1]
}
```

```java
// by labuladong (java)
// åŸå§‹æ€è·¯
class MinStack1 {
    // è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    Stack<Integer> stk = new Stack<>();
    // é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
    Stack<Integer> minStk = new Stack<>();

    public void push(int val) {
        stk.push(val);
        // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        if (minStk.isEmpty() || val <= minStk.peek()) {
            // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
            minStk.push(val);
        } else {
            // æ’å…¥çš„è¿™ä¸ªå…ƒç´ æ¯”è¾ƒå¤§
            minStk.push(minStk.peek());
        }
    }
    
    public void pop() {
        stk.pop();
        minStk.pop();
    }
    
    public int top() {
        return stk.peek();
    }
    
    public int getMin() {
        // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        return minStk.peek();
    }
}
// ä¼˜åŒ–ç‰ˆ
class MinStack {
    // è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    Stack<Integer> stk = new Stack<>();
    // é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
    Stack<Integer> minStk = new Stack<>();

    public void push(int val) {
        stk.push(val);
        // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        if (minStk.isEmpty() || val <= minStk.peek()) {
            // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
            minStk.push(val);
        }
    }

    public void pop() {
        // æ³¨æ„ Java çš„è¯­è¨€ç‰¹æ€§ï¼Œæ¯”è¾ƒ Integer ç›¸ç­‰è¦ç”¨ equals æ–¹æ³•
        if (stk.peek().equals(minStk.peek())) {
            // å¼¹å‡ºçš„å…ƒç´ æ˜¯å…¨æ ˆæœ€å°çš„
            minStk.pop();
        }
        stk.pop();
    }

    public int top() {
        return stk.peek();
    }

    public int getMin() {
        // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        return minStk.peek();
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * initialize your data structure here.
 */
var MinStack = function() {
    // è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    this.stk = [];
    // é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
    this.minStk = [];
};

/** 
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function(val) {
    this.stk.push(val);
    // ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    if (this.minStk.length == 0 || val <= this.minStk[this.minStk.length - 1]) {
        // æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
        this.minStk.push(val);
    }
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    // æ³¨æ„ JavaScript çš„è¯­è¨€ç‰¹æ€§ï¼Œæ¯”è¾ƒ Number ç›¸ç­‰ä¸éœ€è¦ç”¨ equals æ–¹æ³•
    if (this.stk[this.stk.length - 1] == this.minStk[this.minStk.length - 1]) {
        // å¼¹å‡ºçš„å…ƒç´ æ˜¯å…¨æ ˆæœ€å°çš„
        this.minStk.pop();
    }
    this.stk.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.stk[this.stk.length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
    // minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
    return this.minStk[this.minStk.length - 1];
};
```

```python
# by chatGPT (python)
class MinStack1:
    # è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    def __init__(self):
        self.stk = []
        # é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
        self.minStk = []

    def push(self, val):
        self.stk.append(val)
        # ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        if not self.minStk or val <= self.minStk[-1]:
            # æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
            self.minStk.append(val)
        else:
            # æ’å…¥çš„è¿™ä¸ªå…ƒç´ æ¯”è¾ƒå¤§
            self.minStk.append(self.minStk[-1])

    def pop(self):
        self.stk.pop()
        self.minStk.pop()

    def top(self):
        return self.stk[-1]

    def getMin(self):
        # minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        return self.minStk[-1]


# ä¼˜åŒ–ç‰ˆ
class MinStack:
    # è®°å½•æ ˆä¸­çš„æ‰€æœ‰å…ƒç´ 
    def __init__(self):
        self.stk = []
        # é˜¶æ®µæ€§è®°å½•æ ˆä¸­çš„æœ€å°å…ƒç´ 
        self.minStk = []

    def push(self, val):
        self.stk.append(val)
        # ç»´æŠ¤ minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        if not self.minStk or val <= self.minStk[-1]:
            # æ–°æ’å…¥çš„è¿™ä¸ªå…ƒç´ å°±æ˜¯å…¨æ ˆæœ€å°çš„
            self.minStk.append(val)

    def pop(self):
        # æ³¨æ„ Python è¯­è¨€ç›¸ç­‰æ¯”è¾ƒå¯ä»¥ä½¿ç”¨ "==" æ“ä½œç¬¦
        if self.stk[-1] == self.minStk[-1]:
            # å¼¹å‡ºçš„å…ƒç´ æ˜¯å…¨æ ˆæœ€å°çš„
            self.minStk.pop()
        self.stk.pop()

    def top(self):
        return self.stk[-1]

    def getMin(self):
        # minStk æ ˆé¡¶ä¸ºå…¨æ ˆæœ€å°å…ƒç´ 
        return self.minStk[-1]
```

https://leetcode.cn/problems/min-stack çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/minimum-absolute-difference-in-bst çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        traverse(root);
        return res;
    }

    TreeNode* prev = nullptr;
    int res = INT_MAX;

    // éå†å‡½æ•°
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        traverse(root->left);
        // ä¸­åºéå†ä½ç½®
        if (prev != nullptr) {
            res = min(res, root->val - prev->val);
        }
        prev = root;
        traverse(root->right);
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func getMinimumDifference(root *TreeNode) int {
    prev := (*TreeNode)(nil)
    res := math.MaxInt32

    var traverse func(root *TreeNode)
    traverse = func(root *TreeNode) {
        if root == nil {
            return
        }

        traverse(root.Left)
        // ä¸­åºéå†ä½ç½®
        if prev != nil {
            res = min(res, root.Val - prev.Val)
        }

        prev = root
        traverse(root.Right)
    }

    traverse(root)
    return res
}

func min(x, y int) int {
    if x < y {
        return x
    }
    return y
}
```

```java
// by labuladong (java)
class Solution {
    public int getMinimumDifference(TreeNode root) {
        traverse(root);
        return res;
    }

    TreeNode prev = null;
    int res = Integer.MAX_VALUE;

    // éå†å‡½æ•°
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        traverse(root.left);
        // ä¸­åºéå†ä½ç½®
        if (prev != null) {
            res = Math.min(res, root.val - prev.val);
        }
        prev = root;
        traverse(root.right);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {TreeNode} root
 * @return {number}
 */
var getMinimumDifference = function(root) {
    let prev = null;
    let res = Number.MAX_SAFE_INTEGER;

    // éå†å‡½æ•°
    function traverse(root) {
        if (root == null) {
            return;
        }
        traverse(root.left);
        // ä¸­åºéå†ä½ç½®
        if (prev != null) {
            res = Math.min(res, root.val - prev.val);
        }
        prev = root;
        traverse(root.right);
    }

    traverse(root);
    return res;
}
```

```python
# by chatGPT (python)
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        self.prev = None
        self.res = float('inf')
        self.traverse(root)
        return self.res
        
    # éå†å‡½æ•°
    def traverse(self, root: TreeNode) -> None:
        if not root:
            return
        
        self.traverse(root.left)
        # ä¸­åºéå†ä½ç½®
        if self.prev:
            self.res = min(self.res, root.val - self.prev.val)
        self.prev = root
        self.traverse(root.right)
```

https://leetcode.cn/problems/minimum-absolute-difference-in-bst çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int minAddToMakeValid(string s) {
        // res è®°å½•æ’å…¥æ¬¡æ•°
        int res = 0;
        // need å˜é‡è®°å½•å³æ‹¬å·çš„éœ€æ±‚é‡
        int need = 0;

        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(') {
                // å¯¹å³æ‹¬å·çš„éœ€æ±‚ + 1
                need++;
            }

            if (s[i] == ')') {
                // å¯¹å³æ‹¬å·çš„éœ€æ±‚ - 1
                need--;

                if (need == -1) {
                    need = 0;
                    // éœ€æ’å…¥ä¸€ä¸ªå·¦æ‹¬å·
                    res++;
                }
            }
        }

        return res + need;
    }
};
```

```go
// by chatGPT (go)
func minAddToMakeValid(s string) int {
    // res è®°å½•æ’å…¥æ¬¡æ•°
    res := 0
    // need å˜é‡è®°å½•å³æ‹¬å·çš„éœ€æ±‚é‡
    need := 0

    for i := 0; i < len(s); i++ {
        if s[i] == '(' {
            // å¯¹å³æ‹¬å·çš„éœ€æ±‚ + 1
            need++
        }

        if s[i] == ')' {
            // å¯¹å³æ‹¬å·çš„éœ€æ±‚ - 1
            need--

            if need == -1 {
                need = 0
                // éœ€æ’å…¥ä¸€ä¸ªå·¦æ‹¬å·
                res++
            }
        }
    }

    return res + need
}
```

```java
// by labuladong (java)
class Solution {
    public int minAddToMakeValid(String s) {
        // res è®°å½•æ’å…¥æ¬¡æ•°
        int res = 0;
        // need å˜é‡è®°å½•å³æ‹¬å·çš„éœ€æ±‚é‡
        int need = 0;

        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                // å¯¹å³æ‹¬å·çš„éœ€æ±‚ + 1
                need++;
            }

            if (s.charAt(i) == ')') {
                // å¯¹å³æ‹¬å·çš„éœ€æ±‚ - 1
                need--;

                if (need == -1) {
                    need = 0;
                    // éœ€æ’å…¥ä¸€ä¸ªå·¦æ‹¬å·
                    res++;
                }
            }
        }

        return res + need;
    }
}
```

```javascript
// by chatGPT (javascript)
var minAddToMakeValid = function(s) {
    // res è®°å½•æ’å…¥æ¬¡æ•°
    let res = 0;
    // need å˜é‡è®°å½•å³æ‹¬å·çš„éœ€æ±‚é‡
    let need = 0;

    for (let i = 0; i < s.length; i++) {
        if (s.charAt(i) == '(') {
            // å¯¹å³æ‹¬å·çš„éœ€æ±‚ + 1
            need++;
        }

        if (s.charAt(i) == ')') {
            // å¯¹å³æ‹¬å·çš„éœ€æ±‚ - 1
            need--;

            if (need == -1) {
                need = 0;
                // éœ€æ’å…¥ä¸€ä¸ªå·¦æ‹¬å·
                res++;
            }
        }
    }

    return res + need;
};
```

```python
# by chatGPT (python)
class Solution:
    def minAddToMakeValid(self, s: str) -> int:
        # res è®°å½•æ’å…¥æ¬¡æ•°
        res = 0
        # need å˜é‡è®°å½•å³æ‹¬å·çš„éœ€æ±‚é‡
        need = 0

        for i in range(len(s)):
            if s[i] == '(':
                # å¯¹å³æ‹¬å·çš„éœ€æ±‚ + 1
                need += 1

            if s[i] == ')':
                # å¯¹å³æ‹¬å·çš„éœ€æ±‚ - 1
                need -= 1

                if need == -1:
                    need = 0
                    # éœ€æ’å…¥ä¸€ä¸ªå·¦æ‹¬å·
                    res += 1

        return res + need
```

https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // å¤‡å¿˜å½•
    int memo[1001][1001];

    /* ä¸»å‡½æ•° */
    int minimumDeleteSum(string s1, string s2) {
        int m = s1.size(), n = s2.size();
        // å¤‡å¿˜å½•å€¼ä¸º -1 ä»£è¡¨æœªæ›¾è®¡ç®—
        memset(memo, -1, sizeof(memo));
        return dp(s1, 0, s2, 0);
    }

    // å®šä¹‰ï¼šå°† s1[i..] å’Œ s2[j..] åˆ é™¤æˆç›¸åŒå­—ç¬¦ä¸²ï¼Œ
    // æœ€å°çš„ ASCII ç ä¹‹å’Œä¸º dp(s1, i, s2, j)ã€‚
    int dp(string s1, int i, string s2, int j) {
        int res = 0;
        // base case
        if (i == s1.size()) {
            // å¦‚æœ s1 åˆ°å¤´äº†ï¼Œé‚£ä¹ˆ s2 å‰©ä¸‹çš„éƒ½å¾—åˆ é™¤
            for (; j < s2.size(); j++)
                res += s2[j];
            return res;
        }
        if (j == s2.size()) {
            // å¦‚æœ s2 åˆ°å¤´äº†ï¼Œé‚£ä¹ˆ s1 å‰©ä¸‹çš„éƒ½å¾—åˆ é™¤
            for (; i < s1.size(); i++)
                res += s1[i];
            return res;
        }

        if (memo[i][j] != -1) {
            return memo[i][j];
        }

        if (s1[i] == s2[j]) {
            // s1[i] å’Œ s2[j] éƒ½æ˜¯åœ¨ lcs ä¸­çš„ï¼Œä¸ç”¨åˆ é™¤
            memo[i][j] = dp(s1, i + 1, s2, j + 1);
        } else {
            // s1[i] å’Œ s2[j] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­ï¼Œåˆ ä¸€ä¸ª
            memo[i][j] = min(
                    s1[i] + dp(s1, i + 1, s2, j),
                    s2[j] + dp(s1, i, s2, j + 1)
            );
        }
        return memo[i][j];
    }
};
```

```go
// by chatGPT (go)
func minimumDeleteSum(s1 string, s2 string) int {
    m, n := len(s1), len(s2)
    // å¤‡å¿˜å½•å€¼ä¸º -1 ä»£è¡¨æœªæ›¾è®¡ç®—
    memo := make([][]int, m)
    for i := range memo {
        memo[i] = make([]int, n)
        for j := range memo[i] {
            memo[i][j] = -1
        }
    }

    var dp func(s1 string, i int, s2 string, j int) int
    // å®šä¹‰ï¼šå°† s1[i..] å’Œ s2[j..] åˆ é™¤æˆç›¸åŒå­—ç¬¦ä¸²ï¼Œ
    // æœ€å°çš„ ASCII ç ä¹‹å’Œä¸º dp(s1, i, s2, j)ã€‚
    dp = func(s1 string, i int, s2 string, j int) int {
        res := 0
        // base case
        if i == len(s1) {
            // å¦‚æœ s1 åˆ°å¤´äº†ï¼Œé‚£ä¹ˆ s2 å‰©ä¸‹çš„éƒ½å¾—åˆ é™¤
            for ; j < len(s2); j++ {
                res += int(s2[j])
            }
            return res
        }
        if j == len(s2) {
            // å¦‚æœ s2 åˆ°å¤´äº†ï¼Œé‚£ä¹ˆ s1 å‰©ä¸‹çš„éƒ½å¾—åˆ é™¤
            for ; i < len(s1); i++ {
                res += int(s1[i])
            }
            return res
        }

        if memo[i][j] != -1 {
            return memo[i][j]
        }

        if s1[i] == s2[j] {
            // s1[i] å’Œ s2[j] éƒ½æ˜¯åœ¨ lcs ä¸­çš„ï¼Œä¸ç”¨åˆ é™¤
            memo[i][j] = dp(s1, i + 1, s2, j + 1)
        } else {
            // s1[i] å’Œ s2[j] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­ï¼Œåˆ ä¸€ä¸ª
            memo[i][j] = min(
                int(s1[i]) + dp(s1, i + 1, s2, j),
                int(s2[j]) + dp(s1, i, s2, j + 1),
            )
        }
        return memo[i][j]
    }

    return dp(s1, 0, s2, 0)
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {

    // å¤‡å¿˜å½•
    int memo[][];

    /* ä¸»å‡½æ•° */
    public int minimumDeleteSum(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // å¤‡å¿˜å½•å€¼ä¸º -1 ä»£è¡¨æœªæ›¾è®¡ç®—
        memo = new int[m][n];
        for (int[] row : memo)
            Arrays.fill(row, -1);

        return dp(s1, 0, s2, 0);
    }

    // å®šä¹‰ï¼šå°† s1[i..] å’Œ s2[j..] åˆ é™¤æˆç›¸åŒå­—ç¬¦ä¸²ï¼Œ
    // æœ€å°çš„ ASCII ç ä¹‹å’Œä¸º dp(s1, i, s2, j)ã€‚
    int dp(String s1, int i, String s2, int j) {
        int res = 0;
        // base case
        if (i == s1.length()) {
            // å¦‚æœ s1 åˆ°å¤´äº†ï¼Œé‚£ä¹ˆ s2 å‰©ä¸‹çš„éƒ½å¾—åˆ é™¤
            for (; j < s2.length(); j++)
                res += s2.charAt(j);
            return res;
        }
        if (j == s2.length()) {
            // å¦‚æœ s2 åˆ°å¤´äº†ï¼Œé‚£ä¹ˆ s1 å‰©ä¸‹çš„éƒ½å¾—åˆ é™¤
            for (; i < s1.length(); i++)
                res += s1.charAt(i);
            return res;
        }

        if (memo[i][j] != -1) {
            return memo[i][j];
        }

        if (s1.charAt(i) == s2.charAt(j)) {
            // s1[i] å’Œ s2[j] éƒ½æ˜¯åœ¨ lcs ä¸­çš„ï¼Œä¸ç”¨åˆ é™¤
            memo[i][j] = dp(s1, i + 1, s2, j + 1);
        } else {
            // s1[i] å’Œ s2[j] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­ï¼Œåˆ ä¸€ä¸ª
            memo[i][j] = Math.min(
                    s1.charAt(i) + dp(s1, i + 1, s2, j),
                    s2.charAt(j) + dp(s1, i, s2, j + 1)
            );
        }
        return memo[i][j];
    }
}
```

```javascript
// by chatGPT (javascript)
var minimumDeleteSum = function(s1, s2) {
    var m = s1.length, n = s2.length;
    // memo[i][j] å­˜å‚¨å°†s1[i...]å’Œs2[j...]åˆ é™¤æˆç›¸åŒå­—ç¬¦ä¸²çš„æœ€å°ASCIIç ä¹‹å’Œ
    var memo = new Array(m);
    for(var i=0; i<memo.length; i++) memo[i] = new Array(n).fill(-1);

    // dpå‡½æ•°å®šä¹‰ï¼Œè®¡ç®—åˆ é™¤æˆç›¸åŒå­—ç¬¦æ‰€éœ€çš„æœ€å°ASCIIç ä¹‹å’Œ
    function dp(i, j) {
        var res = 0;
        // å¦‚æœ s1 åˆ°å¤´äº†ï¼Œé‚£ä¹ˆ s2 å‰©ä¸‹çš„éƒ½å¾—åˆ é™¤
        if (i == s1.length) {
            for (; j < s2.length; j++)
                res += s2.charCodeAt(j);
            return res;
        }
        // å¦‚æœ s2 åˆ°å¤´äº†ï¼Œé‚£ä¹ˆ s1 å‰©ä¸‹çš„éƒ½å¾—åˆ é™¤
        if (j == s2.length) {
            for (; i < s1.length; i++)
                res += s1.charCodeAt(i);
            return res;
        }

        // å¦‚æœmemoæ•°ç»„å·²æœ‰è®°å½•åˆ™ç›´æ¥è¿”å›
        if (memo[i][j] != -1) {
            return memo[i][j];
        }

        // å¦‚æœs1[i]å’Œs2[j]éƒ½åœ¨LCSä¸­ï¼Œåˆ™ä¸éœ€è¦åˆ é™¤
        if (s1.charAt(i) == s2.charAt(j)) {
            memo[i][j] = dp(i + 1, j + 1);
        } else {
            // s1[i] å’Œ s2[j] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­ï¼Œéœ€è¦åˆ æ‰ä¸€ä¸ª
            memo[i][j] = Math.min(
                    s1.charCodeAt(i) + dp(i + 1, j),
                    s2.charCodeAt(j) + dp(i, j + 1)
            );
        }
        return memo[i][j];
    }

    // è¿”å›å°†s1å’Œs2åˆ é™¤æˆç›¸åŒå­—ç¬¦ä¸²çš„æœ€å°ASCIIç ä¹‹å’Œ
    return dp(0, 0);
};
```

```python
# by chatGPT (python)
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
        # å¤‡å¿˜å½•å€¼ä¸º -1 ä»£è¡¨æœªæ›¾è®¡ç®—
        memo = [[-1] * n for _ in range(m)]

        def dp(i: int, j: int) -> int:
            res = 0
            # base case
            if i == m:
                # å¦‚æœ s1 åˆ°å¤´äº†ï¼Œé‚£ä¹ˆ s2 å‰©ä¸‹çš„éƒ½å¾—åˆ é™¤
                for k in range(j, n):
                    res += ord(s2[k])
                return res
            if j == n:
                # å¦‚æœ s2 åˆ°å¤´äº†ï¼Œé‚£ä¹ˆ s1 å‰©ä¸‹çš„éƒ½å¾—åˆ é™¤
                for k in range(i, m):
                    res += ord(s1[k])
                return res

            if memo[i][j] != -1:
                return memo[i][j]

            if s1[i] == s2[j]:
                # s1[i] å’Œ s2[j] éƒ½æ˜¯åœ¨ lcs ä¸­çš„ï¼Œä¸ç”¨åˆ é™¤
                memo[i][j] = dp(i + 1, j + 1)
            else:
                # s1[i] å’Œ s2[j] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­ï¼Œåˆ ä¸€ä¸ª
                memo[i][j] = min(
                    ord(s1[i]) + dp(i + 1, j),
                    ord(s2[j]) + dp(i, j + 1)
                )
            return memo[i][j]

        return dp(0, 0)
```

https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/minimum-depth-of-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == NULL) return 0;
        queue<TreeNode*> q;
        q.push(root);
        // root æœ¬èº«å°±æ˜¯ä¸€å±‚ï¼Œdepth åˆå§‹åŒ–ä¸º 1
        int depth = 1;

        while (!q.empty()) {
            /* å±‚æ•° step */
            int sz = q.size();
            /* å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å››å‘¨æ‰©æ•£ */
            for (int i = 0; i < sz; i++) {
                TreeNode* cur = q.front();
                q.pop();
                /* åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹ */
                if (cur->left == NULL && cur->right == NULL)
                    return depth;
                /* å°† cur çš„ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */
                if (cur->left != NULL)
                    q.push(cur->left);
                if (cur->right != NULL)
                    q.push(cur->right);
            }
            /* è¿™é‡Œå¢åŠ æ­¥æ•° */
            depth++;
        }
        return depth;
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for TreeNode.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func minDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    q := []*TreeNode{root}
    // root æœ¬èº«å°±æ˜¯ä¸€å±‚ï¼Œdepth åˆå§‹åŒ–ä¸º 1
    depth := 1

    for len(q) != 0 {
        /**<extend down -200>
        ![](../pictures/dijkstra/1.jpeg)
        */
        sz := len(q)
        /* éå†å½“å‰å±‚çš„èŠ‚ç‚¹ */
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]
            /* åˆ¤æ–­æ˜¯å¦åˆ°è¾¾å¶å­ç»“ç‚¹ */
            if cur.Left == nil && cur.Right == nil {
                return depth
            }
            /* å°†ä¸‹ä¸€å±‚èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */
            if cur.Left != nil {
                q = append(q, cur.Left)
            }
            if cur.Right != nil {
                q = append(q, cur.Right)
            }
        }
        /* è¿™é‡Œå¢åŠ æ­¥æ•° */
        depth++
    }
    return depth
}
```

```java
// by labuladong (java)
// ã€Œè¿­ä»£ã€çš„é€’å½’æ€è·¯
class Solution {
    private int minDepth = Integer.MAX_VALUE;
    private int currentDepth = 0;

    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        traverse(root);
        return minDepth;
    }

    private void traverse(TreeNode root) {
        if (root == null) {
            return;
        }

        // åšé€‰æ‹©ï¼šåœ¨è¿›å…¥èŠ‚ç‚¹æ—¶å¢åŠ å½“å‰æ·±åº¦
        currentDepth++;

        // å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹ï¼Œæ›´æ–°æœ€å°æ·±åº¦
        if (root.left == null && root.right == null) {
            minDepth = Math.min(minDepth, currentDepth);
        }

        traverse(root.left);
        traverse(root.right);

        // æ’¤é”€é€‰æ‹©ï¼šåœ¨ç¦»å¼€èŠ‚ç‚¹æ—¶å‡å°‘å½“å‰æ·±åº¦
        currentDepth--;
    }
}

// ã€Œåˆ†è§£é—®é¢˜ã€çš„é€’å½’æ€è·¯
class Solution2 {
    public int minDepth(TreeNode root) {
        // åŸºæœ¬æƒ…å†µï¼šå¦‚æœèŠ‚ç‚¹ä¸ºç©ºï¼Œè¿”å›æ·±åº¦ä¸º0
        if (root == null) {
            return 0;
        }

        // é€’å½’è®¡ç®—å·¦å­æ ‘çš„æœ€å°æ·±åº¦
        int leftDepth = minDepth(root.left);
        // é€’å½’è®¡ç®—å³å­æ ‘çš„æœ€å°æ·±åº¦
        int rightDepth = minDepth(root.right);

        // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå¦‚æœå·¦å­æ ‘ä¸ºç©ºï¼Œè¿”å›å³å­æ ‘çš„æ·±åº¦åŠ 1
        if (leftDepth == 0) {
            return rightDepth + 1;
        }
        // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå¦‚æœå³å­æ ‘ä¸ºç©ºï¼Œè¿”å›å·¦å­æ ‘çš„æ·±åº¦åŠ 1
        if (rightDepth == 0) {
            return leftDepth + 1;
        }

        // è®¡ç®—å¹¶è¿”å›æœ€å°æ·±åº¦ï¼šå·¦å³å­æ ‘æ·±åº¦çš„æœ€å°å€¼åŠ 1
        return Math.min(leftDepth, rightDepth) + 1;
    }
}


// BFS çš„æ€è·¯
class Solution3 {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        // root æœ¬èº«å°±æ˜¯ä¸€å±‚ï¼Œdepth åˆå§‹åŒ–ä¸º 1
        int depth = 1;

        while (!q.isEmpty()) {
            /**<extend down -200>
            ![](../pictures/dijkstra/1.jpeg)
            */
            int sz = q.size();
            /* éå†å½“å‰å±‚çš„èŠ‚ç‚¹ */
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                /* åˆ¤æ–­æ˜¯å¦åˆ°è¾¾å¶å­ç»“ç‚¹ */
                if (cur.left == null && cur.right == null)
                    return depth;
                /* å°†ä¸‹ä¸€å±‚èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */
                if (cur.left != null)
                    q.offer(cur.left);
                if (cur.right != null)
                    q.offer(cur.right);
            }
            /* è¿™é‡Œå¢åŠ æ­¥æ•° */
            depth++;
        }
        return depth;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if (root === null) return 0;
    var q = [];
    q.push(root);
    //rootæœ¬èº«å°±æ˜¯ä¸€å±‚ï¼Œdepthåˆå§‹åŒ–ä¸º 1
    var depth = 1;

    while (q.length !== 0) {
        /** <extend down -200>
         ![](../pictures/dijkstra/1.jpeg)
         */
        var sz = q.length;
        /* éå†å½“å‰å±‚çš„èŠ‚ç‚¹ */
        for (var i = 0; i < sz; i++) {

            var cur = q.shift();
            /* åˆ¤æ–­æ˜¯å¦åˆ°è¾¾å¶å­ç»“ç‚¹ */
            if (!cur.left && !cur.right) {
                return depth;
            }
            /* å°†ä¸‹ä¸€å±‚èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— 
            */
           if (cur.left !== null) {
             q.push(cur.left);
            }
            if (cur.right !== null) {
              q.push(cur.right);
             }
            
        }
        /* è¿™é‡Œå¢åŠ æ­¥æ•° */
        depth++;
    }
    return depth;
};
```

```python
# by chatGPT (python)
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        q = collections.deque([root])
        # root æœ¬èº«å°±æ˜¯ä¸€å±‚ï¼Œdepth åˆå§‹åŒ–ä¸º 1
        depth = 1
        while q:
            # extend down -200>
            # ![](../pictures/dijkstra/1.jpeg)
            sz = len(q)
            ## éå†å½“å‰å±‚çš„èŠ‚ç‚¹
            for i in range(sz):
                cur = q.popleft()
                ## åˆ¤æ–­æ˜¯å¦åˆ°è¾¾å¶å­ç»“ç‚¹
                if not cur.left and not cur.right:
                    return depth
                ## å°†ä¸‹ä¸€å±‚èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
            ## è¿™é‡Œå¢åŠ æ­¥æ•°
            depth += 1
        return depth
```

https://leetcode.cn/problems/minimum-depth-of-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/minimum-distance-between-bst-nodes çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int minDiffInBST(TreeNode* root) {
        traverse(root);
        return res;
    }
    
    TreeNode* prev = nullptr;
    int res = INT_MAX;
    
    // éå†å‡½æ•°
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        traverse(root->left);
        // ä¸­åºéå†ä½ç½®
        if (prev != nullptr) {
            res = min(res, root->val - prev->val);
        }
        prev = root;
        traverse(root->right);
    }
};
```

```go
// by chatGPT (go)
func minDiffInBST(root *TreeNode) int {
    var (
        prev *TreeNode
        res = math.MaxInt32
        // éå†å‡½æ•°
        traverse func(*TreeNode)
    )

    traverse = func(root *TreeNode) {
        if root == nil {
            return
        }
        traverse(root.Left)
        // ä¸­åºéå†ä½ç½®
        if prev != nil {
            res = min(res, root.Val - prev.Val)
        }
        prev = root
        traverse(root.Right)
    }

    traverse(root)
    return res
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int minDiffInBST(TreeNode root) {
        traverse(root);
        return res;
    }

    TreeNode prev = null;
    int res = Integer.MAX_VALUE;

    // éå†å‡½æ•°
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        traverse(root.left);
        // ä¸­åºéå†ä½ç½®
        if (prev != null) {
            res = Math.min(res, root.val - prev.val);
        }
        prev = root;
        traverse(root.right);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDiffInBST = function(root) {
  let prev = null;
  let res = Number.MAX_SAFE_INTEGER;

  // éå†å‡½æ•°
  const traverse = (root) => {
    if (!root) {
      return;
    }
    traverse(root.left);
    // ä¸­åºéå†ä½ç½®
    if (prev) {
      res = Math.min(res, root.val - prev.val);
    }
    prev = root;
    traverse(root.right);
  }

  traverse(root);
  return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def minDiffInBST(self, root: TreeNode) -> int:
        self.prev = None
        self.res = float('inf')
        self.traverse(root)
        return self.res

    # éå†å‡½æ•°
    def traverse(self, root: TreeNode) -> None:
        if not root:
            return
        self.traverse(root.left)
        # ä¸­åºéå†ä½ç½®
        if self.prev:
            self.res = min(self.res, root.val - self.prev.val)
        self.prev = root
        self.traverse(root.right)
```

https://leetcode.cn/problems/minimum-distance-between-bst-nodes çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/minimum-falling-path-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int res = INT_MAX;
        // å¤‡å¿˜å½•é‡Œçš„å€¼åˆå§‹åŒ–ä¸º 66666
        vector<vector<int>> memo(n, vector<int>(n, 66666));
        // ç»ˆç‚¹å¯èƒ½åœ¨ matrix[n-1] çš„ä»»æ„ä¸€åˆ—
        for (int j = 0; j < n; j++) {
            res = min(res, dp(matrix, memo, n - 1, j));
        }
        return res;
    }

    int dp(vector<vector<int>>& matrix, vector<vector<int>>& memo, int i, int j) {
        // 1ã€ç´¢å¼•åˆæ³•æ€§æ£€æŸ¥
        if (i < 0 || j < 0 || i >= matrix.size() || j >= matrix[0].size()) {
            return 99999;
        }
        // 2ã€base case
        if (i == 0) {
            return matrix[0][j];
        }
        // 3ã€æŸ¥æ‰¾å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[i][j] != 66666) {
            return memo[i][j];
        }
        // è¿›è¡ŒçŠ¶æ€è½¬ç§»
        memo[i][j] = matrix[i][j] + three_min(
            dp(matrix, memo, i - 1, j),
            dp(matrix, memo, i - 1, j - 1),
            dp(matrix, memo, i - 1, j + 1)
        );

        return memo[i][j];
    }

    int three_min(int a, int b, int c) {
        return min(a, min(b, c));
    }
};
```

```go
// by chatGPT (go)
import (
    "fmt"
    "math"
)

func minFallingPathSum(matrix [][]int) int {
    n := len(matrix)
    res := math.MaxInt32
    // å¤‡å¿˜å½•é‡Œçš„å€¼åˆå§‹åŒ–ä¸º 66666
    memo := make([][]int, n)
    for i := 0; i < n; i++ {
        memo[i] = make([]int, n)
        for j := 0; j < n; j++ {
            memo[i][j] = 66666
        }
    }
    // ç»ˆç‚¹å¯èƒ½åœ¨ matrix[n-1] çš„ä»»æ„ä¸€åˆ—
    for j := 0; j < n; j++ {
        res = min(res, dp(matrix, n-1, j, memo))
    }
    return res
}

// å¤‡å¿˜å½•
func dp(matrix [][]int, i, j int, memo [][]int) int {
    // 1ã€ç´¢å¼•åˆæ³•æ€§æ£€æŸ¥
    if i < 0 || j < 0 ||
        i >= len(matrix) ||
        j >= len(matrix[0]) {
        return 99999
    }
    // 2ã€base case
    if i == 0 {
        return matrix[0][j]
    }
    // 3ã€æŸ¥æ‰¾å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
    if memo[i][j] != 66666 {
        return memo[i][j]
    }
    memo[i][j] = matrix[i][j] + min(
        dp(matrix, i-1, j, memo),
        dp(matrix, i-1, j-1, memo),
        dp(matrix, i-1, j+1, memo),
    )
    return memo[i][j]
}

// è¿”å›ä¸‰ä¸ªæ•°ä¸­çš„æœ€å°å€¼
func min(a, b, c int) int {
    return int(math.Min(float64(a), math.Min(float64(b), float64(c))))
}
```

```java
// by labuladong (java)
class Solution {
    public int minFallingPathSum(int[][] matrix) {
        int n = matrix.length;
        int res = Integer.MAX_VALUE;
        // å¤‡å¿˜å½•é‡Œçš„å€¼åˆå§‹åŒ–ä¸º 66666
        memo = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(memo[i], 66666);
        }
        // ç»ˆç‚¹å¯èƒ½åœ¨ matrix[n-1] çš„ä»»æ„ä¸€åˆ—
        for (int j = 0; j < n; j++) {
            res = Math.min(res, dp(matrix, n - 1, j));
        }
        return res;
    }

    // å¤‡å¿˜å½•
    int[][] memo;

    int dp(int[][] matrix, int i, int j) {
        // 1ã€ç´¢å¼•åˆæ³•æ€§æ£€æŸ¥
        if (i < 0 || j < 0 ||
                i >= matrix.length ||
                j >= matrix[0].length) {

            return 99999;
        }
        // 2ã€base case
        if (i == 0) {
            return matrix[0][j];
        }
        // 3ã€æŸ¥æ‰¾å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[i][j] != 66666) {
            return memo[i][j];
        }
        // è¿›è¡ŒçŠ¶æ€è½¬ç§»
        memo[i][j] = matrix[i][j] + min(
                dp(matrix, i - 1, j),
                dp(matrix, i - 1, j - 1),
                dp(matrix, i - 1, j + 1)
        );

        return memo[i][j];
    }
    /**<extend up -100>
    ![](../pictures/å¤‡å¿˜å½•åŸºç¡€/1.jpeg)
    */
    int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }
}
```

```javascript
// by chatGPT (javascript)
var minFallingPathSum = function(matrix) {
    var n = matrix.length, res = Number.MAX_VALUE;
    // å¤‡å¿˜å½•é‡Œçš„å€¼åˆå§‹åŒ–ä¸º 66666
    var memo = new Array(n).map(() => new Array(n).fill(66666));
    // ç»ˆç‚¹å¯èƒ½åœ¨ matrix[n-1] çš„ä»»æ„ä¸€åˆ—
    for (var j = 0; j < n; j++) {
        res = Math.min(res, dp(matrix, n - 1, j));
    }
    return res;

    function dp(matrix, i, j) {
        // 1ã€ç´¢å¼•åˆæ³•æ€§æ£€æŸ¥
        if (i < 0 || j < 0 || i >= matrix.length || j >= matrix[0].length) {
            return 99999;
        }
        // 2ã€base case
        if (i === 0) {
            return matrix[0][j];
        }
        // 3ã€æŸ¥æ‰¾å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[i][j] !== 66666) {
            return memo[i][j];
        }
        // è¿›è¡ŒçŠ¶æ€è½¬ç§»
        memo[i][j] = matrix[i][j] + min(
            dp(matrix, i - 1, j),
            dp(matrix, i - 1, j - 1),
            dp(matrix, i - 1, j + 1)
        );
        return memo[i][j];
    }

    // æ±‚ä¸‰è€…æœ€å°å€¼
    function min(a, b, c) {
        return Math.min(a, Math.min(b, c));
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        n = len(matrix)
        res = float('inf')
        # å¤‡å¿˜å½•é‡Œçš„å€¼åˆå§‹åŒ–ä¸º 66666
        memo = [[66666]*n for _ in range(n)]
        # ç»ˆç‚¹å¯èƒ½åœ¨ matrix[n-1] çš„ä»»æ„ä¸€åˆ—
        for j in range(n):
            res = min(res, self.dp(matrix, memo, n-1, j))
        return res

    def dp(self, matrix, memo, i, j):
        # 1. ç´¢å¼•åˆæ³•æ€§æ£€æŸ¥
        if i < 0 or j < 0 or i >= len(matrix) or j >= len(matrix[0]):
            return 99999
        # 2. base case
        if i == 0:
            return matrix[0][j]
        # 3. æŸ¥æ‰¾å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if memo[i][j] != 66666:
            return memo[i][j]
        # è¿›è¡ŒçŠ¶æ€è½¬ç§»
        memo[i][j] = matrix[i][j] + min(
            self.dp(matrix, memo, i-1, j),
            self.dp(matrix, memo, i-1, j-1),
            self.dp(matrix, memo, i-1, j+1)
        )
        return memo[i][j]
```

https://leetcode.cn/problems/minimum-falling-path-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/minimum-height-trees çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        // 1ã€æ„å»ºé‚»æ¥è¡¨
        vector<vector<int>> graph(n);
        for (auto& edge : edges) {
            // æ— å‘å›¾ï¼Œç­‰åŒäºåŒå‘å›¾
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }

        // 2ã€æ‰¾åˆ°æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹
        vector<int> leaves;
        for (int i = 0; i < n; i++) {
            if (graph[i].size() == 1) {
                leaves.push_back(i);
            }
        }

        // 3ã€ä¸æ–­åˆ é™¤å¶å­èŠ‚ç‚¹ï¼Œç›´åˆ°å‰©ä¸‹çš„èŠ‚ç‚¹æ•°å°äºç­‰äº 2 ä¸ª
        int remainNodeNum = n;
        while (remainNodeNum > 2) {
            // åˆ é™¤å½“å‰å¶å­èŠ‚ç‚¹ï¼Œè®¡ç®—æ–°çš„å¶å­èŠ‚ç‚¹
            remainNodeNum -= leaves.size();
            vector<int> newLeaves;
            for (auto leaf : leaves) {
                // å°†è¢«åˆ é™¤çš„å¶å­èŠ‚ç‚¹çš„é‚»æ¥èŠ‚ç‚¹çš„åº¦å‡ 1
                int neighbor = graph[leaf][0];
                graph[neighbor].erase(find(graph[neighbor].begin(), graph[neighbor].end(), leaf));
                // å¦‚æœé‚»æ¥èŠ‚ç‚¹çš„åº¦ä¸º 1ï¼Œè¯´æ˜å®ƒä¹Ÿå˜æˆäº†å¶å­èŠ‚ç‚¹
                if (graph[neighbor].size() == 1) {
                    newLeaves.push_back(neighbor);
                }
            }
            leaves = newLeaves;
        }

        // æœ€åå‰©ä¸‹çš„èŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹
        return leaves;
    }
};
```

```go
// by chatGPT (go)
func findMinHeightTrees(n int, edges [][]int) []int {
    // 1ã€æ„å»ºé‚»æ¥è¡¨
    graph := make([][]int, n)
    for i := 0; i < n; i++ {
        graph[i] = []int{}
    }
    for _, edge := range edges {
        // æ— å‘å›¾ï¼Œç­‰åŒäºåŒå‘å›¾
        graph[edge[0]] = append(graph[edge[0]], edge[1])
        graph[edge[1]] = append(graph[edge[1]], edge[0])
    }

    // 2ã€æ‰¾åˆ°æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹
    leaves := []int{}
    for i := 0; i < n; i++ {
        if len(graph[i]) == 1 {
            leaves = append(leaves, i)
        }
    }

    // 3ã€ä¸æ–­åˆ é™¤å¶å­èŠ‚ç‚¹ï¼Œç›´åˆ°å‰©ä¸‹çš„èŠ‚ç‚¹æ•°å°äºç­‰äº 2 ä¸ª
    remainNodeNum := n
    for remainNodeNum > 2 {
        // åˆ é™¤å½“å‰å¶å­èŠ‚ç‚¹ï¼Œè®¡ç®—æ–°çš„å¶å­èŠ‚ç‚¹
        remainNodeNum -= len(leaves)
        newLeaves := []int{}
        for _, leaf := range leaves {
            // å°†è¢«åˆ é™¤çš„å¶å­èŠ‚ç‚¹çš„é‚»æ¥èŠ‚ç‚¹çš„åº¦å‡ 1
            neighbor := graph[leaf][0]
            graph[neighbor] = removeElement(graph[neighbor], leaf)
            // å¦‚æœé‚»æ¥èŠ‚ç‚¹çš„åº¦ä¸º 1ï¼Œè¯´æ˜å®ƒä¹Ÿå˜æˆäº†å¶å­èŠ‚ç‚¹
            if len(graph[neighbor]) == 1 {
                newLeaves = append(newLeaves, neighbor)
            }
        }
        leaves = newLeaves
    }

    // æœ€åå‰©ä¸‹çš„èŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹
    return leaves
}

// åˆ é™¤åˆ‡ç‰‡ä¸­çš„å…ƒç´ 
func removeElement(slice []int, elem int) []int {
    index := -1
    for i, v := range slice {
        if v == elem {
            index = i
            break
        }
    }
    if index == -1 {
        return slice
    }
    return append(slice[:index], slice[index+1:]...)
}
```

```java
// by labuladong (java)
class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        // 1ã€æ„å»ºé‚»æ¥è¡¨
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<Integer>());
        }
        for (int[] edge : edges) {
            // æ— å‘å›¾ï¼Œç­‰åŒäºåŒå‘å›¾
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }

        // 2ã€æ‰¾åˆ°æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹
        List<Integer> leaves = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (graph.get(i).size() == 1) {
                leaves.add(i);
            }
        }

        // 3ã€ä¸æ–­åˆ é™¤å¶å­èŠ‚ç‚¹ï¼Œç›´åˆ°å‰©ä¸‹çš„èŠ‚ç‚¹æ•°å°äºç­‰äº 2 ä¸ª
        int remainNodeNum = n;
        while (remainNodeNum > 2) {
            // åˆ é™¤å½“å‰å¶å­èŠ‚ç‚¹ï¼Œè®¡ç®—æ–°çš„å¶å­èŠ‚ç‚¹
            remainNodeNum -= leaves.size();
            List<Integer> newLeaves = new ArrayList<>();
            for (int leaf : leaves) {
                // å°†è¢«åˆ é™¤çš„å¶å­èŠ‚ç‚¹çš„é‚»æ¥èŠ‚ç‚¹çš„åº¦å‡ 1
                int neighbor = graph.get(leaf).get(0);
                graph.get(neighbor).remove(leaf);
                // å¦‚æœé‚»æ¥èŠ‚ç‚¹çš„åº¦ä¸º 1ï¼Œè¯´æ˜å®ƒä¹Ÿå˜æˆäº†å¶å­èŠ‚ç‚¹
                if (graph.get(neighbor).size() == 1) {
                    newLeaves.add(neighbor);
                }
        }

        // æœ€åå‰©ä¸‹çš„èŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹
        return leaves;
    }
}
```

```javascript
// by chatGPT (javascript)
var findMinHeightTrees = function(n, edges) {
    // 1ã€æ„å»ºé‚»æ¥è¡¨
    let graph = new Array(n);
    for(let i = 0; i < n; i++) {
        graph[i] = [];
    }
    for(let edge of edges) {
        // æ— å‘å›¾ï¼Œç­‰åŒäºåŒå‘å›¾
        graph[edge[0]].push(edge[1]);
        graph[edge[1]].push(edge[0]);
    }

    // 2ã€æ‰¾åˆ°æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹
    let leaves = [];
    for(let i = 0; i < n; i++) {
        if(graph[i].length === 1) {
            leaves.push(i);
        }
    }

    // 3ã€ä¸æ–­åˆ é™¤å¶å­èŠ‚ç‚¹ï¼Œç›´åˆ°å‰©ä¸‹çš„èŠ‚ç‚¹æ•°å°äºç­‰äº 2 ä¸ª
    let remainNodeNum = n;
    while(remainNodeNum > 2) {
        // åˆ é™¤å½“å‰å¶å­èŠ‚ç‚¹ï¼Œè®¡ç®—æ–°çš„å¶å­èŠ‚ç‚¹
        remainNodeNum -= leaves.length;
        let newLeaves = [];
        for(let leaf of leaves) {
            // å°†è¢«åˆ é™¤çš„å¶å­èŠ‚ç‚¹çš„é‚»æ¥èŠ‚ç‚¹çš„åº¦å‡ 1
            let neighbor = graph[leaf][0];
            graph[neighbor].splice(graph[neighbor].indexOf(leaf), 1);
            // å¦‚æœé‚»æ¥èŠ‚ç‚¹çš„åº¦ä¸º 1ï¼Œè¯´æ˜å®ƒä¹Ÿå˜æˆäº†å¶å­èŠ‚ç‚¹
            if(graph[neighbor].length === 1) {
                newLeaves.push(neighbor);
            }
        }
        leaves = newLeaves;
    }

    // æœ€åå‰©ä¸‹çš„èŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹
    return leaves;
};
```

```python
# by chatGPT (python)
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        # 1ã€æ„å»ºé‚»æ¥è¡¨
        graph = [[] for _ in range(n)]
        for edge in edges:
            # æ— å‘å›¾ï¼Œç­‰åŒäºåŒå‘å›¾
            graph[edge[0]].append(edge[1])
            graph[edge[1]].append(edge[0])

        # 2ã€æ‰¾åˆ°æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹
        leaves = []
        for i in range(n):
            if len(graph[i]) == 1:
                leaves.append(i)

        # 3ã€ä¸æ–­åˆ é™¤å¶å­èŠ‚ç‚¹ï¼Œç›´åˆ°å‰©ä¸‹çš„èŠ‚ç‚¹æ•°å°äºç­‰äº 2 ä¸ª
        remainNodeNum = n
        while remainNodeNum > 2:
            # åˆ é™¤å½“å‰å¶å­èŠ‚ç‚¹ï¼Œè®¡ç®—æ–°çš„å¶å­èŠ‚ç‚¹
            remainNodeNum -= len(leaves)
            newLeaves = []
            for leaf in leaves:
                # å°†è¢«åˆ é™¤çš„å¶å­èŠ‚ç‚¹çš„é‚»æ¥èŠ‚ç‚¹çš„åº¦å‡ 1
                neighbor = graph[leaf][0]
                graph[neighbor].remove(leaf)
                # å¦‚æœé‚»æ¥èŠ‚ç‚¹çš„åº¦ä¸º 1ï¼Œè¯´æ˜å®ƒä¹Ÿå˜æˆäº†å¶å­èŠ‚ç‚¹
                if len(graph[neighbor]) == 1:
                    newLeaves.append(neighbor)
            
            leaves = newLeaves

        # æœ€åå‰©ä¸‹çš„èŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹
        return leaves
```

https://leetcode.cn/problems/minimum-height-trees çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int minInsertions(string s) {
        int res = 0, need = 0;

        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(') {
                need += 2;
                if (need % 2 == 1) {
                    res++;
                    need--;
                }
            }

            if (s[i] == ')') {
                need--;
                if (need == -1) {
                    res++;
                    need = 1;
                }
            }
        }

        return res + need;
    }
};
```

```go
// by chatGPT (go)
func minInsertions(s string) int {
	res := 0
	need := 0

	for i := 0; i < len(s); i++ {
		if s[i] == '(' {
			need += 2
			if need%2 == 1 {
				res++
				need--
			}
		} else if s[i] == ')' {
			need--
			if need == -1 {
				res++
				need = 1
			}
		}
	}

	return res + need
}
```

```java
// by labuladong (java)
class Solution {
    public int minInsertions(String s) {
        int res = 0, need = 0;

        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                need += 2;
                if (need % 2 == 1) {
                    res++;
                    need--;
                }
            }

            if (s.charAt(i) == ')') {
                need--;
                if (need == -1) {
                    res++;
                    need = 1;
                }
            }
        }

        return res + need;
    }
}
```

```javascript
// by chatGPT (javascript)
var minInsertions = function(s) {
    let res = 0, need = 0;

    for (let i = 0; i < s.length; i++) {
        if (s.charAt(i) == '(') {
            need += 2;
            if (need % 2 == 1) {
                res++;
                need--;
            }
        }

        if (s.charAt(i) == ')') {
            need--;
            if (need == -1) {
                res++;
                need = 1;
            }
        }
    }
    return res + need;
};
```

```python
# by chatGPT (python)
class Solution:
    def minInsertions(self, s: str) -> int:
        res = 0
        need = 0
        
        # Traverse through string s
        for i in range(len(s)):
            if s[i] == '(':
                need += 2
                if need % 2 == 1:
                    res += 1
                    need -= 1
            
            if s[i] == ')':
                need -= 1
                if need == -1:
                    res += 1
                    need = 1
        
        return res + need
```

https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // åŒºé—´è°ƒåº¦é—®é¢˜
    int findMinArrowShots(vector<vector<int>>& intvs) {
        if (intvs.size() == 0) return 0;
        // æŒ‰ end å‡åºæ’åº
        sort(intvs.begin(), intvs.end(), [](const auto& a, const auto& b) {
            return a[1] < b[1];
        });
        // è‡³å°‘æœ‰ä¸€ä¸ªåŒºé—´ä¸ç›¸äº¤
        int count = 1;
        // æ’åºåï¼Œç¬¬ä¸€ä¸ªåŒºé—´å°±æ˜¯ x
        int x_end = intvs[0][1];
        for (auto& interval : intvs) {
            int start = interval[0];
            // æŠŠ >= æ”¹æˆ > å°±è¡Œäº†
            if (start > x_end) {
                count++;
                x_end = interval[1];
            }
        }
        return count;
    }
};
```

```go
// by chatGPT (go)
import (
    "fmt"
    "sort"
)

// findMinArrowShots æ˜¯åŒºé—´è°ƒåº¦é—®é¢˜çš„è§£å†³æ–¹æ¡ˆ
func findMinArrowShots(intvs [][]int) int {
    if len(intvs) == 0 {
        return 0
    }
    // æŒ‰ end å‡åºæ’åº
    sort.Slice(intvs, func(i, j int) bool {
        return intvs[i][1] < intvs[j][1]
    })
    // è‡³å°‘æœ‰ä¸€ä¸ªåŒºé—´ä¸ç›¸äº¤
    count := 1
    // æ’åºåï¼Œç¬¬ä¸€ä¸ªåŒºé—´å°±æ˜¯ x
    xEnd := intvs[0][1]
    for _, interval := range intvs {
        start := interval[0]
        // æŠŠ >= æ”¹æˆ > å°±è¡Œäº†
        if start > xEnd {
            count++
            xEnd = interval[1]
        }
    }
    return count
}
```

```java
// by labuladong (java)
class Solution {
    // åŒºé—´è°ƒåº¦é—®é¢˜
    public int findMinArrowShots(int[][] intvs) {
        if (intvs.length == 0) return 0;
        // æŒ‰ end å‡åºæ’åº
        Arrays.sort(intvs, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return a[1] - b[1];
            }
        });
        // è‡³å°‘æœ‰ä¸€ä¸ªåŒºé—´ä¸ç›¸äº¤
        int count = 1;
        // æ’åºåï¼Œç¬¬ä¸€ä¸ªåŒºé—´å°±æ˜¯ x
        int x_end = intvs[0][1];
        for (int[] interval : intvs) {
            int start = interval[0];
            // æŠŠ >= æ”¹æˆ > å°±è¡Œäº†
            if (start > x_end) {
                count++;
                x_end = interval[1];
            }
        }
        return count;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} intvs
 * @return {number}
 */
var findMinArrowShots = function(intvs) {
    if (intvs.length == 0) return 0;
    // æŒ‰ end å‡åºæ’åº
    intvs.sort((a, b) => { return a[1] - b[1]; });
    // è‡³å°‘æœ‰ä¸€ä¸ªåŒºé—´ä¸ç›¸äº¤
    let count = 1;
    // æ’åºåï¼Œç¬¬ä¸€ä¸ªåŒºé—´å°±æ˜¯ x
    let xEnd = intvs[0][1];
    for (let interval of intvs) {
        let start = interval[0];
        // æŠŠ >= æ”¹æˆ > å°±è¡Œäº†
        if (start > xEnd) {
            count++;
            xEnd = interval[1];
        }
    }
    return count;
}
```

```python
# by chatGPT (python)
# åŒºé—´è°ƒåº¦é—®é¢˜
class Solution:
    def findMinArrowShots(self, intvs: List[List[int]]) -> int:
        if not intvs:
            return 0
        # æŒ‰ end å‡åºæ’åº
        intvs.sort(key=lambda x: x[1])
        # è‡³å°‘æœ‰ä¸€ä¸ªåŒºé—´ä¸ç›¸äº¤
        count = 1
        # æ’åºåï¼Œç¬¬ä¸€ä¸ªåŒºé—´å°±æ˜¯ x
        x_end = intvs[0][1]
        for interval in intvs:
            start = interval[0]
            # æŠŠ >= æ”¹æˆ > å°±è¡Œäº†
            if start > x_end:
                count += 1
                x_end = interval[1]
        return count
```

https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/minimum-path-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
private:
    int memo[205][205];

public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        memset(memo, -1, sizeof memo);

        return dp(grid, m - 1, n - 1);
    }

    int dp(vector<vector<int>>& grid, int i, int j) {
        // base case
        if (i == 0 && j == 0) {
            return grid[0][0];
        }
        if (i < 0 || j < 0) {
            return INT_MAX;
        }

        // é¿å…é‡å¤è®¡ç®—
        if (memo[i][j] != -1) {
            return memo[i][j];
        }

        // å°†è®¡ç®—ç»“æœè®°å…¥å¤‡å¿˜å½•
        memo[i][j] = min(
            dp(grid, i - 1, j),
            dp(grid, i, j - 1)
        ) + grid[i][j];

        return memo[i][j];
    }
};
```

```go
// by chatGPT (go)
import "math"

func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    // æ„é€ å¤‡å¿˜å½•ï¼Œåˆå§‹å€¼å…¨éƒ¨è®¾ä¸º -1
    memo := make([][]int, m)
    for i := range memo {
        memo[i] = make([]int, n)
        for j := range memo[i] {
            memo[i][j] = -1
        }
    }

    var dp func(i, j int) int
    dp = func(i, j int) int {
        // base case
        if i == 0 && j == 0 {
            return grid[0][0]
        }
        if i < 0 || j < 0 {
            return int(math.MaxInt64)
        }
        // é¿å…é‡å¤è®¡ç®—
        if memo[i][j] != -1 {
            return memo[i][j]
        }
        // å°†è®¡ç®—ç»“æœè®°å…¥å¤‡å¿˜å½•
        memo[i][j] = min(
            dp(i-1, j), 
            dp(i, j-1),
        ) + grid[i][j]

        return memo[i][j]
    }
    return dp(m-1, n-1)
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    int[][] memo;

    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        // æ„é€ å¤‡å¿˜å½•ï¼Œåˆå§‹å€¼å…¨éƒ¨è®¾ä¸º -1
        memo = new int[m][n];
        for (int[] row : memo)
            Arrays.fill(row, -1);

        return dp(grid, m - 1, n - 1);
    }

    int dp(int[][] grid, int i, int j) {
        // base case
        if (i == 0 && j == 0) {
            return grid[0][0];
        }
        if (i < 0 || j < 0) {
            return Integer.MAX_VALUE;
        }
        // é¿å…é‡å¤è®¡ç®—
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // å°†è®¡ç®—ç»“æœè®°å…¥å¤‡å¿˜å½•
        memo[i][j] = Math.min(
                dp(grid, i - 1, j),
                dp(grid, i, j - 1)
        ) + grid[i][j];

        return memo[i][j];
    }
}
```

```javascript
// by chatGPT (javascript)
var minPathSum = function(grid) {
    const m = grid.length;
    const n = grid[0].length;
    // æ„é€ å¤‡å¿˜å½•ï¼Œåˆå§‹å€¼å…¨éƒ¨è®¾ä¸º -1
    const memo = new Array(m);
    for (let i = 0; i < m; i++) {
        memo[i] = new Array(n).fill(-1);
    }

    return dp(grid, m - 1, n - 1);

    function dp(grid, i, j) {
        if (i === 0 && j === 0) {
            // base case
            return grid[0][0];
        }
        if (i < 0 || j < 0) {
            // è¶Šç•Œ
            return Infinity;
        }
        // é¿å…é‡å¤è®¡ç®—
        if (memo[i][j] !== -1) {
            return memo[i][j];
        }
        // å°†è®¡ç®—ç»“æœè®°å…¥å¤‡å¿˜å½•
        memo[i][j] = Math.min(
            dp(grid, i - 1, j),
            dp(grid, i, j - 1)
        ) + grid[i][j];

        return memo[i][j];
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        # æ„é€ å¤‡å¿˜å½•ï¼Œåˆå§‹å€¼å…¨éƒ¨è®¾ä¸º -1
        memo = [[-1 for _ in range(n)] for _ in range(m)]

        return self.dp(grid, m - 1, n - 1, memo)

    def dp(self, grid: List[List[int]], i: int, j: int, memo: List[List[int]]) -> int:
        # base case
        if i == 0 and j == 0:
            return grid[0][0]
        if i < 0 or j < 0:
            return float("inf")
        # é¿å…é‡å¤è®¡ç®—
        if memo[i][j] != -1:
            return memo[i][j]
        # å°†è®¡ç®—ç»“æœè®°å…¥å¤‡å¿˜å½•
        memo[i][j] = min(
            self.dp(grid, i - 1, j, memo),
            self.dp(grid, i, j - 1, memo)
        ) + grid[i][j]

        return memo[i][j]
```

https://leetcode.cn/problems/minimum-path-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/minimum-window-substring çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    string minWindow(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;

        int left = 0, right = 0;
        int valid = 0;
        // è®°å½•æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•åŠé•¿åº¦
        int start = 0, len = INT_MAX;
        /**<extend down -200>
        ![](../pictures/slidingwindow/1.png)
        */
        while (right < s.size()) {
            // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
            char c = s[right];
            // å³ç§»çª—å£
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c])
                    valid++;
            }

            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (valid == need.size()) {
                /**<extend down -200>
                ![](../pictures/slidingwindow/2.png)
                */
                // åœ¨è¿™é‡Œæ›´æ–°æœ€å°è¦†ç›–å­ä¸²
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
                char d = s[left];
                // å·¦ç§»çª—å£
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
            /**<extend up -50>
            ![](../pictures/slidingwindow/4.png)
            */
        }
        // è¿”å›æœ€å°è¦†ç›–å­ä¸²
        return len == INT_MAX ?
                "" : s.substr(start, len);
    }
};
```

```go
// by mario_huang (go)
func minWindow(s string, t string) string {
    need := map[byte]int{}
    window := map[byte]int{}
    for _, c := range []byte(t) {
        need[c]++
    }
    left, right := 0, 0
    valid := 0
    // è®°å½•æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•åŠé•¿åº¦
    start, length := 0, math.MaxInt
    /**<extend down -200>
      ![](../pictures/slidingwindow/1.png)
    */
    for right < len(s) {
        // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
        c := s[right]
        // å³ç§»çª—å£
        right++
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        if _, ok := need[c]; ok {
            window[c]++
            if window[c] == need[c] {
                valid++
            }
        }
        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        for valid == len(need) {
            /**<extend down -200>
              ![](../pictures/slidingwindow/2.png)
            */
            // åœ¨è¿™é‡Œæ›´æ–°æœ€å°è¦†ç›–å­ä¸²
            if right-left < length {
                start = left
                length = right - left
            }
            // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
            d := s[left]
            // å·¦ç§»çª—å£
            left++
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if _, ok := need[d]; ok {
                if window[d] == need[d] {
                    valid--
                }
                window[d]--
            }
        }
        /**<extend up -50>
          ![](../pictures/slidingwindow/4.png)
        */
    }
    // è¿”å›æœ€å°è¦†ç›–å­ä¸²
    if length == math.MaxInt {
        return ""
    } else {
        return s[start : start+length]
    }
}
```

```java
// by chatGPT (java)
class Solution {
    public String minWindow(String s, String t) {
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);

        int left = 0, right = 0;
        int valid = 0;
        // è®°å½•æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•åŠé•¿åº¦
        int start = 0, len = Integer.MAX_VALUE;

        while (right < s.length()) {
            // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
            char c = s.charAt(right);
            // å³ç§»çª—å£
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c).equals(need.get(c)))
                    valid++;
            }

            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (valid == need.size()) {
                // åœ¨è¿™é‡Œæ›´æ–°æœ€å°è¦†ç›–å­ä¸²
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
                char d = s.charAt(left);
                // å·¦ç§»çª—å£
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if (need.containsKey(d)) {
                    if (window.get(d).equals(need.get(d)))
                        valid--;
                    window.put(d, window.get(d) - 1);
                }
            }
        }

        // è¿”å›æœ€å°è¦†ç›–å­ä¸²
        return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);
    }
}
```

```javascript
// by chatGPT (javascript)
var minWindow = function(s, t) {
    const need = new Map();
    const window = new Map();
    // ç»Ÿè®¡ t ä¸­æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°
    for (let c of t) {
        need.set(c, need.has(c) ? need.get(c) + 1 : 1)
    }

    let left = 0, right = 0;
    let valid = 0;
    // è®°å½•æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•åŠé•¿åº¦
    let start = 0, len = Infinity;
    while (right < s.length) {
        // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
        let c = s[right];
        // å³ç§»çª—å£
        right++;
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        if (need.has(c)) {
            window.set(c, window.has(c) ? window.get(c) + 1 : 1)
            if (window.get(c) === need.get(c))
                valid++;
        }

        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        while (valid === need.size) {
            // åœ¨è¿™é‡Œæ›´æ–°æœ€å°è¦†ç›–å­ä¸²
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
            let d = s[left];
            // å·¦ç§»çª—å£
            left++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.has(d)) {
                if (window.get(d) === need.get(d))
                    valid--;
                window.set(d, window.get(d) - 1)
            }
        }
    }
    // è¿”å›æœ€å°è¦†ç›–å­ä¸²
    return len === Infinity ?
            "" : s.substr(start, len);
};
```

```python
# by chatGPT (python)
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        from collections import Counter
        need = Counter(t)
        window = Counter()

        left, right = 0, 0
        valid = 0
        # è®°å½•æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•åŠé•¿åº¦
        start, length = 0, float('inf')
        """
        <extend down -200>
        ![](../pictures/slidingwindow/1.png)
        """
        while right < len(s):
            # c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
            c = s[right]
            right += 1
            # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if c in need:
                window[c] += 1
                if window[c] == need[c]:
                    valid += 1

            # åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while valid == len(need):
                """
                <extend down -200>
                ![](../pictures/slidingwindow/2.png)
                """
                # åœ¨è¿™é‡Œæ›´æ–°æœ€å°è¦†ç›–å­ä¸²
                if right - left < length:
                    start = left
                    length = right - left
                # d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
                d = s[left]
                left += 1
                # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if d in need:
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1

            """
            <extend up -50>
            ![](../pictures/slidingwindow/4.png)
            """
        # è¿”å›æœ€å°è¦†ç›–å­ä¸²
        return '' if length == float('inf') else s[start:start+length]
```

https://leetcode.cn/problems/minimum-window-substring çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/missing-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int res = 0;
        // å…ˆå’Œæ–°è¡¥çš„ç´¢å¼•å¼‚æˆ–ä¸€ä¸‹
        res ^= n;
        // å’Œå…¶ä»–çš„å…ƒç´ ã€ç´¢å¼•åšå¼‚æˆ–
        for (int i = 0; i < n; i++)
            res ^= i ^ nums[i];
        return res;
    }
};
```

```go
// by chatGPT (go)
/*
 * @lc app=leetcode id=268 lang=golang
 *
 * [268] Missing Number
 *
 * https://leetcode.com/problems/missing-number/description/
 *
 * algorithms
 * Easy (49.34%)
 * Total Accepted:    321.9K
 * Total Submissions: 647.5K
 * Testcase Example:  '[3,0,1]'
 *
 * Given an array containing n distinct numbers taken from 0, 1, 2, ..., n,
 * find the one that is missing from the array.
 *
 * Example 1:
 *
 *
 * Input: [3,0,1]
 * Output: 2
 *
 *
 * Example 2:
 *
 *
 * Input: [9,6,4,2,3,5,7,0,1]
 * Output: 8
 *
 *
 * Note:
 * Your algorithm should run in linear runtime complexity. Could you implement
 * it using only constant extra space complexity?
 */

func missingNumber(nums []int) int {
    n := len(nums)
    res := 0
    // å…ˆå’Œæ–°è¡¥çš„ç´¢å¼•å¼‚æˆ–ä¸€ä¸‹
    res ^= n
    // å’Œå…¶ä»–çš„å…ƒç´ ã€ç´¢å¼•åšå¼‚æˆ–
    for i := 0; i < n; i++ {
        res ^= i ^ nums[i]
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int missingNumber(int[] nums) {
        int n = nums.length;
        int res = 0;
        // å…ˆå’Œæ–°è¡¥çš„ç´¢å¼•å¼‚æˆ–ä¸€ä¸‹
        res ^= n;
        // å’Œå…¶ä»–çš„å…ƒç´ ã€ç´¢å¼•åšå¼‚æˆ–
        for (int i = 0; i < n; i++)
            res ^= i ^ nums[i];
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var missingNumber = function(nums) {
    let n = nums.length;
    let res = 0;
    // å…ˆå’Œæ–°è¡¥çš„ç´¢å¼•å¼‚æˆ–ä¸€ä¸‹
    res ^= n;
    // å’Œå…¶ä»–çš„å…ƒç´ ã€ç´¢å¼•åšå¼‚æˆ–
    for (let i = 0; i < n; i++)
        res ^= i ^ nums[i];
    return res;
}
```

```python
# by chatGPT (python)
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        res = 0
        # å…ˆå’Œæ–°è¡¥çš„ç´¢å¼•å¼‚æˆ–ä¸€ä¸‹
        res ^= n
        # å’Œå…¶ä»–çš„å…ƒç´ ã€ç´¢å¼•åšå¼‚æˆ–
        for i in range(n):
            res ^= i ^ nums[i]
        return res
```

https://leetcode.cn/problems/missing-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int removeStones(vector<vector<int>>& stones) {
        int n = stones.size();

        // ä¸€ç»´åæ ‡ -> èŠ‚ç‚¹ ID
        unordered_map<int, int> codeToId;
        for (int i = 0; i < n; i++) {
            codeToId[encode(stones[i])] = i;
        }

        // è®°å½•æ¯ä¸€è¡Œæ¯ä¸€åˆ—æœ‰å“ªäº›èŠ‚ç‚¹
        unordered_map<int, vector<int>> colIndexToCodes, rowIndexToCodes;
        for (auto point : stones) {
            int x = point[0], y = point[1];
            rowIndexToCodes[x].push_back(encode(point));
            colIndexToCodes[y].push_back(encode(point));
        }

        // å¯åŠ¨ union find ç®—æ³•
        UF uf(n);

        // æŠŠæ¯ä¸€åˆ—çš„èŠ‚ç‚¹è¿é€š
        for (auto& [index, col] : colIndexToCodes) {
            int firstId = codeToId[col[0]];
            for (int i = 1; i < col.size(); i++) {
                int otherId = codeToId[col[i]];
                uf.my_union(firstId, otherId);
            }
        }

        // æŠŠæ¯ä¸€è¡Œçš„èŠ‚ç‚¹è¿é€š
        for (auto& [index, row] : rowIndexToCodes) {
            int firstId = codeToId[row[0]];
            for (int i = 1; i < row.size(); i++) {
                int otherId = codeToId[row[i]];
                uf.my_union(firstId, otherId);
            }
        }
        // çŸ³å¤´æ€»æ•° - è¿é€šåˆ†é‡æ•°é‡å°±æ˜¯è¢«æ¶ˆé™¤çš„çŸ³å¤´ä¸ªæ•°
        return n - uf.count();
    }

    // å°†äºŒç»´åæ ‡è½¬åŒ–æˆä¸€ç»´ç´¢å¼•
    int encode(vector<int>& point) {
        return point[0] * 10000 + point[1];
    }

};

// union find ç®—æ³•æ¨¡æ¿
class UF {
public:
    // è¿é€šåˆ†é‡ä¸ªæ•°
    int count;
    // å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
    vector<int> parent;

    // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
    UF(int n) : count(n), parent(n) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    void my_union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);

        if (rootP == rootQ) {
            return;
        }

        parent[rootQ] = rootP;
        // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        count--;
    }

    // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
};
```

```go
// by chatGPT (go)
func removeStones(stones [][]int) int {
    n := len(stones)

    // ä¸€ç»´åæ ‡ -> èŠ‚ç‚¹ ID
    codeToId := make(map[int]int, n)
    for i := 0; i < n; i++ {
        codeToId[encode(stones[i])] = i
    }

    // è®°å½•æ¯ä¸€è¡Œæ¯ä¸€åˆ—æœ‰å“ªäº›èŠ‚ç‚¹
    colIndexToCodes := make(map[int][]int)
    rowIndexToCodes := make(map[int][]int)
    for _, point := range stones {
        x, y := point[0], point[1]
        rowIndexToCodes[x] = append(rowIndexToCodes[x], encode(point))
        colIndexToCodes[y] = append(colIndexToCodes[y], encode(point))
    }

    // å¯åŠ¨ union find ç®—æ³•
    uf := newUF(n)

    // æŠŠæ¯ä¸€åˆ—çš„èŠ‚ç‚¹è¿é€š
    for _, col := range colIndexToCodes {
        firstId := codeToId[col[0]]
        for i := 1; i < len(col); i++ {
            otherId := codeToId[col[i]]
            uf.union(firstId, otherId)
        }
    }

    // æŠŠæ¯ä¸€è¡Œçš„èŠ‚ç‚¹è¿é€š
    for _, row := range rowIndexToCodes {
        firstId := codeToId[row[0]]
        for i := 1; i < len(row); i++ {
            otherId := codeToId[row[i]]
            uf.union(firstId, otherId)
        }
    }
    // çŸ³å¤´æ€»æ•° - è¿é€šåˆ†é‡æ•°é‡å°±æ˜¯è¢«æ¶ˆé™¤çš„çŸ³å¤´ä¸ªæ•°
    return n - uf.count()
}

// å°†äºŒç»´åæ ‡è½¬åŒ–æˆä¸€ç»´ç´¢å¼•
func encode(point []int) int {
    return point[0]*10000 + point[1]
}

type UF struct {
    // è¿é€šåˆ†é‡ä¸ªæ•°
    count int
    // å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
    parent []int
}

// n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
func newUF(n int) *UF {
    uf := new(UF)
    uf.count = n
    uf.parent = make([]int, n)
    for i := 0; i < n; i++ {
        uf.parent[i] = i
    }
    return uf
}

// å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
func (uf *UF) union(p int, q int) {
    rootP := uf.find(p)
    rootQ := uf.find(q)

    if rootP == rootQ {
        return
    }

    uf.parent[rootQ] = rootP
    // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
    uf.count--
}

// åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
func (uf *UF) connected(p int, q int) bool {
    rootP := uf.find(p)
    rootQ := uf.find(q)
    return rootP == rootQ
}

func (uf *UF) find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.find(uf.parent[x])
    }
    return uf.parent[x]
}

// è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
func (uf *UF) count() int {
    return uf.count
}
```

```java
// by labuladong (java)
class Solution {
    public int removeStones(int[][] stones) {
        int n = stones.length;

        // ä¸€ç»´åæ ‡ -> èŠ‚ç‚¹ ID
        HashMap<Integer, Integer> codeToId = new HashMap<>();
        for (int i = 0; i < n; i++) {
            codeToId.put(encode(stones[i]), i);
        }

        // è®°å½•æ¯ä¸€è¡Œæ¯ä¸€åˆ—æœ‰å“ªäº›èŠ‚ç‚¹
        HashMap<Integer, List<Integer>> colIndexToCodes = new HashMap<>();
        HashMap<Integer, List<Integer>> rowIndexToCodes = new HashMap<>();
        for (int[] point : stones) {
            int x = point[0], y = point[1];
            rowIndexToCodes.putIfAbsent(x, new ArrayList<>());
            colIndexToCodes.putIfAbsent(y, new ArrayList<>());
            rowIndexToCodes.get(x).add(encode(point));
            colIndexToCodes.get(y).add(encode(point));
        }

        // å¯åŠ¨ union find ç®—æ³•
        UF uf = new UF(n);

        // æŠŠæ¯ä¸€åˆ—çš„èŠ‚ç‚¹è¿é€š
        for (int index : colIndexToCodes.keySet()) {
            List<Integer> col = colIndexToCodes.get(index);
            int firstId = codeToId.get(col.get(0));
            for (int i = 1; i < col.size(); i++) {
                int otherId = codeToId.get(col.get(i));
                uf.union(firstId, otherId);
            }
        }

        // æŠŠæ¯ä¸€è¡Œçš„èŠ‚ç‚¹è¿é€š
        for (int index : rowIndexToCodes.keySet()) {
            List<Integer> row = rowIndexToCodes.get(index);
            int firstId = codeToId.get(row.get(0));
            for (int i = 1; i < row.size(); i++) {
                int otherId = codeToId.get(row.get(i));
                uf.union(firstId, otherId);
            }
        }
        // çŸ³å¤´æ€»æ•° - è¿é€šåˆ†é‡æ•°é‡å°±æ˜¯è¢«æ¶ˆé™¤çš„çŸ³å¤´ä¸ªæ•°
        return n - uf.count();
    }

    // å°†äºŒç»´åæ ‡è½¬åŒ–æˆä¸€ç»´ç´¢å¼•
    int encode(int[] point) {
        return point[0] * 10000 + point[1];
    }

}

// union find ç®—æ³•æ¨¡æ¿
class UF {
    // è¿é€šåˆ†é‡ä¸ªæ•°
    private int count;
    // å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
    private int[] parent;

    // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
    public UF(int n) {
        this.count = n;
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);

        if (rootP == rootQ) {
            return;
        }

        parent[rootQ] = rootP;
        // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        count--;
    }

    // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
    public int count() {
        return count;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} stones
 * @return {number}
 */
var removeStones = function(stones) {
    const n = stones.length;

    // ä¸€ç»´åæ ‡ -> èŠ‚ç‚¹ ID
    let codeToId = new Map();
    for (let i = 0; i < n; i++) {
        codeToId.set(encode(stones[i]), i);
    }

    // è®°å½•æ¯ä¸€è¡Œæ¯ä¸€åˆ—æœ‰å“ªäº›èŠ‚ç‚¹
    let colIndexToCodes = new Map();
    let rowIndexToCodes = new Map();
    stones.forEach(point => {
        const x = point[0], y = point[1];
        rowIndexToCodes.set(x, rowIndexToCodes.get(x) || []);
        colIndexToCodes.set(y, colIndexToCodes.get(y) || []);
        rowIndexToCodes.get(x).push(encode(point));
        colIndexToCodes.get(y).push(encode(point));
    });

    // å¯åŠ¨ union find ç®—æ³•
    let uf = new UF(n);

    // æŠŠæ¯ä¸€åˆ—çš„èŠ‚ç‚¹è¿é€š
    for (let index of colIndexToCodes.keys()) {
        const col = colIndexToCodes.get(index);
        const firstId = codeToId.get(col[0]);
        for (let i = 1; i < col.length; i++) {
            const otherId = codeToId.get(col[i]);
            uf.union(firstId, otherId);
        }
    }

    // æŠŠæ¯ä¸€è¡Œçš„èŠ‚ç‚¹è¿é€š
    for (let index of rowIndexToCodes.keys()) {
        const row = rowIndexToCodes.get(index);
        const firstId = codeToId.get(row[0]);
        for (let i = 1; i < row.length; i++) {
            const otherId = codeToId.get(row[i]);
            uf.union(firstId, otherId);
        }
    }

    // çŸ³å¤´æ€»æ•° - è¿é€šåˆ†é‡æ•°é‡å°±æ˜¯è¢«æ¶ˆé™¤çš„çŸ³å¤´ä¸ªæ•°
    return n - uf.count();
};

// å°†äºŒç»´åæ ‡è½¬åŒ–æˆä¸€ç»´ç´¢å¼•
function encode(point) {
    return point[0] * 10000 + point[1];
}

// union find ç®—æ³•æ¨¡æ¿
class UF {
    // è¿é€šåˆ†é‡ä¸ªæ•°
    count = 0;
    // å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
    parent = [];

    // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
    constructor(n) {
        this.count = n;
        this.parent = new Array(n).fill(0);
        for (let i = 0; i < n; i++) {
            this.parent[i] = i;
        }
    }

    // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    union(p, q) {
        let rootP = this.find(p);
        let rootQ = this.find(q);

        if (rootP === rootQ) {
            return;
        }

        this.parent[rootQ] = rootP;
        // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        this.count--;
    }

    // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    connected(p, q) {
        let rootP = this.find(p);
        let rootQ = this.find(q);
        return rootP === rootQ;
    }

    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
    }

    // è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
    count() {
        return this.count;
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        n = len(stones)

        # ä¸€ç»´åæ ‡ -> èŠ‚ç‚¹ ID
        codeToId = {}
        for i in range(n):
            codeToId[self.encode(stones[i])] = i

        # è®°å½•æ¯ä¸€è¡Œæ¯ä¸€åˆ—æœ‰å“ªäº›èŠ‚ç‚¹
        colIndexToCodes = {}
        rowIndexToCodes = {}
        for point in stones:
            x, y = point[0], point[1]
            rowIndexToCodes.setdefault(x, [])
            colIndexToCodes.setdefault(y, [])
            rowIndexToCodes[x].append(self.encode(point))
            colIndexToCodes[y].append(self.encode(point))

        # å¯åŠ¨ union find ç®—æ³•
        uf = UF(n)

        # æŠŠæ¯ä¸€åˆ—çš„èŠ‚ç‚¹è¿é€š
        for index in colIndexToCodes.keys():
            col = colIndexToCodes[index]
            firstId = codeToId[col[0]]
            for i in range(1, len(col)):
                otherId = codeToId[col[i]]
                uf.union(firstId, otherId)

        # æŠŠæ¯ä¸€è¡Œçš„èŠ‚ç‚¹è¿é€š
        for index in rowIndexToCodes.keys():
            row = rowIndexToCodes[index]
            firstId = codeToId[row[0]]
            for i in range(1, len(row)):
                otherId = codeToId[row[i]]
                uf.union(firstId, otherId)

        # çŸ³å¤´æ€»æ•° - è¿é€šåˆ†é‡æ•°é‡å°±æ˜¯è¢«æ¶ˆé™¤çš„çŸ³å¤´ä¸ªæ•°
        return n - uf.count()

    # å°†äºŒç»´åæ ‡è½¬åŒ–æˆä¸€ç»´ç´¢å¼•
    def encode(self, point: List[int]) -> int:
        return point[0] * 10000 + point[1]


# union find ç®—æ³•æ¨¡æ¿
class UF:
    # è¿é€šåˆ†é‡ä¸ªæ•°
    def __init__(self, n: int):
        # å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
        self.parent = list(range(n))
        self.count = n

    # å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    def union(self, p: int, q: int) -> None:
        rootP = self.find(p)
        rootQ = self.find(q)

        if rootP == rootQ:
            return

        self.parent[rootQ] = rootP
        # ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        self.count -= 1

    # åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    def connected(self, p: int, q: int) -> bool:
        rootP = self.find(p)
        rootQ = self.find(q)
        return rootP == rootQ

    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    # è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
    def count(self) -> int:
        return self.count
```

https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/move-zeroes çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // å»é™¤ nums ä¸­çš„æ‰€æœ‰ 0
        // è¿”å›å»é™¤ 0 ä¹‹åçš„æ•°ç»„é•¿åº¦
        int p = removeElement(nums, 0);
        // å°† p ä¹‹åçš„æ‰€æœ‰å…ƒç´ èµ‹å€¼ä¸º 0
        for (; p < nums.size(); p++) {
            nums[p] = 0;
        }
    }

    // åŒæŒ‡é’ˆæŠ€å·§ï¼Œå¤ç”¨ [27. ç§»é™¤å…ƒç´ ] çš„è§£æ³•ã€‚
    int removeElement(vector<int>& nums, int val) {
        int fast = 0, slow = 0;
        while (fast < nums.size()) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

```go
// by chatGPT (go)
func moveZeroes(nums []int) {
    // å»é™¤ nums ä¸­çš„æ‰€æœ‰ 0
    // è¿”å›å»é™¤ 0 ä¹‹åçš„æ•°ç»„é•¿åº¦
    p := removeElement(nums, 0)
    // å°† p ä¹‹åçš„æ‰€æœ‰å…ƒç´ èµ‹å€¼ä¸º 0
    for ; p < len(nums); p++ {
        nums[p] = 0
    }
}

// åŒæŒ‡é’ˆæŠ€å·§ï¼Œå¤ç”¨ [27. ç§»é™¤å…ƒç´ ] çš„è§£æ³•ã€‚
func removeElement(nums []int, val int) int {
    fast := 0
    slow := 0
    for fast < len(nums) {
        if nums[fast] != val {
            nums[slow] = nums[fast]
            slow++
        }
        fast++
    }
    return slow
}
```

```java
// by labuladong (java)
class Solution {
    public void moveZeroes(int[] nums) {
        // å»é™¤ nums ä¸­çš„æ‰€æœ‰ 0
        // è¿”å›å»é™¤ 0 ä¹‹åçš„æ•°ç»„é•¿åº¦
        int p = removeElement(nums, 0);
        // å°† p ä¹‹åçš„æ‰€æœ‰å…ƒç´ èµ‹å€¼ä¸º 0
        for (; p < nums.length; p++) {
            nums[p] = 0;
        }
    }

    // åŒæŒ‡é’ˆæŠ€å·§ï¼Œå¤ç”¨ [27. ç§»é™¤å…ƒç´ ] çš„è§£æ³•ã€‚
    int removeElement(int[] nums, int val) {
        int fast = 0, slow = 0;
        while (fast < nums.length) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
}
```

```javascript
// by chatGPT (javascript)
var moveZeroes = function(nums) {
    // å»é™¤ nums ä¸­çš„æ‰€æœ‰ 0
    // è¿”å›å»é™¤ 0 ä¹‹åçš„æ•°ç»„é•¿åº¦
    var p = removeElement(nums, 0);
    // å°† p ä¹‹åçš„æ‰€æœ‰å…ƒç´ èµ‹å€¼ä¸º 0
    for (; p < nums.length; p++) {
        nums[p] = 0;
    }
};

// åŒæŒ‡é’ˆæŠ€å·§ï¼Œå¤ç”¨ [27. ç§»é™¤å…ƒç´ ] çš„è§£æ³•ã€‚
var removeElement = function(nums, val) {
    var fast = 0, slow = 0;
    while (fast < nums.length) {
        if (nums[fast] !== val) {
            nums[slow] = nums[fast];
            slow++;
        }
        fast++;
    }
    return slow;
};
```

```python
# by chatGPT (python)
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # å»é™¤ nums ä¸­çš„æ‰€æœ‰ 0
        # è¿”å›å»é™¤ 0 ä¹‹åçš„æ•°ç»„é•¿åº¦
        p = self.removeElement(nums, 0)
        # å°† p ä¹‹åçš„æ‰€æœ‰å…ƒç´ èµ‹å€¼ä¸º 0
        for i in range(p, len(nums)):
            nums[i] = 0
            
    # åŒæŒ‡é’ˆæŠ€å·§ï¼Œå¤ç”¨ [27. ç§»é™¤å…ƒç´ ] çš„è§£æ³•ã€‚
    def removeElement(self, nums: List[int], val: int) -> int:
        fast = 0
        slow = 0
        while fast < len(nums):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return slow
```

https://leetcode.cn/problems/move-zeroes çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/n-ary-tree-level-order-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> res;
        if (root == nullptr) {
            return res;
        }

        // ä»¥ä¸‹æ˜¯æ ‡å‡†çš„ BFS ç®—æ³•éå†æ¡†æ¶
        queue<Node*> q;
        q.push(root);

        while (!q.empty()) {
            int sz = q.size();
            vector<int> level;
            for (int i = 0; i < sz; i++) {
                Node* cur = q.front();
                q.pop();
                level.push_back(cur->val);
                // å¤šå‰æ ‘å¯èƒ½æœ‰å¤šä¸ªå­èŠ‚ç‚¹ï¼Œå°†æ‰€æœ‰å­èŠ‚ç‚¹éƒ½åŠ å…¥é˜Ÿåˆ—
                for (Node* child : cur->children) {
                    q.push(child);
                }
            }
            // å½“å‰å±‚éå†å®Œæ¯•
            res.push_back(level);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func levelOrder(root *Node) [][]int {
    res := [][]int{}
    if root == nil {
        return res
    }
    
    // ä»¥ä¸‹æ˜¯æ ‡å‡†çš„ BFS ç®—æ³•éå†æ¡†æ¶
    q := []*Node{root}

    for len(q) != 0 {
        sz := len(q)
        level := []int{}
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]
            level = append(level, cur.Val)
            // å¤šå‰æ ‘å¯èƒ½æœ‰å¤šä¸ªå­èŠ‚ç‚¹ï¼Œå°†æ‰€æœ‰å­èŠ‚ç‚¹éƒ½åŠ å…¥é˜Ÿåˆ—
            for _, child := range cur.Children {
                q = append(q, child)
            }
        }
        // å½“å‰å±‚éå†å®Œæ¯•
        res = append(res, level)
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> res = new LinkedList<>();
        if (root == null) {
            return res;
        }
        
        // ä»¥ä¸‹æ˜¯æ ‡å‡†çš„ BFS ç®—æ³•éå†æ¡†æ¶
        Queue<Node> q = new LinkedList<>();
        q.offer(root);

        while (!q.isEmpty()) {
            int sz = q.size();
            List<Integer> level = new LinkedList<>();
            for (int i = 0; i < sz; i++) {
                Node cur = q.poll();
                level.add(cur.val);
                // å¤šå‰æ ‘å¯èƒ½æœ‰å¤šä¸ªå­èŠ‚ç‚¹ï¼Œå°†æ‰€æœ‰å­èŠ‚ç‚¹éƒ½åŠ å…¥é˜Ÿåˆ—
                for (Node child : cur.children) {
                    q.offer(child);
                }
            }
            // å½“å‰å±‚éå†å®Œæ¯•
            res.add(level);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
// å°† Java ä»£ç è½¬åŒ–ä¸º JavaScript ä»£ç 
var levelOrder = function(root) {
  // åˆ›å»ºä¸€ä¸ªæ•°ç»„ res æ¥å­˜å‚¨éå†ç»“æœ
  const res = []
  if (!root) {
    // å¦‚æœç»“ç‚¹ä¸º null åˆ™è¿”å› res æ•°ç»„
    return res
  }
  
  // åˆ›å»ºä¸€ä¸ªé˜Ÿåˆ— q ç”¨äº BFS éå†
  let q = []
  q.push(root)

  while (q.length > 0) {
    // è®°å½•å½“å‰é˜Ÿåˆ—ä¸­å…ƒç´ ä¸ªæ•°
    const sz = q.length
    // åˆ›å»ºä¸€ä¸ªæ•°ç»„ level æ¥å­˜å‚¨å½“å‰å±‚æ‰€æœ‰ç»“ç‚¹çš„å€¼
    const level = []
    for (let i = 0; i < sz; i++) {
      // å¼¹å‡ºé˜Ÿå¤´ç»“ç‚¹ cur å¹¶å°†å…¶å€¼åŠ å…¥ level æ•°ç»„ä¸­
      const cur = q.shift()
      level.push(cur.val)

      // å°†å½“å‰ç»“ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— q ä¸­
      for (const child of cur.children) {
        q.push(child)
      }
    }
  
    // å°†å½“å‰å±‚çš„å€¼ level åŠ å…¥åˆ° res æ•°ç»„ä¸­
    res.push(level)
  }
  
  // è¿”å›éå†ç»“æœ
  return res
}
```

```python
# by chatGPT (python)
class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        res = []
        if not root:
            return res

        # ä»¥ä¸‹æ˜¯æ ‡å‡†çš„ BFS ç®—æ³•éå†æ¡†æ¶
        q = deque()
        q.append(root)

        while q:
            sz = len(q)
            level = []
            for i in range(sz):
                cur = q.popleft()
                level.append(cur.val)
                # å¤šå‰æ ‘å¯èƒ½æœ‰å¤šä¸ªå­èŠ‚ç‚¹ï¼Œå°†æ‰€æœ‰å­èŠ‚ç‚¹éƒ½åŠ å…¥é˜Ÿåˆ—
                for child in cur.children:
                    q.append(child)
            # å½“å‰å±‚éå†å®Œæ¯•
            res.append(level)
        return res
```

https://leetcode.cn/problems/n-ary-tree-level-order-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/n-ary-tree-postorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> postorder(Node* root) {
        traverse(root);
        return res;
    }

private:
    vector<int> res;

    void traverse(Node* root) {
        if (root == nullptr) {
            return;
        }
        // å‰åºéå†ä½ç½®
        for (Node* child : root->children) {
            traverse(child);
        }
        // ååºéå†ä½ç½®
        res.push_back(root->val);
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Children []*Node
 * }
 */

func postorder(root *Node) []int {
    res := make([]int, 0)
    traverse(root, &res) // use closure to avoid using global variable
    return res
}

func traverse(root *Node, res *[]int) {
    if root == nil {
        return
    }
    // å‰åºéå†ä½ç½®
    for _, child := range root.Children {
        traverse(child, res)
    }
    // ååºéå†ä½ç½®
    *res = append(*res, root.Val)
}
```

```java
// by labuladong (java)
class Solution {
    public List<Integer> postorder(Node root) {
        traverse(root);
        return res;
    }

    List<Integer> res = new LinkedList<>();

    void traverse(Node root) {
        if (root == null) {
            return;
        }
        // å‰åºéå†ä½ç½®
        for (Node child : root.children) {
            traverse(child);
        }
        // ååºéå†ä½ç½®
        res.add(root.val);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {Node} root
 * @return {number[]}
 */
var postorder = function(root) {
    var res = [];

    var traverse = function(root) {
        if (root === null) {
            return;
        }
        // å‰åºéå†ä½ç½®
        for (var i = 0; i < root.children.length; i++) {
            traverse(root.children[i]);
        }
        // ååºéå†ä½ç½®
        res.push(root.val);
    };

    traverse(root);
    return res;
}
```

```python
# by chatGPT (python)
# Definition for a Node.
# class Node:
#     def __init__(self, val=None, children=None):
#         self.val = val
#         self.children = children if children is not None else []

class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        self.traverse(root)
        return self.res
    
    res = []

    def traverse(self, root: 'Node') -> None:
        if not root:
            return
        # å‰åºéå†ä½ç½®
        for child in root.children:
            self.traverse(child)
        # ååºéå†ä½ç½®
        self.res.append(root.val)
```

https://leetcode.cn/problems/n-ary-tree-postorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/n-ary-tree-preorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> preorder(Node* root) {
        traverse(root);
        return res;
    }

private:
    vector<int> res;

    void traverse(Node* root) {
        if (!root) {
            return;
        }
        // å‰åºéå†ä½ç½®
        res.push_back(root->val);
        for (Node* child : root->children) {
            traverse(child);
        }
        // ååºéå†ä½ç½®
    }
};
```

```go
// by chatGPT (go)
import "container/list"

// Node Definition
type Node struct {
    Val      int
    Children []*Node
}

func preorder(root *Node) []int {
    var res []int
    traverse(root, &res)
    return res
}

func traverse(root *Node, res *[]int) {
    if root == nil {
        return
    }
    // å‰åºéå†ä½ç½®
    *res = append(*res, root.Val)
    for _, child := range root.Children {
        traverse(child, res)
    }
    // ååºéå†ä½ç½®
}
```

```java
// by labuladong (java)
class Solution {
    public List<Integer> preorder(Node root) {
        traverse(root);
        return res;
    }

    List<Integer> res = new LinkedList<>();

    void traverse(Node root) {
        if (root == null) {
            return;
        }
        // å‰åºéå†ä½ç½®
        res.add(root.val);
        for (Node child : root.children) {
            traverse(child);
        }
        // ååºéå†ä½ç½®
    }
}
```

```javascript
// by chatGPT (javascript)
var preorder = function(root) {
    var res = [];

    var traverse = function(root) {
        if (root === null) {
            return;
        }
        // å‰åºéå†ä½ç½®
        res.push(root.val);
        for (var i = 0; i < root.children.length; i++) {
            traverse(root.children[i]);
        }
        // ååºéå†ä½ç½®
    }

    traverse(root);
    return res;
}
```

```python
# by chatGPT (python)
class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        self.traverse(root)
        return self.res
    
    def __init__(self):
        self.res = []

    def traverse(self, root: 'Node'):
        if not root:
            return
        # å‰åºéå†ä½ç½®
        self.res.append(root.val)
        for child in root.children:
            self.traverse(child)
        # ååºéå†ä½ç½®
```

https://leetcode.cn/problems/n-ary-tree-preorder-traversal çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/n-queens çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    vector<vector<string>> res;

    /* è¾“å…¥æ£‹ç›˜è¾¹é•¿ nï¼Œè¿”å›æ‰€æœ‰åˆæ³•çš„æ”¾ç½® */
    vector<vector<string>> solveNQueens(int n) {
        // '.' è¡¨ç¤ºç©ºï¼Œ'Q' è¡¨ç¤ºçš‡åï¼Œåˆå§‹åŒ–ç©ºæ£‹ç›˜ã€‚
        vector<string> board(n, string(n, '.'));
        backtrack(board, 0);
        return res;
    }

    // è·¯å¾„ï¼šboard ä¸­å°äº row çš„é‚£äº›è¡Œéƒ½å·²ç»æˆåŠŸæ”¾ç½®äº†çš‡å
    // é€‰æ‹©åˆ—è¡¨ï¼šç¬¬ row è¡Œçš„æ‰€æœ‰åˆ—éƒ½æ˜¯æ”¾ç½®çš‡åçš„é€‰æ‹©
    // ç»“æŸæ¡ä»¶ï¼šrow è¶…è¿‡ board çš„æœ€åä¸€è¡Œ
    void backtrack(vector<string>& board, int row) {
        // è§¦å‘ç»“æŸæ¡ä»¶
        if (row == board.size()) {
            res.push_back(board);
            return;
        }

        int n = board[row].size();
        for (int col = 0; col < n; col++) {
            // æ’é™¤ä¸åˆæ³•é€‰æ‹©
            if (!isValid(board, row, col)) {
                /**<extend up -200>
                ![](../pictures/backtracking/7.jpg)
                */
                continue;
            }
            // åšé€‰æ‹©
            board[row][col] = 'Q';
            // è¿›å…¥ä¸‹ä¸€è¡Œå†³ç­–
            backtrack(board, row + 1);
            // æ’¤é”€é€‰æ‹©
            board[row][col] = '.';
        }
    }

    /* æ˜¯å¦å¯ä»¥åœ¨ board[row][col] æ”¾ç½®çš‡åï¼Ÿ*/
    bool isValid(vector<string>& board, int row, int col) {
        int n = board.size();
        // æ£€æŸ¥åˆ—æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
        for (int i = 0; i <= row; i++) {
            if (board[i][col] == 'Q')
                return false;
        }
        // æ£€æŸ¥å³ä¸Šæ–¹æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
        for (int i = row - 1, j = col + 1;
             i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q')
                return false;
        }
        // æ£€æŸ¥å·¦ä¸Šæ–¹æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
        for (int i = row - 1, j = col - 1;
             i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q')
                return false;
        }
        return true;
    }
};
```

```go
// by chatGPT (go)
type backtracking struct {
    res [][]string
}

func (b *backtracking) solveNQueens(n int) [][]string {
    board := make([]string, n)
    for i := 0; i < n; i++ {
        board[i] = strings.Repeat(".", n)
    }
    b.backtrack(board, 0)
    return b.res
}

func (b *backtracking) backtrack(board []string, row int) {
    if row == len(board) {
        temp := make([]string, len(board))
        copy(temp, board)
        b.res = append(b.res, temp)
        return
    }

    n := len(board[row])
    for col := 0; col < n; col++ {
        if !b.isValid(board, row, col) {
            // æ’é™¤ä¸åˆæ³•é€‰æ‹©
            continue
        }
        // åšé€‰æ‹©
        board[row] = board[row][:col] + "Q" + board[row][col+1:]
        // è¿›å…¥ä¸‹ä¸€è¡Œå†³ç­–
        b.backtrack(board, row+1)
        // æ’¤é”€é€‰æ‹©
        board[row] = board[row][:col] + "." + board[row][col+1:]
    }
}

func (b *backtracking) isValid(board []string, row, col int) bool {
    n := len(board)
    // æ£€æŸ¥åˆ—æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
    for i := 0; i <= row; i++ {
        if board[i][col] == 'Q' {
            return false
        }
    }
    // æ£€æŸ¥å³ä¸Šæ–¹æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
    for i, j := row-1, col+1; i >= 0 && j < n; i, j = i-1, j+1 {
        if board[i][j] == 'Q' {
            return false
        }
    }
    // æ£€æŸ¥å·¦ä¸Šæ–¹æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
    for i, j := row-1, col-1; i >= 0 && j >= 0; i, j = i-1, j-1 {
        if board[i][j] == 'Q' {
            return false
        }
    }
    return true
}
```

```java
// by chatGPT (java)
class Solution {
    List<List<String>> res = new ArrayList<>();

    /**
     * è¾“å…¥æ£‹ç›˜è¾¹é•¿ nï¼Œè¿”å›æ‰€æœ‰åˆæ³•çš„æ”¾ç½®
     */
    public List<List<String>> solveNQueens(int n) {
        // '.' è¡¨ç¤ºç©ºï¼Œ'Q' è¡¨ç¤ºçš‡åï¼Œåˆå§‹åŒ–ç©ºæ£‹ç›˜ã€‚
        List<String> board = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            sb.append('.');
        }
        for (int i = 0; i < n; i++) {
            board.add(sb.toString());
        }
        backtrack(board, 0);
        return res;
    }

    /**
     * *è·¯å¾„ï¼šboard ä¸­å°äº row çš„é‚£äº›è¡Œéƒ½å·²ç»æˆåŠŸæ”¾ç½®äº†çš‡å
     * *é€‰æ‹©åˆ—è¡¨ï¼šç¬¬ row è¡Œçš„æ‰€æœ‰åˆ—éƒ½æ˜¯æ”¾ç½®çš‡åçš„é€‰æ‹©
     * *ç»“æŸæ¡ä»¶ï¼šrow è¶…è¿‡ board çš„æœ€åä¸€è¡Œ
     */
    private void backtrack(List<String> board, int row) {
        if (row == board.size()) {
            res.add(new ArrayList<>(board));
            return;
        }

        int n = board.get(row).length();
        for (int col = 0; col < n; col++) {
            // æ’é™¤ä¸åˆæ³•é€‰æ‹©
            if (!isValid(board, row, col)) {
                /**<extend up -200>
                ![](../pictures/backtracking/7.jpg)
                */
                continue;
            }
            // åšé€‰æ‹©
            char[] arr = board.get(row).toCharArray();
            arr[col] = 'Q';
            board.set(row, String.valueOf(arr));
            // è¿›å…¥ä¸‹ä¸€è¡Œå†³ç­–
            backtrack(board, row + 1);
            // æ’¤é”€é€‰æ‹©
            arr[col] = '.';
            board.set(row, String.valueOf(arr));
        }
    }

    /* æ˜¯å¦å¯ä»¥åœ¨ board[row][col] æ”¾ç½®çš‡åï¼Ÿ*/
    private boolean isValid(List<String> board, int row, int col) {
        int n = board.size();

        // æ£€æŸ¥åˆ—æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
        for (int i = 0; i <= row; i++) {
            if (board.get(i).charAt(col) == 'Q') {
                return false;
            }
        }

        // æ£€æŸ¥å³ä¸Šæ–¹æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board.get(i).charAt(j) == 'Q') {
                return false;
            }
        }

        // æ£€æŸ¥å·¦ä¸Šæ–¹æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board.get(i).charAt(j) == 'Q') {
                return false;
            }
        }

        return true;
    }
}
```

```javascript
// by chatGPT (javascript)
var solveNQueens = function(n) {
  var res = [];

  // '.' è¡¨ç¤ºç©ºï¼Œ'Q' è¡¨ç¤ºçš‡åï¼Œåˆå§‹åŒ–ç©ºæ£‹ç›˜ã€‚
  var board = new Array(n);
  for (var i = 0; i < n; i++) {
    board[i] = new Array(n).fill('.');
  }

  backtrack(board, 0);

  return res;

  // è·¯å¾„ï¼šboard ä¸­å°äº row çš„é‚£äº›è¡Œéƒ½å·²ç»æˆåŠŸæ”¾ç½®äº†çš‡å
  // é€‰æ‹©åˆ—è¡¨ï¼šç¬¬ row è¡Œçš„æ‰€æœ‰åˆ—éƒ½æ˜¯æ”¾ç½®çš‡åçš„é€‰æ‹©
  // ç»“æŸæ¡ä»¶ï¼šrow è¶…è¿‡ board çš„æœ€åä¸€è¡Œ
  function backtrack(board, row) {
    // è§¦å‘ç»“æŸæ¡ä»¶
    if (row === board.length) {
      res.push(Array.from(board, row => row.join('')));
      return;
    }

    var n = board.length;
    for (var col = 0; col < n; col++) {
      // æ’é™¤ä¸åˆæ³•é€‰æ‹©
      if (!isValid(board, row, col)) {
        continue;
      }
      // åšé€‰æ‹©
      board[row][col] = 'Q';
      // è¿›å…¥ä¸‹ä¸€è¡Œå†³ç­–
      backtrack(board, row + 1);
      // æ’¤é”€é€‰æ‹©
      board[row][col] = '.';
    }
  }

  /* æ˜¯å¦å¯ä»¥åœ¨ board[row][col] æ”¾ç½®çš‡åï¼Ÿ*/
  function isValid(board, row, col) {
    var n = board.length;
    // æ£€æŸ¥åˆ—æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
    for (var i = 0; i <= row; i++) {
      if (board[i][col] === 'Q') {
        return false;
      }
    }
    // æ£€æŸ¥å³ä¸Šæ–¹æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
    for (var i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
      if (board[i][j] === 'Q') {
        return false;
      }
    }
    // æ£€æŸ¥å·¦ä¸Šæ–¹æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
    for (var i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
      if (board[i][j] === 'Q') {
        return false;
      }
    }
    return true;
  }
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.res = []

    def solveNQueens(self, n: int) -> List[List[str]]:
        board = [['.' for j in range(n)] for i in range(n)]  # åˆå§‹åŒ–ç©ºæ£‹ç›˜
        self.backtrack(board, 0)
        return self.res

    def backtrack(self, board: List[List[str]], row: int):
        if row == len(board):  # è§¦å‘ç»“æŸæ¡ä»¶
            self.res.append([''.join(board[i]) for i in range(len(board))])
            return

        for col in range(len(board[row])):
            if not self.isValid(board, row, col):  # æ’é™¤ä¸åˆæ³•é€‰æ‹©
                continue
            board[row][col] = 'Q'  # åšé€‰æ‹©
            self.backtrack(board, row + 1)  # è¿›å…¥ä¸‹ä¸€è¡Œå†³ç­–
            board[row][col] = '.'  # æ’¤é”€é€‰æ‹©

    def isValid(self, board: List[List[str]], row: int, col: int) -> bool:
        n = len(board)
        # æ£€æŸ¥åˆ—æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
        for i in range(row + 1):
            if board[i][col] == 'Q':
                return False
        # æ£€æŸ¥å³ä¸Šæ–¹æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
        for i, j in zip(range(row - 1, -1, -1), range(col + 1, n)):
            if board[i][j] == 'Q':
                return False
        # æ£€æŸ¥å·¦ä¸Šæ–¹æ˜¯å¦æœ‰çš‡åäº’ç›¸å†²çª
        for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):
            if board[i][j] == 'Q':
                return False
        return True
```

https://leetcode.cn/problems/n-queens çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/nZZqjQ çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int H) {
        int left = 1;
        int right = 1000000000 + 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (f(piles, mid) <= H) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    // å®šä¹‰ï¼šé€Ÿåº¦ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å°æ—¶åƒå®Œæ‰€æœ‰é¦™è•‰
    // f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
    int f(vector<int>& piles, int x) {
        int hours = 0;
        for (int pile : piles) {
            hours += (pile + x - 1) / x;
        }
        return hours;
    }
};
```

```go
// by chatGPT (go)
// Go Solution Code for LeetCode Problem 875: Koko Eating Bananas

func minEatingSpeed(piles []int, H int) int {
    left := 1
    right := 1000000000 + 1

    for left < right {
        mid := left + (right - left) / 2
        if f(piles, mid) <= H {
            right = mid
        } else {
            left = mid + 1
        }
    }
    return left
}

// å®šä¹‰ï¼šé€Ÿåº¦ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å°æ—¶åƒå®Œæ‰€æœ‰é¦™è•‰
// f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
func f(piles []int, x int) int {
    hours := 0
    for i := 0; i < len(piles); i++ {
        hours += piles[i] / x
        if piles[i] % x > 0 {
            hours++
        }
    }
    return hours
}
```

```java
// by labuladong (java)
class Solution {
    public int minEatingSpeed(int[] piles, int H) {
        int left = 1;
        int right = 1000000000 + 1;

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (f(piles, mid) <= H) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    // å®šä¹‰ï¼šé€Ÿåº¦ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å°æ—¶åƒå®Œæ‰€æœ‰é¦™è•‰
    // f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
    int f(int[] piles, int x) {
        int hours = 0;
        for (int i = 0; i < piles.length; i++) {
            hours += piles[i] / x;
            if (piles[i] % x > 0) {
                hours++;
            }
        }
        return hours;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} piles
 * @param {number} H
 * @return {number}
 */
var minEatingSpeed = function(piles, H) {
    let left = 1;
    let right = 1000000000 + 1;

    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (f(piles, mid) <= H) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
};

// å®šä¹‰ï¼šé€Ÿåº¦ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å°æ—¶åƒå®Œæ‰€æœ‰é¦™è•‰
// f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
function f(piles, x) {
    let hours = 0;
    for (let i = 0; i < piles.length; i++) {
        hours += Math.floor(piles[i] / x);
        if (piles[i] % x > 0) {
            hours++;
        }
    }
    return hours;
}
```

```python
# by chatGPT (python)
class Solution:
    def minEatingSpeed(self, piles: List[int], H: int) -> int:
        left = 1
        right = 1000000000 + 1

        while left < right:
            mid = left + (right - left) // 2
            if self.f(piles, mid) <= H:
                right = mid
            else:
                left = mid + 1
        return left

    # å®šä¹‰ï¼šé€Ÿåº¦ä¸º x æ—¶ï¼Œéœ€è¦ f(x) å°æ—¶åƒå®Œæ‰€æœ‰é¦™è•‰
    # f(x) éšç€ x çš„å¢åŠ å•è°ƒé€’å‡
    def f(self, piles: List[int], x: int) -> int:
        hours = 0
        for i in range(len(piles)):
            hours += piles[i] // x
            if piles[i] % x > 0:
                hours += 1
        return hours
```

https://leetcode.cn/problems/nZZqjQ çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int m = maze.size();
        int n = maze[0].size();
        vector<vector<int>> dirs {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        
        // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
        queue<vector<int>> queue;
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        queue.push(entrance);
        visited[entrance[0]][entrance[1]] = true;
        // å¯åŠ¨ BFS ç®—æ³•ä» entrance å¼€å§‹åƒå››å‘¨æ‰©æ•£
        int step = 0;
        while (!queue.empty()) {
            int sz = queue.size();
            step++;
            // æ‰©æ•£å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
            for (int i = 0; i < sz; i++) {
                vector<int> cur = queue.front();
                queue.pop();
                // æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šå°è¯•å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘æ‰©å±•ä¸€æ­¥
                for (vector<int> dir : dirs) {
                    int x = cur[0] + dir[0];
                    int y = cur[1] + dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n
                            || visited[x][y] || maze[x][y] == '+') {
                        continue;
                    }
                    if (x == 0 || x == m - 1 || y == 0 || y == n - 1) {
                        // èµ°åˆ°è¾¹ç•Œï¼ˆå‡ºå£ï¼‰
                        return step;
                    }
                    visited[x][y] = true;
                    queue.push(vector<int>{x, y});
                }
            }
        }
        return -1;
    }
};
```

```go
// by chatGPT (go)
func nearestExit(maze [][]byte, entrance []int) int {
    m, n := len(maze), len(maze[0])
    dirs := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}

    // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
    queue := [][]int{entrance}
    visited := make([][]bool, m)
    for i := 0; i < m; i++ {
        visited[i] = make([]bool, n)
    }
    visited[entrance[0]][entrance[1]] = true
    // å¯åŠ¨ BFS ç®—æ³•ä» entrance å¼€å§‹åƒå››å‘¨æ‰©æ•£
    step := 0
    for len(queue) > 0 {
        sz := len(queue)
        step++
        // æ‰©æ•£å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
        for i := 0; i < sz; i++ {
            cur := queue[0]
            queue = queue[1:]
            // æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šå°è¯•å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘æ‰©å±•ä¸€æ­¥
            for _, dir := range dirs {
                x := cur[0] + dir[0]
                y := cur[1] + dir[1]
                if x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || maze[x][y] == '+' {
                    continue
                }
                if x == 0 || x == m-1 || y == 0 || y == n-1 {
                    // èµ°åˆ°è¾¹ç•Œï¼ˆå‡ºå£ï¼‰
                    return step
                }
                visited[x][y] = true
                queue = append(queue, []int{x, y})
            }
        }
    }
    return -1
}
```

```java
// by labuladong (java)
class Solution {
    public int nearestExit(char[][] maze, int[] entrance) {
        int m = maze.length;
        int n = maze[0].length;
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] visited = new boolean[m][n];
        queue.offer(entrance);
        visited[entrance[0]][entrance[1]] = true;
        // å¯åŠ¨ BFS ç®—æ³•ä» entrance å¼€å§‹åƒå››å‘¨æ‰©æ•£
        int step = 0;
        while (!queue.isEmpty()) {
            int sz = queue.size();
            step++;
            // æ‰©æ•£å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
            for (int i = 0; i < sz; i++) {
                int[] cur = queue.poll();
                // æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šå°è¯•å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘æ‰©å±•ä¸€æ­¥
                for (int[] dir : dirs) {
                    int x = cur[0] + dir[0];
                    int y = cur[1] + dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n
                            || visited[x][y] || maze[x][y] == '+') {
                        continue;
                    }
                    if (x == 0 || x == m - 1 || y == 0 || y == n - 1) {
                        // èµ°åˆ°è¾¹ç•Œï¼ˆå‡ºå£ï¼‰
                        return step;
                    }
                    visited[x][y] = true;
                    queue.offer(new int[]{x, y});
                }
            }
        }
        return -1;
    }
}
```

```javascript
// by chatGPT (javascript)
var nearestExit = function(maze, entrance) {
    const m = maze.length;
    const n = maze[0].length;
    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];

    // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
    const queue = [];
    const visited = Array(m).fill(0).map(() => Array(n).fill(false));
    queue.push(entrance);
    visited[entrance[0]][entrance[1]] = true;

    // å¯åŠ¨ BFS ç®—æ³•ä» entrance å¼€å§‹åƒå››å‘¨æ‰©æ•£
    let step = 0;
    while (queue.length) {
        const sz = queue.length;
        step++;

        // æ‰©æ•£å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
        for (let i = 0; i < sz; i++) {
            const cur = queue.shift();

            // æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šå°è¯•å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘æ‰©å±•ä¸€æ­¥
            for (const dir of dirs) {
                const x = cur[0] + dir[0];
                const y = cur[1] + dir[1];

                if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || maze[x][y] === '+') {
                    continue;
                }

                if (x === 0 || x === m - 1 || y === 0 || y === n - 1) {
                    // èµ°åˆ°è¾¹ç•Œï¼ˆå‡ºå£ï¼‰
                    return step;
                }

                visited[x][y] = true;
                queue.push([x, y]);
            }
        }
    }

    return -1;
};
```

```python
# by chatGPT (python)
class Solution:
    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
        m, n = len(maze), len(maze[0])
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        # BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
        queue = deque()
        visited = [[False] * n for _ in range(m)]
        queue.append(tuple(entrance))
        visited[entrance[0]][entrance[1]] = True
        # å¯åŠ¨ BFS ç®—æ³•ä» entrance å¼€å§‹åƒå››å‘¨æ‰©æ•£
        step = 0
        while queue:
            sz = len(queue)
            step += 1
            # æ‰©æ•£å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
            for _ in range(sz):
                cur_x, cur_y = queue.popleft()
                # æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šå°è¯•å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘æ‰©å±•ä¸€æ­¥
                for dir_x, dir_y in dirs:
                    nxt_x, nxt_y = cur_x + dir_x, cur_y + dir_y
                    if nxt_x < 0 or nxt_x >= m or nxt_y < 0 or nxt_y >= n \
                            or visited[nxt_x][nxt_y] or maze[nxt_x][nxt_y] == '+':
                        continue
                    if nxt_x == 0 or nxt_x == m - 1 or nxt_y == 0 or nxt_y == n - 1:
                        # èµ°åˆ°è¾¹ç•Œï¼ˆå‡ºå£ï¼‰
                        return step
                    visited[nxt_x][nxt_y] = True
                    queue.append((nxt_x, nxt_y))
        return -1
```

https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/network-delay-time çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        // èŠ‚ç‚¹ç¼–å·æ˜¯ä» 1 å¼€å§‹çš„ï¼Œæ‰€ä»¥è¦ä¸€ä¸ªå¤§å°ä¸º n + 1 çš„é‚»æ¥è¡¨
        vector<vector<pair<int, int>>> graph(n + 1);
        for (int i = 1; i <= n; i++) {
            graph[i] = vector<pair<int, int>>();
        }
        // æ„é€ å›¾
        for (auto& edge : times) {
            int from = edge[0];
            int to = edge[1];
            int weight = edge[2];
            // from -> List<(to, weight)>
            // é‚»æ¥è¡¨å­˜å‚¨å›¾ç»“æ„ï¼ŒåŒæ—¶å­˜å‚¨æƒé‡ä¿¡æ¯
            graph[from].emplace_back(to, weight);
        }
        // å¯åŠ¨ dijkstra ç®—æ³•è®¡ç®—ä»¥èŠ‚ç‚¹ k ä¸ºèµ·ç‚¹åˆ°å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„
        vector<int> distTo = dijkstra(k, graph, n);

        // æ‰¾åˆ°æœ€é•¿çš„é‚£ä¸€æ¡æœ€çŸ­è·¯å¾„
        int res = 0;
        for (int i = 1; i < distTo.size(); i++) {
            if (distTo[i] == INT_MAX) {
                // æœ‰èŠ‚ç‚¹ä¸å¯è¾¾ï¼Œè¿”å› -1
                return -1;
            }
            res = max(res, distTo[i]);
        }
        return res;
    }

private:
    // è¾“å…¥ä¸€ä¸ªèµ·ç‚¹ startï¼Œè®¡ç®—ä» start åˆ°å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»
    vector<int> dijkstra(int start, vector<vector<pair<int, int>>>& graph, int n) {
        // å®šä¹‰ï¼šdistTo[i] çš„å€¼å°±æ˜¯èµ·ç‚¹ start åˆ°è¾¾èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„æƒé‡
        vector<int> distTo(n + 1, INT_MAX);
        // base caseï¼Œstart åˆ° start çš„æœ€çŸ­è·ç¦»å°±æ˜¯ 0
        distTo[start] = 0;

        // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒdistFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        // ä»èµ·ç‚¹ start å¼€å§‹è¿›è¡Œ BFS
        pq.emplace(0, start);

        while (!pq.empty()) {
            auto [curDistFromStart, curNodeID] = pq.top();
            pq.pop();

            if (curDistFromStart > distTo[curNodeID]) {
                continue;
            }

            // å°† curNode çš„ç›¸é‚»èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
            for (auto& [nextNodeID, weight] : graph[curNodeID]) {
                int distToNextNode = distTo[curNodeID] + weight;
                // æ›´æ–° dp table
                if (distTo[nextNodeID] > distToNextNode) {
                    distTo[nextNodeID] = distToNextNode;
                    pq.emplace(distToNextNode, nextNodeID);
                }
            }
        }
        return distTo;
    }
};
```

```go
// by chatGPT (go)
import (
	"container/heap"
	"math"
)

func networkDelayTime(times [][]int, n int, k int) int {
	// èŠ‚ç‚¹ç¼–å·æ˜¯ä» 1 å¼€å§‹çš„ï¼Œæ‰€ä»¥è¦ä¸€ä¸ªå¤§å°ä¸º n + 1 çš„é‚»æ¥è¡¨
	graph := make([][][]int, n+1)
	for i := 1; i <= n; i++ {
		graph[i] = make([][]int, 0)
	}

	// æ„é€ å›¾
	for _, edge := range times {
		from := edge[0]
		to := edge[1]
		weight := edge[2]
		// from -> [ [to, weight], ... ]
		// é‚»æ¥è¡¨å­˜å‚¨å›¾ç»“æ„ï¼ŒåŒæ—¶å­˜å‚¨æƒé‡ä¿¡æ¯
		graph[from] = append(graph[from], []int{to, weight})
	}

	// å¯åŠ¨ dijkstra ç®—æ³•è®¡ç®—ä»¥èŠ‚ç‚¹ k ä¸ºèµ·ç‚¹åˆ°å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„
	distTo := dijkstra(k, graph)

	// æ‰¾åˆ°æœ€é•¿çš„é‚£ä¸€æ¡æœ€çŸ­è·¯å¾„
	res := 0
	for i := 1; i < len(distTo); i++ {
		if distTo[i] == math.MaxInt32 {
			// æœ‰èŠ‚ç‚¹ä¸å¯è¾¾ï¼Œè¿”å› -1
			return -1
		}
		res = max(res, distTo[i])
	}
	return res
}

type State struct {
	// å›¾èŠ‚ç‚¹çš„ id
	id int
	// ä» start èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·ç¦»
	distFromStart int
}

type PriorityQueue []*State

func (pq PriorityQueue) Len() int { return len(pq) }
func (pq PriorityQueue) Less(i, j int) bool {
	return pq[i].distFromStart < pq[j].distFromStart
}
func (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] }

func (pq *PriorityQueue) Push(x interface{}) {
	item := x.(*State)
	*pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() interface{} {
	old := *pq
	n := len(old)
	item := old[n-1]
	old[n-1] = nil       // avoid memory leak
	*pq = old[0 : n-1]
	return item
}

// è¾“å…¥ä¸€ä¸ªèµ·ç‚¹ startï¼Œè®¡ç®—ä» start åˆ°å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»
func dijkstra(start int, graph [][][]int) []int {
	// å®šä¹‰ï¼šdistTo[i] çš„å€¼å°±æ˜¯èµ·ç‚¹ start åˆ°è¾¾èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„æƒé‡
	distTo := make([]int, len(graph))
	for i := 1; i < len(graph); i++ {
		distTo[i] = math.MaxInt32
	}
	// base caseï¼Œstart åˆ° start çš„æœ€çŸ­è·ç¦»å°±æ˜¯ 0
	distTo[start] = 0

	// ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒdistFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
	pq := make(PriorityQueue, 0)
	heap.Init(&pq)
	// ä»èµ·ç‚¹ start å¼€å§‹è¿›è¡Œ BFS
	heap.Push(&pq, &State{id: start, distFromStart: 0})

	for pq.Len() > 0 {
		curState := heap.Pop(&pq).(*State)
		curNodeID := curState.id
		curDistFromStart := curState.distFromStart

		if curDistFromStart > distTo[curNodeID] {
			continue
		}

		// å°† curNode çš„ç›¸é‚»èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
		for _, neighbor := range graph[curNodeID] {
			nextNodeID := neighbor[0]
			distToNextNode := distTo[curNodeID] + neighbor[1]
			// æ›´æ–° dp table
			if distTo[nextNodeID] > distToNextNode {
				distTo[nextNodeID] = distToNextNode
				heap.Push(&pq, &State{id: nextNodeID, distFromStart: distToNextNode})
			}
		}
	}
	return distTo
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

```java
// by labuladong (java)
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        // èŠ‚ç‚¹ç¼–å·æ˜¯ä» 1 å¼€å§‹çš„ï¼Œæ‰€ä»¥è¦ä¸€ä¸ªå¤§å°ä¸º n + 1 çš„é‚»æ¥è¡¨
        List<int[]>[] graph = new LinkedList[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new LinkedList<>();
        }
        // æ„é€ å›¾
        for (int[] edge : times) {
            int from = edge[0];
            int to = edge[1];
            int weight = edge[2];
            // from -> List<(to, weight)>
            // é‚»æ¥è¡¨å­˜å‚¨å›¾ç»“æ„ï¼ŒåŒæ—¶å­˜å‚¨æƒé‡ä¿¡æ¯
            graph[from].add(new int[]{to, weight});
        }
        // å¯åŠ¨ dijkstra ç®—æ³•è®¡ç®—ä»¥èŠ‚ç‚¹ k ä¸ºèµ·ç‚¹åˆ°å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„
        int[] distTo = dijkstra(k, graph);

        // æ‰¾åˆ°æœ€é•¿çš„é‚£ä¸€æ¡æœ€çŸ­è·¯å¾„
        int res = 0;
        for (int i = 1; i < distTo.length; i++) {
            if (distTo[i] == Integer.MAX_VALUE) {
                // æœ‰èŠ‚ç‚¹ä¸å¯è¾¾ï¼Œè¿”å› -1
                return -1;
            }
            res = Math.max(res, distTo[i]);
        }
        return res;
    }

    class State {
        // å›¾èŠ‚ç‚¹çš„ id
        int id;
        // ä» start èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·ç¦»
        int distFromStart;

        State(int id, int distFromStart) {
            this.id = id;
            this.distFromStart = distFromStart;
        }
    }

    // è¾“å…¥ä¸€ä¸ªèµ·ç‚¹ startï¼Œè®¡ç®—ä» start åˆ°å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»
    int[] dijkstra(int start, List<int[]>[] graph) {
        // å®šä¹‰ï¼šdistTo[i] çš„å€¼å°±æ˜¯èµ·ç‚¹ start åˆ°è¾¾èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„æƒé‡
        int[] distTo = new int[graph.length];
        Arrays.fill(distTo, Integer.MAX_VALUE);
        // base caseï¼Œstart åˆ° start çš„æœ€çŸ­è·ç¦»å°±æ˜¯ 0
        distTo[start] = 0;

        // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒdistFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
        Queue<State> pq = new PriorityQueue<>((a, b) -> {
            return a.distFromStart - b.distFromStart;
        });
        // ä»èµ·ç‚¹ start å¼€å§‹è¿›è¡Œ BFS
        pq.offer(new State(start, 0));

        while (!pq.isEmpty()) {
            State curState = pq.poll();
            int curNodeID = curState.id;
            int curDistFromStart = curState.distFromStart;

            if (curDistFromStart > distTo[curNodeID]) {
                continue;
            }

            // å°† curNode çš„ç›¸é‚»èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
            for (int[] neighbor : graph[curNodeID]) {
                int nextNodeID = neighbor[0];
                int distToNextNode = distTo[curNodeID] + neighbor[1];
                // æ›´æ–° dp table
                if (distTo[nextNodeID] > distToNextNode) {
                    distTo[nextNodeID] = distToNextNode;
                    pq.offer(new State(nextNodeID, distToNextNode));
                }
            }
        }
        return distTo;
    }
}
```

```javascript
// by chatGPT (javascript)
var networkDelayTime = function(times, n, k) {
    // èŠ‚ç‚¹ç¼–å·æ˜¯ä» 1 å¼€å§‹çš„ï¼Œæ‰€ä»¥è¦ä¸€ä¸ªå¤§å°ä¸º n + 1 çš„é‚»æ¥è¡¨
    let graph = new Array(n + 1);
    for (let i = 1; i <= n; i++) {
        graph[i] = [];
    }
    // æ„é€ å›¾
    for (let edge of times) {
        let from = edge[0];
        let to = edge[1];
        let weight = edge[2];
        // from -> List<(to, weight)>
        // é‚»æ¥è¡¨å­˜å‚¨å›¾ç»“æ„ï¼ŒåŒæ—¶å­˜å‚¨æƒé‡ä¿¡æ¯
        graph[from].push([to, weight]);
    }
    // å¯åŠ¨ dijkstra ç®—æ³•è®¡ç®—ä»¥èŠ‚ç‚¹ k ä¸ºèµ·ç‚¹åˆ°å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„
    let distTo = dijkstra(k, graph);

    // æ‰¾åˆ°æœ€é•¿çš„é‚£ä¸€æ¡æœ€çŸ­è·¯å¾„
    let res = 0;
    for (let i = 1; i < distTo.length; i++) {
        if (distTo[i] === Infinity) {
            // æœ‰èŠ‚ç‚¹ä¸å¯è¾¾ï¼Œè¿”å› -1
            return -1;
        }
        res = Math.max(res, distTo[i]);
    }
    return res;
};

class State {
    // å›¾èŠ‚ç‚¹çš„ id
    constructor(id, distFromStart) {
        this.id = id;
        // ä» start èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·ç¦»
        this.distFromStart = distFromStart;
    }
}

// è¾“å…¥ä¸€ä¸ªèµ·ç‚¹ startï¼Œè®¡ç®—ä» start åˆ°å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»
function dijkstra(start, graph) {
    // å®šä¹‰ï¼šdistTo[i] çš„å€¼å°±æ˜¯èµ·ç‚¹ start åˆ°è¾¾èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„æƒé‡
    let distTo = new Array(graph.length).fill(Infinity);
    // base caseï¼Œstart åˆ° start çš„æœ€çŸ­è·ç¦»å°±æ˜¯ 0
    distTo[start] = 0;

    // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒdistFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
    let pq = [];
    // ä»èµ·ç‚¹ start å¼€å§‹è¿›è¡Œ BFS
    pq.push(new State(start, 0));
    pq.sort((a, b) => {
        return a.distFromStart - b.distFromStart;
    });

    while (pq.length > 0) {
        let curState = pq.shift();
        let curNodeID = curState.id;
        let curDistFromStart = curState.distFromStart;

        if (curDistFromStart > distTo[curNodeID]) {
            continue;
        }

        // å°† curNode çš„ç›¸é‚»èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
        for (let neighbor of graph[curNodeID]) {
            let nextNodeID = neighbor[0];
            let distToNextNode = distTo[curNodeID] + neighbor[1];
            // æ›´æ–° dp table
            if (distTo[nextNodeID] > distToNextNode) {
                distTo[nextNodeID] = distToNextNode;
                pq.push(new State(nextNodeID, distToNextNode));
                pq.sort((a, b) => {
                    return a.distFromStart - b.distFromStart;
                });
            }
        }
    }
    return distTo;
}
```

```python
# by chatGPT (python)
import heapq
from typing import List

class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        # èŠ‚ç‚¹ç¼–å·æ˜¯ä» 1 å¼€å§‹çš„ï¼Œæ‰€ä»¥è¦ä¸€ä¸ªå¤§å°ä¸º n + 1 çš„é‚»æ¥è¡¨
        graph = [[] for _ in range(n+1)]
        for edge in times:
            from_node, to_node, weight = edge[0], edge[1], edge[2]
            # from -> List<(to, weight)>
            # é‚»æ¥è¡¨å­˜å‚¨å›¾ç»“æ„ï¼ŒåŒæ—¶å­˜å‚¨æƒé‡ä¿¡æ¯
            graph[from_node].append((to_node, weight))
        # å¯åŠ¨ dijkstra ç®—æ³•è®¡ç®—ä»¥èŠ‚ç‚¹ k ä¸ºèµ·ç‚¹åˆ°å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„
        dist_to = self.dijkstra(k, graph)

        # æ‰¾åˆ°æœ€é•¿çš„é‚£ä¸€æ¡æœ€çŸ­è·¯å¾„
        res = 0
        for i in range(1, len(dist_to)):
            if dist_to[i] == float('inf'):
                # æœ‰èŠ‚ç‚¹ä¸å¯è¾¾ï¼Œè¿”å› -1
                return -1
            res = max(res, dist_to[i])
        return res

    class State:
        # å›¾èŠ‚ç‚¹çš„ id
        def __init__(self, id: int, dist_from_start: int):
            self.id = id
            # ä» start èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·ç¦»
            self.dist_from_start = dist_from_start

        def __lt__(self, other):
            return self.dist_from_start < other.dist_from_start

    # è¾“å…¥ä¸€ä¸ªèµ·ç‚¹ startï¼Œè®¡ç®—ä» start åˆ°å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»
    def dijkstra(self, start: int, graph: List[List[int]]) -> List[int]:
        # å®šä¹‰ï¼šdistTo[i] çš„å€¼å°±æ˜¯èµ·ç‚¹ start åˆ°è¾¾èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„æƒé‡
        dist_to = [float('inf')] * len(graph)
        # base caseï¼Œstart åˆ° start çš„æœ€çŸ­è·ç¦»å°±æ˜¯ 0
        dist_to[start] = 0

        # ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒdistFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
        pq = [Solution.State(start, 0)]
        # ä»èµ·ç‚¹ start å¼€å§‹è¿›è¡Œ BFS
        heapq.heapify(pq)

        while pq:
            cur_state = heapq.heappop(pq)
            cur_node_id = cur_state.id
            cur_dist_from_start = cur_state.dist_from_start

            if cur_dist_from_start > dist_to[cur_node_id]:
                continue

            # å°† cur_node çš„ç›¸é‚»èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
            for neighbor in graph[cur_node_id]:
                next_node_id, dist_to_next_node = neighbor[0], dist_to[cur_node_id] + neighbor[1]
                # æ›´æ–° dp table
                if dist_to[next_node_id] > dist_to_next_node:
                    dist_to[next_node_id] = dist_to_next_node
                    heapq.heappush(pq, Solution.State(next_node_id, dist_to_next_node))
        return dist_to
```

https://leetcode.cn/problems/network-delay-time çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/next-greater-element-i çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        // è®°å½• nums2 ä¸­æ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
        vector<int> greater = nextGreaterElement(nums2);
        // è½¬åŒ–æˆæ˜ å°„ï¼šå…ƒç´  x -> x çš„ä¸‹ä¸€ä¸ªæœ€å¤§å…ƒç´ 
        map<int, int> greaterMap;
        for (int i = 0; i < nums2.size(); i++) {
            greaterMap[nums2[i]] = greater[i];
        }
        // nums1 æ˜¯ nums2 çš„å­é›†ï¼Œæ‰€ä»¥æ ¹æ® greaterMap å¯ä»¥å¾—åˆ°ç»“æœ
        vector<int> res(nums1.size());
        for (int i = 0; i < nums1.size(); i++) {
            res[i] = greaterMap[nums1[i]];
        }
        return res;
    }

    // è®¡ç®— nums ä¸­æ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
    vector<int> nextGreaterElement(vector<int>& nums) {
        int n = nums.size();
        // å­˜æ”¾ç­”æ¡ˆçš„æ•°ç»„
        vector<int> res(n);
        stack<int> s;
        // å€’ç€å¾€æ ˆé‡Œæ”¾
        for (int i = n - 1; i >= 0; i--) {
            // åˆ¤å®šä¸ªå­é«˜çŸ®
            while (!s.empty() && s.top() <= nums[i]) {
                // çŸ®ä¸ªèµ·å¼€ï¼Œåæ­£ä¹Ÿè¢«æŒ¡ç€äº†ã€‚ã€‚ã€‚
                s.pop();
            }
            // nums[i] èº«åçš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
            res[i] = s.empty() ? -1 : s.top();
            s.push(nums[i]);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
import "fmt"

func nextGreaterElement(nums1 []int, nums2 []int) []int {
    // è®°å½• nums2 ä¸­æ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
    greater := nextGreater(nums2)
    // è½¬åŒ–æˆæ˜ å°„ï¼šå…ƒç´  x -> x çš„ä¸‹ä¸€ä¸ªæœ€å¤§å…ƒç´ 
    greaterMap := make(map[int]int)
    for i, v := range nums2 {
        greaterMap[v] = greater[i]
    }
    // nums1 æ˜¯ nums2 çš„å­é›†ï¼Œæ‰€ä»¥æ ¹æ® greaterMap å¯ä»¥å¾—åˆ°ç»“æœ
    res := make([]int, len(nums1))
    for i, v := range nums1 {
        res[i] = greaterMap[v]
    }
    return res
}

// è®¡ç®— nums ä¸­æ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
func nextGreater(nums []int) []int {
    n := len(nums)
    // å­˜æ”¾ç­”æ¡ˆçš„æ•°ç»„
    res := make([]int, n)
    s := []int{}
    // å€’ç€å¾€æ ˆé‡Œæ”¾
    for i := n - 1; i >= 0; i-- {
        // åˆ¤å®šä¸ªå­é«˜çŸ®
        for len(s) != 0 && s[len(s)-1] <= nums[i] {
            // çŸ®ä¸ªèµ·å¼€ï¼Œåæ­£ä¹Ÿè¢«æŒ¡ç€äº†ã€‚ã€‚ã€‚
            s = s[:len(s)-1]
        }
        // nums[i] èº«åçš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
        if len(s) == 0 {
            res[i] = -1
        } else {
            res[i] = s[len(s)-1]
        }
        s = append(s, nums[i])
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        // è®°å½• nums2 ä¸­æ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
        int[] greater = nextGreaterElement(nums2);
        // è½¬åŒ–æˆæ˜ å°„ï¼šå…ƒç´  x -> x çš„ä¸‹ä¸€ä¸ªæœ€å¤§å…ƒç´ 
        HashMap<Integer, Integer> greaterMap = new HashMap<>();
        for (int i = 0; i < nums2.length; i++) {
            greaterMap.put(nums2[i], greater[i]);
        }
        // nums1 æ˜¯ nums2 çš„å­é›†ï¼Œæ‰€ä»¥æ ¹æ® greaterMap å¯ä»¥å¾—åˆ°ç»“æœ
        int[] res = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            res[i] = greaterMap.get(nums1[i]);
        }
        return res;
    }

    // è®¡ç®— nums ä¸­æ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
    int[] nextGreaterElement(int[] nums) {
        int n = nums.length;
        // å­˜æ”¾ç­”æ¡ˆçš„æ•°ç»„
        int[] res = new int[n];
        Stack<Integer> s = new Stack<>();
        // å€’ç€å¾€æ ˆé‡Œæ”¾
        for (int i = n - 1; i >= 0; i--) {
            // åˆ¤å®šä¸ªå­é«˜çŸ®
            while (!s.isEmpty() && s.peek() <= nums[i]) {
                // çŸ®ä¸ªèµ·å¼€ï¼Œåæ­£ä¹Ÿè¢«æŒ¡ç€äº†ã€‚ã€‚ã€‚
                s.pop();
            }
            // nums[i] èº«åçš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
            res[i] = s.isEmpty() ? -1 : s.peek();
            s.push(nums[i]);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var nextGreaterElement = function(nums1, nums2) {
    // è®°å½• nums2 ä¸­æ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
    var greater = nextGreater(nums2);
    // è½¬åŒ–æˆæ˜ å°„ï¼šå…ƒç´  x -> x çš„ä¸‹ä¸€ä¸ªæœ€å¤§å…ƒç´ 
    var greaterMap = new Map();
    for (var i = 0; i < nums2.length; i++) {
        greaterMap.set(nums2[i], greater[i]);
    }
    // nums1 æ˜¯ nums2 çš„å­é›†ï¼Œæ‰€ä»¥æ ¹æ® greaterMap å¯ä»¥å¾—åˆ°ç»“æœ
    var res = new Array(nums1.length);
    for (var i = 0; i < nums1.length; i++) {
        res[i] = greaterMap.get(nums1[i]);
    }
    return res;
};

// è®¡ç®— nums ä¸­æ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
var nextGreater = function(nums) {
    var n = nums.length;
    // å­˜æ”¾ç­”æ¡ˆçš„æ•°ç»„
    var res = new Array(n);
    var s = [];
    // å€’ç€å¾€æ ˆé‡Œæ”¾
    for (var i = n - 1; i >= 0; i--) {
        // åˆ¤å®šä¸ªå­é«˜çŸ®
        while (s.length && s[s.length-1] <= nums[i]) {
            // çŸ®ä¸ªèµ·å¼€ï¼Œåæ­£ä¹Ÿè¢«æŒ¡ç€äº†ã€‚ã€‚ã€‚
            s.pop();
        }
        // nums[i] èº«åçš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
        res[i] = s.length == 0 ? -1 : s[s.length-1];
        s.push(nums[i]);
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # è®°å½• nums2 ä¸­æ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
        greater = self.nextGreater(nums2)
        # è½¬åŒ–æˆæ˜ å°„ï¼šå…ƒç´  x -> x çš„ä¸‹ä¸€ä¸ªæœ€å¤§å…ƒç´ 
        greaterMap = {}
        for i in range(len(nums2)):
            greaterMap[nums2[i]] = greater[i]
        # nums1 æ˜¯ nums2 çš„å­é›†ï¼Œæ‰€ä»¥æ ¹æ® greaterMap å¯ä»¥å¾—åˆ°ç»“æœ
        res = []
        for num in nums1:
            res.append(greaterMap[num])
        return res

    # è®¡ç®— nums ä¸­æ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
    def nextGreater(self, nums: List[int]) -> List[int]:
        n = len(nums)
        # å­˜æ”¾ç­”æ¡ˆçš„æ•°ç»„
        res = [-1] * n
        s = []
        # å€’ç€å¾€æ ˆé‡Œæ”¾
        for i in range(n - 1, -1, -1):
            # åˆ¤å®šä¸ªå­é«˜çŸ®
            while s and s[-1] <= nums[i]:
                # çŸ®ä¸ªèµ·å¼€ï¼Œåæ­£ä¹Ÿè¢«æŒ¡ç€äº†ã€‚ã€‚ã€‚
                s.pop()
            # nums[i] èº«åçš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
            if s:
                res[i] = s[-1]
            s.append(nums[i])
        return res
```

https://leetcode.cn/problems/next-greater-element-i çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/nim-game çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool canWinNim(int n) {
        // å¦‚æœä¸Šæ¥å°±è¸©åˆ° 4 çš„å€æ•°ï¼Œé‚£å°±è®¤è¾“å§
        // å¦åˆ™ï¼Œå¯ä»¥æŠŠå¯¹æ–¹æ§åˆ¶åœ¨ 4 çš„å€æ•°ï¼Œå¿…èƒœ
        return n % 4 != 0;
    }
};
```

```go
// by chatGPT (go)
func canWinNim(n int) bool {
    // å¦‚æœä¸Šæ¥å°±è¸©åˆ° 4 çš„å€æ•°ï¼Œé‚£å°±è®¤è¾“å§
    // å¦åˆ™ï¼Œå¯ä»¥æŠŠå¯¹æ–¹æ§åˆ¶åœ¨ 4 çš„å€æ•°ï¼Œå¿…èƒœ
    return n % 4 != 0
}
```

```java
// by labuladong (java)
class Solution {
    public boolean canWinNim(int n) {
        // å¦‚æœä¸Šæ¥å°±è¸©åˆ° 4 çš„å€æ•°ï¼Œé‚£å°±è®¤è¾“å§
        // å¦åˆ™ï¼Œå¯ä»¥æŠŠå¯¹æ–¹æ§åˆ¶åœ¨ 4 çš„å€æ•°ï¼Œå¿…èƒœ
        return n % 4 != 0;
    }
}
```

```javascript
// by chatGPT (javascript)
var canWinNim = function(n) {
    // å¦‚æœä¸Šæ¥å°±è¸©åˆ° 4 çš„å€æ•°ï¼Œé‚£å°±è®¤è¾“å§
    // å¦åˆ™ï¼Œå¯ä»¥æŠŠå¯¹æ–¹æ§åˆ¶åœ¨ 4 çš„å€æ•°ï¼Œå¿…èƒœ
    return n % 4 !== 0;
};
```

```python
# by chatGPT (python)
class Solution:
    def canWinNim(self, n: int) -> bool:
        # å¦‚æœä¸Šæ¥å°±è¸©åˆ° 4 çš„å€æ•°ï¼Œé‚£å°±è®¤è¾“å§
        # å¦åˆ™ï¼Œå¯ä»¥æŠŠå¯¹æ–¹æ§åˆ¶åœ¨ 4 çš„å€æ•°ï¼Œå¿…èƒœ
        return n % 4 != 0
```

https://leetcode.cn/problems/nim-game çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/non-decreasing-subsequences çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        if (nums.empty()) {
            return res;
        }
        backtrack(nums, 0);
        return res;
    }
    
private:
    vector<vector<int>> res;
    // è®°å½•å›æº¯çš„è·¯å¾„
    deque<int> track;  
    
    // å›æº¯ç®—æ³•ä¸»å‡½æ•°
    void backtrack(vector<int>& nums, int start) {
        if (track.size() >= 2) {
            // æ‰¾åˆ°ä¸€ä¸ªåˆæ³•ç­”æ¡ˆ
            res.push_back(vector<int>(track.begin(), track.end()));
        }
        // ç”¨å“ˆå¸Œé›†åˆé˜²æ­¢é‡å¤é€‰æ‹©ç›¸åŒå…ƒç´ 
        unordered_set<int> used;
        // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
        for (int i = start; i < nums.size(); i++) {
            // ä¿è¯é›†åˆä¸­å…ƒç´ éƒ½æ˜¯é€’å¢é¡ºåº
            if (!track.empty() && track.back() > nums[i]) {
                continue;
            }
            // ä¿è¯ä¸è¦é‡å¤ä½¿ç”¨ç›¸åŒçš„å…ƒç´ 
            if (used.count(nums[i])) {
                continue;
            }
            // é€‰æ‹© nums[i]
            used.insert(nums[i]);
            track.push_back(nums[i]);
            // é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
            backtrack(nums, i + 1);
            // æ’¤é”€é€‰æ‹© nums[i]
            track.pop_back();
        }
    }
};
```

```go
// by chatGPT (go)
func findSubsequences(nums []int) [][]int {
    res := [][]int{}
    if len(nums) == 0 {
        return res
    }
    track := []int{}
    backtrack(nums, 0, &track, &res)
    return res
}

// å›æº¯ç®—æ³•ä¸»å‡½æ•°
func backtrack(nums []int, start int, track *[]int, res *[][]int) {
    if len(*track) >= 2 {
        // æ‰¾åˆ°ä¸€ä¸ªåˆæ³•ç­”æ¡ˆ
        temp := make([]int, len(*track))
        copy(temp, *track)
        *res = append(*res, temp)
    }
    // ç”¨å“ˆå¸Œé›†åˆé˜²æ­¢é‡å¤é€‰æ‹©ç›¸åŒå…ƒç´ 
    used := make(map[int]bool)
    // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
    for i := start; i < len(nums); i++ {
        // ä¿è¯é›†åˆä¸­å…ƒç´ éƒ½æ˜¯é€’å¢é¡ºåº
        if len(*track) > 0 && (*track)[len(*track)-1] > nums[i] {
            continue
        }
        // ä¿è¯ä¸è¦é‡å¤ä½¿ç”¨ç›¸åŒçš„å…ƒç´ 
        if used[nums[i]] {
            continue
        }
        // é€‰æ‹© nums[i]
        used[nums[i]] = true
        *track = append(*track, nums[i])
        // é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
        backtrack(nums, i+1, track, res)
        // æ’¤é”€é€‰æ‹© nums[i]
        *track = (*track)[:len(*track)-1]
    }
}
```

```java
// by labuladong (java)
class Solution {
    public List<List<Integer>> findSubsequences(int[] nums) {
        if (nums.length == 0) {
            return res;
        }
        backtrack(nums, 0);
        return res;
    }

    List<List<Integer>> res = new LinkedList<>();
    // è®°å½•å›æº¯çš„è·¯å¾„
    LinkedList<Integer> track = new LinkedList<>();

    // å›æº¯ç®—æ³•ä¸»å‡½æ•°
    void backtrack(int[] nums, int start) {
        if (track.size() >= 2) {
            // æ‰¾åˆ°ä¸€ä¸ªåˆæ³•ç­”æ¡ˆ
            res.add(new LinkedList<>(track));
        }
        // ç”¨å“ˆå¸Œé›†åˆé˜²æ­¢é‡å¤é€‰æ‹©ç›¸åŒå…ƒç´ 
        HashSet<Integer> used = new HashSet<>();
        // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
        for (int i = start; i < nums.length; i++) {
            // ä¿è¯é›†åˆä¸­å…ƒç´ éƒ½æ˜¯é€’å¢é¡ºåº
            if (!track.isEmpty() && track.getLast() > nums[i]) {
                continue;
            }
            // ä¿è¯ä¸è¦é‡å¤ä½¿ç”¨ç›¸åŒçš„å…ƒç´ 
            if (used.contains(nums[i])) {
                /**<extend up -200>
                 ![](../pictures/æ’åˆ—ç»„åˆ/9.jpeg)
                 */
                continue;
            }
            // é€‰æ‹© nums[i]
            used.add(nums[i]);
            track.add(nums[i]);
            // é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
            backtrack(nums, i + 1);
            // æ’¤é”€é€‰æ‹© nums[i]
            track.removeLast();
        }
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var findSubsequences = function(nums) {
    var res = [];
    // è®°å½•å›æº¯çš„è·¯å¾„
    var track = [];

    // å›æº¯ç®—æ³•ä¸»å‡½æ•°
    var backtrack = function(nums, start) {
        if (track.length >= 2) {
            // æ‰¾åˆ°ä¸€ä¸ªåˆæ³•ç­”æ¡ˆ
            res.push([...track]);
        }
        // ç”¨å“ˆå¸Œé›†åˆé˜²æ­¢é‡å¤é€‰æ‹©ç›¸åŒå…ƒç´ 
        var used = new Set();
        // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
        for (var i = start; i < nums.length; i++) {
            // ä¿è¯é›†åˆä¸­å…ƒç´ éƒ½æ˜¯é€’å¢é¡ºåº
            if (track.length!==0 && track[track.length-1] > nums[i]) {
                continue;
            }
            // ä¿è¯ä¸è¦é‡å¤ä½¿ç”¨ç›¸åŒçš„å…ƒç´ 
            if (used.has(nums[i])) {
                /**<extend up -200>
                 ![](../pictures/æ’åˆ—ç»„åˆ/9.jpeg)
                 */
                continue;
            }
            // é€‰æ‹© nums[i]
            used.add(nums[i]);
            track.push(nums[i]);
            // é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
            backtrack(nums, i + 1);
            // æ’¤é”€é€‰æ‹© nums[i]
            track.pop();
        }
    }

    if (nums.length === 0) {
        return res;
    }
    backtrack(nums, 0);
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        if len(nums) == 0:
            return self.res
        self.backtrack(nums, 0)
        return self.res

    # Initialize empty list for storing result
    res = []
    # Initialize empty list for storing the path
    track = []

    # Backtracking algorithm main function
    def backtrack(self, nums: List[int], start: int) -> None:
        # If a valid answer is found (path has length 2 or greater), add to the result list
        if len(self.track) >= 2:
            self.res.append(self.track[:])
        # Use hash set to avoid selecting duplicate elements
        used = set()
        # Standard backtracking algorithm framework
        for i in range(start, len(nums)):
            # Ensure the elements in the track list are in increasing order
            if len(self.track) > 0 and self.track[-1] > nums[i]:
                continue
            # Avoid using the same element multiple times
            if nums[i] in used:
                # Extend up -200
                # ![](../pictures/æ’åˆ—ç»„åˆ/9.jpeg)
                continue
            used.add(nums[i])
            self.track.append(nums[i])
            self.backtrack(nums, i+1)
            self.track.pop()
```

https://leetcode.cn/problems/non-decreasing-subsequences çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/non-overlapping-intervals çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        int n = intervals.size();
        return n - intervalSchedule(intervals);
    }

    // åŒºé—´è°ƒåº¦ç®—æ³•ï¼Œç®—å‡º intvs ä¸­æœ€å¤šæœ‰å‡ ä¸ªäº’ä¸ç›¸äº¤çš„åŒºé—´
    int intervalSchedule(vector<vector<int>>& intvs) {
        if (intvs.empty()) return 0;
        // æŒ‰ end å‡åºæ’åº
        sort(intvs.begin(), intvs.end(), [](const vector<int>& a, const vector<int>& b){
            return a[1] < b[1];
        });
        // è‡³å°‘æœ‰ä¸€ä¸ªåŒºé—´ä¸ç›¸äº¤
        int count = 1;
        // æ’åºåï¼Œç¬¬ä¸€ä¸ªåŒºé—´å°±æ˜¯ x
        int x_end = intvs[0][1];
        for (const auto& interval : intvs) {
            int start = interval[0];
            if (start >= x_end) {
                // æ‰¾åˆ°ä¸‹ä¸€ä¸ªé€‰æ‹©çš„åŒºé—´äº†
                count++;
                x_end = interval[1];
            }
        }
        return count;
    }
};
```

```go
// by chatGPT (go)
import "sort"

func eraseOverlapIntervals(intervals [][]int) int {
	n := len(intervals)
	return n - intervalSchedule(intervals)
}

// åŒºé—´è°ƒåº¦ç®—æ³•ï¼Œç®—å‡º intvs ä¸­æœ€å¤šæœ‰å‡ ä¸ªäº’ä¸ç›¸äº¤çš„åŒºé—´
func intervalSchedule(intvs [][]int) int {
	if len(intvs) == 0 {
		return 0
	}
	// æŒ‰ end å‡åºæ’åº
	sort.Slice(intvs, func(i, j int) bool {
		return intvs[i][1] < intvs[j][1]
	})
	// è‡³å°‘æœ‰ä¸€ä¸ªåŒºé—´ä¸ç›¸äº¤
	count := 1
	// æ’åºåï¼Œç¬¬ä¸€ä¸ªåŒºé—´å°±æ˜¯ x
	xEnd := intvs[0][1]
	for _, interval := range intvs {
		start := interval[0]
		if start >= xEnd {
			// æ‰¾åˆ°ä¸‹ä¸€ä¸ªé€‰æ‹©çš„åŒºé—´äº†
			count++
			xEnd = interval[1]
		}
	}
	return count
}
```

```java
// by labuladong (java)
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        int n = intervals.length;
        return n - intervalSchedule(intervals);
    }

    // åŒºé—´è°ƒåº¦ç®—æ³•ï¼Œç®—å‡º intvs ä¸­æœ€å¤šæœ‰å‡ ä¸ªäº’ä¸ç›¸äº¤çš„åŒºé—´
    int intervalSchedule(int[][] intvs) {
        if (intvs.length == 0) return 0;
        // æŒ‰ end å‡åºæ’åº
        Arrays.sort(intvs, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return a[1] - b[1];
            }
        });
        // è‡³å°‘æœ‰ä¸€ä¸ªåŒºé—´ä¸ç›¸äº¤
        int count = 1;
        // æ’åºåï¼Œç¬¬ä¸€ä¸ªåŒºé—´å°±æ˜¯ x
        int x_end = intvs[0][1];
        for (int[] interval : intvs) {
            int start = interval[0];
            if (start >= x_end) {
                // æ‰¾åˆ°ä¸‹ä¸€ä¸ªé€‰æ‹©çš„åŒºé—´äº†
                count++;
                x_end = interval[1];
            }
        }
        return count;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var eraseOverlapIntervals = function(intervals) {
    var n = intervals.length;
    return n - intervalSchedule(intervals);
};

/**
 * åŒºé—´è°ƒåº¦ç®—æ³•ï¼Œç®—å‡º intvs ä¸­æœ€å¤šæœ‰å‡ ä¸ªäº’ä¸ç›¸äº¤çš„åŒºé—´
 * @param {number[][]} intvs
 * @return {number}
 */
var intervalSchedule = function(intvs) {
    if (intvs.length === 0) return 0;
    // æŒ‰ end å‡åºæ’åº
    intvs.sort((a, b) => a[1] - b[1]);
    // è‡³å°‘æœ‰ä¸€ä¸ªåŒºé—´ä¸ç›¸äº¤
    var count = 1;
    // æ’åºåï¼Œç¬¬ä¸€ä¸ªåŒºé—´å°±æ˜¯ x
    var x_end = intvs[0][1];
    for (var i = 1; i < intvs.length; i++) {
        var start = intvs[i][0];
        if (start >= x_end) {
            // æ‰¾åˆ°ä¸‹ä¸€ä¸ªé€‰æ‹©çš„åŒºé—´äº†
            count++;
            x_end = intvs[i][1];
        }
    }
    return count;
};
```

```python
# by chatGPT (python)
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        n = len(intervals)
        return n - self.intervalSchedule(intervals)

    # åŒºé—´è°ƒåº¦ç®—æ³•ï¼Œç®—å‡º intvs ä¸­æœ€å¤šæœ‰å‡ ä¸ªäº’ä¸ç›¸äº¤çš„åŒºé—´
    def intervalSchedule(self, intvs: List[List[int]]) -> int:
        if len(intvs) == 0:
            return 0
        # æŒ‰ end å‡åºæ’åº
        intvs = sorted(intvs, key=lambda x:x[1])
        # è‡³å°‘æœ‰ä¸€ä¸ªåŒºé—´ä¸ç›¸äº¤
        count = 1
        # æ’åºåï¼Œç¬¬ä¸€ä¸ªåŒºé—´å°±æ˜¯ x
        x_end = intvs[0][1]
        for interval in intvs:
            start = interval[0]
            if start >= x_end:
                # æ‰¾åˆ°ä¸‹ä¸€ä¸ªé€‰æ‹©çš„åŒºé—´äº†
                count += 1
                x_end = interval[1]
        return count
```

https://leetcode.cn/problems/non-overlapping-intervals çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/nth-digit çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int findNthDigit(int n) {
        // ä½æ•°ï¼ˆä¸€ä½æ•°ï¼Œä¸¤ä½æ•°...ï¼‰
        int digit = 1;
        // 1,10,100, 1000 è¿™æ ·çš„åç¼€
        long long base = 1;

        while (n > 9 * base * digit) {
            n -= 9 * base * digit;
            base *= 10;
            digit++;
        }

        // æ­¤æ—¶å‡è®¾ base = 1000ï¼Œé‚£ä¹ˆè¯´æ˜ n æ˜¯ 100~999 ä¸­çš„æŸä¸ªä¸‰ä½æ•°çš„æŸä¸€ä½
        // å“ªä¸ªä¸‰ä½æ•°å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        long long val = base + (n - 1) / digit;
        // æ˜¯è¿™ä¸ªä¸‰ä½æ•°çš„ç¬¬å‡ ä½å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        int index = (n - 1) % digit;

        // æ€ä¹ˆæŠŠ val çš„ç¬¬ index è¿™ä¸€ä½æ•°å­—æŠ å‡ºæ¥å‘¢ï¼Ÿå¯ä»¥è½¬åŒ–æˆå­—ç¬¦ä¸²æ¥ç®—ï¼š
        return to_string(val)[index] - '0';
    }
};
```

```go
// by chatGPT (go)
func findNthDigit(n int) int {
    // ä½æ•°ï¼ˆä¸€ä½æ•°ï¼Œä¸¤ä½æ•°...ï¼‰
    digit := 1
    // 1,10,100, 1000 è¿™æ ·çš„åç¼€
    base := int64(1)

    for n > 9*base*int64(digit) {
        n -= 9 * int(base) * digit
        base *= 10
        digit++
    }

    // æ­¤æ—¶å‡è®¾ base = 1000ï¼Œé‚£ä¹ˆè¯´æ˜ n æ˜¯ 100~999 ä¸­çš„æŸä¸ªä¸‰ä½æ•°çš„æŸä¸€ä½
    // å“ªä¸ªä¸‰ä½æ•°å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
    val := base + (int64(n)-1)/int64(digit)
    // æ˜¯è¿™ä¸ªä¸‰ä½æ•°çš„ç¬¬å‡ ä½å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
    index := (n - 1) % digit

    // æ€ä¹ˆæŠŠ val çš„ç¬¬ index è¿™ä¸€ä½æ•°å­—æŠ å‡ºæ¥å‘¢ï¼Ÿå¯ä»¥è½¬åŒ–æˆå­—ç¬¦ä¸²æ¥ç®—ï¼š
    return int(strconv.Itoa(int(val))[index] - '0')
}
```

```java
// by labuladong (java)
class Solution {
    public int findNthDigit(int n) {
        // ä½æ•°ï¼ˆä¸€ä½æ•°ï¼Œä¸¤ä½æ•°...ï¼‰
        int digit = 1;
        // 1,10,100, 1000 è¿™æ ·çš„åç¼€
        long base = 1;

        while (n > 9 * base * digit) {
            n -= 9 * base * digit;
            base *= 10;
            digit++;
        }

        // æ­¤æ—¶å‡è®¾ base = 1000ï¼Œé‚£ä¹ˆè¯´æ˜ n æ˜¯ 100~999 ä¸­çš„æŸä¸ªä¸‰ä½æ•°çš„æŸä¸€ä½
        // å“ªä¸ªä¸‰ä½æ•°å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        long val = base + (n - 1) / digit;
        // æ˜¯è¿™ä¸ªä¸‰ä½æ•°çš„ç¬¬å‡ ä½å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        int index = (n - 1) % digit;

        // æ€ä¹ˆæŠŠ val çš„ç¬¬ index è¿™ä¸€ä½æ•°å­—æŠ å‡ºæ¥å‘¢ï¼Ÿå¯ä»¥è½¬åŒ–æˆå­—ç¬¦ä¸²æ¥ç®—ï¼š
        return ("" + val).charAt(index) - '0';
    }
}
```

```javascript
// by chatGPT (javascript)
var findNthDigit = function(n) {
  // ä½æ•°ï¼ˆä¸€ä½æ•°ï¼Œä¸¤ä½æ•°...ï¼‰
  let digit = 1;
  // 1,10,100, 1000 è¿™æ ·çš„åç¼€
  let base = 1;

  while (n > 9 * base * digit) {
    n -= 9 * base * digit;
    base *= 10;
    digit++;
  }

  // æ­¤æ—¶å‡è®¾ base = 1000ï¼Œé‚£ä¹ˆè¯´æ˜ n æ˜¯ 100~999 ä¸­çš„æŸä¸ªä¸‰ä½æ•°çš„æŸä¸€ä½
  // å“ªä¸ªä¸‰ä½æ•°å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
  let val = base + Math.floor((n - 1) / digit);
  // æ˜¯è¿™ä¸ªä¸‰ä½æ•°çš„ç¬¬å‡ ä½å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
  let index = (n - 1) % digit;

  // æ€ä¹ˆæŠŠ val çš„ç¬¬ index è¿™ä¸€ä½æ•°å­—æŠ å‡ºæ¥å‘¢ï¼Ÿå¯ä»¥è½¬åŒ–æˆå­—ç¬¦ä¸²æ¥ç®—ï¼š
  return ("" + val).charAt(index) - '0';
};
```

```python
# by chatGPT (python)
class Solution:
    def findNthDigit(self, n: int) -> int:
        # ä½æ•°ï¼ˆä¸€ä½æ•°ï¼Œä¸¤ä½æ•°...ï¼‰
        digit = 1
        # 1,10,100, 1000 è¿™æ ·çš„åç¼€
        base = 1

        while n > 9 * base * digit:
            n -= 9 * base * digit
            base *= 10
            digit += 1

        # æ­¤æ—¶å‡è®¾ base = 1000ï¼Œé‚£ä¹ˆè¯´æ˜ n æ˜¯ 100~999 ä¸­çš„æŸä¸ªä¸‰ä½æ•°çš„æŸä¸€ä½
        # å“ªä¸ªä¸‰ä½æ•°å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        val = base + (n - 1) // digit
        # æ˜¯è¿™ä¸ªä¸‰ä½æ•°çš„ç¬¬å‡ ä½å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        index = (n - 1) % digit

        # æ€ä¹ˆæŠŠ val çš„ç¬¬ index è¿™ä¸€ä½æ•°å­—æŠ å‡ºæ¥å‘¢ï¼Ÿå¯ä»¥è½¬åŒ–æˆå­—ç¬¦ä¸²æ¥ç®—ï¼š
        return int(str(val)[index])
```

https://leetcode.cn/problems/nth-digit çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/number-of-1-bits çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // you need to treat n as an unsigned value
    int hammingWeight(uint32_t n) {
        int res = 0;
        while (n != 0) {
            n = n & (n - 1);
            res++;
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func hammingWeight(n uint32) int {
    res := 0
    for n != 0 {
        n &= n - 1
        res++
    }
    return res
}
```

```java
// by labuladong (java)
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res = 0;
        while (n != 0) {
            n = n & (n - 1);
            res++;
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var hammingWeight = function(n) {
    // you need to treat n as an unsigned value
    var res = 0;
    while (n !== 0) {
        n = n & (n - 1);
        res++;
    }
    return res;
}
```

```python
# by chatGPT (python)
class Solution:
    # you need to treat n as an unsigned value
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n != 0:
            n = n & (n-1)
            res += 1
        return res
```

https://leetcode.cn/problems/number-of-1-bits çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/number-of-closed-islands çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // ä¸»å‡½æ•°ï¼šè®¡ç®—å°é—­å²›å±¿çš„æ•°é‡
    int closedIsland(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        for (int j = 0; j < n; j++) {
            // æŠŠé ä¸Šè¾¹çš„å²›å±¿æ·¹æ‰
            dfs(grid, 0, j);
            // æŠŠé ä¸‹è¾¹çš„å²›å±¿æ·¹æ‰
            dfs(grid, m - 1, j);
        }
        for (int i = 0; i < m; i++) {
            // æŠŠé å·¦è¾¹çš„å²›å±¿æ·¹æ‰
            dfs(grid, i, 0);
            // æŠŠé å³è¾¹çš„å²›å±¿æ·¹æ‰
            dfs(grid, i, n - 1);
        }
        // éå† gridï¼Œå‰©ä¸‹çš„å²›å±¿éƒ½æ˜¯å°é—­å²›å±¿
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    res++;
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }

    // ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
    void dfs(vector<vector<int>>& grid, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return;
        }
        if (grid[i][j] == 1) {
            // å·²ç»æ˜¯æµ·æ°´äº†
            return;
        }
        // å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = 1;
        // æ·¹æ²¡ä¸Šä¸‹å·¦å³çš„é™†åœ°
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
};
```

```go
// by chatGPT (go)
// è®¡ç®—å°é—­å²›å±¿çš„æ•°é‡
func closedIsland(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    for j := 0; j < n; j++ {
        // æŠŠé ä¸Šè¾¹çš„å²›å±¿æ·¹æ‰
        dfs(grid, 0, j)
        // æŠŠé ä¸‹è¾¹çš„å²›å±¿æ·¹æ‰
        dfs(grid, m-1, j)
    }
    for i := 0; i < m; i++ {
        // æŠŠé å·¦è¾¹çš„å²›å±¿æ·¹æ‰
        dfs(grid, i, 0)
        // æŠŠé å³è¾¹çš„å²›å±¿æ·¹æ‰
        dfs(grid, i, n-1)
    }
    // éå† gridï¼Œå‰©ä¸‹çš„å²›å±¿éƒ½æ˜¯å°é—­å²›å±¿
    res := 0
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if grid[i][j] == 0 {
                res++
                dfs(grid, i, j)
            }
        }
    }
    return res
}

// ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
func dfs(grid [][]int, i, j int) {
    m, n := len(grid), len(grid[0])
    if i < 0 || j < 0 || i >= m || j >= n {
        return
    }
    if grid[i][j] == 1 {
        // å·²ç»æ˜¯æµ·æ°´äº†
        return
    }
    // å°† (i, j) å˜æˆæµ·æ°´
    grid[i][j] = 1
    // æ·¹æ²¡ä¸Šä¸‹å·¦å³çš„é™†åœ°
    dfs(grid, i+1, j)
    dfs(grid, i, j+1)
    dfs(grid, i-1, j)
    dfs(grid, i, j-1)
}
```

```java
// by labuladong (java)
class Solution {
     // ä¸»å‡½æ•°ï¼šè®¡ç®—å°é—­å²›å±¿çš„æ•°é‡
    public int closedIsland(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        for (int j = 0; j < n; j++) {
            // æŠŠé ä¸Šè¾¹çš„å²›å±¿æ·¹æ‰
            dfs(grid, 0, j);
            // æŠŠé ä¸‹è¾¹çš„å²›å±¿æ·¹æ‰
            dfs(grid, m - 1, j);
        }
        for (int i = 0; i < m; i++) {
            // æŠŠé å·¦è¾¹çš„å²›å±¿æ·¹æ‰
            dfs(grid, i, 0);
            // æŠŠé å³è¾¹çš„å²›å±¿æ·¹æ‰
            dfs(grid, i, n - 1);
        }
        // éå† gridï¼Œå‰©ä¸‹çš„å²›å±¿éƒ½æ˜¯å°é—­å²›å±¿
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    res++;
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }

    // ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
    void dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return;
        }
        if (grid[i][j] == 1) {
            // å·²ç»æ˜¯æµ·æ°´äº†
            return;
        }
        // å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = 1;
        // æ·¹æ²¡ä¸Šä¸‹å·¦å³çš„é™†åœ°
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
}
```

```javascript
// by chatGPT (javascript)
var closedIsland = function(grid) {
    var m = grid.length, n = grid[0].length;
    for (var j = 0; j < n; j++) {
        // æŠŠé ä¸Šè¾¹çš„å²›å±¿æ·¹æ‰
        dfs(grid, 0, j);
        // æŠŠé ä¸‹è¾¹çš„å²›å±¿æ·¹æ‰
        dfs(grid, m - 1, j);
    }
    for (var i = 0; i < m; i++) {
        // æŠŠé å·¦è¾¹çš„å²›å±¿æ·¹æ‰
        dfs(grid, i, 0);
        // æŠŠé å³è¾¹çš„å²›å±¿æ·¹æ‰
        dfs(grid, i, n - 1);
    }
    // éå† gridï¼Œå‰©ä¸‹çš„å²›å±¿éƒ½æ˜¯å°é—­å²›å±¿
    var res = 0;
    for (var i = 0; i < m; i++) {
        for (var j = 0; j < n; j++) {
            if (grid[i][j] === 0) {
                res++;
                dfs(grid, i, j);
            }
        }
    }
    return res;
}

// ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
function dfs(grid, i, j) {
    var m = grid.length, n = grid[0].length;
    if (i < 0 || j < 0 || i >= m || j >= n) {
        return;
    }
    if (grid[i][j] === 1) {
        // å·²ç»æ˜¯æµ·æ°´äº†
        return;
    }
    // å°† (i, j) å˜æˆæµ·æ°´
    grid[i][j] = 1;
    // æ·¹æ²¡ä¸Šä¸‹å·¦å³çš„é™†åœ°
    dfs(grid, i + 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i - 1, j);
    dfs(grid, i, j - 1);
}
```

```python
# by chatGPT (python)
class Solution:
    def closedIsland(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        for j in range(n):
            # æŠŠé ä¸Šè¾¹çš„å²›å±¿æ·¹æ‰
            self.dfs(grid, 0, j)
            # æŠŠé ä¸‹è¾¹çš„å²›å±¿æ·¹æ‰
            self.dfs(grid, m - 1, j)
        for i in range(m):
            # æŠŠé å·¦è¾¹çš„å²›å±¿æ·¹æ‰
            self.dfs(grid, i, 0)
            # æŠŠé å³è¾¹çš„å²›å±¿æ·¹æ‰
            self.dfs(grid, i, n - 1)
        # éå† gridï¼Œå‰©ä¸‹çš„å²›å±¿éƒ½æ˜¯å°é—­å²›å±¿
        res = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0:
                    res += 1
                    self.dfs(grid, i, j)
        return res

    # ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
    def dfs(self, grid: List[List[int]], i: int, j: int) -> None:
        m, n = len(grid), len(grid[0])
        if i < 0 or j < 0 or i >= m or j >= n:
            return
        if grid[i][j] == 1:
            # å·²ç»æ˜¯æµ·æ°´äº†
            return
        # å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = 1
        # æ·¹æ²¡ä¸Šä¸‹å·¦å³çš„é™†åœ°
        self.dfs(grid, i + 1, j)
        self.dfs(grid, i, j + 1)
        self.dfs(grid, i - 1, j)
        self.dfs(grid, i, j - 1)
```

https://leetcode.cn/problems/number-of-closed-islands çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/number-of-distinct-islands çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int numDistinctIslands(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        // è®°å½•æ‰€æœ‰å²›å±¿çš„åºåˆ—åŒ–ç»“æœ
        unordered_set<string> islands;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // æ·¹æ‰è¿™ä¸ªå²›å±¿ï¼ŒåŒæ—¶å­˜å‚¨å²›å±¿çš„åºåˆ—åŒ–ç»“æœ
                    string s;
                    // åˆå§‹çš„æ–¹å‘å¯ä»¥éšä¾¿å†™ï¼Œä¸å½±å“æ­£ç¡®æ€§
                    dfs(grid, i, j, s, 's'); // ç”¨å­—ç¬¦ä»£æ›¿æ•°å­—ï¼Œæ–¹ä¾¿åç»­æ‹¼æ¥
                    islands.insert(s);
                    /**<extend up -200>
                    ![](../pictures/å²›å±¿/6.png)
                    */
                }
            }
        }
        // ä¸ç›¸åŒçš„å²›å±¿æ•°é‡
        return islands.size();
    }

private:
    void dfs(vector<vector<int>>& grid, int i, int j, string& s, char dir) {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || j < 0 || i >= m || j >= n 
            || grid[i][j] == 0) {
            return;
        }
        // å‰åºéå†ä½ç½®ï¼šè¿›å…¥ (i, j)
        grid[i][j] = 0;
        s += dir;
        dfs(grid, i - 1, j, s, 'u'); // ä¸Š
        dfs(grid, i + 1, j, s, 'd'); // ä¸‹
        dfs(grid, i, j - 1, s, 'l'); // å·¦
        dfs(grid, i, j + 1, s, 'r'); // å³
        
        // ååºéå†ä½ç½®ï¼šç¦»å¼€ (i, j)
        s += 'b';
    }
};
```

```go
// by chatGPT (go)
// LeetCodeé—®é¢˜â€œä¸åŒå²›å±¿çš„æ•°é‡â€çš„è§£å†³æ–¹æ¡ˆï¼š https://leetcode.com/problems/number-of-distinct-islands/
// ä½œè€…ï¼šObadiah Crowe
// æ—¶é—´ï¼š2021å¹´7æœˆ29æ—¥
import (
	"fmt"
	"strconv"
	"strings"
)

func numDistinctIslands(grid [][]int) int {
	// è®¡ç®—è¡Œæ•°å’Œåˆ—æ•°
	m, n := len(grid), len(grid[0])

	// å­˜å‚¨æ‰€æœ‰ä¸åŒå²›å±¿çš„åºåˆ—åŒ–ç»“æœ
	islands := make(map[string]bool)
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == 1 {
				// æ·¹æ²¡æ­¤å²›å±¿ï¼ŒåŒæ—¶å­˜å‚¨å…¶åºåˆ—åŒ–ç»“æœ
				var sb strings.Builder
				// åˆå§‹æ–¹å‘å¯ä»¥æ˜¯ä»»æ„çš„ï¼Œä¸ä¼šå½±å“æ­£è§£
				dfs(grid, i, j, &sb, 666)
				islands[sb.String()] = true
				/**<å‘ä¸Šæ‰©å±•-200>
				![](../pictures/å²›å±¿/6.png)
				*/
			}
		}
	}

	// å²›å±¿æ•°é‡å³ä¸ºä¸åŒå²›å±¿åºåˆ—åŒ–ç»“æœçš„æ•°é‡
	return len(islands)
}

func dfs(grid [][]int, i, j int, sb *strings.Builder, dir int) {
	// è®¡ç®—è¡Œæ•°å’Œåˆ—æ•°
	m, n := len(grid), len(grid[0])

	// å¦‚æœ(i, j)ä¸åœ¨ç½‘æ ¼èŒƒå›´å†…, æˆ–è€…æ˜¯æµ·æ´‹, ç›´æ¥è¿”å›
	if i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0 {
		return
	}

	// pre-order: è¿›å…¥ç‚¹(i, j)
	grid[i][j] = 0 // æ·¹æ²¡è¯¥å²›å±¿
	sb.WriteString(strconv.Itoa(dir) + ",") //è®°å½•æ–¹å‘

	dfs(grid, i-1, j, sb, 1) // ä¸Š
	dfs(grid, i+1, j, sb, 2) // ä¸‹
	dfs(grid, i, j-1, sb, 3) // å·¦
	dfs(grid, i, j+1, sb, 4) // å³

	// post-order: ç¦»å¼€ç‚¹(i, j)
	sb.WriteString(strconv.Itoa(-dir) + ",") // è®°å½•æ–¹å‘
}
```

```java
// by labuladong (java)
class Solution {
    public int numDistinctIslands(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        // è®°å½•æ‰€æœ‰å²›å±¿çš„åºåˆ—åŒ–ç»“æœ
        HashSet<String> islands = new HashSet<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // æ·¹æ‰è¿™ä¸ªå²›å±¿ï¼ŒåŒæ—¶å­˜å‚¨å²›å±¿çš„åºåˆ—åŒ–ç»“æœ
                    StringBuilder sb = new StringBuilder();
                    // åˆå§‹çš„æ–¹å‘å¯ä»¥éšä¾¿å†™ï¼Œä¸å½±å“æ­£ç¡®æ€§
                    dfs(grid, i, j, sb, 666);
                    islands.add(sb.toString());
                    /**<extend up -200>
                    ![](../pictures/å²›å±¿/6.png)
                    */
                }
            }
        }
        // ä¸ç›¸åŒçš„å²›å±¿æ•°é‡
        return islands.size();
    }

    private void dfs(int[][] grid, int i, int j, StringBuilder sb, int dir) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n 
            || grid[i][j] == 0) {
            return;
        }
        // å‰åºéå†ä½ç½®ï¼šè¿›å…¥ (i, j)
        grid[i][j] = 0;
        sb.append(dir).append(',');
        
        dfs(grid, i - 1, j, sb, 1); // ä¸Š
        dfs(grid, i + 1, j, sb, 2); // ä¸‹
        dfs(grid, i, j - 1, sb, 3); // å·¦
        dfs(grid, i, j + 1, sb, 4); // å³
        
        // ååºéå†ä½ç½®ï¼šç¦»å¼€ (i, j)
        sb.append(-dir).append(',');
    }
}
```

```javascript
// by chatGPT (javascript)
var numDistinctIslands = function(grid) {
    var m = grid.length, n = grid[0].length;
    // Record the serialization results of all islands
    var islands = new Set();
    for(var i=0; i<m; i++) {
        for(var j=0; j<n; j++) {
            if(grid[i][j] == 1) {
                // Drown the island and store the serialization result of the island
                var sb = new StringBuilder();
                // The initial direction can be written randomly, which does not affect the correctness
                dfs(grid, i, j, sb, 666);
                islands.add(sb.toString());
                /**<extend up -200>
                ![](../pictures/å²›å±¿/6.png)
                */
            }
        }
    } 
    // The number of different islands
    return islands.size();

    function dfs(grid, i, j, sb, dir) {
        if(i<0 || j<0 || i>=m || j>=n || grid[i][j] == 0) {
            return;
        } 
        // Pre-order traversal position: enter (i, j)
        grid[i][j] = 0;
        sb.append(dir).append(',');

        dfs(grid, i-1, j, sb, 1); // up
        dfs(grid, i+1, j, sb, 2); // down
        dfs(grid, i, j-1, sb, 3); // left
        dfs(grid, i, j+1, sb, 4); // right

        // Post-order traversal position: leave (i, j)
        sb.append(-dir).append(',');
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def numDistinctIslands(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        islands = set() # è®°å½•æ‰€æœ‰å²›å±¿çš„åºåˆ—åŒ–ç»“æœ
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1: # å¦‚æœå²›å±¿æ˜¯1
                    # æ·¹æ‰è¿™ä¸ªå²›å±¿ï¼ŒåŒæ—¶å­˜å‚¨å²›å±¿çš„åºåˆ—åŒ–ç»“æœ
                    sb = [] # æ²¡æœ‰StringBuilderï¼Œç”¨æ•°ç»„ä»£æ›¿
                    # åˆå§‹çš„æ–¹å‘å¯ä»¥éšä¾¿å†™ï¼Œä¸å½±å“æ­£ç¡®æ€§
                    self.dfs(grid, i, j, sb, 666)
                    islands.add("".join(sb))
                    #![](../pictures/å²›å±¿/6.png)

        return len(islands) # è¿”å›ä¸åŒçš„å²›å±¿æ•°é‡

    def dfs(self, grid: List[List[int]], i: int, j: int, sb: List[str], dir: int) -> None:
        m, n = len(grid), len(grid[0])
        if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 0:
            return
        # å‰åºéå†ä½ç½®ï¼šè¿›å…¥ (i, j)
        grid[i][j] = 0
        sb.append(str(dir)).append(',')

        self.dfs(grid, i - 1, j, sb, 1)  # ä¸Š
        self.dfs(grid, i + 1, j, sb, 2)  # ä¸‹
        self.dfs(grid, i, j - 1, sb, 3)  # å·¦
        self.dfs(grid, i, j + 1, sb, 4)  # å³

        # ååºéå†ä½ç½®ï¼šç¦»å¼€ (i, j)
        sb.append(str(-dir)).append(',')
```

https://leetcode.cn/problems/number-of-distinct-islands çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/number-of-enclaves çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int numEnclaves(vector<vector<int>>& grid) {

        int m = grid.size(), n = grid[0].size();
        
        for (int i = 0; i < m; i++) {
            dfs(grid, i, 0);
            dfs(grid, i, n - 1);
        }

        for (int j = 0; j < n; j++) {
            dfs(grid, 0, j);
            dfs(grid, m - 1, j);
        }

        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    res += 1;
                }
            }
        }
        return res;
    }

    void dfs(vector<vector<int>>& grid, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0) {
            return;
        }

        grid[i][j] = 0;

        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
};
```

```go
// by chatGPT (go)
// LeetCode é¢˜ç›®é“¾æ¥ https://leetcode-cn.com/problems/number-of-enclaves/
func numEnclaves(grid [][]int) int {
    m, n := len(grid), len(grid[0])

    for i := 0; i < m; i++ {
        dfs(grid, i, 0)
        dfs(grid, i, n-1)
    }

    for j := 0; j < n; j++ {
        dfs(grid, 0, j)
        dfs(grid, m-1, j)
    }

    var res int
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if grid[i][j] == 1 {
                res += 1
            }
        }
    }
    return res
}

func dfs(grid [][]int, i, j int) {
    m, n := len(grid), len(grid[0])
    if i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0 {
        return
    }

    grid[i][j] = 0

    dfs(grid, i+1, j)
    dfs(grid, i, j+1)
    dfs(grid, i-1, j)
    dfs(grid, i, j-1)
}
```

```java
// by labuladong (java)
class Solution {
    public int numEnclaves(int[][] grid) {
        int m = grid.length, n = grid[0].length;

        for (int i = 0; i < m; i++) {
            dfs(grid, i, 0);
            dfs(grid, i, n - 1);
        }

        for (int j = 0; j < n; j++) {
            dfs(grid, 0, j);
            dfs(grid, m - 1, j);
        }

        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    res += 1;
                }
            }
        }
        return res;
    }

    void dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0) {
            return;
        }

        grid[i][j] = 0;

        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} grid
 * @return {number}
 */
var numEnclaves = function(grid) {
    var m = grid.length, n = grid[0].length;

    for (var i = 0; i < m; i++) {
        dfs(grid, i, 0);
        dfs(grid, i, n - 1);
    }

    for (var j = 0; j < n; j++) {
        dfs(grid, 0, j);
        dfs(grid, m - 1, j);
    }

    var res = 0;
    for (var row = 0; row < m; row++) {
        for (var col = 0; col < n; col++) {
            if (grid[row][col] === 1) {
                res += 1;
            }
        }
    }
    return res;
};

function dfs(grid, i, j) {
    var m = grid.length, n = grid[0].length;
    if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] === 0) {
        return;
    }

    grid[i][j] = 0;

    dfs(grid, i + 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i - 1, j);
    dfs(grid, i, j - 1);
}
```

```python
# by chatGPT (python)
class Solution:
    def numEnclaves(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        for i in range(m):
            self.dfs(grid, i, 0)
            self.dfs(grid, i, n - 1)

        for j in range(n):
            self.dfs(grid, 0, j)
            self.dfs(grid, m - 1, j)

        res = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    res += 1
        return res

    def dfs(self, grid: List[List[int]], i: int, j: int) -> None:
        m, n = len(grid), len(grid[0])
        if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 0:
            return

        grid[i][j] = 0

        self.dfs(grid, i + 1, j)
        self.dfs(grid, i, j + 1)
        self.dfs(grid, i - 1, j)
        self.dfs(grid, i, j - 1)
```

https://leetcode.cn/problems/number-of-enclaves çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/number-of-islands çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    // ä¸»å‡½æ•°ï¼Œè®¡ç®—å²›å±¿æ•°é‡
public:
    int numIslands(vector<vector<char>>& grid) {
        int res = 0;
        int m = grid.size(), n = grid[0].size();
        // éå† grid
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    // æ¯å‘ç°ä¸€ä¸ªå²›å±¿ï¼Œå²›å±¿æ•°é‡åŠ ä¸€
                    res++;
                    // ç„¶åä½¿ç”¨ DFS å°†å²›å±¿æ·¹äº†
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }

private:
    // ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
    void dfs(vector<vector<char>>& grid, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return;
        }
        if (grid[i][j] == '0') {
            // å·²ç»æ˜¯æµ·æ°´äº†
            return;
        }
        // å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = '0';
        // æ·¹æ²¡ä¸Šä¸‹å·¦å³çš„é™†åœ°
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
};
```

```go
// by chatGPT (go)
func numIslands(grid [][]byte) int {
    res := 0
    m, n := len(grid), len(grid[0])
    // éå† grid
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if grid[i][j] == '1' {
                // æ¯å‘ç°ä¸€ä¸ªå²›å±¿ï¼Œå²›å±¿æ•°é‡åŠ ä¸€
                res++
                // ç„¶åä½¿ç”¨ DFS å°†å²›å±¿æ·¹äº†
                dfs(grid, i, j)
            }
        }
    }
    return res
}

// ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
func dfs(grid [][]byte, i, j int) {
    m, n := len(grid), len(grid[0])
    if i < 0 || j < 0 || i >= m || j >= n {
        // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
        return
    }
    if grid[i][j] == '0' {
        // å·²ç»æ˜¯æµ·æ°´äº†
        return
    }
    // å°† (i, j) å˜æˆæµ·æ°´
    grid[i][j] = '0'
    // æ·¹æ²¡ä¸Šä¸‹å·¦å³çš„é™†åœ°
    dfs(grid, i+1, j)
    dfs(grid, i, j+1)
    dfs(grid, i-1, j)
    dfs(grid, i, j-1)
}
```

```java
// by labuladong (java)
class Solution {
    // ä¸»å‡½æ•°ï¼Œè®¡ç®—å²›å±¿æ•°é‡
    public int numIslands(char[][] grid) {
        int res = 0;
        int m = grid.length, n = grid[0].length;
        // éå† grid
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    // æ¯å‘ç°ä¸€ä¸ªå²›å±¿ï¼Œå²›å±¿æ•°é‡åŠ ä¸€
                    res++;
                    // ç„¶åä½¿ç”¨ DFS å°†å²›å±¿æ·¹äº†
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }

    // ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
    void dfs(char[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return;
        }
        if (grid[i][j] == '0') {
            // å·²ç»æ˜¯æµ·æ°´äº†
            return;
        }
        // å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = '0';
        // æ·¹æ²¡ä¸Šä¸‹å·¦å³çš„é™†åœ°
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
}
```

```javascript
// by chatGPT (javascript)
var numIslands = function(grid) {
    var res = 0;
    var m = grid.length, n = grid[0].length;
    // éå† grid
    for (var i = 0; i < m; i++) {
        for (var j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                // æ¯å‘ç°ä¸€ä¸ªå²›å±¿ï¼Œå²›å±¿æ•°é‡åŠ ä¸€
                res++;
                // ç„¶åä½¿ç”¨ DFS å°†å²›å±¿æ·¹äº†
                dfs(grid, i, j);
            }
        }
    }
    return res;
};

// ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
function dfs(grid, i, j) {
    var m = grid.length, n = grid[0].length;
    if (i < 0 || j < 0 || i >= m || j >= n) {
        // è¶…å‡ºç´¢å¼•è¾¹ç•Œ
        return;
    }
    if (grid[i][j] == '0') {
        // å·²ç»æ˜¯æµ·æ°´äº†
        return;
    }
    // å°† (i, j) å˜æˆæµ·æ°´
    grid[i][j] = '0';
    // æ·¹æ²¡ä¸Šä¸‹å·¦å³çš„é™†åœ°
    dfs(grid, i + 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i - 1, j);
    dfs(grid, i, j - 1);
}
```

```python
# by chatGPT (python)
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        res = 0
        m = len(grid)
        n = len(grid[0])
        # éå† grid
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    # æ¯å‘ç°ä¸€ä¸ªå²›å±¿ï¼Œå²›å±¿æ•°é‡åŠ ä¸€
                    res += 1
                    # ç„¶åä½¿ç”¨ DFS å°†å²›å±¿æ·¹äº†
                    self.dfs(grid, i, j)
        return res

    # ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´
    def dfs(self, grid: List[List[str]], i: int, j: int) -> None:
        m = len(grid)
        n = len(grid[0])
        if i < 0 or j < 0 or i >= m or j >= n:
            # è¶…å‡ºç´¢å¼•è¾¹ç•Œ
            return
        if grid[i][j] == '0':
            # å·²ç»æ˜¯æµ·æ°´äº†
            return
        # å°† (i, j) å˜æˆæµ·æ°´
        grid[i][j] = '0'
        # æ·¹æ²¡ä¸Šä¸‹å·¦å³çš„é™†åœ°
        self.dfs(grid, i + 1, j)
        self.dfs(grid, i, j + 1)
        self.dfs(grid, i - 1, j)
        self.dfs(grid, i, j - 1)
```

https://leetcode.cn/problems/number-of-islands çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int countStudents(vector<int>& students, vector<int>& sandwiches) {
        //studentCount [0 or 1] åˆ†åˆ«ä»£è¡¨åƒ 0 å’Œåƒ 1çš„å­¦ç”Ÿæ•°é‡
        vector<int> studentCount(2, 0);
        for (int type : students) {
            studentCount[type]++;
        }
        //éå†ä¸‰æ˜æ²»æ ˆï¼Œè‹¥æ ˆé¡¶çš„ä¸‰æ˜æ²»æ— æ³•è¢«å–èµ°ï¼Œåˆ™å‰©ä¸‹çš„äººéƒ½åƒä¸ä¸Šäº†
        for (int type : sandwiches) {
            if (studentCount[type] == 0) {
                //ä¸¤ç§å–œå¥½åŠ èµ·æ¥å°±æ˜¯å‰©ä¸‹çš„å­¦ç”Ÿæ•°é‡
                return studentCount[0] + studentCount[1];
            }
            studentCount[type]--;
        }
        return 0;
    }
};
```

```go
// by chatGPT (go)
func countStudents(students []int, sandwiches []int) int {
    // studentCount[0 or 1] åˆ†åˆ«ä»£è¡¨åƒ 0 å’Œåƒ 1çš„å­¦ç”Ÿæ•°é‡
    studentCount := [2]int{0, 0}
    for _, type_ := range students {
        studentCount[type_]++
    }
    // éå†ä¸‰æ˜æ²»æ ˆï¼Œè‹¥æ ˆé¡¶çš„ä¸‰æ˜æ²»æ— æ³•è¢«å–èµ°ï¼Œåˆ™å‰©ä¸‹çš„äººéƒ½åƒä¸ä¸Šäº†
    for _, type_ := range sandwiches {
        if studentCount[type_] == 0 {
            // ä¸¤ç§å–œå¥½åŠ èµ·æ¥å°±æ˜¯å‰©ä¸‹çš„å­¦ç”Ÿæ•°é‡
            return studentCount[0] + studentCount[1]
        }
        studentCount[type_]--
    }
    return 0
}
```

```java
// by labuladong (java)
class Solution {
    public int countStudents(int[] students, int[] sandwiches) {
        // studentCount[0 or 1] åˆ†åˆ«ä»£è¡¨åƒ 0 å’Œåƒ 1çš„å­¦ç”Ÿæ•°é‡
        int[] studentCount = new int[2];
        for (int type : students) {
            studentCount[type]++;
        }
        // éå†ä¸‰æ˜æ²»æ ˆï¼Œè‹¥æ ˆé¡¶çš„ä¸‰æ˜æ²»æ— æ³•è¢«å–èµ°ï¼Œåˆ™å‰©ä¸‹çš„äººéƒ½åƒä¸ä¸Šäº†
        for (int type : sandwiches) {
            if (studentCount[type] == 0) {
                // ä¸¤ç§å–œå¥½åŠ èµ·æ¥å°±æ˜¯å‰©ä¸‹çš„å­¦ç”Ÿæ•°é‡
                return studentCount[0] + studentCount[1];
            }
            studentCount[type]--;
        }
        return 0;
    }
}
```

```javascript
// by chatGPT (javascript)
var countStudents = function(students, sandwiches) {
    // studentCount[0 or 1] åˆ†åˆ«ä»£è¡¨åƒ 0 å’Œåƒ 1çš„å­¦ç”Ÿæ•°é‡
    var studentCount = new Array(2).fill(0);
    for (var type of students) {
        studentCount[type]++;
    }
    // éå†ä¸‰æ˜æ²»æ ˆï¼Œè‹¥æ ˆé¡¶çš„ä¸‰æ˜æ²»æ— æ³•è¢«å–èµ°ï¼Œåˆ™å‰©ä¸‹çš„äººéƒ½åƒä¸ä¸Šäº†
    for (var type of sandwiches) {
        if (studentCount[type] == 0) {
            // ä¸¤ç§å–œå¥½åŠ èµ·æ¥å°±æ˜¯å‰©ä¸‹çš„å­¦ç”Ÿæ•°é‡
            return studentCount[0] + studentCount[1];
        }
        studentCount[type]--;
    }
    return 0;
}
```

```python
# by chatGPT (python)
class Solution:
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        # studentCount[0 or 1] åˆ†åˆ«ä»£è¡¨åƒ 0 å’Œåƒ 1çš„å­¦ç”Ÿæ•°é‡
        studentCount = [0,0]
        for type in students:
            studentCount[type] += 1
        # éå†ä¸‰æ˜æ²»æ ˆï¼Œè‹¥æ ˆé¡¶çš„ä¸‰æ˜æ²»æ— æ³•è¢«å–èµ°ï¼Œåˆ™å‰©ä¸‹çš„äººéƒ½åƒä¸ä¸Šäº†
        for type in sandwiches:
            if studentCount[type] == 0:
                # ä¸¤ç§å–œå¥½åŠ èµ·æ¥å°±æ˜¯å‰©ä¸‹çš„å­¦ç”Ÿæ•°é‡
                return studentCount[0] + studentCount[1]
            studentCount[type] -= 1
        return 0
```

https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/open-the-lock çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int openLock(vector<string>& deadends, string target) {
        // è®°å½•éœ€è¦è·³è¿‡çš„æ­»äº¡å¯†ç 
        unordered_set<string> deads(deadends.begin(), deadends.end());
        // è®°å½•å·²ç»ç©·ä¸¾è¿‡çš„å¯†ç ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
        unordered_set<string> visited;
        queue<string> q;
        // ä»èµ·ç‚¹å¼€å§‹å¯åŠ¨å¹¿åº¦ä¼˜å…ˆæœç´¢
        int step = 0;
        q.push("0000");
        visited.insert("0000");

        while (!q.empty()) {
            int sz = q.size();
            /* å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å‘¨å›´æ‰©æ•£ */
            for (int i = 0; i < sz; i++) {
                string cur = q.front(); q.pop();

                /* åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹ */
                if (deads.count(cur))
                    continue;
                if (cur == target)
                    return step;

                /* å°†ä¸€ä¸ªèŠ‚ç‚¹çš„æœªéå†ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */
                for (int j = 0; j < 4; j++) {
                    string up = plusOne(cur, j);
                    if (!visited.count(up)) {
                        q.push(up);
                        visited.insert(up);
                    }
                    string down = minusOne(cur, j);
                    if (!visited.count(down)) {
                        q.push(down);
                        visited.insert(down);
                    }
                }
            }
            /* åœ¨è¿™é‡Œå¢åŠ æ­¥æ•° */
            step++;
        }
        // å¦‚æœç©·ä¸¾å®Œéƒ½æ²¡æ‰¾åˆ°ç›®æ ‡å¯†ç ï¼Œé‚£å°±æ˜¯æ‰¾ä¸åˆ°äº†
        return -1;
    }

    // å°† s[j] å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡
    string plusOne(string s, int j) {
        if (s[j] == '9') s[j] = '0';
        else s[j] += 1;
        return s;
    }

    // å°† s[i] å‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡
    string minusOne(string s, int j) {
        if (s[j] == '0') s[j] = '9';
        else s[j] -= 1;
        return s;
    }
};
```

```go
// by chatGPT (go)
import "fmt"

func openLock(deadends []string, target string) int {
    // è®°å½•éœ€è¦è·³è¿‡çš„æ­»äº¡å¯†ç 
    deads := make(map[string]bool)
    for _, s := range deadends {
        deads[s] = true
    }
    // è®°å½•å·²ç»ç©·ä¸¾è¿‡çš„å¯†ç ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
    visited := make(map[string]bool)
    q := make([]string, 0)
    // ä»èµ·ç‚¹å¼€å§‹å¯åŠ¨å¹¿åº¦ä¼˜å…ˆæœç´¢
    step := 0
    q = append(q, "0000")
    visited["0000"] = true

    for len(q) > 0 {
        sz := len(q)
        /* å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å‘¨å›´æ‰©æ•£ */
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]

            /* åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹ */
            if deads[cur] {
                continue
            }
            if cur == target {
                return step
            }

            /* å°†ä¸€ä¸ªèŠ‚ç‚¹çš„æœªéå†ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */
            for j := 0; j < 4; j++ {
                up := plusOne(cur, j)
                if !visited[up] {
                    q = append(q, up)
                    visited[up] = true
                }
                down := minusOne(cur, j)
                if !visited[down] {
                    q = append(q, down)
                    visited[down] = true
                }
            }
        }
        /* åœ¨è¿™é‡Œå¢åŠ æ­¥æ•° */
        step++
    }
    // å¦‚æœç©·ä¸¾å®Œéƒ½æ²¡æ‰¾åˆ°ç›®æ ‡å¯†ç ï¼Œé‚£å°±æ˜¯æ‰¾ä¸åˆ°äº†
    return -1
}

// å°† s[j] å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡
func plusOne(s string, j int) string {
    ch := []byte(s)
    if ch[j] == '9' {
        ch[j] = '0'
    } else {
        ch[j] += 1
    }
    return string(ch)
}

// å°† s[i] å‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡
func minusOne(s string, j int) string {
    ch := []byte(s)
    if ch[j] == '0' {
        ch[j] = '9'
    } else {
        ch[j] -= 1
    }
    return string(ch)
}
```

```java
// by labuladong (java)
class Solution {
    public int openLock(String[] deadends, String target) {
        // è®°å½•éœ€è¦è·³è¿‡çš„æ­»äº¡å¯†ç 
        Set<String> deads = new HashSet<>();
        for (String s : deadends) deads.add(s);
        // è®°å½•å·²ç»ç©·ä¸¾è¿‡çš„å¯†ç ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
        Set<String> visited = new HashSet<>();
        Queue<String> q = new LinkedList<>();
        // ä»èµ·ç‚¹å¼€å§‹å¯åŠ¨å¹¿åº¦ä¼˜å…ˆæœç´¢
        int step = 0;
        q.offer("0000");
        visited.add("0000");

        while (!q.isEmpty()) {
            int sz = q.size();
            /* å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å‘¨å›´æ‰©æ•£ */
            for (int i = 0; i < sz; i++) {
                String cur = q.poll();

                /* åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹ */
                if (deads.contains(cur))
                    continue;
                if (cur.equals(target))
                    return step;

                /* å°†ä¸€ä¸ªèŠ‚ç‚¹çš„æœªéå†ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */
                for (int j = 0; j < 4; j++) {
                    String up = plusOne(cur, j);
                    if (!visited.contains(up)) {
                        q.offer(up);
                        visited.add(up);
                    }
                    String down = minusOne(cur, j);
                    if (!visited.contains(down)) {
                        q.offer(down);
                        visited.add(down);
                    }
                }
            }
            /* åœ¨è¿™é‡Œå¢åŠ æ­¥æ•° */
            step++;
        }
        // å¦‚æœç©·ä¸¾å®Œéƒ½æ²¡æ‰¾åˆ°ç›®æ ‡å¯†ç ï¼Œé‚£å°±æ˜¯æ‰¾ä¸åˆ°äº†
        return -1;
    }

    // å°† s[j] å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡
    String plusOne(String s, int j) {
        char[] ch = s.toCharArray();
        if (ch[j] == '9')
            ch[j] = '0';
        else
            ch[j] += 1;
        return new String(ch);
    }

    // å°† s[i] å‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡
    String minusOne(String s, int j) {
        char[] ch = s.toCharArray();
        if (ch[j] == '0')
            ch[j] = '9';
        else
            ch[j] -= 1;
        return new String(ch);
    }
}
```

```javascript
// by chatGPT (javascript)
var openLock = function(deadends, target) {
  // è®°å½•éœ€è¦è·³è¿‡çš„æ­»äº¡å¯†ç 
  const deads = new Set(deadends);
  // è®°å½•å·²ç»ç©·ä¸¾è¿‡çš„å¯†ç ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
  const visited = new Set();
  const q = [];
  // ä»èµ·ç‚¹å¼€å§‹å¯åŠ¨å¹¿åº¦ä¼˜å…ˆæœç´¢
  let step = 0;
  q.push("0000");
  visited.add("0000");

  while (q.length > 0) {
    let sz = q.length;
    /* å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å‘¨å›´æ‰©æ•£ */
    for (let i = 0; i < sz; i++) {
      let cur = q.shift();
      /* åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹ */
      if (deads.has(cur)) continue;
          if (cur === target) return step;

      /* å°†ä¸€ä¸ªèŠ‚ç‚¹çš„æœªéå†ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */
      for (let j = 0; j < 4; j++) {
        let up = plusOne(cur, j);
        if (!visited.has(up)) {
          q.push(up);
          visited.add(up);
        }
        let down = minusOne(cur, j);
        if (!visited.has(down)) {
          q.push(down);
          visited.add(down);
        }
      }
    }
    /* åœ¨è¿™é‡Œå¢åŠ æ­¥æ•° */
    step++;
  }
  // å¦‚æœç©·ä¸¾å®Œéƒ½æ²¡æ‰¾åˆ°ç›®æ ‡å¯†ç ï¼Œé‚£å°±æ˜¯æ‰¾ä¸åˆ°äº†
  return -1;
}

// å°† s[j] å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡
function plusOne(s, j) {
  let ch = s.split("");
  if (ch[j] === "9") ch[j] = "0";
  else ch[j] = String(+ch[j]+1);
  return ch.join("");
}

// å°† s[i] å‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡
function minusOne(s, j) {
  let ch = s.split("");
  if (ch[j] === "0") ch[j] = "9";
  else ch[j] = String(+ch[j]-1);
  return ch.join("");
}
```

```python
# by chatGPT (python)
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        # è®°å½•éœ€è¦è·³è¿‡çš„æ­»äº¡å¯†ç 
        deads = set(deadends)
        # è®°å½•å·²ç»ç©·ä¸¾è¿‡çš„å¯†ç ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
        visited = set()
        q = collections.deque()
        # ä»èµ·ç‚¹å¼€å§‹å¯åŠ¨å¹¿åº¦ä¼˜å…ˆæœç´¢
        step = 0
        q.append("0000")
        visited.add("0000")

        while q:
            sz = len(q)
            # å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å‘¨å›´æ‰©æ•£
            for i in range(sz):
                cur = q.popleft()

                # åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
                if cur in deads:
                    continue
                if cur == target:
                    return step

                # å°†ä¸€ä¸ªèŠ‚ç‚¹çš„æœªéå†ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
                for j in range(4):
                    up = plusOne(cur,j)
                    if up not in visited:
                        q.append(up)
                        visited.add(up)
                    down = minusOne(cur,j)
                    if down not in visited:
                        q.append(down)
                        visited.add(down)
            # åœ¨è¿™é‡Œå¢åŠ æ­¥æ•°
            step += 1
        # å¦‚æœç©·ä¸¾å®Œéƒ½æ²¡æ‰¾åˆ°ç›®æ ‡å¯†ç ï¼Œé‚£å°±æ˜¯æ‰¾ä¸åˆ°äº†
        return -1

    # å°† s[j] å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡
    def plusOne(s: str, j: int) -> str:
        ch = list(s)
        if ch[j] == '9':
            ch[j] = '0'
        else:
            ch[j] = chr(ord(ch[j])+1)
        return "".join(ch)

    # å°† s[i] å‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡
    def minusOne(s: str, j: int) -> str:
        ch = list(s)
        if ch[j] == '0':
            ch[j] = '9'
        else:
            ch[j] = chr(ord(ch[j])-1)
        return "".join(ch)
```

https://leetcode.cn/problems/open-the-lock çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/out-of-boundary-paths çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
private:
    int memo[50][50][51];
    int m, n;
public:
    //å®šä¹‰ä¸€ä¸ªè®°å½•å‡ºç•Œè·¯å¾„æ•°é‡çš„å‡½æ•°
    int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        this->m = m;
        this->n = n;
        // å¤‡å¿˜å½•åˆå§‹åŒ–ä¸ºç‰¹æ®Šå€¼ -1
        memset(memo, -1, sizeof(memo));
        // æŒ‰ç…§å®šä¹‰ï¼Œè®¡ç®—ä» (startRow, startColumn) å¼€å§‹ï¼Œæœ€å¤§ç§»åŠ¨æ¬¡æ•°ä¸º maxMove çš„å‡ºç•Œè·¯å¾„æ•°é‡
        return dp(maxMove, startRow, startColumn);
    }

    //ä» (i,j) å‡ºå‘ï¼Œæœ€å¤§ç§»åŠ¨æ¬¡æ•°ä¸º maxMoveï¼Œå‡ºç•Œçš„è·¯å¾„æ•°é‡ä¸º dp(maxMove, i, j)
    int dp(int maxMove, int i, int j) {
        // base caseï¼Œæ‰¾åˆ°ä¸€æ¡å‡ºç•Œè·¯å¾„
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return 1;
        }
        // é¿å…å†—ä½™è®¡ç®—
        if (memo[i][j][maxMove] != -1) {
            return memo[i][j][maxMove];
        }
        // æ— æ³•åœ¨æœ‰é™çš„æ­¥æ•°å†…å‡ºç•Œ
        if (maxMove == 0) {
            return 0;
        }
        // çŠ¶æ€è½¬ç§»å…³ç³»ï¼š
        // åœ¨ maxMove æ­¥ä¹‹å†…ä» (i, j) è¸¢å‡ºç•Œçš„è·¯å¾„æ•°é‡ç­‰äº
        // åœ¨ maxMove - 1 æ­¥ä¹‹å†…ä» (i, j) çš„ç›¸é‚»ä½ç½®è¸¢å‡ºç•Œçš„è·¯å¾„æ•°é‡ä¹‹å’Œ

        long res = 0;
        res += dp(maxMove - 1, i, j + 1); //å‘å³èµ°
        res += dp(maxMove - 1, i + 1, j); //å‘ä¸‹èµ°
        res += dp(maxMove - 1, i - 1, j); //å‘ä¸Šèµ°
        res += dp(maxMove - 1, i, j - 1); //å‘å·¦èµ°

        memo[i][j][maxMove] = (int) (res % 1000000007); // ä¿å­˜ç»“æœ
        return memo[i][j][maxMove];
    }
};
```

```go
// by chatGPT (go)
// å®šä¹‰ä¸€ä¸ªä¸‰ç»´å¤‡å¿˜å½•
func findPaths(m int, n int, maxMove int, startRow int, startColumn int) int {
    memo := make([][][]int, m)
    for i := 0; i < m; i++ {
        memo[i] = make([][]int, n)
        for j := 0; j < n; j++ {
            memo[i][j] = make([]int, maxMove+1)
            for k := 0; k <= maxMove; k++ {
                // å¤‡å¿˜å½•åˆå§‹åŒ–ä¸º -1
                memo[i][j][k] = -1
            }
        }
    }

    // æŒ‰ç…§å®šä¹‰ï¼Œè®¡ç®—ä» (startRow, startColumn) å¼€å§‹ï¼Œæœ€å¤§ç§»åŠ¨æ¬¡æ•°ä¸º maxMove çš„å‡ºç•Œè·¯å¾„æ•°é‡
    return dp(memo, maxMove, startRow, startColumn, m, n)
}

// å®šä¹‰ï¼šä» (i, j) å‡ºå‘ï¼Œæœ€å¤§ç§»åŠ¨æ¬¡æ•°ä¸º maxMoveï¼Œå‡ºç•Œçš„è·¯å¾„æ•°é‡ä¸º dp(memo, maxMove, i, j)
func dp(memo [][][]int, maxMove int, i int, j int, m int, n int) int {
    // base caseï¼Œæ‰¾åˆ°ä¸€æ¡å‡ºç•Œè·¯å¾„
    if i < 0 || j < 0 || i >= m || j >= n {
        return 1
    }
    // é¿å…å†—ä½™è®¡ç®—
    if memo[i][j][maxMove] != -1 {
        return memo[i][j][maxMove]
    }
    // æ— æ³•åœ¨æœ‰é™çš„æ­¥æ•°å†…å‡ºç•Œ
    if maxMove == 0 {
        return 0
    }
    // çŠ¶æ€è½¬ç§»å…³ç³»ï¼š
    // åœ¨ maxMove æ­¥ä¹‹å†…ä» (i, j) è¸¢å‡ºç•Œçš„è·¯å¾„æ•°é‡ç­‰äº
    // åœ¨ maxMove - 1 æ­¥ä¹‹å†…ä» (i, j) çš„ç›¸é‚»ä½ç½®è¸¢å‡ºç•Œçš„è·¯å¾„æ•°é‡ä¹‹å’Œ
    var res, mod int
    mod = 1e9 + 7
    res += dp(memo, maxMove-1, i, j+1, m, n)
    res += dp(memo, maxMove-1, i+1, j, m, n)
    res += dp(memo, maxMove-1, i-1, j, m, n)
    res += dp(memo, maxMove-1, i, j-1, m, n)
	
    memo[i][j][maxMove] = res % mod
    return memo[i][j][maxMove]
}
```

```java
// by labuladong (java)
class Solution {
    int[][][] memo;
    int m, n;

    public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        this.m = m;
        this.n = n;
        memo = new int[m][n][maxMove + 1];
        // å¤‡å¿˜å½•åˆå§‹åŒ–ä¸ºç‰¹æ®Šå€¼ -1
        for (int[][] plane : memo) {
            for (int[] row : plane) {
                Arrays.fill(row, -1);
            }
        }
        // æŒ‰ç…§å®šä¹‰ï¼Œè®¡ç®—ä» (startRow, startColumn) å¼€å§‹ï¼Œæœ€å¤§ç§»åŠ¨æ¬¡æ•°ä¸º maxMove çš„å‡ºç•Œè·¯å¾„æ•°é‡
        return dp(maxMove, startRow, startColumn);
    }

    // å®šä¹‰ï¼šä» (i, j) å‡ºå‘ï¼Œæœ€å¤§ç§»åŠ¨æ¬¡æ•°ä¸º maxMoveï¼Œå‡ºç•Œçš„è·¯å¾„æ•°é‡ä¸º dp(maxMove, i, j)
    int dp(int maxMove, int i, int j) {
        // base caseï¼Œæ‰¾åˆ°ä¸€æ¡å‡ºç•Œè·¯å¾„
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return 1;
        }
        // é¿å…å†—ä½™è®¡ç®—
        if (memo[i][j][maxMove] != -1) {
            return memo[i][j][maxMove];
        }
        // æ— æ³•åœ¨æœ‰é™çš„æ­¥æ•°å†…å‡ºç•Œ
        if (maxMove == 0) {
            return 0;
        }
        // çŠ¶æ€è½¬ç§»å…³ç³»ï¼š
        // åœ¨ maxMove æ­¥ä¹‹å†…ä» (i, j) è¸¢å‡ºç•Œçš„è·¯å¾„æ•°é‡ç­‰äº
        // åœ¨ maxMove - 1 æ­¥ä¹‹å†…ä» (i, j) çš„ç›¸é‚»ä½ç½®è¸¢å‡ºç•Œçš„è·¯å¾„æ•°é‡ä¹‹å’Œ
        long res = 0;
        res += dp(maxMove - 1, i, j + 1);
        res += dp(maxMove - 1, i + 1, j);
        res += dp(maxMove - 1, i - 1, j);
        res += dp(maxMove - 1, i, j - 1);

        memo[i][j][maxMove] = (int) (res % 1000000007);
        return memo[i][j][maxMove];
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} m
 * @param {number} n
 * @param {number} maxMove
 * @param {number} startRow
 * @param {number} startColumn
 * @return {number}
 */
var findPaths = function(m, n, maxMove, startRow, startColumn) {
    // memoæ•°ç»„ç”¨äºå­˜å‚¨è®¡ç®—è¿‡çš„ç»“æœï¼Œé¿å…é‡å¤è®¡ç®—
    let memo = new Array(m);
    for (let i = 0; i < m; i++) {
        memo[i] = new Array(n);
        for (let j = 0; j < n; j++) {
            memo[i][j] = new Array(maxMove + 1).fill(-1);
        }
    }
    // æŒ‰ç…§å®šä¹‰ï¼Œè®¡ç®—ä»(startRow, startColumn)å¼€å§‹ï¼Œæœ€å¤§ç§»åŠ¨æ¬¡æ•°ä¸ºmaxMoveçš„å‡ºç•Œè·¯å¾„æ•°é‡
    return dp(maxMove, startRow, startColumn);

    // å®šä¹‰ï¼šä»(i, j)å‡ºå‘ï¼Œæœ€å¤§ç§»åŠ¨æ¬¡æ•°ä¸ºmaxMoveï¼Œå‡ºç•Œçš„è·¯å¾„æ•°é‡ä¸ºdp(maxMove, i, j)
    function dp(maxMove, i, j) {
        // base caseï¼Œæ‰¾åˆ°ä¸€æ¡å‡ºç•Œè·¯å¾„
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return 1;
        }
        // é¿å…å†—ä½™è®¡ç®—
        if (memo[i][j][maxMove] !== -1) {
            return memo[i][j][maxMove];
        }
        // æ— æ³•åœ¨æœ‰é™çš„æ­¥æ•°å†…å‡ºç•Œ
        if (maxMove === 0) {
            return 0;
        }
        // çŠ¶æ€è½¬ç§»å…³ç³»ï¼š
        // åœ¨ maxMove æ­¥ä¹‹å†…ä» (i, j) è¸¢å‡ºç•Œçš„è·¯å¾„æ•°é‡ç­‰äº
        // åœ¨ maxMove - 1 æ­¥ä¹‹å†…ä» (i, j) çš„ç›¸é‚»ä½ç½®è¸¢å‡ºç•Œçš„è·¯å¾„æ•°é‡ä¹‹å’Œ
        let res = 0;
        res += dp(maxMove - 1, i, j + 1);
        res += dp(maxMove - 1, i + 1, j);
        res += dp(maxMove - 1, i - 1, j);
        res += dp(maxMove - 1, i, j - 1);

        memo[i][j][maxMove] = res % 1000000007;
        return memo[i][j][maxMove];
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:
        memo = [[[-1 for _ in range(maxMove + 1)] for _ in range(n)] for _ in range(m)]

        def dp(maxMove: int, i: int, j: int) -> int:
            # base caseï¼Œæ‰¾åˆ°ä¸€æ¡å‡ºç•Œè·¯å¾„
            if i < 0 or j < 0 or i >= m or j >= n:
                return 1
            # é¿å…å†—ä½™è®¡ç®—
            if memo[i][j][maxMove] != -1:
                return memo[i][j][maxMove]
            # æ— æ³•åœ¨æœ‰é™çš„æ­¥æ•°å†…å‡ºç•Œ
            if maxMove == 0:
                return 0
            # çŠ¶æ€è½¬ç§»å…³ç³»ï¼š
            # åœ¨ maxMove æ­¥ä¹‹å†…ä» (i, j) è¸¢å‡ºç•Œçš„è·¯å¾„æ•°é‡ç­‰äº
            # åœ¨ maxMove - 1 æ­¥ä¹‹å†…ä» (i, j) çš„ç›¸é‚»ä½ç½®è¸¢å‡ºç•Œçš„è·¯å¾„æ•°é‡ä¹‹å’Œ
            res = 0
            res += dp(maxMove - 1, i, j + 1)
            res += dp(maxMove - 1, i + 1, j)
            res += dp(maxMove - 1, i - 1, j)
            res += dp(maxMove - 1, i, j - 1)

            memo[i][j][maxMove] = res % 1000000007
            return memo[i][j][maxMove]

        # å¤‡å¿˜å½•åˆå§‹åŒ–ä¸ºç‰¹æ®Šå€¼ -1
        for plane in memo:
            for row in plane:
                for k in range(maxMove + 1):
                    row[k] = -1

        # æŒ‰ç…§å®šä¹‰ï¼Œè®¡ç®—ä» (startRow, startColumn) å¼€å§‹ï¼Œæœ€å¤§ç§»åŠ¨æ¬¡æ•°ä¸º maxMove çš„å‡ºç•Œè·¯å¾„æ•°é‡
        return dp(maxMove, startRow, startColumn)
```

https://leetcode.cn/problems/out-of-boundary-paths çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/palindrome-linked-list çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode *slow, *fast;   // Define two pointers
        slow = fast = head;      // Initialize the pointers
        while (fast != nullptr && fast->next != nullptr) {  // Loop until fast pointer reaches the end
            slow = slow->next;   // Move slow pointer one step
            fast = fast->next->next;   // Move fast pointer two step
        }

        if (fast != nullptr)    // If fast pointer is not nullptr
            slow = slow->next;  // Move the slow pointer one step

        ListNode *left = head;  // Initialize left pointer to head
        ListNode *right = reverse(slow);   // Reverse the right half of the list and make the right pointer point to the new head
        while (right != nullptr) {        // Loop until right pointer is nullptr
            if (left->val != right->val)  // If the values of left and right pointers are not equal
                return false;            // Return false
            left = left->next;           // Move the left pointer one step
            right = right->next;         // Move the right pointer one step
        }

        return true;   // Return true if all elements in the list are equal to their corresponding elements in the reversed list
    }

    ListNode* reverse(ListNode* head) {
        ListNode *pre = nullptr, *cur = head;   // Define two pointers
        while (cur != nullptr) {   // Loop until the last node of the list is reached
            ListNode *next = cur->next;    // Store the next pointer temporarily
            cur->next = pre;               // Reverse the pointer
            pre = cur;                     // Move the pre pointer one step
            cur = next;                    // Move the cur pointer one step forward
        }
        return pre;            // Return the new head
    }
};
```

```go
// by chatGPT (go)
func isPalindrome(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    if fast != nil {
        slow = slow.Next
    }

    left, right := head, reverse(slow)
    for right != nil {
        if left.Val != right.Val {
            return false
        }
        left = left.Next
        right = right.Next
    }

    return true
}

func reverse(head *ListNode) *ListNode {
    var pre, cur *ListNode
    cur = head
    for cur != nil {
        next := cur.Next
        cur.Next = pre
        pre = cur
        cur = next
    }
    return pre
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode slow, fast;
        slow = fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        if (fast != null)
            slow = slow.next;

        ListNode left = head;
        ListNode right = reverse(slow);
        while (right != null) {
            if (left.val != right.val)
                return false;
            left = left.next;
            right = right.next;
        }

        return true;
    }

    ListNode reverse(ListNode head) {
        ListNode pre = null, cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

```javascript
// by chatGPT (javascript)
var isPalindrome = function(head) {
  let [slow, fast] = [head, head];
  while (fast !== null && fast.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
  }

  if (fast !== null)
    slow = slow.next;

  let left = head;
  let right = reverse(slow);
  while (right !== null) {
    if (left.val !== right.val)
      return false;
    left = left.next;
    right = right.next;
  }

  return true;
};

function reverse(head) {
  let [pre, cur] = [null, head];
  while (cur !== null) {
    let next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }
  return pre;
}
```

```python
# by chatGPT (python)
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        if fast:
            slow = slow.next

        left = head
        right = self.reverse(slow)
        while right:
            if left.val != right.val:
                return False
            left = left.next
            right = right.next
            
        return True
    
    def reverse(self, head: ListNode) -> ListNode:
        pre, cur = None, head
        while cur:
            next_node = cur.next
            cur.next = pre
            pre = cur
            cur = next_node
            
        return pre
```

https://leetcode.cn/problems/palindrome-linked-list çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/palindrome-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0) {
            return false;
        }
        int temp = x;
        // y æ˜¯ x ç¿»è½¬åçš„æ•°å­—
        int y = 0;
        while (temp > 0) {
            int last_num = temp % 10;
            temp = temp / 10;
            // ä»æœ€é«˜ä½ç”Ÿæˆæ•°å­—çš„æŠ€å·§
            y = y * 10 + last_num;
        }
        return y == x;
    }
};
```

```go
// by chatGPT (go)
// IsPalindrome æ˜¯åˆ¤æ–­ä¸€ä¸ªæ•´æ•°æ˜¯å¦ä¸ºå›æ–‡æ•°çš„å‡½æ•°
func IsPalindrome(x int) bool {
	// å¦‚æœ x æ˜¯è´Ÿæ•°ï¼Œé‚£ä¹ˆå®ƒä¸å¯èƒ½ä¸ºå›æ–‡æ•°ï¼Œç›´æ¥è¿”å› false
	if x < 0 {
		return false
	}

	// temp æ˜¯ x çš„å‰¯æœ¬
	temp := x
	// y æ˜¯ x ç¿»è½¬åçš„æ•°å­—
	y := 0

	// å°† temp é€†åºç”Ÿæˆ y
	for temp > 0 {
		lastNum := temp % 10
		temp = temp / 10
		y = y*10 + lastNum
	}

	// å¦‚æœ x å’Œ y ç›¸ç­‰ï¼Œé‚£ä¹ˆ x å°±æ˜¯å›æ–‡æ•°
	return y == x
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0) {
            return false;
        }
        int temp = x;
        // y æ˜¯ x ç¿»è½¬åçš„æ•°å­—
        int y = 0;
        while (temp > 0) {
            int last_num = temp % 10;
            temp = temp / 10;
            // ä»æœ€é«˜ä½ç”Ÿæˆæ•°å­—çš„æŠ€å·§
            y = y * 10 + last_num;
        }
        return y == x;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    if (x < 0) {
        return false;
    }
    var temp = x;
    // y æ˜¯ x ç¿»è½¬åçš„æ•°å­—
    var y = 0;
    while (temp > 0) {
        var last_num = temp % 10;
        temp = Math.floor(temp / 10);
        // ä»æœ€é«˜ä½ç”Ÿæˆæ•°å­—çš„æŠ€å·§
        y = y * 10 + last_num;
    }
    return y == x;
};
```

```python
# by chatGPT (python)
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        temp = x
        # y æ˜¯ x ç¿»è½¬åçš„æ•°å­—
        y = 0
        while temp > 0:
            last_num = temp % 10
            temp = temp // 10
            # ä»æœ€é«˜ä½ç”Ÿæˆæ•°å­—çš„æŠ€å·§
            y = y * 10 + last_num
        return y == x
```

https://leetcode.cn/problems/palindrome-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/pancake-sorting çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    vector<int> res; 
    
public:
    vector<int> pancakeSort(vector<int>& cakes) {
        sort(cakes, cakes.size());
        return res;
    }

    void sort(vector<int>& cakes, int n) {
        // base case
        if (n == 1) return;

        // å¯»æ‰¾æœ€å¤§é¥¼çš„ç´¢å¼•
        int maxCake = 0;
        int maxCakeIndex = 0;
        for (int i = 0; i < n; i++)
            if (cakes[i] > maxCake) {
                maxCakeIndex = i;
                maxCake = cakes[i];
            }

        // ç¬¬ä¸€æ¬¡ç¿»è½¬ï¼Œå°†æœ€å¤§é¥¼ç¿»åˆ°æœ€ä¸Šé¢
        reverse(cakes, 0, maxCakeIndex);
        res.push_back(maxCakeIndex + 1);
        // ç¬¬äºŒæ¬¡ç¿»è½¬ï¼Œå°†æœ€å¤§é¥¼ç¿»åˆ°æœ€ä¸‹é¢
        reverse(cakes, 0, n - 1);
        res.push_back(n);
        //é€’å½’è°ƒç”¨
        sort(cakes, n - 1);
    }

    void reverse(vector<int>& arr, int i, int j) {
        while (i < j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */

func pancakeSort(cakes []int) []int {
    // è®°å½•åè½¬æ“ä½œåºåˆ—
    res := []int{}
    sort(cakes, len(cakes), &res)
    return res
}

func sort(cakes []int, n int, res *[]int) {
    // base case
    if n == 1 {
        return
    }

    // å¯»æ‰¾æœ€å¤§é¥¼çš„ç´¢å¼•
    maxCake := 0
    maxCakeIndex := 0
    for i := 0; i < n; i++ {
        if cakes[i] > maxCake {
            maxCakeIndex = i
            maxCake = cakes[i]
        }
    }

    // ç¬¬ä¸€æ¬¡ç¿»è½¬ï¼Œå°†æœ€å¤§é¥¼ç¿»åˆ°æœ€ä¸Šé¢
    reverse(cakes, 0, maxCakeIndex)
    *res = append(*res, maxCakeIndex+1)
    // ç¬¬äºŒæ¬¡ç¿»è½¬ï¼Œå°†æœ€å¤§é¥¼ç¿»åˆ°æœ€ä¸‹é¢
    reverse(cakes, 0, n-1)
    *res = append(*res, n)

    // é€’å½’è°ƒç”¨
    sort(cakes, n-1, res)
}

func reverse(arr []int, i int, j int) {
    for i < j {
        temp := arr[i]
        arr[i] = arr[j];
        arr[j] = temp;
        i++
        j--
    }
}
```

```java
// by labuladong (java)
class Solution {
    // è®°å½•åè½¬æ“ä½œåºåˆ—
    LinkedList<Integer> res = new LinkedList<>();

    public List<Integer> pancakeSort(int[] cakes) {
        sort(cakes, cakes.length);
        return res;
    }

    void sort(int[] cakes, int n) {
        // base case
        if (n == 1) return;

        // å¯»æ‰¾æœ€å¤§é¥¼çš„ç´¢å¼•
        int maxCake = 0;
        int maxCakeIndex = 0;
        for (int i = 0; i < n; i++)
            if (cakes[i] > maxCake) {
                maxCakeIndex = i;
                maxCake = cakes[i];
            }

        // ç¬¬ä¸€æ¬¡ç¿»è½¬ï¼Œå°†æœ€å¤§é¥¼ç¿»åˆ°æœ€ä¸Šé¢
        reverse(cakes, 0, maxCakeIndex);
        res.add(maxCakeIndex + 1);
        // ç¬¬äºŒæ¬¡ç¿»è½¬ï¼Œå°†æœ€å¤§é¥¼ç¿»åˆ°æœ€ä¸‹é¢
        reverse(cakes, 0, n - 1);
        res.add(n);
        /**<extend up -150>
        ![](../pictures/pancakeSort/3.jpg)
        */
        // é€’å½’è°ƒç”¨
        sort(cakes, n - 1);
        /**<extend up -150>
        ![](../pictures/pancakeSort/4.jpg)
        */
    }

    void reverse(int[] arr, int i, int j) {
        while (i < j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var pancakeSort = function(cakes) {
    // Record the flip sequence 
    // è®°å½•åè½¬æ“ä½œåºåˆ—
    const res = [];

    // Sort the cakes array and record the flipping sequence
    // å¯¹è›‹ç³•æ•°ç»„è¿›è¡Œæ’åºï¼Œå¹¶è®°å½•ç¿»è½¬åºåˆ—
    sort(cakes, cakes.length);

    // Return the flipping sequence 
    // è¿”å›ç¿»è½¬åºåˆ—
    return res;

    /**
     * Sort the cakes array in decreasing order recursively
     * é€’å½’ä»¥é€’å‡çš„é¡ºåºå¯¹è›‹ç³•æ•°ç»„æ’åº
     * @param {number[]} cakes - The array for sorting
     * @param {number} n - The length of the array
     */
    function sort(cakes, n) {
        // Base case
        // åŸºæœ¬æƒ…å†µ
        if (n == 1) return;

        // Find the index of max cake
        // æ‰¾åˆ°æœ€å¤§è›‹ç³•çš„ç´¢å¼•
        let maxCake = 0;
        let maxCakeIndex = 0;

        for (let i = 0; i < n; i++) {
            if (cakes[i] > maxCake) {
                maxCakeIndex = i;
                maxCake = cakes[i];
            }
        }

        // First flip to bring the max cake to the top
        // ç¬¬ä¸€æ¬¡ç¿»è½¬ï¼Œå°†æœ€å¤§é¥¼ç¿»åˆ°æœ€ä¸Šé¢
        reverse(cakes, 0, maxCakeIndex);

        res.push(maxCakeIndex + 1);

        // Second flip the max cake to bring it to the bottom
        // ç¬¬äºŒæ¬¡ç¿»è½¬ï¼Œå°†æœ€å¤§é¥¼ç¿»åˆ°æœ€ä¸‹é¢
        reverse(cakes, 0, n - 1);

        res.push(n);

        // Recursively call the sort function with length-1
        // é€’å½’è°ƒç”¨é•¿åº¦å‡1çš„ sort å‡½æ•°
        sort(cakes, n - 1);
    }

    /**
     * Flip the cake array from index i to index j
     * ç¿»è½¬è›‹ç³•æ•°ç»„ä» i åˆ° j ç´¢å¼•
     * @param {number[]} arr - The array for flipping
     * @param {number} i - The start index
     * @param {number} j - The end index
     */
    function reverse(arr, i, j) {
        while (i < j) {
            let temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.res = [] #è®°å½•åè½¬æ“ä½œåºåˆ—
    def pancakeSort(self, cakes: List[int]) -> List[int]:
        self.sort(cakes, len(cakes))
        return self.res

    def sort(self, cakes: List[int], n: int) -> None:
        # base case
        if n == 1:
            return

        # å¯»æ‰¾æœ€å¤§é¥¼çš„ç´¢å¼•
        maxCake = 0
        maxCakeIndex = 0
        for i in range(n):
            if cakes[i] > maxCake:
                maxCakeIndex = i
                maxCake = cakes[i]

        # ç¬¬ä¸€æ¬¡ç¿»è½¬ï¼Œå°†æœ€å¤§é¥¼ç¿»åˆ°æœ€ä¸Šé¢
        self.reverse(cakes, 0, maxCakeIndex)
        self.res.append(maxCakeIndex + 1)
        # ç¬¬äºŒæ¬¡ç¿»è½¬ï¼Œå°†æœ€å¤§é¥¼ç¿»åˆ°æœ€ä¸‹é¢
        self.reverse(cakes, 0, n - 1)
        self.res.append(n)

        #é€’å½’è°ƒç”¨
        self.sort(cakes, n - 1)

    def reverse(self, arr: List[int], i: int, j: int) -> None:
        while i < j:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
            j -= 1
```

https://leetcode.cn/problems/pancake-sorting çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/partition-equal-subset-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (int num : nums) sum += num;
        // å’Œä¸ºå¥‡æ•°æ—¶ï¼Œä¸å¯èƒ½åˆ’åˆ†æˆä¸¤ä¸ªå’Œç›¸ç­‰çš„é›†åˆ
        if (sum % 2 != 0) return false;
        int n = nums.size();
        sum = sum / 2;
        vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));
        // base case
        for (int i = 0; i <= n; i++)
            dp[i][0] = true;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= sum; j++) {
                if (j - nums[i - 1] < 0) { 
                    // èƒŒåŒ…å®¹é‡ä¸è¶³ï¼Œä¸èƒ½è£…å…¥ç¬¬ i ä¸ªç‰©å“
                    dp[i][j] = dp[i - 1][j];
                } else { 
                    // è£…å…¥æˆ–ä¸è£…å…¥èƒŒåŒ…
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
                }
            }
        }
        return dp[n][sum];
    }
};
```

```go
// by chatGPT (go)
func canPartition(nums []int) bool {
    var sum int
    for _, num := range nums {
        sum += num
    }
    // å’Œä¸ºå¥‡æ•°æ—¶ï¼Œä¸å¯èƒ½åˆ’åˆ†æˆä¸¤ä¸ªå’Œç›¸ç­‰çš„é›†åˆ
    if sum % 2 != 0 {
        return false
    }
    n := len(nums)
    sum = sum / 2
    dp := make([][]bool, n+1)
    for i := range dp {
        dp[i] = make([]bool, sum+1)
    }
    // base case
    for i := 0; i <= n; i++ {
        dp[i][0] = true
    }

    for i := 1; i <= n; i++ {
        for j := 1; j <= sum; j++ {
            if j - nums[i-1] < 0 {
                // èƒŒåŒ…å®¹é‡ä¸è¶³ï¼Œä¸èƒ½è£…å…¥ç¬¬ i ä¸ªç‰©å“
                dp[i][j] = dp[i - 1][j]
            } else {
                // è£…å…¥æˆ–ä¸è£…å…¥èƒŒåŒ…
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]
            }
        }
    }
    return dp[n][sum]
}
```

```java
// by labuladong (java)
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) sum += num;
        // å’Œä¸ºå¥‡æ•°æ—¶ï¼Œä¸å¯èƒ½åˆ’åˆ†æˆä¸¤ä¸ªå’Œç›¸ç­‰çš„é›†åˆ
        if (sum % 2 != 0) return false;
        int n = nums.length;
        sum = sum / 2;
        boolean[][] dp = new boolean[n + 1][sum + 1];
        // base case
        for (int i = 0; i <= n; i++)
            dp[i][0] = true;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= sum; j++) {
                if (j - nums[i - 1] < 0) {
                    // èƒŒåŒ…å®¹é‡ä¸è¶³ï¼Œä¸èƒ½è£…å…¥ç¬¬ i ä¸ªç‰©å“
                    dp[i][j] = dp[i - 1][j];
                } else {
                    // è£…å…¥æˆ–ä¸è£…å…¥èƒŒåŒ…
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
                }
            }
        }
        return dp[n][sum];
    }
}
```

```javascript
// by chatGPT (javascript)
var canPartition = function(nums) {
    var sum = nums.reduce(function(acc, curr){return acc + curr});
    // å’Œä¸ºå¥‡æ•°æ—¶ï¼Œä¸å¯èƒ½åˆ’åˆ†æˆä¸¤ä¸ªå’Œç›¸ç­‰çš„é›†åˆ
    if (sum % 2 !== 0) return false;
    var n = nums.length;
    sum = sum / 2;
    var dp = new Array(n + 1).fill().map(() => new Array(sum + 1).fill(false));
    // base case
    for (var i = 0; i <= n; i++)
        dp[i][0] = true;

    for (var i = 1; i <= n; i++) {
        for (var j = 1; j <= sum; j++) {
            if (j - nums[i - 1] < 0) {
                // èƒŒåŒ…å®¹é‡ä¸è¶³ï¼Œä¸èƒ½è£…å…¥ç¬¬ i ä¸ªç‰©å“
                dp[i][j] = dp[i - 1][j];
            } else {
                // è£…å…¥æˆ–ä¸è£…å…¥èƒŒåŒ…
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
            }
        }
    }
    return dp[n][sum];
};
```

```python
# by chatGPT (python)
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sum_ = sum(nums)
        # å’Œä¸ºå¥‡æ•°æ—¶ï¼Œä¸å¯èƒ½åˆ’åˆ†æˆä¸¤ä¸ªå’Œç›¸ç­‰çš„é›†åˆ
        if sum_ % 2 != 0:
            return False
        n = len(nums)
        sum_ = sum_ // 2
        dp = [[False] * (sum_ + 1) for _ in range(n + 1)]
        
        # base case
        for i in range(n + 1):
            dp[i][0] = True

        for i in range(1, n + 1):
            for j in range(1, sum_ + 1):
                if j - nums[i - 1] < 0:
                    # èƒŒåŒ…å®¹é‡ä¸è¶³ï¼Œä¸èƒ½è£…å…¥ç¬¬ i ä¸ªç‰©å“
                    dp[i][j] = dp[i - 1][j]
                else:
                    # è£…å…¥æˆ–ä¸è£…å…¥èƒŒåŒ…
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]
        return dp[n][sum_]
```

https://leetcode.cn/problems/partition-equal-subset-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/partition-to-k-equal-sum-subsets çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        // æ’é™¤ä¸€äº›åŸºæœ¬æƒ…å†µ
        if (k > nums.size()) return false;
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum % k != 0) return false;

        int used = 0;
        int target = sum / k;
        return backtrack(k, 0, nums, 0, used, target);
    }
    
private:
    unordered_map<int, bool> memo;

    bool backtrack(int k, int bucket, vector<int>& nums, int start, int used, int target) {
        if (k == 0) {
            return true;
        }
        if (bucket == target) {
            bool res = backtrack(k - 1, 0, nums, 0, used, target);
            memo[used] = res;
            return res;
        }

        if (memo.count(used)) {
            return memo[used];
        }

        for (int i = start; i < nums.size(); i++) {
            if ((used >> i) & 1) {
                continue;
            }
            if (nums[i] + bucket > target) {
                continue;
            }
            used |= 1 << i;
            bucket += nums[i];
            if (backtrack(k, bucket, nums, i + 1, used, target)) {
                return true;
            }
            used ^= 1 << i;
            bucket -= nums[i];
        }

        return false;
    }
};
```

```go
// by chatGPT (go)
func canPartitionKSubsets(nums []int, k int) bool {
    memo := make(map[int]bool)
    // æ’é™¤ä¸€äº›åŸºæœ¬æƒ…å†µ
    if k > len(nums) {
        return false
    }
    sum := 0
    for _, v := range nums {
        sum += v
    }
    if sum%k != 0 {
        return false
    }

    var backtrack func(k, bucket int, nums []int, start, used, target int) bool
    backtrack = func(k, bucket int, nums []int, start, used, target int) bool {
        // base case
        if k == 0 {
            // æ‰€æœ‰æ¡¶éƒ½è¢«è£…æ»¡äº†ï¼Œè€Œä¸” nums ä¸€å®šå…¨éƒ¨ç”¨å®Œäº†
            return true
        }
        if bucket == target {
            // è£…æ»¡äº†å½“å‰æ¡¶ï¼Œé€’å½’ç©·ä¸¾ä¸‹ä¸€ä¸ªæ¡¶çš„é€‰æ‹©
            // è®©ä¸‹ä¸€ä¸ªæ¡¶ä» nums[0] å¼€å§‹é€‰æ•°å­—
            if res, ok := memo[used]; ok {
                return res
            }
            res := backtrack(k-1, 0, nums, 0, used, target)
            // ç¼“å­˜ç»“æœ
            memo[used] = res
            return res
        }

        if res, ok := memo[used]; ok {
            // é¿å…å†—ä½™è®¡ç®—
            return res
        }

        for i := start; i < len(nums); i++ {
            // å‰ªæ
            if (used>>i)&1 == 1 { // åˆ¤æ–­ç¬¬ i ä½æ˜¯å¦æ˜¯ 1
                // nums[i] å·²ç»è¢«è£…å…¥åˆ«çš„æ¡¶ä¸­
                continue
            }
            if nums[i]+bucket > target {
                continue
            }
            // åšé€‰æ‹©
            newUsed := used | 1<<i // å°†ç¬¬ i ä½ç½®ä¸º 1
            newBucket := bucket + nums[i]
            // é€’å½’ç©·ä¸¾ä¸‹ä¸€ä¸ªæ•°å­—æ˜¯å¦è£…å…¥å½“å‰æ¡¶
            if backtrack(k, newBucket, nums, i+1, newUsed, target) {
                return true
            }
            // æ’¤é”€é€‰æ‹©
        }

        memo[used] = false
        return false
    }

    used := 0 // ä½¿ç”¨ä½å›¾æŠ€å·§
    target := sum / k
    // k å·æ¡¶åˆå§‹ä»€ä¹ˆéƒ½æ²¡è£…ï¼Œä» nums[0] å¼€å§‹åšé€‰æ‹©
    return backtrack(k, 0, nums, 0, used, target)
}
```

```java
// by labuladong (java)
class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
        // æ’é™¤ä¸€äº›åŸºæœ¬æƒ…å†µ
        if (k > nums.length) return false;
        int sum = 0;
        for (int v : nums) sum += v;
        if (sum % k != 0) return false;
        
        int used = 0; // ä½¿ç”¨ä½å›¾æŠ€å·§
        int target = sum / k;
        // k å·æ¡¶åˆå§‹ä»€ä¹ˆéƒ½æ²¡è£…ï¼Œä» nums[0] å¼€å§‹åšé€‰æ‹©
        return backtrack(k, 0, nums, 0, used, target);
    }

    HashMap<Integer, Boolean> memo = new HashMap<>();

    boolean backtrack(int k, int bucket,
                    int[] nums, int start, int used, int target) {        
        // base case
        if (k == 0) {
            // æ‰€æœ‰æ¡¶éƒ½è¢«è£…æ»¡äº†ï¼Œè€Œä¸” nums ä¸€å®šå…¨éƒ¨ç”¨å®Œäº†
            return true;
        }
        if (bucket == target) {
            // è£…æ»¡äº†å½“å‰æ¡¶ï¼Œé€’å½’ç©·ä¸¾ä¸‹ä¸€ä¸ªæ¡¶çš„é€‰æ‹©
            // è®©ä¸‹ä¸€ä¸ªæ¡¶ä» nums[0] å¼€å§‹é€‰æ•°å­—
            boolean res = backtrack(k - 1, 0, nums, 0, used, target);
            // ç¼“å­˜ç»“æœ
            memo.put(used, res);
            return res;
        }
        
        if (memo.containsKey(used)) {
            // é¿å…å†—ä½™è®¡ç®—
            return memo.get(used);
        }

        for (int i = start; i < nums.length; i++) {
            // å‰ªæ
            if (((used >> i) & 1) == 1) { // åˆ¤æ–­ç¬¬ i ä½æ˜¯å¦æ˜¯ 1
                // nums[i] å·²ç»è¢«è£…å…¥åˆ«çš„æ¡¶ä¸­
                continue;
            }
            if (nums[i] + bucket > target) {
                continue;
            }
            // åšé€‰æ‹©
            used |= 1 << i; // å°†ç¬¬ i ä½ç½®ä¸º 1
            bucket += nums[i];
            /**<extend down -200>
            ![](../pictures/é›†åˆåˆ’åˆ†/5.jpeg)
            */
            // é€’å½’ç©·ä¸¾ä¸‹ä¸€ä¸ªæ•°å­—æ˜¯å¦è£…å…¥å½“å‰æ¡¶
            if (backtrack(k, bucket, nums, i + 1, used, target)) {
                return true;
            }
            // æ’¤é”€é€‰æ‹©
            used ^= 1 << i; // å°†ç¬¬ i ä½ç½®ä¸º 0
            bucket -= nums[i];
        }

        return false;
    }
}
```

```javascript
// by chatGPT (javascript)
var canPartitionKSubsets = function(nums, k) {
    let memo = new Map();
    
    function backtrack(k, bucket, nums, start, used, target) {  
        // base case
        if (k == 0) {
            // æ‰€æœ‰æ¡¶éƒ½è¢«è£…æ»¡äº†ï¼Œè€Œä¸” nums ä¸€å®šå…¨éƒ¨ç”¨å®Œäº†
            return true;
        }
        if (bucket == target) {
            // è£…æ»¡äº†å½“å‰æ¡¶ï¼Œé€’å½’ç©·ä¸¾ä¸‹ä¸€ä¸ªæ¡¶çš„é€‰æ‹©
            // è®©ä¸‹ä¸€ä¸ªæ¡¶ä» nums[0] å¼€å§‹é€‰æ•°å­—
            let res = backtrack(k - 1, 0, nums, 0, used, target);
            // ç¼“å­˜ç»“æœ
            memo.set(used, res);
            return res;
        }

        if (memo.has(used)) {
            // é¿å…å†—ä½™è®¡ç®—
            return memo.get(used);
        }

        for (let i = start; i < nums.length; i++) {
            // å‰ªæ
            if (((used >> i) & 1) == 1) { // åˆ¤æ–­ç¬¬ i ä½æ˜¯å¦æ˜¯ 1
                // nums[i] å·²ç»è¢«è£…å…¥åˆ«çš„æ¡¶ä¸­
                continue;
            }
            if (nums[i] + bucket > target) {
                continue;
            }
            // åšé€‰æ‹©
            let newUsed = used | (1 << i); // å°†ç¬¬ i ä½ç½®ä¸º 1
            let newBucket = bucket + nums[i];
            /**<extend down -200>
            ![](../pictures/é›†åˆåˆ’åˆ†/5.jpeg)
            */
            // é€’å½’ç©·ä¸¾ä¸‹ä¸€ä¸ªæ•°å­—æ˜¯å¦è£…å…¥å½“å‰æ¡¶
            if (backtrack(k, newBucket, nums, i + 1, newUsed, target)) {
                return true;
            }
            // æ’¤é”€é€‰æ‹©
            newUsed ^= (1 << i); // å°†ç¬¬ i ä½ç½®ä¸º 0
            newBucket -= nums[i];
        }

        memo.set(used, false);
        return false;
    }

    // æ’é™¤ä¸€äº›åŸºæœ¬æƒ…å†µ
    if (k > nums.length) return false;
    let sum = 0;
    for (let v of nums) sum += v;
    if (sum % k != 0) return false;

    let used = 0; // ä½¿ç”¨ä½å›¾æŠ€å·§
    let target = sum / k;
    // k å·æ¡¶åˆå§‹ä»€ä¹ˆéƒ½æ²¡è£…ï¼Œä» nums[0] å¼€å§‹åšé€‰æ‹©
    return backtrack(k, 0, nums, 0, used, target);
};
```

```python
# by chatGPT (python)
class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        # æ’é™¤ä¸€äº›åŸºæœ¬æƒ…å†µ
        if k > len(nums):
            return False
        _sum = sum(nums)
        if _sum % k != 0:
            return False
        
        used = 0 # ä½¿ç”¨ä½å›¾æŠ€å·§
        target = _sum // k
        # k å·æ¡¶åˆå§‹ä»€ä¹ˆéƒ½æ²¡è£…ï¼Œä» nums[0] å¼€å§‹åšé€‰æ‹©
        return self.backtrack(k, 0, nums, 0, used, target, {})
        
    def backtrack(self, k: int, bucket: int, nums: List[int], start: int, used: int, target: int, memo: Dict[int, bool]) -> bool:        
        # base case
        if k == 0:
            # æ‰€æœ‰æ¡¶éƒ½è¢«è£…æ»¡äº†ï¼Œè€Œä¸” nums ä¸€å®šå…¨éƒ¨ç”¨å®Œäº†
            return True
        if bucket == target:
            # è£…æ»¡äº†å½“å‰æ¡¶ï¼Œé€’å½’ç©·ä¸¾ä¸‹ä¸€ä¸ªæ¡¶çš„é€‰æ‹©
            # è®©ä¸‹ä¸€ä¸ªæ¡¶ä» nums[0] å¼€å§‹é€‰æ•°å­—
            if used in memo:
                return memo[used]
            res = self.backtrack(k - 1, 0, nums, 0, used, target, memo)
            # ç¼“å­˜ç»“æœ
            memo[used] = res
            return res
        
        for i in range(start, len(nums)):
            # å‰ªæ
            if used >> i & 1 == 1:
                # nums[i] å·²ç»è¢«è£…å…¥åˆ«çš„æ¡¶ä¸­
                continue
            if nums[i] + bucket > target:
                continue
            # åšé€‰æ‹©
            used |= 1 << i # å°†ç¬¬ i ä½ç½®ä¸º 1
            bucket += nums[i]
            # é€’å½’ç©·ä¸¾ä¸‹ä¸€ä¸ªæ•°å­—æ˜¯å¦è£…å…¥å½“å‰æ¡¶
            if self.backtrack(k, bucket, nums, i + 1, used, target, memo):
                return True
            # æ’¤é”€é€‰æ‹©
            used ^= 1 << i # å°†ç¬¬ i ä½ç½®ä¸º 0
            bucket -= nums[i]
            
        return False
```

https://leetcode.cn/problems/partition-to-k-equal-sum-subsets çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/pascals-triangle çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
// è¿­ä»£æ–¹å¼
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res;
        if (numRows < 1) {
            return res;
        }
        // å…ˆæŠŠç¬¬ä¸€å±‚è£…è¿›å»ä½œä¸º base case
        vector<int> firstRow(1, 1);
        res.push_back(firstRow);
        // å¼€å§‹ä¸€å±‚ä¸€å±‚ç”Ÿæˆï¼Œè£…å…¥ res
        for (int i = 2; i <= numRows; i++) {
            vector<int> prevRow = res.back();
            res.push_back(generateNextRow(prevRow));
        }
        return res;
    }

    // è¾“å…¥ä¸Šä¸€å±‚çš„å…ƒç´ ï¼Œç”Ÿæˆå¹¶è¿”å›ä¸‹ä¸€å±‚çš„å…ƒç´ 
    vector<int> generateNextRow(vector<int>& prevRow) {
        vector<int> curRow(1, 1);
        for (int i = 0; i < prevRow.size() - 1; i++) {
            curRow.push_back(prevRow[i] + prevRow[i + 1]);
        }
        curRow.push_back(1);
        return curRow;
    }
};

// é€’å½’æ–¹å¼
class Solution2 {
public:
    // å®šä¹‰ï¼šè¾“å…¥ numRowsï¼Œè¿”å›è¡Œæ•°ä¸º numRows çš„æ¨è¾‰ä¸‰è§’
    vector<vector<int>> generate(int numRows) {
        // é€’å½’çš„ base case
        if (numRows == 1) {
            vector<vector<int>> triangle(1, vector<int>(1, 1));
            return triangle;
        }

        // å…ˆé€’å½’ç”Ÿæˆé«˜åº¦ä¸º numRows - 1 çš„æ¨è¾‰ä¸‰è§’
        vector<vector<int>> triangle = generate(numRows - 1);

        // æ ¹æ®æœ€åº•å±‚å…ƒç´ ç”Ÿæˆä¸€è¡Œæ–°å…ƒç´ 
        vector<int> bottomRow = triangle.back();
        vector<int> newRow(1, 1);
        for (int i = 0; i < bottomRow.size() - 1; i++) {
            newRow.push_back(bottomRow[i] + bottomRow[i + 1]);
        }
        newRow.push_back(1);
        // æŠŠæ–°çš„ä¸€è¡Œæ”¾åˆ°æ¨è¾‰ä¸‰è§’åº•éƒ¨
        triangle.push_back(newRow);

        return triangle;
    }
};
```

```go
// by chatGPT (go)
// è¿­ä»£æ–¹å¼
func generate(numRows int) [][]int {
    res := [][]int{}
    if numRows < 1 {
        return res
    }
    // å…ˆæŠŠç¬¬ä¸€å±‚è£…è¿›å»ä½œä¸º base case
    firstRow := []int{1}
    res = append(res, firstRow)
    // å¼€å§‹ä¸€å±‚ä¸€å±‚ç”Ÿæˆï¼Œè£…å…¥ res
    for i := 2; i <= numRows; i++ {
        prevRow := res[len(res)-1]
        res = append(res, generateNextRow(prevRow))
    }
    return res
}

// è¾“å…¥ä¸Šä¸€å±‚çš„å…ƒç´ ï¼Œç”Ÿæˆå¹¶è¿”å›ä¸‹ä¸€å±‚çš„å…ƒç´ 
func generateNextRow(prevRow []int) []int {
    curRow := []int{1}
    for i := 0; i < len(prevRow)-1; i++ {
        curRow = append(curRow, prevRow[i]+prevRow[i+1])
    }
    curRow = append(curRow, 1)
    return curRow
}

// é€’å½’æ–¹å¼
func generate(numRows int) [][]int {
    // é€’å½’çš„ base case
    if numRows == 1 {
        triangle := [][]int{}
        // å…ˆæŠŠç¬¬ä¸€å±‚è£…è¿›å»ä½œä¸º base case
        firstRow := []int{1}
        triangle = append(triangle, firstRow)
        return triangle
    }

    // å…ˆé€’å½’ç”Ÿæˆé«˜åº¦ä¸º numRows - 1 çš„æ¨è¾‰ä¸‰è§’
    triangle := generate(numRows - 1)

    // æ ¹æ®æœ€åº•å±‚å…ƒç´ ç”Ÿæˆä¸€è¡Œæ–°å…ƒç´ 
    bottomRow := triangle[len(triangle)-1]
    newRow := []int{1}
    for i := 0; i < len(bottomRow)-1; i++ {
        newRow = append(newRow, bottomRow[i]+bottomRow[i+1])
    }
    newRow = append(newRow, 1)
    // æŠŠæ–°çš„ä¸€è¡Œæ”¾åˆ°æ¨è¾‰ä¸‰è§’åº•éƒ¨
    triangle = append(triangle, newRow)

    return triangle
}
```

```java
// by labuladong (java)
// è¿­ä»£æ–¹å¼
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<>();
        if (numRows < 1) {
            return res;
        }
        // å…ˆæŠŠç¬¬ä¸€å±‚è£…è¿›å»ä½œä¸º base case
        List<Integer> firstRow = new ArrayList<>();
        firstRow.add(1);
        res.add(firstRow);
        // å¼€å§‹ä¸€å±‚ä¸€å±‚ç”Ÿæˆï¼Œè£…å…¥ res
        for (int i = 2; i <= numRows; i++) {
            List<Integer> prevRow = res.get(res.size() - 1);
            res.add(generateNextRow(prevRow));
        }
        return res;
    }

    // è¾“å…¥ä¸Šä¸€å±‚çš„å…ƒç´ ï¼Œç”Ÿæˆå¹¶è¿”å›ä¸‹ä¸€å±‚çš„å…ƒç´ 
    List<Integer> generateNextRow(List<Integer> prevRow) {
        List<Integer> curRow = new ArrayList<>();
        curRow.add(1);
        for (int i = 0; i < prevRow.size() - 1; i++) {
            curRow.add(prevRow.get(i) + prevRow.get(i + 1));
        }
        curRow.add(1);
        return curRow;
    }
}

// é€’å½’æ–¹å¼
class Solution2 {
    // å®šä¹‰ï¼šè¾“å…¥ numRowsï¼Œè¿”å›è¡Œæ•°ä¸º numRows çš„æ¨è¾‰ä¸‰è§’
    public List<List<Integer>> generate(int numRows) {
        // é€’å½’çš„ base case
        if (numRows == 1) {
            List<List<Integer>> triangle = new ArrayList<>();
            // å…ˆæŠŠç¬¬ä¸€å±‚è£…è¿›å»ä½œä¸º base case
            List<Integer> firstRow = new ArrayList<>();
            firstRow.add(1);
            triangle.add(firstRow);
            return triangle;
        }

        // å…ˆé€’å½’ç”Ÿæˆé«˜åº¦ä¸º numRows - 1 çš„æ¨è¾‰ä¸‰è§’
        List<List<Integer>> triangle = generate(numRows - 1);

        // æ ¹æ®æœ€åº•å±‚å…ƒç´ ç”Ÿæˆä¸€è¡Œæ–°å…ƒç´ 
        List<Integer> bottomRow = triangle.get(triangle.size() - 1);
        List<Integer> newRow = new ArrayList<>();
        newRow.add(1);
        for (int i = 0; i < bottomRow.size() - 1; i++) {
            newRow.add(bottomRow.get(i) + bottomRow.get(i + 1));
        }
        newRow.add(1);
        // æŠŠæ–°çš„ä¸€è¡Œæ”¾åˆ°æ¨è¾‰ä¸‰è§’åº•éƒ¨
        triangle.add(newRow);

        return triangle;
    }
}
```

```javascript
// by chatGPT (javascript)
var generate = function(numRows) {
    var res = []
    if (numRows < 1) {
        return res;
    }
    // å…ˆæŠŠç¬¬ä¸€å±‚è£…è¿›å»ä½œä¸º base case
    var firstRow = [1];
    res.push(firstRow);
    // å¼€å§‹ä¸€å±‚ä¸€å±‚ç”Ÿæˆï¼Œè£…å…¥ res
    for (var i = 2; i <= numRows; i++) {
        var prevRow = res[res.length - 1];
        res.push(generateNextRow(prevRow));
    }
    return res;
}

// è¾“å…¥ä¸Šä¸€å±‚çš„å…ƒç´ ï¼Œç”Ÿæˆå¹¶è¿”å›ä¸‹ä¸€å±‚çš„å…ƒç´ 
var generateNextRow = function(prevRow) {
    var curRow = [1];
    for (var i = 0; i < prevRow.length - 1; i++) {
        curRow.push(prevRow[i] + prevRow[i + 1]);
    }
    curRow.push(1);
    return curRow;
}

// å®šä¹‰ï¼šè¾“å…¥ numRowsï¼Œè¿”å›è¡Œæ•°ä¸º numRows çš„æ¨è¾‰ä¸‰è§’
var generate = function(numRows) {
    // é€’å½’çš„ base case
    if (numRows == 1) {
        var triangle = [];
        // å…ˆæŠŠç¬¬ä¸€å±‚è£…è¿›å»ä½œä¸º base case
        var firstRow = [1];
        triangle.push(firstRow);
        return triangle;
    }

    // å…ˆé€’å½’ç”Ÿæˆé«˜åº¦ä¸º numRows - 1 çš„æ¨è¾‰ä¸‰è§’
    var triangle = generate(numRows - 1);

    // æ ¹æ®æœ€åº•å±‚å…ƒç´ ç”Ÿæˆä¸€è¡Œæ–°å…ƒç´ 
    var bottomRow = triangle[triangle.length - 1];
    var newRow = [1];
    for (var i = 0; i < bottomRow.length - 1; i++) {
        newRow.push(bottomRow[i] + bottomRow[i + 1]);
    }
    newRow.push(1);
    // æŠŠæ–°çš„ä¸€è¡Œæ”¾åˆ°æ¨è¾‰ä¸‰è§’åº•éƒ¨
    triangle.push(newRow);

    return triangle;
}
```

```python
# by chatGPT (python)
# è¿­ä»£æ–¹å¼
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        if numRows < 1:
            return res
        # å…ˆæŠŠç¬¬ä¸€å±‚è£…è¿›å»ä½œä¸º base case
        firstRow = [1]
        res.append(firstRow)
        # å¼€å§‹ä¸€å±‚ä¸€å±‚ç”Ÿæˆï¼Œè£…å…¥ res
        for i in range(2, numRows+1):
            prevRow = res[-1]
            res.append(self.generateNextRow(prevRow))
        return res

    # è¾“å…¥ä¸Šä¸€å±‚çš„å…ƒç´ ï¼Œç”Ÿæˆå¹¶è¿”å›ä¸‹ä¸€å±‚çš„å…ƒç´ 
    def generateNextRow(self, prevRow: List[int]) -> List[int]:
        curRow = [1]
        for i in range(len(prevRow) - 1):
            curRow.append(prevRow[i] + prevRow[i + 1])
        curRow.append(1)
        return curRow


# é€’å½’æ–¹å¼
class Solution2:
    # å®šä¹‰ï¼šè¾“å…¥ numRowsï¼Œè¿”å›è¡Œæ•°ä¸º numRows çš„æ¨è¾‰ä¸‰è§’
    def generate(self, numRows: int) -> List[List[int]]:
        # é€’å½’çš„ base case
        if numRows == 1:
            triangle = []
            # å…ˆæŠŠç¬¬ä¸€å±‚è£…è¿›å»ä½œä¸º base case
            firstRow = [1]
            triangle.append(firstRow)
            return triangle

        # å…ˆé€’å½’ç”Ÿæˆé«˜åº¦ä¸º numRows - 1 çš„æ¨è¾‰ä¸‰è§’
        triangle = self.generate(numRows - 1)

        # æ ¹æ®æœ€åº•å±‚å…ƒç´ ç”Ÿæˆä¸€è¡Œæ–°å…ƒç´ 
        bottomRow = triangle[-1]
        newRow = [1]
        for i in range(len(bottomRow) - 1):
            newRow.append(bottomRow[i] + bottomRow[i + 1])
        newRow.append(1)
        # æŠŠæ–°çš„ä¸€è¡Œæ”¾åˆ°æ¨è¾‰ä¸‰è§’åº•éƒ¨
        triangle.append(newRow)

        return triangle
```

https://leetcode.cn/problems/pascals-triangle çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/path-with-maximum-probability çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
#include <bits/stdc++.h>
using namespace std;

// struct ä¸å†éœ€è¦å£°æ˜ï¼Œç›´æ¥åœ¨ç»“æ„ä½“å†…è¿›è¡Œå®šä¹‰
class Solution {
public:
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {
        vector<vector<pair<double, int>>> graph(n);
        for (int i = 0; i < edges.size(); i++) {
            int from = edges[i][0];
            int to = edges[i][1];
            double weight = succProb[i];
            // æ— å‘å›¾å…¶å®å°±æ˜¯åŒå‘å›¾
            graph[from].push_back(make_pair(weight, to));
            graph[to].push_back(make_pair(weight, from));
        }
        return dijkstra(start, end, graph);
    }

    struct State {
        int id;
        double distFromStart;
        State(int id, double distFromStart) : id(id), distFromStart(distFromStart) {}
        bool operator < (const State& rhs) const {
            return distFromStart < rhs.distFromStart;
        }
    };

    double dijkstra(int start, int end, vector<vector<pair<double, int>>>& graph) {
        int V = graph.size();
        vector<double> distTo(V, -1);
        distTo[start] = 1;
        priority_queue<State> pq;
        pq.push(State(start, 1));
        while (!pq.empty()) {
            State curState = pq.top();
            pq.pop();
            int curNodeID = curState.id;
            double curDistFromStart = curState.distFromStart;
            if (curNodeID == end) {
                return curDistFromStart;
            }
            if (curDistFromStart < distTo[curNodeID]) {
                continue;
            }
            for (auto neighbor : graph[curNodeID]) {
                int nextNodeID = neighbor.second;
                double distToNextNode = distTo[curNodeID] * neighbor.first;
                if (distTo[nextNodeID] < distToNextNode) {
                    distTo[nextNodeID] = distToNextNode;
                    pq.push(State(nextNodeID, distToNextNode));
                }
            }
        }
        return 0.0;
    }
};
```

```go
// by chatGPT (go)
type State struct {
    id   int
    dist float64
}

func maxProbability(n int, edges [][]int, succProb []float64, start int, end int) float64 {
    graph := make([][]State, n)
    for i := 0; i < n; i++ {
        graph[i] = make([]State, 0)
    }

    // æ„é€ æ— å‘å›¾
    for i := 0; i < len(edges); i++ {
        from := edges[i][0]
        to := edges[i][1]
        weight := succProb[i]
        // æ— å‘å›¾å…¶å®å°±æ˜¯åŒå‘å›¾
        graph[from] = append(graph[from], State{to, weight})
        graph[to] = append(graph[to], State{from, weight})
    }

    return dijkstra(start, end, graph)
}

func dijkstra(start int, end int, graph [][]State) float64 {
    // å›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
    V := len(graph)
    // è®°å½•æœ€çŸ­è·¯å¾„çš„æƒé‡ï¼Œä½ å¯ä»¥ç†è§£ä¸º dp table
    // å®šä¹‰ï¼šdistTo[i] çš„å€¼å°±æ˜¯èŠ‚ç‚¹ start åˆ°è¾¾èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„æƒé‡
    distTo := make([]float64, V)
    // dp table åˆå§‹åŒ–ä¸ºæ­£æ— ç©·
    for i := 0; i < V; i++ {
        distTo[i] = -1
    }
    // base caseï¼Œstart åˆ° start çš„æœ€çŸ­è·ç¦»å°±æ˜¯ 0
    distTo[start] = 1

    // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒdistFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
    pq := make(PriorityQueue, 0)
    heap.Init(&pq)
    //ä»èµ·ç‚¹ start å¼€å§‹è¿›è¡Œ BFS
    heap.Push(&pq, &State{id: start, dist: 1})

    for pq.Len() > 0 {
        curState := heap.Pop(&pq).(*State)
        curNodeID := curState.id
        curDistFromStart := curState.dist

        // åœ¨è¿™é‡ŒåŠ ä¸€ä¸ªåˆ¤æ–­å°±è¡Œäº†ï¼Œå…¶ä»–ä»£ç ä¸ç”¨æ”¹
        if curNodeID == end {
            return curDistFromStart
        }

        if curDistFromStart < distTo[curNodeID] {
            // å·²ç»æœ‰ä¸€æ¡æ›´çŸ­çš„è·¯å¾„åˆ°è¾¾ curNode èŠ‚ç‚¹äº†
            continue
        }
        // å°† curNode çš„ç›¸é‚»èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
        for _, neighbor := range graph[curNodeID] {
            nextNodeID := neighbor.id
            // çœ‹çœ‹ä» curNode è¾¾åˆ° nextNode çš„è·ç¦»æ˜¯å¦ä¼šæ›´çŸ­
            distToNextNode := distTo[curNodeID] * neighbor.dist
            if distTo[nextNodeID] < distToNextNode {
                // æ›´æ–° dp table
                distTo[nextNodeID] = distToNextNode
                // å°†è¿™ä¸ªèŠ‚ç‚¹ä»¥åŠè·ç¦»æ”¾å…¥é˜Ÿåˆ—
                heap.Push(&pq, &State{nextNodeID, distToNextNode})
            }
        }
    }
    return 0.0
}

// ä¼˜å…ˆçº§é˜Ÿåˆ—æ•°æ®ç»“æ„ï¼Œç”¨äºå®ç° BFS å¹¿åº¦ä¼˜å…ˆæœç´¢
type PriorityQueue []*State

func (pq PriorityQueue) Len() int {
    return len(pq)
}

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i].dist > pq[j].dist
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    item := x.(*State)
    *pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
}
```

```java
// by labuladong (java)
class Solution {
    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
        List<double[]>[] graph = new LinkedList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new LinkedList<>();
        }
        // æ„é€ æ— å‘å›¾
        for (int i = 0; i < edges.length; i++) {
            int from = edges[i][0];
            int to = edges[i][1];
            double weight = succProb[i];
            // æ— å‘å›¾å…¶å®å°±æ˜¯åŒå‘å›¾
            graph[from].add(new double[]{(double)to, weight});
            graph[to].add(new double[]{(double)from, weight});
        }
        
        
        return dijkstra(start, end, graph);
    }
    
    class State {
        // å›¾èŠ‚ç‚¹çš„ id
        int id;
        // ä» start èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·ç¦»
        double distFromStart;

        State(int id, double distFromStart) {
            this.id = id;
            this.distFromStart = distFromStart;
        }
    }
    
    double dijkstra(int start, int end, List<double[]>[] graph) {
        // å›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
        int V = graph.length;
        // è®°å½•æœ€çŸ­è·¯å¾„çš„æƒé‡ï¼Œä½ å¯ä»¥ç†è§£ä¸º dp table
        // å®šä¹‰ï¼šdistTo[i] çš„å€¼å°±æ˜¯èŠ‚ç‚¹ start åˆ°è¾¾èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„æƒé‡
        double[] distTo = new double[V];
        // dp table åˆå§‹åŒ–ä¸ºæ­£æ— ç©·
        Arrays.fill(distTo, -1);
        // base caseï¼Œstart åˆ° start çš„æœ€çŸ­è·ç¦»å°±æ˜¯ 0
        distTo[start] = 1;

        // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒdistFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
        Queue<State> pq = new PriorityQueue<>((a, b) -> {
            return Double.compare(b.distFromStart, a.distFromStart);
        });
        // ä»èµ·ç‚¹ start å¼€å§‹è¿›è¡Œ BFS
        pq.offer(new State(start, 1));

        while (!pq.isEmpty()) {
            State curState = pq.poll();
            int curNodeID = curState.id;
            double curDistFromStart = curState.distFromStart;

            // åœ¨è¿™é‡ŒåŠ ä¸€ä¸ªåˆ¤æ–­å°±è¡Œäº†ï¼Œå…¶ä»–ä»£ç ä¸ç”¨æ”¹
            if (curNodeID == end) {
                return curDistFromStart;
            }
            
            if (curDistFromStart < distTo[curNodeID]) {
                // å·²ç»æœ‰ä¸€æ¡æ›´çŸ­çš„è·¯å¾„åˆ°è¾¾ curNode èŠ‚ç‚¹äº†
                continue;
            }
            // å°† curNode çš„ç›¸é‚»èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
            for (double[] neighbor : graph[curNodeID]) {
                int nextNodeID = (int)neighbor[0];
                // çœ‹çœ‹ä» curNode è¾¾åˆ° nextNode çš„è·ç¦»æ˜¯å¦ä¼šæ›´çŸ­
                double distToNextNode = distTo[curNodeID] * neighbor[1];
                if (distTo[nextNodeID] < distToNextNode) {
                    // æ›´æ–° dp table
                    distTo[nextNodeID] = distToNextNode;
                    // å°†è¿™ä¸ªèŠ‚ç‚¹ä»¥åŠè·ç¦»æ”¾å…¥é˜Ÿåˆ—
                    pq.offer(new State(nextNodeID, distToNextNode));
                }
            }
        }
        return 0.0;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number[]} succProb
 * @param {number} start
 * @param {number} end
 * @return {number}
 */
var maxProbability = function(n, edges, succProb, start, end) {
    const graph = [];
    for (let i = 0; i < n; i++) {
        graph[i] = [];
    }
    // æ„é€ æ— å‘å›¾
    for (let i = 0; i < edges.length; i++) {
        const from = edges[i][0];
        const to = edges[i][1];
        const weight = succProb[i];
        // æ— å‘å›¾å…¶å®å°±æ˜¯åŒå‘å›¾
        graph[from].push([to, weight]);
        graph[to].push([from, weight]);
    }


    return dijkstra(start, end, graph);
};

class State {
    // å›¾èŠ‚ç‚¹çš„ id
    constructor(id, distFromStart) {
        this.id = id;
        // ä» start èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·ç¦»
        this.distFromStart = distFromStart;
    }
}

function dijkstra(start, end, graph) {
    // å›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
    const V = graph.length;
    // è®°å½•æœ€çŸ­è·¯å¾„çš„æƒé‡ï¼Œä½ å¯ä»¥ç†è§£ä¸º dp table
    // å®šä¹‰ï¼šdistTo[i] çš„å€¼å°±æ˜¯èŠ‚ç‚¹ start åˆ°è¾¾èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„æƒé‡
    const distTo = new Array(V).fill(-1);
    // dp table åˆå§‹åŒ–ä¸ºæ­£æ— ç©·
    distTo[start] = 1;

    // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒdistFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
    const pq = new PriorityQueue({
        compare: (a, b) => {
            return b.distFromStart - a.distFromStart;
        }
    });
    // ä»èµ·ç‚¹ start å¼€å§‹è¿›è¡Œ BFS
    pq.enqueue(new State(start, 1));

    while (!pq.isEmpty()) {
        const curState = pq.dequeue();
        const curNodeID = curState.id;
        const curDistFromStart = curState.distFromStart;

        // åœ¨è¿™é‡ŒåŠ ä¸€ä¸ªåˆ¤æ–­å°±è¡Œäº†ï¼Œå…¶ä»–ä»£ç ä¸ç”¨æ”¹
        if (curNodeID === end) {
            return curDistFromStart;
        }

        if (curDistFromStart < distTo[curNodeID]) {
            // å·²ç»æœ‰ä¸€æ¡æ›´çŸ­çš„è·¯å¾„åˆ°è¾¾ curNode èŠ‚ç‚¹äº†
            continue;
        }
        // å°† curNode çš„ç›¸é‚»èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
        for (const neighbor of graph[curNodeID]) {
            const nextNodeID = neighbor[0];
            // çœ‹çœ‹ä» curNode è¾¾åˆ° nextNode çš„è·ç¦»æ˜¯å¦ä¼šæ›´çŸ­
            const distToNextNode = distTo[curNodeID] * neighbor[1];
            if (distTo[nextNodeID] < distToNextNode) {
                // æ›´æ–° dp table
                distTo[nextNodeID] = distToNextNode;
                // å°†è¿™ä¸ªèŠ‚ç‚¹ä»¥åŠè·ç¦»æ”¾å…¥é˜Ÿåˆ—
                pq.enqueue(new State(nextNodeID, distToNextNode));
            }
        }
    }
    return 0.0;
}
```

```python
# by chatGPT (python)
import heapq
from typing import List


class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
        graph = [[] for _ in range(n)]
        for i in range(len(edges)):
            from_, to = edges[i][0], edges[i][1]
            weight = succProb[i]
            graph[from_].append((to, weight))
            graph[to].append((from_, weight))

        return self.dijkstra(start, end, graph)

    class State:
        def __init__(self, id_, distFromStart):
            self.id = id_
            self.distFromStart = distFromStart

        def __lt__(self, other):
            return self.distFromStart > other.distFromStart

    def dijkstra(self, start, end, graph):
        V = len(graph)
        # è®°å½•æœ€çŸ­è·¯å¾„çš„æƒé‡ï¼Œä½ å¯ä»¥ç†è§£ä¸º dp table
        # å®šä¹‰ï¼šdistTo[i] çš„å€¼å°±æ˜¯èŠ‚ç‚¹ start åˆ°è¾¾èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„æƒé‡
        distTo = [-1] * V
        # dp table åˆå§‹åŒ–ä¸ºæ­£æ— ç©·
        distTo[start] = 1

        # ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒdistFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
        pq = []
        # ä»èµ·ç‚¹ start å¼€å§‹è¿›è¡Œ BFS
        heapq.heappush(pq, self.State(start, 1))

        while pq:
            curState = heapq.heappop(pq)
            curNodeID = curState.id
            curDistFromStart = curState.distFromStart

            # åœ¨è¿™é‡ŒåŠ ä¸€ä¸ªåˆ¤æ–­å°±è¡Œäº†ï¼Œå…¶ä»–ä»£ç ä¸ç”¨æ”¹
            if curNodeID == end:
                return curDistFromStart

            if curDistFromStart < distTo[curNodeID]:
                # å·²ç»æœ‰ä¸€æ¡æ›´çŸ­çš„è·¯å¾„åˆ°è¾¾ curNode èŠ‚ç‚¹äº†
                continue
            # å°† curNode çš„ç›¸é‚»èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
            for neighbor in graph[curNodeID]:
                nextNodeID = neighbor[0]
                # çœ‹çœ‹ä» curNode è¾¾åˆ° nextNode çš„è·ç¦»æ˜¯å¦ä¼šæ›´çŸ­
                distToNextNode = distTo[curNodeID] * neighbor[1]
                if distTo[nextNodeID] < distToNextNode:
                    # æ›´æ–° dp table
                    distTo[nextNodeID] = distToNextNode
                    # å°†è¿™ä¸ªèŠ‚ç‚¹ä»¥åŠè·ç¦»æ”¾å…¥é˜Ÿåˆ—
                    heapq.heappush(pq, self.State(nextNodeID, distToNextNode))
        return 0.0
```

https://leetcode.cn/problems/path-with-maximum-probability çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/path-with-minimum-effort çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // Dijkstra ç®—æ³•ï¼Œè®¡ç®— (0, 0) åˆ° (m - 1, n - 1) çš„æœ€å°ä½“åŠ›æ¶ˆè€—
    int minimumEffortPath(vector<vector<int>>& heights) {
        int m = heights.size(), n = heights[0].size();
        // å®šä¹‰ï¼šä» (0, 0) åˆ° (i, j) çš„æœ€å°ä½“åŠ›æ¶ˆè€—æ˜¯ effortTo[i][j]
        vector<vector<int>> effortTo(m,vector<int>(n, INT_MAX)); // dp table åˆå§‹åŒ–ä¸ºæ­£æ— ç©·
        // base caseï¼Œèµ·ç‚¹åˆ°èµ·ç‚¹çš„æœ€å°æ¶ˆè€—å°±æ˜¯ 0
        effortTo[0][0] = 0;

        // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒeffortFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
        priority_queue<State,vector<State>,Comp> pq; // ç¬¬äºŒä¸ªå‚æ•°å°±æ˜¯è‡ªå®šä¹‰è¯­æ³•æ ¼å¼ï¼Œè¯¦è§ä¸‹æ–¹
        // ä»èµ·ç‚¹ (0, 0) å¼€å§‹è¿›è¡Œ BFS
        pq.push(State(0, 0, 0));

        while (!pq.empty()) {
            State curState = pq.top();
            pq.pop();
            int curX = curState.x;
            int curY = curState.y;
            int curEffortFromStart = curState.effortFromStart;

            // åˆ°è¾¾ç»ˆç‚¹æå‰ç»“æŸ
            if (curX == m - 1 && curY == n - 1) {
                return curEffortFromStart;
            }

            if (curEffortFromStart > effortTo[curX][curY]) {
                continue;
            }
            // å°† (curX, curY) çš„ç›¸é‚»åæ ‡è£…å…¥é˜Ÿåˆ—
            for (auto& neighbor : adj(heights, curX, curY)) {
                int nextX = neighbor[0];
                int nextY = neighbor[1];
                // è®¡ç®—ä» (curX, curY) è¾¾åˆ° (nextX, nextY) çš„æ¶ˆè€—
                int effortToNextNode = max(
                    effortTo[curX][curY],
                    abs(heights[curX][curY] - heights[nextX][nextY])
                );
                // æ›´æ–° dp table
                if (effortTo[nextX][nextY] > effortToNextNode) {
                    effortTo[nextX][nextY] = effortToNextNode;
                    pq.push(State(nextX, nextY, effortToNextNode));
                }
            }
        }
        // æ­£å¸¸æƒ…å†µä¸ä¼šè¾¾åˆ°è¿™ä¸ª return
        return -1;
    }

    // æ–¹å‘æ•°ç»„ï¼Œä¸Šä¸‹å·¦å³çš„åæ ‡åç§»é‡
    vector<vector<int>> dirs {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    // è¿”å›åæ ‡ (x, y) çš„ä¸Šä¸‹å·¦å³ç›¸é‚»åæ ‡
    vector<vector<int>> adj(vector<vector<int>>& matrix, int x, int y) {
        int m = matrix.size(), n = matrix[0].size();
        // å­˜å‚¨ç›¸é‚»èŠ‚ç‚¹
        vector<vector<int>> neighbors;
        for (auto& dir : dirs) {
            int nx = x + dir[0];
            int ny = y + dir[1];
            if (nx >= m || nx < 0 || ny >= n || ny < 0) {
                // ç´¢å¼•è¶Šç•Œ
                continue;
            }
            neighbors.push_back({nx, ny});
        }
        return neighbors;
    }

    struct State {
        // çŸ©é˜µä¸­çš„ä¸€ä¸ªä½ç½®
        int x, y;
        // ä»èµ·ç‚¹ (0, 0) åˆ°å½“å‰ä½ç½®çš„æœ€å°ä½“åŠ›æ¶ˆè€—ï¼ˆè·ç¦»ï¼‰
        int effortFromStart;

        State(int x, int y, int effortFromStart) {
            this->x = x;
            this->y = y;
            this->effortFromStart = effortFromStart;
        }
    };

    struct Comp {
        bool operator() (State& a, State& b) {
            return a.effortFromStart > b.effortFromStart;
        }
    };
};
```

```go
// by chatGPT (go)
func minimumEffortPath(heights [][]int) int {
    m := len(heights)
    n := len(heights[0])
    // å®šä¹‰ï¼šä» (0, 0) åˆ° (i, j) çš„æœ€å°ä½“åŠ›æ¶ˆè€—æ˜¯ effortTo[i][j]
    effortTo := make([][]int, m)
    for i := range effortTo {
        effortTo[i] = make([]int, n)
        // dp table åˆå§‹åŒ–ä¸ºæ­£æ— ç©·
        for j := range effortTo[i] {
            effortTo[i][j] = math.MaxInt32
        }
    }
    // base caseï¼Œèµ·ç‚¹åˆ°èµ·ç‚¹çš„æœ€å°æ¶ˆè€—å°±æ˜¯ 0
    effortTo[0][0] = 0

    // æ–¹å‘æ•°ç»„ï¼Œä¸Šä¸‹å·¦å³çš„åæ ‡åç§»é‡
    var dirs = [][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}

    // è¿”å›åæ ‡ (x, y) çš„ä¸Šä¸‹å·¦å³ç›¸é‚»åæ ‡
    var adj = func(x, y int) [][]int {
        // å­˜å‚¨ç›¸é‚»èŠ‚ç‚¹
        neighbors := make([][]int, 0)
        for _, dir := range dirs {
            nx, ny := x+dir[0], y+dir[1]
            if nx >= m || nx < 0 || ny >= n || ny < 0 {
                // ç´¢å¼•è¶Šç•Œ
                continue
            }
            neighbors = append(neighbors, []int{nx, ny})
        }
        return neighbors
    }

    // ä¼˜å…ˆçº§é˜Ÿåˆ—çš„ç±»å‹å®šä¹‰
    type PriorityQueue []*State

    func (pq PriorityQueue) Len() int            { return len(pq) }
    func (pq PriorityQueue) Less(i, j int) bool  { return pq[i].effortFromStart < pq[j].effortFromStart }
    func (pq PriorityQueue) Swap(i, j int)       { pq[i], pq[j] = pq[j], pq[i] }
    func (pq *PriorityQueue) Push(x interface{}) { *pq = append(*pq, x.(*State)) }
    func (pq *PriorityQueue) Pop() interface{} {
        old := *pq
        n := len(old)
        item := old[n-1]
        *pq = old[0 : n-1]
        return item
    }

    // ä»èµ·ç‚¹ (0, 0) å¼€å§‹è¿›è¡Œ BFS
    pq := make(PriorityQueue, 0)
    heap.Init(&pq)
    pq.Push(&State{0, 0, 0})
    for pq.Len() > 0 {
        curState := heap.Pop(&pq).(*State)
        curX, curY, curEffortFromStart := curState.x, curState.y, curState.effortFromStart

        // åˆ°è¾¾ç»ˆç‚¹æå‰ç»“æŸ
        if curX == m-1 && curY == n-1 {
            return curEffortFromStart
        }

        if curEffortFromStart > effortTo[curX][curY] {
            continue
        }
        // å°† (curX, curY) çš„ç›¸é‚»åæ ‡è£…å…¥é˜Ÿåˆ—
        for _, neighbor := range adj(curX, curY) {
            nextX, nextY := neighbor[0], neighbor[1]
            // è®¡ç®—ä» (curX, curY) è¾¾åˆ° (nextX, nextY) çš„æ¶ˆè€—
            effortToNextNode := max(
                effortTo[curX][curY],
                abs(heights[curX][curY]-heights[nextX][nextY]),
            )
            // æ›´æ–° dp table
            if effortTo[nextX][nextY] > effortToNextNode {
                effortTo[nextX][nextY] = effortToNextNode
                heap.Push(&pq, &State{nextX, nextY, effortToNextNode})
            }
        }
    }
    // æ­£å¸¸æƒ…å†µä¸ä¼šè¾¾åˆ°è¿™ä¸ª return
    return -1
}

type State struct {
    // çŸ©é˜µä¸­çš„ä¸€ä¸ªä½ç½®
    x, y int
    // ä»èµ·ç‚¹ (0, 0) åˆ°å½“å‰ä½ç½®çš„æœ€å°ä½“åŠ›æ¶ˆè€—ï¼ˆè·ç¦»ï¼‰
    effortFromStart int
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}
```

```java
// by labuladong (java)
class Solution {
    // Dijkstra ç®—æ³•ï¼Œè®¡ç®— (0, 0) åˆ° (m - 1, n - 1) çš„æœ€å°ä½“åŠ›æ¶ˆè€—
    public int minimumEffortPath(int[][] heights) {
        int m = heights.length, n = heights[0].length;
        // å®šä¹‰ï¼šä» (0, 0) åˆ° (i, j) çš„æœ€å°ä½“åŠ›æ¶ˆè€—æ˜¯ effortTo[i][j]
        int[][] effortTo = new int[m][n];
        // dp table åˆå§‹åŒ–ä¸ºæ­£æ— ç©·
        for (int i = 0; i < m; i++) {
            Arrays.fill(effortTo[i], Integer.MAX_VALUE);
        }
        // base caseï¼Œèµ·ç‚¹åˆ°èµ·ç‚¹çš„æœ€å°æ¶ˆè€—å°±æ˜¯ 0
        effortTo[0][0] = 0;

        // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒeffortFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
        Queue<State> pq = new PriorityQueue<>((a, b) -> {
            return a.effortFromStart - b.effortFromStart;
        });

        // ä»èµ·ç‚¹ (0, 0) å¼€å§‹è¿›è¡Œ BFS
        pq.offer(new State(0, 0, 0));

        while (!pq.isEmpty()) {
            State curState = pq.poll();
            int curX = curState.x;
            int curY = curState.y;
            int curEffortFromStart = curState.effortFromStart;

            // åˆ°è¾¾ç»ˆç‚¹æå‰ç»“æŸ
            if (curX == m - 1 && curY == n - 1) {
                return curEffortFromStart;
            }

            if (curEffortFromStart > effortTo[curX][curY]) {
                continue;
            }
            // å°† (curX, curY) çš„ç›¸é‚»åæ ‡è£…å…¥é˜Ÿåˆ—
            for (int[] neighbor : adj(heights, curX, curY)) {
                int nextX = neighbor[0];
                int nextY = neighbor[1];
                // è®¡ç®—ä» (curX, curY) è¾¾åˆ° (nextX, nextY) çš„æ¶ˆè€—
                int effortToNextNode = Math.max(
                        effortTo[curX][curY],
                        Math.abs(heights[curX][curY] - heights[nextX][nextY])
                );
                // æ›´æ–° dp table
                if (effortTo[nextX][nextY] > effortToNextNode) {
                    effortTo[nextX][nextY] = effortToNextNode;
                    pq.offer(new State(nextX, nextY, effortToNextNode));
                }
            }
        }
        // æ­£å¸¸æƒ…å†µä¸ä¼šè¾¾åˆ°è¿™ä¸ª return
        return -1;
    }

    // æ–¹å‘æ•°ç»„ï¼Œä¸Šä¸‹å·¦å³çš„åæ ‡åç§»é‡
    int[][] dirs = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    // è¿”å›åæ ‡ (x, y) çš„ä¸Šä¸‹å·¦å³ç›¸é‚»åæ ‡
    List<int[]> adj(int[][] matrix, int x, int y) {
        int m = matrix.length, n = matrix[0].length;
        // å­˜å‚¨ç›¸é‚»èŠ‚ç‚¹
        List<int[]> neighbors = new ArrayList<>();
        for (int[] dir : dirs) {
            int nx = x + dir[0];
            int ny = y + dir[1];
            if (nx >= m || nx < 0 || ny >= n || ny < 0) {
                // ç´¢å¼•è¶Šç•Œ
                continue;
            }
            neighbors.add(new int[]{nx, ny});
        }
        return neighbors;
    }

    class State {
        // çŸ©é˜µä¸­çš„ä¸€ä¸ªä½ç½®
        int x, y;
        // ä»èµ·ç‚¹ (0, 0) åˆ°å½“å‰ä½ç½®çš„æœ€å°ä½“åŠ›æ¶ˆè€—ï¼ˆè·ç¦»ï¼‰
        int effortFromStart;

        State(int x, int y, int effortFromStart) {
            this.x = x;
            this.y = y;
            this.effortFromStart = effortFromStart;
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var minimumEffortPath = function(heights) {

    // Dijkstra ç®—æ³•ï¼Œè®¡ç®— (0, 0) åˆ° (m - 1, n - 1) çš„æœ€å°ä½“åŠ›æ¶ˆè€—
    let m = heights.length,
        n = heights[0].length,
        // å®šä¹‰ï¼šä» (0, 0) åˆ° (i, j) çš„æœ€å°ä½“åŠ›æ¶ˆè€—æ˜¯ effortTo[i][j]
        effortTo = Array.from({ length: m }, () => Array(n).fill(Number.MAX_SAFE_INTEGER)),
        // æ–¹å‘æ•°ç»„ï¼Œä¸Šä¸‹å·¦å³çš„åæ ‡åç§»é‡
        dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]],
        // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒeffortFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
        pq = [];

    // ä»èµ·ç‚¹ (0, 0) å¼€å§‹è¿›è¡Œ BFS
    pq.push(new State(0, 0, 0));

    // base caseï¼Œèµ·ç‚¹åˆ°èµ·ç‚¹çš„æœ€å°æ¶ˆè€—å°±æ˜¯ 0
    effortTo[0][0] = 0;

    class State {
        // çŸ©é˜µä¸­çš„ä¸€ä¸ªä½ç½®
        // ä»èµ·ç‚¹ (0, 0) åˆ°å½“å‰ä½ç½®çš„æœ€å°ä½“åŠ›æ¶ˆè€—ï¼ˆè·ç¦»ï¼‰
        constructor(x, y, effortFromStart) {
            this.x = x;
            this.y = y;
            this.effortFromStart = effortFromStart;
        }
    }

    function adj(matrix, x, y) {
        let m = matrix.length, n = matrix[0].length;
        // å­˜å‚¨ç›¸é‚»èŠ‚ç‚¹
        let neighbors = [];
        for (let dir of dirs) {
            let nx = x + dir[0];
            let ny = y + dir[1];
            if (nx >= m || nx < 0 || ny >= n || ny < 0) {
                // ç´¢å¼•è¶Šç•Œ
                continue;
            }
            neighbors.push([nx, ny]);
        }
        return neighbors;
    }

    while (pq.length != 0) {
        let curState = pq.shift();
        let curX = curState.x;
        let curY = curState.y;
        let curEffortFromStart = curState.effortFromStart;

        // åˆ°è¾¾ç»ˆç‚¹æå‰ç»“æŸ
        if (curX == m - 1 && curY == n - 1) {
            return curEffortFromStart;
        }
    
        if (curEffortFromStart > effortTo[curX][curY]) {
            continue;
        }

        // å°† (curX, curY) çš„ç›¸é‚»åæ ‡è£…å…¥é˜Ÿåˆ—
        for (let neighbor of adj(heights, curX, curY)) {
            let nextX = neighbor[0];
            let nextY = neighbor[1];
            // è®¡ç®—ä» (curX, curY) è¾¾åˆ° (nextX, nextY) çš„æ¶ˆè€—
            let effortToNextNode = Math.max(
                effortTo[curX][curY],
                Math.abs(heights[curX][curY] - heights[nextX][nextY])
            );
            // æ›´æ–° dp table
            if (effortTo[nextX][nextY] > effortToNextNode) {
                effortTo[nextX][nextY] = effortToNextNode;
                pq.push(new State(nextX, nextY, effortToNextNode));
            }
        }
    }
    
    // æ­£å¸¸æƒ…å†µä¸ä¼šè¾¾åˆ°è¿™ä¸ª return
    return -1;
};
```

```python
# by chatGPT (python)
import heapq

class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m, n = len(heights), len(heights[0])
        # å®šä¹‰ï¼šä» (0, 0) åˆ° (i, j) çš„æœ€å°ä½“åŠ›æ¶ˆè€—æ˜¯ effortTo[i][j]
        effortTo = [[float('inf')] * n for _ in range(m)]
        # base caseï¼Œèµ·ç‚¹åˆ°èµ·ç‚¹çš„æœ€å°æ¶ˆè€—å°±æ˜¯ 0
        effortTo[0][0] = 0
        
        # ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒeffortFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
        pq = []
        
        # ä»èµ·ç‚¹ (0, 0) å¼€å§‹è¿›è¡Œ BFS
        heapq.heappush(pq, [0, 0, 0])

        while pq:
            curEffortFromStart, curX, curY = heapq.heappop(pq)
            
            # åˆ°è¾¾ç»ˆç‚¹æå‰ç»“æŸ
            if curX == m - 1 and curY == n - 1:
                return curEffortFromStart
            
            if curEffortFromStart > effortTo[curX][curY]:
                continue
                
            # å°† (curX, curY) çš„ç›¸é‚»åæ ‡è£…å…¥é˜Ÿåˆ—
            for nextX, nextY in self.adj(heights, curX, curY):
                # è®¡ç®—ä» (curX, curY) è¾¾åˆ° (nextX, nextY) çš„æ¶ˆè€—
                effortToNextNode = max(
                    effortTo[curX][curY],
                    abs(heights[curX][curY] - heights[nextX][nextY])
                )
                # æ›´æ–° dp table
                if effortTo[nextX][nextY] > effortToNextNode:
                    effortTo[nextX][nextY] = effortToNextNode
                    heapq.heappush(pq, [effortToNextNode, nextX, nextY])
                    
        # æ­£å¸¸æƒ…å†µä¸ä¼šè¾¾åˆ°è¿™ä¸ª return
        return -1
    
    # æ–¹å‘æ•°ç»„ï¼Œä¸Šä¸‹å·¦å³çš„åæ ‡åç§»é‡
    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]

    # è¿”å›åæ ‡ (x, y) çš„ä¸Šä¸‹å·¦å³ç›¸é‚»åæ ‡
    def adj(self, matrix, x, y):
        m, n = len(matrix), len(matrix[0])
        # å­˜å‚¨ç›¸é‚»èŠ‚ç‚¹
        neighbors = []
        for dir in self.dirs:
            nx = x + dir[0]
            ny = y + dir[1]
            if nx >= m or nx < 0 or ny >= n or ny < 0:
                # ç´¢å¼•è¶Šç•Œ
                continue
            neighbors.append([nx, ny])
        return neighbors
```

https://leetcode.cn/problems/path-with-minimum-effort çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/peak-index-in-a-mountain-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& nums) {
        // å–ä¸¤ç«¯éƒ½é—­çš„äºŒåˆ†æœç´¢
        int left = 0, right = nums.size() - 1;
        // å› ä¸ºé¢˜ç›®å¿…ç„¶æœ‰è§£ï¼Œæ‰€ä»¥è®¾ç½® left == right ä¸ºç»“æŸæ¡ä»¶
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                // mid æœ¬èº«å°±æ˜¯å³°å€¼æˆ–å…¶å·¦ä¾§æœ‰ä¸€ä¸ªå³°å€¼
                right = mid;
            } else {
                // mid å³ä¾§æœ‰ä¸€ä¸ªå³°å€¼
                left = mid + 1;
            }
        }
        return left;
    }
};
```

```go
// by chatGPT (go)
func peakIndexInMountainArray(nums []int) int {
    // å–ä¸¤ç«¯éƒ½é—­çš„äºŒåˆ†æœç´¢
    left, right := 0, len(nums)-1
    // å› ä¸ºé¢˜ç›®å¿…ç„¶æœ‰è§£ï¼Œæ‰€ä»¥è®¾ç½® left == right ä¸ºç»“æŸæ¡ä»¶
    for left < right {
        mid := left + (right-left)/2
        if nums[mid] > nums[mid+1] {
            // mid æœ¬èº«å°±æ˜¯å³°å€¼æˆ–å…¶å·¦ä¾§æœ‰ä¸€ä¸ªå³°å€¼
            right = mid
        } else {
            // mid å³ä¾§æœ‰ä¸€ä¸ªå³°å€¼
            left = mid + 1
        }
    }
    return left
}
```

```java
// by labuladong (java)
class Solution {
    public int peakIndexInMountainArray(int[] nums) {
        // å–ä¸¤ç«¯éƒ½é—­çš„äºŒåˆ†æœç´¢
        int left = 0, right = nums.length - 1;
        // å› ä¸ºé¢˜ç›®å¿…ç„¶æœ‰è§£ï¼Œæ‰€ä»¥è®¾ç½® left == right ä¸ºç»“æŸæ¡ä»¶
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                // mid æœ¬èº«å°±æ˜¯å³°å€¼æˆ–å…¶å·¦ä¾§æœ‰ä¸€ä¸ªå³°å€¼
                right = mid;
            } else {
                // mid å³ä¾§æœ‰ä¸€ä¸ªå³°å€¼
                left = mid + 1;
            }
        }
        return left;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @return {number}
 */
var peakIndexInMountainArray = function(nums) {
    // å–ä¸¤ç«¯éƒ½é—­çš„äºŒåˆ†æœç´¢
    let left = 0, right = nums.length - 1;
    // å› ä¸ºé¢˜ç›®å¿…ç„¶æœ‰è§£ï¼Œæ‰€ä»¥è®¾ç½® left == right ä¸ºç»“æŸæ¡ä»¶
    while (left < right) {
        const mid = left + Math.floor((right - left) / 2);
        if (nums[mid] > nums[mid + 1]) {
            // mid æœ¬èº«å°±æ˜¯å³°å€¼æˆ–å…¶å·¦ä¾§æœ‰ä¸€ä¸ªå³°å€¼
            right = mid;
        } else {
            // mid å³ä¾§æœ‰ä¸€ä¸ªå³°å€¼
            left = mid + 1;
        }
    }
    return left;
};
```

```python
# by chatGPT (python)
class Solution:
    def peakIndexInMountainArray(self, nums: List[int]) -> int:
        # å–ä¸¤ç«¯éƒ½é—­çš„äºŒåˆ†æœç´¢
        left, right = 0, len(nums) - 1
        # å› ä¸ºé¢˜ç›®å¿…ç„¶æœ‰è§£ï¼Œæ‰€ä»¥è®¾ç½® left == right ä¸ºç»“æŸæ¡ä»¶
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[mid + 1]:
                # mid æœ¬èº«å°±æ˜¯å³°å€¼æˆ–å…¶å·¦ä¾§æœ‰ä¸€ä¸ªå³°å€¼
                right = mid
            else:
                # mid å³ä¾§æœ‰ä¸€ä¸ªå³°å€¼
                left = mid + 1
        return left
```

https://leetcode.cn/problems/peak-index-in-a-mountain-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/peeking-iterator çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class PeekingIterator : public Iterator<int> {
private:
    Iterator<int>* iter; // è¿­ä»£å™¨
    int nextElem; // ç¼“å­˜ä¸‹ä¸€ä¸ªå…ƒç´ 
public:
    PeekingIterator(const vector<int>& nums) : Iterator(nums) {
        iter = &nums; // åˆå§‹åŒ–è¿­ä»£å™¨
        if (Iterator::hasNext()) { // æ£€æŸ¥æ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ 
            nextElem = Iterator::next(); // å–å‡ºä¸‹ä¸€ä¸ªå…ƒç´ å¹¶ç¼“å­˜
        }
    }

    int peek() { // è¿”å›å½“å‰ç¼“å­˜çš„å…ƒç´ 
        return nextElem;
    }

    int next() { // è¿”å›ç¼“å­˜çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå¹¶æ›´æ–°ç¼“å­˜
        int res = nextElem;
        if (Iterator::hasNext()) {
            nextElem = Iterator::next();
        } else {
            nextElem = NULL;
        }
        return res;
    }

    bool hasNext() const { // æ£€æŸ¥æ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ 
        return nextElem != NULL;
    }
};
```

```go
// by chatGPT (go)
type Iterator interface {
    hasNext() bool
    next() int
}

type PeekingIterator struct {
    iter     Iterator
    // ä¿å­˜ä¸‹ä¸€ä¸ªå…ƒç´ çš„ç¼“å­˜
    nextElem int
}

func Constructor(iter Iterator) *PeekingIterator {
    this := new(PeekingIterator)
    this.iter = iter
    // æŠŠä¸‹ä¸€ä¸ªå…ƒç´ æå‰æ‹¿å‡ºæ¥å¹¶ç¼“å­˜èµ·æ¥
    if iter.hasNext() {
        this.nextElem = iter.next()
    }
    return this
}

// è¿”å›è¿­ä»£å™¨çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œä½†æ˜¯ä¸ç§»åŠ¨è¿­ä»£å™¨çš„æŒ‡é’ˆ
func (this *PeekingIterator) peek() int {
    return this.nextElem
}

//ä»¥ä¸‹æ–¹æ³•å’Œ Iterator æ¥å£ä¸­çš„ä¸€æ ·ã€‚
func (this *PeekingIterator) next() int {
    res := this.nextElem
    // å¦‚æœè¿­ä»£å™¨è¿˜æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå°±æ›´æ–°ç¼“å­˜
    if this.iter.hasNext() {
        this.nextElem = this.iter.next()
    } else {
        this.nextElem = 0
    }
    return res
}

func (this *PeekingIterator) hasNext() bool {
    return this.nextElem != 0
}
```

```java
// by labuladong (java)
// Java Iterator interface reference:
// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html

class PeekingIterator implements Iterator<Integer> {
	private Iterator<Integer> iter;
	// æŠŠè¿­ä»£å™¨çš„ä¸‹ä¸€ä¸ªå…ƒç´ æå‰æ‹¿å‡ºæ¥å¹¶ç¼“å­˜èµ·æ¥
	private Integer nextElem;

	public PeekingIterator(Iterator<Integer> iterator) {
		this.iter = iterator;
		this.nextElem = iterator.next();
	}

	public Integer peek() {
		return nextElem;
	}


	@Override
	public Integer next() {
		Integer res = nextElem;
		// æ›´æ–° nextElem
		if (iter.hasNext()) {
			nextElem = iter.next();
		} else {
			nextElem = null;
		}
		return res;
	}

	@Override
	public boolean hasNext() {
		return nextElem != null;
	}
}
```

```javascript
// by chatGPT (javascript)
/**
 * Javascript iterator reference:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol
 */

var PeekingIterator = function(iterator) {
  this.iter = iterator;
  // æŠŠè¿­ä»£å™¨çš„ä¸‹ä¸€ä¸ªå…ƒç´ æå‰æ‹¿å‡ºæ¥å¹¶ç¼“å­˜èµ·æ¥
  this.nextElem = iterator.next();
};

PeekingIterator.prototype.peek = function() {
  return this.nextElem;
};

PeekingIterator.prototype.next = function() {
  var res = this.nextElem;
  // æ›´æ–° nextElem
  if (this.iter.hasNext()) {
    this.nextElem = this.iter.next();
  } else {
    this.nextElem = null;
  }
  return res;
};

PeekingIterator.prototype.hasNext = function() {
  return this.nextElem !== null;
};
```

```python
# by chatGPT (python)
# Python Iterator interface reference:
# https://docs.python.org/3/library/stdtypes.html#iterator-types

class PeekingIterator:
    def __init__(self, iterator):
        self.iter = iterator
        # æŠŠè¿­ä»£å™¨çš„ä¸‹ä¸€ä¸ªå…ƒç´ æå‰æ‹¿å‡ºæ¥å¹¶ç¼“å­˜èµ·æ¥
        self.next_elem = self.iter.__next__()

    def peek(self):
        return self.next_elem

    def __next__(self):
        res = self.next_elem
        # æ›´æ–° next_elem
        try:
            self.next_elem = self.iter.__next__()
        except StopIteration:
            self.next_elem = None
        return res

    def __iter__(self):
        return self

    def __bool__(self):
        return self.next_elem is not None
```

https://leetcode.cn/problems/peeking-iterator çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/perfect-rectangle çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        int X1 = INT_MAX, Y1 = INT_MAX;
        int X2 = INT_MIN, Y2 = INT_MIN;
        set<pair<int, int>> points;
        int actual_area = 0;
        for(auto &r: rectangles){
            //è®¡ç®—å®Œç¾çŸ©å½¢çš„ç†è®ºé¡¶ç‚¹åæ ‡
            X1 = min(X1, r[0]);
            Y1 = min(Y1, r[1]);
            X2 = max(X2, r[2]);
            Y2 = max(Y2, r[3]);
            //ç´¯åŠ å°çŸ©å½¢çš„é¢ç§¯
            actual_area += (r[2] - r[0]) * (r[3] - r[1]);
            
            //è®°å½•æœ€ç»ˆå½¢æˆçš„å›¾å½¢ä¸­çš„é¡¶ç‚¹
            pair<int, int> p1 = {r[0], r[1]};
            pair<int, int> p2 = {r[0], r[3]};
            pair<int, int> p3 = {r[2], r[1]};
            pair<int, int> p4 = {r[2], r[3]};
            vector<pair<int, int>> cur_points = {p1, p2, p3, p4};
            //å¦‚æœåæ ‡å·²ç»å­˜åœ¨ï¼Œé‚£ä¹ˆä»seté‡Œé¢åˆ é™¤
            //å¦‚æœåæ ‡ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆæ·»åŠ 
            for(auto &p: cur_points){
                if(points.count(p)) points.erase(p);
                else points.insert(p);
            }
        }
        // åˆ¤æ–­é¢ç§¯æ˜¯å¦ç›¸åŒ
        int expected_area = (X2 - X1) * (Y2 - Y1);
        if(actual_area != expected_area) return false;
        // åˆ¤æ–­æœ€ç»ˆç•™ä¸‹çš„é¡¶ç‚¹ä¸ªæ•°æ˜¯å¦ä¸º 4
        if(points.size() != 4) return false;
        // åˆ¤æ–­ç•™ä¸‹çš„ 4 ä¸ªé¡¶ç‚¹æ˜¯å¦æ˜¯å®Œç¾çŸ©å½¢çš„é¡¶ç‚¹
        if(!points.count({X1, Y1})) return false;
        if(!points.count({X1, Y2})) return false;
        if(!points.count({X2, Y1})) return false;
        if(!points.count({X2, Y2})) return false;
        // é¢ç§¯å’Œé¡¶ç‚¹éƒ½å¯¹åº”ï¼Œè¯´æ˜çŸ©å½¢ç¬¦åˆé¢˜æ„
        return true;
    }
};
```

```go
// by chatGPT (go)
func isRectangleCover(rectangles [][]int) bool {
    inf := 1<<31 - 1
    X1, Y1 := inf, inf
    X2, Y2 := -inf, -inf

    points := make(map[[2]int]bool)
    actual_area := 0
    for _, rectangle := range rectangles {
        // è®¡ç®—å®Œç¾çŸ©å½¢çš„ç†è®ºé¡¶ç‚¹åæ ‡
        x1, y1, x2, y2 := rectangle[0], rectangle[1], rectangle[2], rectangle[3]
        X1, Y1 = min(X1, x1), min(Y1, y1)
        X2, Y2 = max(X2, x2), max(Y2, y2)
        // ç´¯åŠ å°çŸ©å½¢çš„é¢ç§¯
        actual_area += (x2 - x1) * (y2 - y1)
        // è®°å½•æœ€ç»ˆå½¢æˆçš„å›¾å½¢ä¸­çš„é¡¶ç‚¹
        p1, p2 := [2]int{x1, y1}, [2]int{x1, y2}
        p3, p4 := [2]int{x2, y1}, [2]int{x2, y2}
        for _, p := range [][2]int{p1, p2, p3, p4} {
            if _, ok := points[p]; ok {
                delete(points, p)
            } else {
                points[p] = true
            }
        }
    }
    // åˆ¤æ–­é¢ç§¯æ˜¯å¦ç›¸åŒ
    expected_area := (X2 - X1) * (Y2 - Y1)
    if actual_area != expected_area {
        return false
    }
    // åˆ¤æ–­æœ€ç»ˆç•™ä¸‹çš„é¡¶ç‚¹ä¸ªæ•°æ˜¯å¦ä¸º 4
    if len(points) != 4 {
        return false
    }
    // åˆ¤æ–­ç•™ä¸‹çš„ 4 ä¸ªé¡¶ç‚¹æ˜¯å¦æ˜¯å®Œç¾çŸ©å½¢çš„é¡¶ç‚¹
    if !points[[2]int{X1, Y1}] {
        return false
    }
    if !points[[2]int{X1, Y2}] {
        return false
    }
    if !points[[2]int{X2, Y1}] {
        return false
    }
    if !points[[2]int{X2, Y2}] {
        return false
    }
    // é¢ç§¯å’Œé¡¶ç‚¹éƒ½å¯¹åº”ï¼Œè¯´æ˜çŸ©å½¢ç¬¦åˆé¢˜æ„
    return true
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by chatGPT (java)
class Solution {
    public boolean isRectangleCover(int[][] rectangles) {
        int X1 = Integer.MAX_VALUE, Y1 = Integer.MAX_VALUE;
        int X2 = Integer.MIN_VALUE, Y2 = Integer.MIN_VALUE;
      
        Set<String> points = new HashSet<>();
        int actual_area = 0;
      
        for(int[] rectangle: rectangles){
            // è®¡ç®—å®Œç¾çŸ©å½¢çš„ç†è®ºé¡¶ç‚¹åæ ‡
            X1 = Math.min(X1, rectangle[0]);
            Y1 = Math.min(Y1, rectangle[1]);
            X2 = Math.max(X2, rectangle[2]);
            Y2 = Math.max(Y2, rectangle[3]);
            // ç´¯åŠ å°çŸ©å½¢çš„é¢ç§¯
            actual_area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1]);
            // è®°å½•æœ€ç»ˆå½¢æˆçš„å›¾å½¢ä¸­çš„é¡¶ç‚¹
            String p1 = rectangle[0] + "," + rectangle[1];
            String p2 = rectangle[0] + "," + rectangle[3];
            String p3 = rectangle[2] + "," + rectangle[1];
            String p4 = rectangle[2] + "," + rectangle[3];
            for (String p : new String[] { p1, p2, p3, p4 }) {
                if (points.contains(p))
                    points.remove(p);
                else
                    points.add(p);
            }
        }
        // åˆ¤æ–­é¢ç§¯æ˜¯å¦ç›¸åŒ
        int expected_area = (X2 - X1) * (Y2 - Y1);
        if(actual_area!=expected_area){
            return false;
        }
        // åˆ¤æ–­æœ€ç»ˆç•™ä¸‹çš„é¡¶ç‚¹ä¸ªæ•°æ˜¯å¦ä¸º 4
        if(points.size()!=4){
            return false;
        }
        // åˆ¤æ–­ç•™ä¸‹çš„ 4 ä¸ªé¡¶ç‚¹æ˜¯å¦æ˜¯å®Œç¾çŸ©å½¢çš„é¡¶ç‚¹
        if (!points.contains(X1 + "," + Y1))
            return false;
        if (!points.contains(X1 + "," + Y2))
            return false;
        if (!points.contains(X2 + "," + Y1))
            return false;
        if (!points.contains(X2 + "," + Y2))
            return false;
        // é¢ç§¯å’Œé¡¶ç‚¹éƒ½å¯¹åº”ï¼Œè¯´æ˜çŸ©å½¢ç¬¦åˆé¢˜æ„
        return true;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
* @param {number[][]} rectangles
* @return {boolean}
*/
var isRectangleCover = function(rectangles) {
    let X1 = Infinity, Y1 = Infinity;   // è®°å½•æœ€å·¦ä¸‹è§’ç‚¹çš„åæ ‡
    let X2 = -Infinity, Y2 = -Infinity; // è®°å½•æœ€å³ä¸Šè§’ç‚¹çš„åæ ‡
    let points = new Set();             // è®°å½•æ¯ä¸ªå°çŸ©å½¢çš„å››ä¸ªè§’è½
    let actual_area = 0;                // è®°å½•å°çŸ©å½¢çš„é¢ç§¯ä¹‹å’Œ
    for(let i=0; i<rectangles.length; i++){
        let x1 = rectangles[i][0];
        let y1 = rectangles[i][1];
        let x2 = rectangles[i][2];
        let y2 = rectangles[i][3];
        X1 = Math.min(X1, x1);
        Y1 = Math.min(Y1, y1);
        X2 = Math.max(X2, x2);
        Y2 = Math.max(Y2, y2);
        actual_area += (x2 - x1) * (y2 - y1);
        let p1 = [x1, y1];
        let p2 = [x1, y2];
        let p3 = [x2, y1];
        let p4 = [x2, y2];
        for(let point of [p1, p2, p3, p4]){ // éå†æ¯ä¸ªå°çŸ©å½¢å†…çš„å››ä¸ªè§’è½
            if(points.has(point)) points.delete(point); // å¦‚æœå·²ç»åœ¨pointsä¸­ï¼Œåˆ é™¤
            else points.add(point); // å¦‚æœä¸åœ¨pointsä¸­ï¼Œæ·»åŠ 
        }
    }
    let expected_area = (X2-X1) * (Y2-Y1); // ç†è®ºå®Œç¾çŸ©å½¢çš„é¢ç§¯
    if(actual_area !== expected_area) return false;
    if(points.length !== 4) return false;
    if(!points.has([X1, Y1]) || !points.has([X1, Y2]) || !points.has([X2, Y1]) || !points.has([X2, Y2])) return false; // åˆ¤æ–­æ˜¯å¦æ˜¯å®Œç¾çŸ©å½¢çš„å››ä¸ªè§’è½åæ ‡ç‚¹
    return true;
};
```

```python
# by labuladong (python)
class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        X1, Y1 = float('inf'), float('inf')
        X2, Y2 = -float('inf'), -float('inf')
        
        points = set()
        actual_area = 0
        for x1, y1, x2, y2 in rectangles:
            # è®¡ç®—å®Œç¾çŸ©å½¢çš„ç†è®ºé¡¶ç‚¹åæ ‡
            X1, Y1 = min(X1, x1), min(Y1, y1)
            X2, Y2 = max(X2, x2), max(Y2, y2)
            # ç´¯åŠ å°çŸ©å½¢çš„é¢ç§¯
            actual_area += (x2 - x1) * (y2 - y1)
            # è®°å½•æœ€ç»ˆå½¢æˆçš„å›¾å½¢ä¸­çš„é¡¶ç‚¹
            p1, p2 = (x1, y1), (x1, y2)
            p3, p4 = (x2, y1), (x2, y2)
            for p in [p1, p2, p3, p4]:
                if p in points: points.remove(p)
                else:           points.add(p)
        # åˆ¤æ–­é¢ç§¯æ˜¯å¦ç›¸åŒ
        expected_area = (X2 - X1) * (Y2 - Y1)
        if actual_area != expected_area:
            return False
        # åˆ¤æ–­æœ€ç»ˆç•™ä¸‹çš„é¡¶ç‚¹ä¸ªæ•°æ˜¯å¦ä¸º 4
        if len(points) != 4:       return False
        # åˆ¤æ–­ç•™ä¸‹çš„ 4 ä¸ªé¡¶ç‚¹æ˜¯å¦æ˜¯å®Œç¾çŸ©å½¢çš„é¡¶ç‚¹
        if (X1, Y1) not in points: return False
        if (X1, Y2) not in points: return False
        if (X2, Y1) not in points: return False
        if (X2, Y2) not in points: return False
        # é¢ç§¯å’Œé¡¶ç‚¹éƒ½å¯¹åº”ï¼Œè¯´æ˜çŸ©å½¢ç¬¦åˆé¢˜æ„
        return True
```

https://leetcode.cn/problems/perfect-rectangle çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/perfect-squares çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int numSquares(int n) {
        // å®šä¹‰ï¼šå’Œä¸º i çš„å¹³æ–¹æ•°çš„æœ€å°æ•°é‡æ˜¯ dp[i]
        vector<int> dp(n + 1);
        // base case
        dp[0] = 0;
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        for (int i = 1; i <= n; i++) {
            dp[i] = i; // æœ€åçš„æƒ…å†µå°±æ˜¯æ¯ä¸ªæ•°éƒ½æ˜¯ 1ï¼Œæœ€å¤šä¹Ÿå°± i ä¸ªæ•°
            for (int j = 1; j * j <= i; j++) {
                // i - j * j åªè¦å†åŠ ä¸€ä¸ªå¹³æ–¹æ•° j * j å³å¯å‡‘å‡º i
                dp[i] = min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }
};
```

```go
// by chatGPT (go)
func numSquares(n int) int {
    // å®šä¹‰ï¼šå’Œä¸º i çš„å¹³æ–¹æ•°çš„æœ€å°æ•°é‡æ˜¯ dp[i]
    dp := make([]int, n+1)
    // base case
    dp[0] = 0
    // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
    for i := 1; i <= n; i++ {
        dp[i] = i
        for j := 1; j*j <= i; j++ {
            dp[i] = min(dp[i], dp[i-j*j]+1)
        }
    }
    return dp[n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int numSquares(int n) {
        // å®šä¹‰ï¼šå’Œä¸º i çš„å¹³æ–¹æ•°çš„æœ€å°æ•°é‡æ˜¯ dp[i]
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        // base case
        dp[0] = 0;
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j * j <= i; j++) {
                // i - j * j åªè¦å†åŠ ä¸€ä¸ªå¹³æ–¹æ•° j * j å³å¯å‡‘å‡º i
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }
}
```

```javascript
// by chatGPT (javascript)
var numSquares = function(n) {
    // å®šä¹‰ï¼šå’Œä¸º i çš„å¹³æ–¹æ•°çš„æœ€å°æ•°é‡æ˜¯ dp[i]
    const dp = new Array(n+1).fill(0);
    // base case
    dp[0] = 0;
    // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
    for (let i = 1; i <= n; i++) {
        dp[i] = i;
        for (let j = 1; j * j <= i; j++) {
            // i - j * j åªè¦å†åŠ ä¸€ä¸ªå¹³æ–¹æ•° j * j å³å¯å‡‘å‡º i
            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
        }
    }
    return dp[n];
};
```

```python
# by chatGPT (python)
class Solution:
    def numSquares(self, n: int) -> int:
        # å®šä¹‰ï¼šå’Œä¸º i çš„å¹³æ–¹æ•°çš„æœ€å°æ•°é‡æ˜¯ dp[i]
        dp = [float('inf')] * (n+1)
        # base case
        dp[0] = 0
        # çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        for i in range(1, n+1):
            for j in range(1, int(i**0.5)+1):
                # i - j * j åªè¦å†åŠ ä¸€ä¸ªå¹³æ–¹æ•° j * j å³å¯å‡‘å‡º i
                dp[i] = min(dp[i], dp[i - j*j] + 1)
        return dp[n]
```

https://leetcode.cn/problems/perfect-squares çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/permutation-in-string çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:

    // åˆ¤æ–­ s ä¸­æ˜¯å¦å­˜åœ¨ t çš„æ’åˆ—
    bool checkInclusion(string t, string s) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;

        int left = 0, right = 0;
        int valid = 0;
        while (right < s.size()) {
            char c = s[right];
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c])
                    valid++;
            }

            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (right - left >= t.size()) {
                // åœ¨è¿™é‡Œåˆ¤æ–­æ˜¯å¦æ‰¾åˆ°äº†åˆæ³•çš„å­ä¸²
                if (valid == need.size())
                    return true;
                char d = s[left];
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        // æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å­ä¸²
        return false;
    }
};
```

```go
// by chatGPT (go)
// åˆ¤æ–­ s ä¸­æ˜¯å¦å­˜åœ¨ t çš„æ’åˆ—
func checkInclusion(t string, s string) bool {
    need, window := make(map[byte]int), make(map[byte]int)
    for i := range t {
        need[t[i]]++
    }

    left, right := 0, 0
    valid := 0
    for right < len(s) {
        c := s[right]
        right++
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        if _, ok := need[c]; ok {
            window[c]++
            if window[c] == need[c] {
                valid++
            }
        }

        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        for right-left >= len(t) {
            // åœ¨è¿™é‡Œåˆ¤æ–­æ˜¯å¦æ‰¾åˆ°äº†ç¬¦åˆæ¡ä»¶çš„å­ä¸²
            if valid == len(need) {
                return true
            }
            d := s[left]
            left++
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if _, ok := need[d]; ok {
                if window[d] == need[d] {
                    valid--
                }
                window[d]--
            }
        }
    }
    // æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å­ä¸²
    return false
}
```

```java
// by chatGPT (java)
class Solution {
    public boolean checkInclusion(String t, String s) {
        //ä½¿ç”¨å“ˆå¸Œè¡¨ç”¨äºè®°å½• t ä¸­æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°
        Map<Character, Integer> need = new HashMap<>(), window = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            char c = t.charAt(i);
            need.put(c, need.getOrDefault(c, 0) + 1);
        }

        //åˆå§‹åŒ–çª—å£çš„å·¦å³è¾¹ç•ŒåŠåˆæ³•å­—ç¬¦ä¸ªæ•°
        int left = 0, right = 0, valid = 0;
        while (right < s.length()) {
            //c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
            char c = s.charAt(right);
            //å³ç§»çª—å£
            right++;
            //è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c).equals(need.get(c)))
                    valid++;
            }

            //åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (right - left >= t.length()) {
                //åœ¨è¿™é‡Œåˆ¤æ–­æ˜¯å¦æ‰¾åˆ°äº†åˆæ³•çš„å­ä¸²
                if (valid == need.size())
                    return true;
                //d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
                char d = s.charAt(left);
                //å·¦ç§»çª—å£
                left++;

                //è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                if (need.containsKey(d)) {
                    if (window.get(d).equals(need.get(d)))
                        valid--;
                    window.put(d, window.get(d) - 1);
                }
            }
        }
        //æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å­ä¸²
        return false;
    }
}
```

```javascript
// by chatGPT (javascript)
var checkInclusion = function(t, s) {
    // åˆå§‹åŒ– need å’Œ window å“ˆå¸Œè¡¨
    let need = new Map();
    let window = new Map();
    for (let c of t) {
        need.set(c, (need.get(c) || 0) + 1);
    }

    let left = 0;
    let right = 0;
    let valid = 0;
    while (right < s.length) {
        let c = s[right];
        right++;
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„æ›´æ–°
        if (need.has(c)) {
            window.set(c, (window.get(c) || 0) + 1);
            if (window.get(c) === need.get(c)) {
                valid++;
            }
        }

        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦éœ€è¦æ”¶ç¼©
        while (right - left >= t.length) {
            // æ›´æ–°ç»“æœ
            if (valid === need.size) {
                return true;
            }
            let d = s[left];
            left++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„æ›´æ–°
            if (need.has(d)) {
                if (window.get(d) === need.get(d)) {
                    valid--;
                }
                window.set(d, (window.get(d) || 0) - 1);
            }
        }
    }
    // æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å­ä¸²
    return false;
};
```

```python
# by chatGPT (python)
class Solution:
    def checkInclusion(self, t: str, s: str) -> bool:
        # åˆ›å»ºå­—å…¸ï¼Œè®°å½•å­—ç¬¦éœ€è¦å‡ºç°çš„æ¬¡æ•°
        need, window = Counter(t), Counter()
        left, right, valid = 0, 0, 0
        
        # å³æŒ‡é’ˆå‰ç§»ï¼Œæ›´æ–°çª—å£å†…æ•°æ®
        while right < len(s):
            c = s[right]
            right += 1
            # å¦‚æœè¯¥å­—ç¬¦åœ¨éœ€è¦çš„å­—å…¸é‡Œï¼Œæ›´æ–°çª—å£å†…å­—å…¸
            if need[c]:
                window[c] += 1
                # å¦‚æœçª—å£å†…å­—å…¸è¯¥å­—ç¬¦å‡†ç¡®æ¬¡æ•°ä¸éœ€è¦çš„æ¬¡æ•°ç›¸åŒï¼Œè®¡æ•°å™¨+1
                if window[c] == need[c]:
                    valid += 1

            # åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦éœ€è¦æ”¶ç¼©
            while right - left >= len(t):
                # å¦‚æœå­ä¸²åˆæ³•ï¼Œè¿”å›True
                if valid == len(need):
                    return True
                # å·¦æŒ‡é’ˆå‰ç§»äº†ï¼Œéœ€è¦ä»çª—å£å†…å­—å…¸ä¸­å‡æ‰ä¸€ä¸ªå…ƒç´ 
                d = s[left]
                left += 1
                if need[d]:
                    # å¦‚æœçª—å£å†…å­—å…¸è¯¥å­—ç¬¦å‡†ç¡®æ¬¡æ•°ä¸éœ€è¦çš„æ¬¡æ•°ç›¸åŒï¼Œè®¡æ•°å™¨-1
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1
        # æœªæ‰¾åˆ°åˆæ³•çš„å­ä¸²ï¼Œè¿”å›False
        return False
```

https://leetcode.cn/problems/permutation-in-string çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/permutations çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> res;

    /* ä¸»å‡½æ•°ï¼Œè¾“å…¥ä¸€ç»„ä¸é‡å¤çš„æ•°å­—ï¼Œè¿”å›å®ƒä»¬çš„å…¨æ’åˆ— */
    vector<vector<int>> permute(vector<int>& nums) {
        // è®°å½•ã€Œè·¯å¾„ã€
        deque<int> track;
        // ã€Œè·¯å¾„ã€ä¸­çš„å…ƒç´ ä¼šè¢«æ ‡è®°ä¸º trueï¼Œé¿å…é‡å¤ä½¿ç”¨
        vector<bool> used(nums.size(), false);
        
        backtrack(nums, track, used);
        return res;
    }

    // è·¯å¾„ï¼šè®°å½•åœ¨ track ä¸­
    // é€‰æ‹©åˆ—è¡¨ï¼šnums ä¸­ä¸å­˜åœ¨äº track çš„é‚£äº›å…ƒç´ ï¼ˆused[i] ä¸º falseï¼‰
    // ç»“æŸæ¡ä»¶ï¼šnums ä¸­çš„å…ƒç´ å…¨éƒ½åœ¨ track ä¸­å‡ºç°
    void backtrack(vector<int>& nums, deque<int>& track, vector<bool>& used) {
        // è§¦å‘ç»“æŸæ¡ä»¶
        if (track.size() == nums.size()) {
            res.push_back(vector<int>(track.begin(), track.end()));
            return;
        }

        for (int i = 0; i < nums.size(); i++) {
            // æ’é™¤ä¸åˆæ³•çš„é€‰æ‹©
            if (used[i]) {
                /**<extend up -200>
                ![](../pictures/backtracking/6.jpg)
                */
                // nums[i] å·²ç»åœ¨ track ä¸­ï¼Œè·³è¿‡
                continue;
            }
            // åšé€‰æ‹©
            track.push_back(nums[i]);
            used[i] = true;
            // è¿›å…¥ä¸‹ä¸€å±‚å†³ç­–æ ‘
            backtrack(nums, track, used);
            // å–æ¶ˆé€‰æ‹©
            track.pop_back();
            used[i] = false;
        }
    }
};
```

```go
// by chatGPT (go)
func permute(nums []int) [][]int {
    res := [][]int{}
    track := []int{}   // è®°å½•ã€Œè·¯å¾„ã€
    used := make([]bool, len(nums))  // ã€Œè·¯å¾„ã€ä¸­çš„å…ƒç´ ä¼šè¢«æ ‡è®°ä¸º trueï¼Œé¿å…é‡å¤ä½¿ç”¨

    var backtrack func(int)  // å®šä¹‰å›æº¯å‡½æ•°

    backtrack = func(level int) {
        if level == len(nums) {   // è§¦å‘ç»“æŸæ¡ä»¶
            tmp := make([]int, len(track))
            copy(tmp, track)
            res = append(res, tmp)
            return
        }
        // æšä¸¾å‡ºæ‰€æœ‰å¯èƒ½çš„é€‰æ‹©
        for i := 0; i < len(nums); i++ {
            if used[i] {  // æ’é™¤ä¸åˆæ³•çš„é€‰æ‹©
                continue
            }
            track = append(track, nums[i])  // åšé€‰æ‹©
            used[i] = true
            backtrack(level+1)  // è¿›å…¥ä¸‹ä¸€å±‚å†³ç­–æ ‘
            track = track[:len(track)-1]  // å–æ¶ˆé€‰æ‹©
            used[i] = false
        }
    }

    backtrack(0)
    return res
}
```

```java
// by labuladong (java)
class Solution {

    List<List<Integer>> res = new LinkedList<>();

    /* ä¸»å‡½æ•°ï¼Œè¾“å…¥ä¸€ç»„ä¸é‡å¤çš„æ•°å­—ï¼Œè¿”å›å®ƒä»¬çš„å…¨æ’åˆ— */
    List<List<Integer>> permute(int[] nums) {
        // è®°å½•ã€Œè·¯å¾„ã€
        LinkedList<Integer> track = new LinkedList<>();
        // ã€Œè·¯å¾„ã€ä¸­çš„å…ƒç´ ä¼šè¢«æ ‡è®°ä¸º trueï¼Œé¿å…é‡å¤ä½¿ç”¨
        boolean[] used = new boolean[nums.length];
        
        backtrack(nums, track, used);
        return res;
    }

    // è·¯å¾„ï¼šè®°å½•åœ¨ track ä¸­
    // é€‰æ‹©åˆ—è¡¨ï¼šnums ä¸­ä¸å­˜åœ¨äº track çš„é‚£äº›å…ƒç´ ï¼ˆused[i] ä¸º falseï¼‰
    // ç»“æŸæ¡ä»¶ï¼šnums ä¸­çš„å…ƒç´ å…¨éƒ½åœ¨ track ä¸­å‡ºç°
    void backtrack(int[] nums, LinkedList<Integer> track, boolean[] used) {
        // è§¦å‘ç»“æŸæ¡ä»¶
        if (track.size() == nums.length) {
            res.add(new LinkedList(track));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            // æ’é™¤ä¸åˆæ³•çš„é€‰æ‹©
            if (used[i]) {
                /**<extend up -200>
                ![](../pictures/backtracking/6.jpg)
                */
                // nums[i] å·²ç»åœ¨ track ä¸­ï¼Œè·³è¿‡
                continue;
            }
            // åšé€‰æ‹©
            track.add(nums[i]);
            used[i] = true;
            // è¿›å…¥ä¸‹ä¸€å±‚å†³ç­–æ ‘
            backtrack(nums, track, used);
            // å–æ¶ˆé€‰æ‹©
            track.removeLast();
            used[i] = false;
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var permute = function(nums) {
    let res = [];
    let track = [];
    let used = new Array(nums.length).fill(false);
    // è·¯å¾„ï¼šè®°å½•åœ¨ track ä¸­
    // é€‰æ‹©åˆ—è¡¨ï¼šnums ä¸­ä¸å­˜åœ¨äº track çš„é‚£äº›å…ƒç´ ï¼ˆused[i] ä¸º falseï¼‰
    // ç»“æŸæ¡ä»¶ï¼šnums ä¸­çš„å…ƒç´ å…¨éƒ½åœ¨ track ä¸­å‡ºç°
    const backtrack = (nums, track, used) => {
        // è§¦å‘ç»“æŸæ¡ä»¶
        if (track.length === nums.length) {
            res.push([...track]);
            return;
        }

        for (let i = 0; i < nums.length; i++) {
            // æ’é™¤ä¸åˆæ³•çš„é€‰æ‹©
            if (used[i]) {
                // nums[i] å·²ç»åœ¨ track ä¸­ï¼Œè·³è¿‡
                continue;
            }
            // åšé€‰æ‹©
            track.push(nums[i]);
            used[i] = true;
            // è¿›å…¥ä¸‹ä¸€å±‚å†³ç­–æ ‘
            backtrack(nums, track, used);
            // å–æ¶ˆé€‰æ‹©
            track.pop();
            used[i] = false;
        }
    }
    backtrack(nums, track, used);
    return res;
}
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.res = []

    # ä¸»å‡½æ•°ï¼Œè¾“å…¥ä¸€ç»„ä¸é‡å¤çš„æ•°å­—ï¼Œè¿”å›å®ƒä»¬çš„å…¨æ’åˆ— 
    def permute(self, nums: List[int]) -> List[List[int]]:

        # è®°å½•ã€Œè·¯å¾„ã€
        track = []
        # ã€Œè·¯å¾„ã€ä¸­çš„å…ƒç´ ä¼šè¢«æ ‡è®°ä¸º trueï¼Œé¿å…é‡å¤ä½¿ç”¨
        used = [False] * len(nums)
        
        self.backtrack(nums, track, used)
        return self.res

    # è·¯å¾„ï¼šè®°å½•åœ¨ track ä¸­
    # é€‰æ‹©åˆ—è¡¨ï¼šnums ä¸­ä¸å­˜åœ¨äº track çš„é‚£äº›å…ƒç´ ï¼ˆused[i] ä¸º falseï¼‰
    # ç»“æŸæ¡ä»¶ï¼šnums ä¸­çš„å…ƒç´ å…¨éƒ½åœ¨ track ä¸­å‡ºç°
    def backtrack(self, nums: List[int], track: List[int], used: List[bool]) -> None:

        # è§¦å‘ç»“æŸæ¡ä»¶
        if len(track) == len(nums):
            self.res.append(track[:])
            return

        for i in range(len(nums)):
            # æ’é™¤ä¸åˆæ³•çš„é€‰æ‹©
            if used[i]:
                # nums[i] å·²ç»åœ¨ track ä¸­ï¼Œè·³è¿‡
                continue
            # åšé€‰æ‹©
            track.append(nums[i])
            used[i] = True
            # è¿›å…¥ä¸‹ä¸€å±‚å†³ç­–æ ‘
            self.backtrack(nums, track, used)
            # å–æ¶ˆé€‰æ‹©
            track.pop()
            used[i] = False
```

https://leetcode.cn/problems/permutations çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/populating-next-right-pointers-in-each-node çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // ä¸»å‡½æ•°
    Node* connect(Node* root) {
        if (root == nullptr) return nullptr;
        // éå†ã€Œä¸‰å‰æ ‘ã€ï¼Œè¿æ¥ç›¸é‚»èŠ‚ç‚¹
        traverse(root->left, root->right);
        return root;
    }

    // ä¸‰å‰æ ‘éå†æ¡†æ¶
    void traverse(Node* node1, Node* node2) {
        if (node1 == nullptr || node2 == nullptr) {
            return;
        }
        /**** å‰åºä½ç½® ****/
        // å°†ä¼ å…¥çš„ä¸¤ä¸ªèŠ‚ç‚¹ç©¿èµ·æ¥
        node1->next = node2;
        
        // è¿æ¥ç›¸åŒçˆ¶èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹
        traverse(node1->left, node1->right);
        traverse(node2->left, node2->right);
        // è¿æ¥è·¨è¶Šçˆ¶èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹
        traverse(node1->right, node2->left);
    }
};
```

```go
// by chatGPT (go)
func connect(root *Node) *Node {
    if root == nil {
        return nil
    }
    // äºŒå‰æ ‘å±‚åºéå†æ¡†æ¶
    q := make([]*Node, 0)
    q = append(q, root)
    for len(q) > 0 {
        sz := len(q)
        // éå†ä¸€å±‚
        var pre *Node
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]
            // é“¾æ¥å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹çš„ next æŒ‡é’ˆ
            if pre != nil {
                pre.Next = cur
            }
            pre = cur
            // å°†ä¸‹ä¸€å±‚èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
            if cur.Left != nil {
                q = append(q, cur.Left)
            }
            if cur.Right != nil {
                q = append(q, cur.Right)
            }
        }
    }
    return root
}
```

```java
// by labuladong (java)
class Solution {
    // ä¸»å‡½æ•°
    public Node connect(Node root) {
        if (root == null) return null;
        // éå†ã€Œä¸‰å‰æ ‘ã€ï¼Œè¿æ¥ç›¸é‚»èŠ‚ç‚¹
        traverse(root.left, root.right);
        return root;
    }

    // ä¸‰å‰æ ‘éå†æ¡†æ¶
    void traverse(Node node1, Node node2) {
        if (node1 == null || node2 == null) {
            return;
        }
        /**** å‰åºä½ç½® ****/
        // å°†ä¼ å…¥çš„ä¸¤ä¸ªèŠ‚ç‚¹ç©¿èµ·æ¥
        node1.next = node2;
        
        // è¿æ¥ç›¸åŒçˆ¶èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹
        traverse(node1.left, node1.right);
        traverse(node2.left, node2.right);
        // è¿æ¥è·¨è¶Šçˆ¶èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹
        traverse(node1.right, node2.left);
    }
}
```

```javascript
// by chatGPT (javascript)
var connect = function(root) {
    if (root === null) {
        return null;
    }
    // äºŒå‰æ ‘å±‚åºéå†æ¡†æ¶
    const q = [];
    q.push(root);
    while (q.length > 0) {
        const sz = q.length;
        // éå†ä¸€å±‚
        let pre = null;
        for (let i = 0; i < sz; i++) {
            const cur = q.shift();
            // é“¾æ¥å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹çš„ next æŒ‡é’ˆ
            if (pre !== null) {
                pre.next = cur;
            }
            pre = cur;
            // å°†ä¸‹ä¸€å±‚èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
            if (cur.left !== null) {
                q.push(cur.left);
            }
            if (cur.right !== null) {
                q.push(cur.right);
            }
        }
    }
    return root;
};
```

```python
# by chatGPT (python)
# Definition for a Node.
# class Node:
#     def __init__(self, val = 0, left = None, right = None, next = None):
#         self.val = val
#         self.left = left
#         self.right = right
#         self.next = next

class Solution:
    # ä¸»å‡½æ•°
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return

        # éå†ã€Œä¸‰å‰æ ‘ã€ï¼Œè¿æ¥ç›¸é‚»èŠ‚ç‚¹
        self.traverse(root.left, root.right)

        return root

    # ä¸‰å‰æ ‘éå†æ¡†æ¶
    def traverse(self, node1, node2):
        # ç»ˆæ­¢æ¡ä»¶
        if not node1 or not node2:
            return
        # å°†ä¼ å…¥çš„ä¸¤ä¸ªèŠ‚ç‚¹ç©¿èµ·æ¥
        node1.next = node2
        # è¿æ¥ç›¸åŒçˆ¶èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹
        self.traverse(node1.left, node1.right)
        self.traverse(node2.left, node2.right)
        # è¿æ¥è·¨è¶Šçˆ¶èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹
        self.traverse(node1.right, node2.left)
```

https://leetcode.cn/problems/populating-next-right-pointers-in-each-node çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/possible-bipartition çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
private:
    bool ok = true;
    vector<bool> color;
    vector<bool> visited;

public:
    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {
        // å›¾èŠ‚ç‚¹ç¼–å·ä» 1 å¼€å§‹
        color.resize(n + 1);
        visited.resize(n + 1);
        // è½¬åŒ–æˆé‚»æ¥è¡¨è¡¨ç¤ºå›¾ç»“æ„
        vector<vector<int>> graph = buildGraph(n, dislikes);

        for (int v = 1; v <= n; v++) {
            if (!visited[v]) {
                traverse(graph, v);
            }
        }
        return ok;
    }

    // å»ºå›¾å‡½æ•°
    vector<vector<int>> buildGraph(int n, vector<vector<int>>& dislikes) {
        // å›¾èŠ‚ç‚¹ç¼–å·ä¸º 1...n
        vector<vector<int>> graph(n + 1);
        for (int i = 1; i <= n; i++) {
            graph[i] = vector<int>();
        }
        for (auto& edge : dislikes) {
            int v = edge[1];
            int w = edge[0];
            // ã€Œæ— å‘å›¾ã€ç›¸å½“äºã€ŒåŒå‘å›¾ã€
            // v -> w
            graph[v].push_back(w);
            // w -> v
            graph[w].push_back(v);
        }
        return graph;
    }

    // å’Œä¹‹å‰åˆ¤å®šäºŒåˆ†å›¾çš„ traverse å‡½æ•°å®Œå…¨ç›¸åŒ
    void traverse(vector<vector<int>>& graph, int v) {
        if (!ok) return;
        visited[v] = true;
        for (int w : graph[v]) {
            if (!visited[w]) {
                color[w] = !color[v];
                traverse(graph, w);
            } else {
                if (color[w] == color[v]) {
                    ok = false;
                }
            }
        }
    }
};
```

```go
// by chatGPT (go)
import "fmt"

func possibleBipartition(n int, dislikes [][]int) bool {
	color := make([]bool, n+1)
	visited := make([]bool, n+1)
	ok := true

	// è½¬åŒ–æˆé‚»æ¥è¡¨è¡¨ç¤ºå›¾ç»“æ„
	graph := buildGraph(n, dislikes)

	var traverse func(int)
	traverse = func(v int) {
		if !ok {
			return
		}
		visited[v] = true
		for _, w := range graph[v] {
			if !visited[w] {
				color[w] = !color[v]
				traverse(w)
			} else {
				if color[w] == color[v] {
					ok = false
				}
			}
		}
	}

	// å…¨å›¾éå†ï¼Œé˜²æ­¢éè¿é€šå›¾å‡ºç°
	for v := 1; v <= n; v++ {
		if !visited[v] {
			traverse(v)
		}
	}

	return ok
}

// å»ºå›¾å‡½æ•°
func buildGraph(n int, dislikes [][]int) []([]int) {
	graph := make([]([]int), n+1)
	for i := range graph {
		graph[i] = make([]int, 0)
	}
	for _, edge := range dislikes {
		v := edge[1]
		w := edge[0]
		// ã€Œæ— å‘å›¾ã€ç›¸å½“äºã€ŒåŒå‘å›¾ã€
		// v -> w
		graph[v] = append(graph[v], w)
		// w -> v
		graph[w] = append(graph[w], v)
	}
	return graph
}
```

```java
// by labuladong (java)
class Solution {

    private boolean ok = true;
    private boolean[] color;
    private boolean[] visited;

    public boolean possibleBipartition(int n, int[][] dislikes) {
        // å›¾èŠ‚ç‚¹ç¼–å·ä» 1 å¼€å§‹
        color = new boolean[n + 1];
        visited = new boolean[n + 1];
        // è½¬åŒ–æˆé‚»æ¥è¡¨è¡¨ç¤ºå›¾ç»“æ„
        List<Integer>[] graph = buildGraph(n, dislikes);

        for (int v = 1; v <= n; v++) {
            if (!visited[v]) {
                traverse(graph, v);
            }
        }
        return ok;
    }

    // å»ºå›¾å‡½æ•°
    private List<Integer>[] buildGraph(int n, int[][] dislikes) {
        // å›¾èŠ‚ç‚¹ç¼–å·ä¸º 1...n
        List<Integer>[] graph = new LinkedList[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : dislikes) {
            int v = edge[1];
            int w = edge[0];
            // ã€Œæ— å‘å›¾ã€ç›¸å½“äºã€ŒåŒå‘å›¾ã€
            // v -> w
            graph[v].add(w);
            // w -> v
            graph[w].add(v);
        }
        return graph;
    }

    // å’Œä¹‹å‰åˆ¤å®šäºŒåˆ†å›¾çš„ traverse å‡½æ•°å®Œå…¨ç›¸åŒ
    private void traverse(List<Integer>[] graph, int v) {
        if (!ok) return;
        visited[v] = true;
        for (int w : graph[v]) {
            if (!visited[w]) {
                color[w] = !color[v];
                traverse(graph, w);
            } else {
                if (color[w] == color[v]) {
                    ok = false;
                }
            }
        }
    }

}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @param {number[][]} dislikes
 * @return {boolean}
 */
var possibleBipartition = function(n, dislikes) {
    let ok = true;
    let color = new Array(n + 1);
    let visited = new Array(n + 1);
    let graph = buildGraph(n, dislikes);
    // å»ºå›¾å‡½æ•°
    function buildGraph(n, dislikes) {
        // å›¾èŠ‚ç‚¹ç¼–å·ä¸º 1...n
        let graph = new Array(n + 1);
        for (let i = 1; i <= n; i++) {
            graph[i] = new Array();
        }
        for (let i = 0; i < dislikes.length; i++) {
            let v = dislikes[i][0];
            let w = dislikes[i][1];
            // ã€Œæ— å‘å›¾ã€ç›¸å½“äºã€ŒåŒå‘å›¾ã€
            // v -> w
            graph[v].push(w);
            // w -> v
            graph[w].push(v);
        }
        return graph;
    }
    // å’Œä¹‹å‰åˆ¤å®šäºŒåˆ†å›¾çš„ traverse å‡½æ•°å®Œå…¨ç›¸åŒ
    function traverse(graph, v) {
        if (!ok) return;
        visited[v] = true;
        for (let i = 0; i < graph[v].length; i++) {
            let w = graph[v][i];
            if (!visited[w]) {
                color[w] = !color[v];
                traverse(graph, w);
            } else {
                if (color[w] == color[v]) {
                    ok = false;
                }
            }
        }
    }
    for (let v = 1; v <= n; v++) {
        if (!visited[v]) {
            traverse(graph, v);
        }
    }
    return ok;
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.ok = True
        self.color = None
        self.visited = None

    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        # å›¾èŠ‚ç‚¹ç¼–å·ä» 1 å¼€å§‹
        self.color = [False] * (n + 1)
        self.visited = [False] * (n + 1)
        # è½¬åŒ–æˆé‚»æ¥è¡¨è¡¨ç¤ºå›¾ç»“æ„
        graph = self.buildGraph(n, dislikes)

        for v in range(1, n+1):
            if not self.visited[v]:
                self.traverse(graph, v)
        return self.ok

    # å»ºå›¾å‡½æ•°
    def buildGraph(self, n: int, dislikes: List[List[int]]) -> List[List[int]]:
        # å›¾èŠ‚ç‚¹ç¼–å·ä¸º 1...n
        graph = [[] for _ in range(n + 1)]
        for edge in dislikes:
            v = edge[1]
            w = edge[0]
            # ã€Œæ— å‘å›¾ã€ç›¸å½“äºã€ŒåŒå‘å›¾ã€
            # v -> w
            graph[v].append(w)
            # w -> v
            graph[w].append(v)
        return graph

    # å’Œä¹‹å‰åˆ¤å®šäºŒåˆ†å›¾çš„ traverse å‡½æ•°å®Œå…¨ç›¸åŒ
    def traverse(self, graph: List[List[int]], v: int) -> None:
        if not self.ok:
            return
        self.visited[v] = True
        for w in graph[v]:
            if not self.visited[w]:
                self.color[w] = not self.color[v]
                self.traverse(graph, w)
            else:
                if self.color[w] == self.color[v]:
                    self.ok = False
```

https://leetcode.cn/problems/possible-bipartition çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/power-of-two çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if (n <= 0) return false;
        return (n & (n - 1)) == 0;
    }
};
```

```go
// by chatGPT (go)
// Solution to LeetCode problem: Power of Two
// https://leetcode.com/problems/power-of-two/
import "fmt"

func isPowerOfTwo(n int) bool {
    if n <= 0 {
        return false
    }
    return (n & (n - 1)) == 0
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isPowerOfTwo(int n) {
        if (n <= 0) return false;
        return (n & (n - 1)) == 0;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfTwo = function(n) {
    if (n <= 0) return false;
    return (n & (n - 1)) == 0;
};
```

```python
# by chatGPT (python)
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        return (n & (n - 1)) == 0
```

https://leetcode.cn/problems/power-of-two çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/powx-n çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    double myPow(double a, int k) {
        if (k == 0) return 1;

        if (k == INT_MIN) {
            // æŠŠ k æ˜¯ INT_MIN çš„æƒ…å†µå•ç‹¬æ‹¿å‡ºæ¥å¤„ç†
            // é¿å… -k æ•´å‹æº¢å‡º
            return myPow(1 / a, -(k + 1)) / a;
        }

        if (k < 0) {
            return myPow(1 / a, -k);
        }

        if (k % 2 == 1) {
            // k æ˜¯å¥‡æ•°
            return (a * myPow(a, k - 1));
        } else {
            // k æ˜¯å¶æ•°
            double sub = myPow(a, k / 2);
            return (sub * sub);
        }
    }
};
```

```go
// by chatGPT (go)
// Golang Code
func myPow(a float64, k int) float64 {
    if k == 0 {
        return 1
    }

    if k == math.MinInt32 {
        // æŠŠ k æ˜¯ INT_MIN çš„æƒ…å†µå•ç‹¬æ‹¿å‡ºæ¥å¤„ç†
        // é¿å… -k æ•´å‹æº¢å‡º
        return myPow(1 / a, -(k + 1)) / a
    }

    if k < 0 {
        return myPow(1 / a, -k)
    }
    if k % 2 == 1 {
        // k æ˜¯å¥‡æ•°
        return (a * myPow(a, k - 1))
    } else {
        // k æ˜¯å¶æ•°
        sub := myPow(a, k / 2)
        return (sub * sub)
    }
}
```

```java
// by labuladong (java)
class Solution {
    public double myPow(double a, int k) {
        if (k == 0) return 1;

        if (k == Integer.MIN_VALUE) {
            // æŠŠ k æ˜¯ INT_MIN çš„æƒ…å†µå•ç‹¬æ‹¿å‡ºæ¥å¤„ç†
            // é¿å… -k æ•´å‹æº¢å‡º
            return myPow(1 / a, -(k + 1)) / a;
        }

        if (k < 0) {
            return myPow(1 / a, -k);
        }

        if (k % 2 == 1) {
            // k æ˜¯å¥‡æ•°
            return (a * myPow(a, k - 1));
        } else {
            // k æ˜¯å¶æ•°
            double sub = myPow(a, k / 2);
            return (sub * sub);
        }
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} a
 * @param {number} k
 * @return {number}
 */
var myPow = function(a, k) {
    if (k === 0) return 1;

    if (k === -2147483648) {
        // æŠŠ k æ˜¯ INT_MIN çš„æƒ…å†µå•ç‹¬æ‹¿å‡ºæ¥å¤„ç†
        // é¿å… -k æ•´å‹æº¢å‡º
        return myPow(1 / a, -(k + 1)) / a;
    }

    if (k < 0) {
        return myPow(1 / a, -k);
    }

    if (k % 2 === 1) {
        // k æ˜¯å¥‡æ•°
        return (a * myPow(a, k - 1));
    } else {
        // k æ˜¯å¶æ•°
        const sub = myPow(a, k / 2);
        return (sub * sub);
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def myPow(self, a: float, k: int) -> float:
        if k == 0:
            return 1

        if k == -2147483648:
            # æŠŠ k æ˜¯ INT_MIN çš„æƒ…å†µå•ç‹¬æ‹¿å‡ºæ¥å¤„ç†
            # é¿å… -k æ•´å‹æº¢å‡º
            return self.myPow(1 / a, -(k + 1)) / a

        if k < 0:
            return self.myPow(1 / a, -k)

        if k % 2 == 1:
            # k æ˜¯å¥‡æ•°
            return a * self.myPow(a, k - 1)
        else:
            # k æ˜¯å¶æ•°
            sub = self.myPow(a, k // 2)
            return sub * sub
```

https://leetcode.cn/problems/powx-n çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int preimageSizeFZF(int K) {
        // å·¦è¾¹ç•Œå’Œå³è¾¹ç•Œä¹‹å·® + 1 å°±æ˜¯ç­”æ¡ˆ
        return (int)(right_bound(K) - left_bound(K) + 1);
    }

    // é€»è¾‘ä¸å˜ï¼Œæ•°æ®ç±»å‹å…¨éƒ¨æ”¹æˆ long
    long trailingZeroes(long n) {
        long res = 0;
        for (long d = n; d / 5 > 0; d = d / 5) {
            res += d / 5;
        }
        return res;
    }

    /* æœç´¢ trailingZeroes(n) == K çš„å·¦ä¾§è¾¹ç•Œ */
    long left_bound(int target) {
        long lo = 0, hi = LONG_MAX;
        while (lo < hi) {
            long mid = lo + (hi - lo) / 2;
            if (trailingZeroes(mid) < target) {
                lo = mid + 1;
            } else if (trailingZeroes(mid) > target) {
                hi = mid;
            } else {
                hi = mid;
            }
        }
        return lo;
    }

    /* æœç´¢ trailingZeroes(n) == K çš„å³ä¾§è¾¹ç•Œ */
    long right_bound(int target) {
        long lo = 0, hi = LONG_MAX;
        while (lo < hi) {
            long mid = lo + (hi - lo) / 2;
            if (trailingZeroes(mid) < target) {
                lo = mid + 1;
            } else if (trailingZeroes(mid) > target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }

        return lo - 1;
    }
};
```

```go
// by chatGPT (go)
import "math"

func preimageSizeFZF(K int) int {
    // å·¦è¾¹ç•Œå’Œå³è¾¹ç•Œä¹‹å·® + 1 å°±æ˜¯ç­”æ¡ˆ
    return int(right_bound(K) - left_bound(K) + 1)
}

// é€»è¾‘ä¸å˜ï¼Œæ•°æ®ç±»å‹å…¨éƒ¨æ”¹æˆ int64
func trailingZeroes(n int64) int64 {
    var res int64 = 0
    for d := n; d / 5 > 0; d = d / 5 {
        res += d / 5
    }
    return res
}

/* æœç´¢ trailingZeroes(n) == K çš„å·¦ä¾§è¾¹ç•Œ */
func left_bound(target int) int64 {
    var lo, hi int64 = 0, math.MaxInt64
    for lo < hi {
        mid := lo + (hi - lo) / 2
        if trailingZeroes(mid) < int64(target) {
            lo = mid + 1
        } else if trailingZeroes(mid) > int64(target) {
            hi = mid
        } else {
            hi = mid
        }
    }
    return lo
}

/* æœç´¢ trailingZeroes(n) == K çš„å³ä¾§è¾¹ç•Œ */
func right_bound(target int) int64 {
    var lo, hi int64 = 0, math.MaxInt64
    for lo < hi {
        mid := lo + (hi - lo) / 2
        if trailingZeroes(mid) < int64(target) {
            lo = mid + 1
        } else if trailingZeroes(mid) > int64(target) {
            hi = mid
        } else {
            lo = mid + 1
        }
    }

    return lo - 1
}
```

```java
// by labuladong (java)
class Solution {
    public int preimageSizeFZF(int K) {
        // å·¦è¾¹ç•Œå’Œå³è¾¹ç•Œä¹‹å·® + 1 å°±æ˜¯ç­”æ¡ˆ
        return (int)(right_bound(K) - left_bound(K) + 1);
    }

    // é€»è¾‘ä¸å˜ï¼Œæ•°æ®ç±»å‹å…¨éƒ¨æ”¹æˆ long
    long trailingZeroes(long n) {
        long res = 0;
        for (long d = n; d / 5 > 0; d = d / 5) {
            res += d / 5;
        }
        return res;
    }

    /* æœç´¢ trailingZeroes(n) == K çš„å·¦ä¾§è¾¹ç•Œ */
    long left_bound(int target) {
        long lo = 0, hi = Long.MAX_VALUE;
        while (lo < hi) {
            long mid = lo + (hi - lo) / 2;
            if (trailingZeroes(mid) < target) {
                lo = mid + 1;
            } else if (trailingZeroes(mid) > target) {
                hi = mid;
            } else {
                hi = mid;
            }
        }
        return lo;
    }

    /* æœç´¢ trailingZeroes(n) == K çš„å³ä¾§è¾¹ç•Œ */
    long right_bound(int target) {
        long lo = 0, hi = Long.MAX_VALUE;
        while (lo < hi) {
            long mid = lo + (hi - lo) / 2;
            if (trailingZeroes(mid) < target) {
                lo = mid + 1;
            } else if (trailingZeroes(mid) > target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }

        return lo - 1;
    }
}
```

```javascript
// by chatGPT (javascript)
var preimageSizeFZF = function (K) {
  // å·¦è¾¹ç•Œå’Œå³è¾¹ç•Œä¹‹å·® + 1 å°±æ˜¯ç­”æ¡ˆ
  return right_bound(K) - left_bound(K) + 1;
};

// é€»è¾‘ä¸å˜ï¼Œæ•°æ®ç±»å‹å…¨éƒ¨æ”¹æˆ long
var trailingZeroes = function (n) {
  var res = 0;
  for (var d = n; Math.floor(d / 5) > 0; d = Math.floor(d / 5)) {
    res += Math.floor(d / 5);
  }
  return res;
};

/* æœç´¢ trailingZeroes(n) == K çš„å·¦ä¾§è¾¹ç•Œ */
var left_bound = function (target) {
  var lo = 0,
    hi = Number.MAX_VALUE;
  while (lo < hi) {
    var mid = lo + Math.floor((hi - lo) / 2);
    if (trailingZeroes(mid) < target) {
      lo = mid + 1;
    } else if (trailingZeroes(mid) > target) {
      hi = mid;
    } else {
      hi = mid;
    }
  }
  return lo;
};

/* æœç´¢ trailingZeroes(n) == K çš„å³ä¾§è¾¹ç•Œ */
var right_bound = function (target) {
  var lo = 0,
    hi = Number.MAX_VALUE;
  while (lo < hi) {
    var mid = lo + Math.floor((hi - lo) / 2);
    if (trailingZeroes(mid) < target) {
      lo = mid + 1;
    } else if (trailingZeroes(mid) > target) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }

  return lo - 1;
};
```

```python
# by chatGPT (python)
class Solution:
    def preimageSizeFZF(self, K: int) -> int:
        # å·¦è¾¹ç•Œå’Œå³è¾¹ç•Œä¹‹å·® + 1 å°±æ˜¯ç­”æ¡ˆ
        return int(self.right_bound(K) - self.left_bound(K) + 1)

    # é€»è¾‘ä¸å˜ï¼Œæ•°æ®ç±»å‹å…¨éƒ¨æ”¹æˆ long
    def trailingZeroes(self, n: int) -> int:
        res = 0
        for d in range(n, 0, -1):
            while d % 5 == 0:
                res += 1 
                d //= 5
        return res
        
    """ æœç´¢ trailingZeroes(n) == K çš„å·¦ä¾§è¾¹ç•Œ """
    def left_bound(self, target: int) -> int:
        lo, hi = 0, float('inf')
        while lo < hi:
            mid = lo + (hi - lo) // 2
            if self.trailingZeroes(mid) < target:
                lo = mid + 1
            elif self.trailingZeroes(mid) > target:
                hi = mid 
            else:
                hi = mid
                
        return lo
        
    
    """ æœç´¢ trailingZeroes(n) == K çš„å³ä¾§è¾¹ç•Œ """
    def right_bound(self, target: int) -> int:
        lo, hi = 0, float('inf')
        while lo < hi:
            mid = lo + (hi - lo) // 2
            if self.trailingZeroes(mid) < target:
                lo = mid + 1
            elif self.trailingZeroes(mid) > target:
                hi = mid
            else:
                lo = mid + 1
                
        return lo - 1
```

https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/product-of-the-last-k-numbers çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class ProductOfNumbers {
    // å‰ç¼€ç§¯æ•°ç»„
    // preProduct[i] / preProduct[j] å°±æ˜¯ [i, j] ä¹‹é—´çš„å…ƒç´ ç§¯
    vector<int> preProduct;

public:
    ProductOfNumbers() {
        // åˆå§‹åŒ–æ”¾ä¸€ä¸ª 1ï¼Œä¾¿äºè®¡ç®—åç»­æ·»åŠ å…ƒç´ çš„ä¹˜ç§¯
        preProduct.push_back(1);
    }

    void add(int num) {
        if (num == 0) {
            // å¦‚æœæ·»åŠ çš„å…ƒç´ æ˜¯ 0ï¼Œåˆ™å‰é¢çš„å…ƒç´ ç§¯éƒ½åºŸäº†
            preProduct.clear();
            preProduct.push_back(1);
            return;
        }
        int n = preProduct.size();
        // å‰ç¼€ç§¯æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ 
        preProduct.push_back(preProduct[n - 1] * num);
    }

    int getProduct(int k) {
        int n = preProduct.size();
        if (k > n - 1) {
            // ä¸è¶³ k ä¸ªå…ƒç´ ï¼Œæ˜¯å› ä¸ºæœ€å k ä¸ªå…ƒç´ å­˜åœ¨ 0
            return 0;
        }
        // è®¡ç®—æœ€å k ä¸ªå…ƒç´ ç§¯
        return preProduct[n - 1] / preProduct[n - k - 1];
    }
};
```

```go
// by chatGPT (go)
type ProductOfNumbers struct {
    // å‰ç¼€ç§¯æ•°ç»„
    // preProduct[i] / preProduct[j] å°±æ˜¯ [i, j] ä¹‹é—´çš„å…ƒç´ ç§¯
    preProduct []int
}

func Constructor() ProductOfNumbers {
    // åˆå§‹åŒ–æ”¾ä¸€ä¸ª 1ï¼Œä¾¿äºè®¡ç®—åç»­æ·»åŠ å…ƒç´ çš„ä¹˜ç§¯
    return ProductOfNumbers{[]int{1}}
}

func (this *ProductOfNumbers) Add(num int) {
    if num == 0 {
        // å¦‚æœæ·»åŠ çš„å…ƒç´ æ˜¯ 0ï¼Œåˆ™å‰é¢çš„å…ƒç´ ç§¯éƒ½åºŸäº†
        this.preProduct = []int{1}
        return
    }
    n := len(this.preProduct)
    // å‰ç¼€ç§¯æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ 
    this.preProduct = append(this.preProduct, this.preProduct[n-1]*num)
}

func (this *ProductOfNumbers) GetProduct(k int) int {
    n := len(this.preProduct)
    if k > n-1 {
        // ä¸è¶³ k ä¸ªå…ƒç´ ï¼Œæ˜¯å› ä¸ºæœ€å k ä¸ªå…ƒç´ å­˜åœ¨ 0
        return 0
    }
    // è®¡ç®—æœ€å k ä¸ªå…ƒç´ ç§¯
    return this.preProduct[n-1] / this.preProduct[n-k-1]
}
```

```java
// by labuladong (java)
class ProductOfNumbers {
    // å‰ç¼€ç§¯æ•°ç»„
    // preProduct[i] / preProduct[j] å°±æ˜¯ [i, j] ä¹‹é—´çš„å…ƒç´ ç§¯
    ArrayList<Integer> preProduct = new ArrayList<>();

    public ProductOfNumbers() {
        // åˆå§‹åŒ–æ”¾ä¸€ä¸ª 1ï¼Œä¾¿äºè®¡ç®—åç»­æ·»åŠ å…ƒç´ çš„ä¹˜ç§¯
        preProduct.add(1);
    }

    public void add(int num) {
        if (num == 0) {
            // å¦‚æœæ·»åŠ çš„å…ƒç´ æ˜¯ 0ï¼Œåˆ™å‰é¢çš„å…ƒç´ ç§¯éƒ½åºŸäº†
            preProduct.clear();
            preProduct.add(1);
            return;
        }
        int n = preProduct.size();
        // å‰ç¼€ç§¯æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ 
        preProduct.add(preProduct.get(n - 1) * num);
    }

    public int getProduct(int k) {
        int n = preProduct.size();
        if (k > n - 1) {
            // ä¸è¶³ k ä¸ªå…ƒç´ ï¼Œæ˜¯å› ä¸ºæœ€å k ä¸ªå…ƒç´ å­˜åœ¨ 0
            return 0;
        }
        // è®¡ç®—æœ€å k ä¸ªå…ƒç´ ç§¯
        return preProduct.get(n - 1) / preProduct.get(n - k - 1);
    }
}
```

```javascript
// by chatGPT (javascript)
var ProductOfNumbers = function() {
    // å‰ç¼€ç§¯æ•°ç»„
    // preProduct[i] / preProduct[j] å°±æ˜¯ [i, j] ä¹‹é—´çš„å…ƒç´ ç§¯
    this.preProduct = [1];
};

ProductOfNumbers.prototype.add = function(num) {
    if (num === 0) {
        // å¦‚æœæ·»åŠ çš„å…ƒç´ æ˜¯ 0ï¼Œåˆ™å‰é¢çš„å…ƒç´ ç§¯éƒ½åºŸäº†
        this.preProduct = [1];
        return;
    }
    var n = this.preProduct.length;
    // å‰ç¼€ç§¯æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ 
    this.preProduct.push(this.preProduct[n - 1] * num);
};

ProductOfNumbers.prototype.getProduct = function(k) {
    var n = this.preProduct.length;
    if (k > n - 1) {
        // ä¸è¶³ k ä¸ªå…ƒç´ ï¼Œæ˜¯å› ä¸ºæœ€å k ä¸ªå…ƒç´ å­˜åœ¨ 0
        return 0;
    }
    // è®¡ç®—æœ€å k ä¸ªå…ƒç´ ç§¯
    return this.preProduct[n - 1] / this.preProduct[n - k - 1];
};
```

```python
# by chatGPT (python)
class ProductOfNumbers:
    # å‰ç¼€ç§¯æ•°ç»„
    # preProduct[i] / preProduct[j] å°±æ˜¯ [i, j] ä¹‹é—´çš„å…ƒç´ ç§¯
    def __init__(self):
        self.preProduct = [1]

    def add(self, num: int) -> None:
        if num == 0:
            # å¦‚æœæ·»åŠ çš„å…ƒç´ æ˜¯ 0ï¼Œåˆ™å‰é¢çš„å…ƒç´ ç§¯éƒ½åºŸäº†
            self.preProduct.clear()
            self.preProduct.append(1)
            return
        n = len(self.preProduct)
        # å‰ç¼€ç§¯æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ 
        self.preProduct.append(self.preProduct[n - 1] * num)

    def getProduct(self, k: int) -> int:
        n = len(self.preProduct)
        if k > n - 1:
            # ä¸è¶³ k ä¸ªå…ƒç´ ï¼Œæ˜¯å› ä¸ºæœ€å k ä¸ªå…ƒç´ å­˜åœ¨ 0
            return 0
        # è®¡ç®—æœ€å k ä¸ªå…ƒç´ ç§¯
        return self.preProduct[n - 1] // self.preProduct[n - k - 1]
```

https://leetcode.cn/problems/product-of-the-last-k-numbers çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/qJnOS7 çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int longestCommonSubsequence(string s1, string s2) {
        int m = s1.length(), n = s2.length();
        // å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        // ç›®æ ‡ï¼šs1[0..m-1] å’Œ s2[0..n-1] çš„ lcs é•¿åº¦ï¼Œå³ dp[m][n]
        // base case: dp[0][..] = dp[..][0] = 0

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
                if (s1[i - 1] == s2[j - 1]) {
                    // s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    // s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }

        return dp[m][n];
    }
};
```

```go
// by chatGPT (go)
func longestCommonSubsequence(s1 string, s2 string) int {
    m, n := len(s1), len(s2)
    // å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
    dp := make([][]int, m+1)
    for i := 0; i <= m; i++ {
        dp[i] = make([]int, n+1)
    }
    // ç›®æ ‡ï¼šs1[0..m-1] å’Œ s2[0..n-1] çš„ lcs é•¿åº¦ï¼Œå³ dp[m][n]
    // base case: dp[0][..] = dp[..][0] = 0

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            // ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
            if s1[i-1] == s2[j-1] {
                // s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                dp[i][j] = 1 + dp[i-1][j-1]
            } else {
                // s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                dp[i][j] = max(dp[i][j-1], dp[i-1][j])
            }
        }
    }

    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```java
// by labuladong (java)
class Solution {
    public int longestCommonSubsequence(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
        int[][] dp = new int[m + 1][n + 1];
        // ç›®æ ‡ï¼šs1[0..m-1] å’Œ s2[0..n-1] çš„ lcs é•¿åº¦ï¼Œå³ dp[m][n]
        // base case: dp[0][..] = dp[..][0] = 0

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    // s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    // s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }

        return dp[m][n];
    }
}
```

```javascript
// by chatGPT (javascript)
var longestCommonSubsequence = function(s1, s2) {
    var m = s1.length, n = s2.length;
    // å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
    var dp = new Array(m + 1);
    for(var i = 0;i<m+1;i++){
        dp[i] = new Array(n+1).fill(0);
    }

    // ç›®æ ‡ï¼šs1[0..m-1] å’Œ s2[0..n-1] çš„ lcs é•¿åº¦ï¼Œå³ dp[m][n]
    // base case: dp[0][..] = dp[..][0] = 0

    for (var i = 1; i <= m; i++) {
        for (var j = 1; j <= n; j++) {
            // ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                // s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                // s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
            }
        }
    }

    return dp[m][n];
};
```

```python
# by chatGPT (python)
class Solution:
    def longestCommonSubsequence(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)
        # å®šä¹‰ï¼šs1[0..i-1] å’Œ s2[0..j-1] çš„ lcs é•¿åº¦ä¸º dp[i][j]
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        # ç›®æ ‡ï¼šs1[0..m-1] å’Œ s2[0..n-1] çš„ lcs é•¿åº¦ï¼Œå³ dp[m][n]
        # base case: dp[0][..] = dp[..][0] = 0

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # ç°åœ¨ i å’Œ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€
                if s1[i - 1] == s2[j - 1]:
                    # s1[i-1] å’Œ s2[j-1] å¿…ç„¶åœ¨ lcs ä¸­
                    dp[i][j] = 1 + dp[i - 1][j - 1]
                else:
                    # s1[i-1] å’Œ s2[j-1] è‡³å°‘æœ‰ä¸€ä¸ªä¸åœ¨ lcs ä¸­
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])

        return dp[m][n]
```

https://leetcode.cn/problems/qJnOS7 çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    // å¤‡å¿˜å½•
    vector<int> memo;
    int MOD = 1000000007;

public:
    int numWays(int n) {
        if (n == 0) {
            return 1;
        }
        memo = vector(n + 1, 0);
        return dp(n);
    }

    // å®šä¹‰ï¼šçˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ä¸º dp(n)
    int dp(int n) {
        // base case
        if (n <= 2) {
            return n;
        }
        if (memo[n] > 0) {
            return memo[n];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // çˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ç­‰äºçˆ¬åˆ° n - 1 çš„æ–¹æ³•ä¸ªæ•°å’Œçˆ¬åˆ° n - 2 çš„æ–¹æ³•ä¸ªæ•°ä¹‹å’Œã€‚
        memo[n] = (dp(n - 1) + dp(n - 2)) % MOD;
        return memo[n];
    }
};
```

```go
// by chatGPT (go)
func numWays(n int) int {
    memo := make([]int, n+1)
    
    var dp func(int) int
    dp = func(n int) int {
        // base case
        if n <= 2 {
            return n
        }
        if memo[n] > 0 {
            return memo[n]
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // çˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ç­‰äºçˆ¬åˆ° n - 1 çš„æ–¹æ³•ä¸ªæ•°å’Œçˆ¬åˆ° n - 2 çš„æ–¹æ³•ä¸ªæ•°ä¹‹å’Œã€‚
        memo[n] = dp(n-1) + dp(n-2)
        return memo[n]
    }

    return dp(n)
}
```

```java
// by labuladong (java)
class Solution {
    // å¤‡å¿˜å½•
    int[] memo;

    public int climbStairs(int n) {
        memo = new int[n + 1];
        return dp(n);
    }

    // å®šä¹‰ï¼šçˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ä¸º dp(n)
    int dp(int n) {
        // base case
        if (n <= 2) {
            return n;
        }
        if (memo[n] > 0) {
            return memo[n];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // çˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ç­‰äºçˆ¬åˆ° n - 1 çš„æ–¹æ³•ä¸ªæ•°å’Œçˆ¬åˆ° n - 2 çš„æ–¹æ³•ä¸ªæ•°ä¹‹å’Œã€‚
        memo[n] = dp(n - 1) + dp(n - 2);
        return memo[n];
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @return {number}
 */
var numWays = function(n) {
    // å¤‡å¿˜å½•
    const memo = [];
    memo.length = n + 1;
    memo.fill(0);
    return dp(n, memo);
};

/**
 * @param {number} n
 * @param {number[]} memo
 * @return {number}
 */
var dp = function(n, memo) {
    // base case
    if (n <= 2) {
        return n;
    }
    if (memo[n] > 0) {
        return memo[n];
    }
    // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
    // çˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ç­‰äºçˆ¬åˆ° n - 1 çš„æ–¹æ³•ä¸ªæ•°å’Œçˆ¬åˆ° n - 2 çš„æ–¹æ³•ä¸ªæ•°ä¹‹å’Œã€‚
    memo[n] = dp(n - 1, memo) + dp(n - 2, memo);
    return memo[n];
};
```

```python
# by chatGPT (python)
class Solution:
    # å¤‡å¿˜å½•
    memo = []
    MOD = 1e9 + 7
    def numWays(self, n: int) -> int:
        self.memo = [-1] * (n + 1)
        return self.dp(n)

    # å®šä¹‰ï¼šçˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ä¸º dp(n)
    def dp(self, n: int) -> int:
        # base case
        if n <= 2:
            return n if n else 1

        if self.memo[n] != -1:
            return self.memo[n]

        # çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        # çˆ¬åˆ°ç¬¬ n çº§å°é˜¶çš„æ–¹æ³•ä¸ªæ•°ç­‰äºçˆ¬åˆ° n - 1 çš„æ–¹æ³•ä¸ªæ•°å’Œçˆ¬åˆ° n - 2 çš„æ–¹æ³•ä¸ªæ•°ä¹‹å’Œã€‚
        self.memo[n] = self.dp(n - 1) + self.dp(n - 2)
        return round(self.memo[n] % self.MOD)
```

https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/qn8gGX çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        // å­˜å‚¨ä¸‰å…ƒç»„ (num1[i], nums2[i], i)
        // i è®°å½• nums2 å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        auto cmp = [](auto & a, auto & b) {
            return a[0] + a[1] > b[0] + b[1];
        };
        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pq(cmp);
        // æŒ‰ç…§ 23 é¢˜çš„é€»è¾‘åˆå§‹åŒ–ä¼˜å…ˆçº§é˜Ÿåˆ—
        for (int i = 0; i < nums1.size(); i++) {
            pq.push({nums1[i], nums2[0], 0});
        }

        vector<vector<int>> res;
        // æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
        while (!pq.empty() && k > 0) {
            auto cur = pq.top();
            pq.pop();
            k--;
            // é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
            int next_index = cur[2] + 1;
            if (next_index < nums2.size()) {
                pq.push({cur[0], nums2[next_index], next_index});
            }

            vector<int> pair;
            pair.push_back(cur[0]);
            pair.push_back(cur[1]);
            res.push_back(pair);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
import (
	"container/heap"
	"fmt"
)

type item struct {
	num1   int
	num2   int
	num2Index int
}

// ç”¨äºè½¬æ¢ item ä¸º heap ä¸­å®é™…å­˜å‚¨çš„æ•°æ®
type itemHeap []item

func (h itemHeap) Len() int { return len(h) }
func (h itemHeap) Less(i, j int) bool {
	return h[i].num1 + h[i].num2 < h[j].num1 + h[j].num2
}
func (h itemHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }
func (h *itemHeap) Push(x interface{}) { *h = append(*h, x.(item)) }
func (h *itemHeap) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[:n-1]
	return x
}

func kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int {
	// å­˜å‚¨ä¸‰å…ƒç»„ (num1[i], nums2[i], i)
	// i è®°å½• nums2 å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
	pq := &itemHeap{}
	heap.Init(pq)

	// æŒ‰ç…§23é¢˜çš„é€»è¾‘åˆå§‹åŒ–ä¼˜å…ˆçº§é˜Ÿåˆ—
	for i := 0; i < len(nums1); i++ {
		heap.Push(pq, item{nums1[i], nums2[0], 0})
	}

	res := [][]int{}
	// æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
	for pq.Len() > 0 && k > 0 {
		cur := heap.Pop(pq).(item)
		k--
		// é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
		nextIndex := cur.num2Index + 1
		if nextIndex < len(nums2) {
			heap.Push(pq, item{cur.num1, nums2[nextIndex], nextIndex})
		}

		pair := []int{cur.num1, cur.num2}
		res = append(res, pair)
	}
	return res
}
```

```java
// by labuladong (java)
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        // å­˜å‚¨ä¸‰å…ƒç»„ (num1[i], nums2[i], i)
        // i è®°å½• nums2 å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            // æŒ‰ç…§æ•°å¯¹çš„å…ƒç´ å’Œå‡åºæ’åº
            return (a[0] + a[1]) - (b[0] + b[1]);
        });
        // æŒ‰ç…§ 23 é¢˜çš„é€»è¾‘åˆå§‹åŒ–ä¼˜å…ˆçº§é˜Ÿåˆ—
        for (int i = 0; i < nums1.length; i++) {
            pq.offer(new int[]{nums1[i], nums2[0], 0});
        }

        List<List<Integer>> res = new ArrayList<>();
        // æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
        while (!pq.isEmpty() && k > 0) {
            int[] cur = pq.poll();
            k--;
            // é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
            int next_index = cur[2] + 1;
            if (next_index < nums2.length) {
                pq.add(new int[]{cur[0], nums2[next_index], next_index});
            }

            List<Integer> pair = new ArrayList<>();
            pair.add(cur[0]);
            pair.add(cur[1]);
            res.add(pair);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number[][]}
 */

var kSmallestPairs = function(nums1, nums2, k) {
    // å­˜å‚¨ä¸‰å…ƒç»„ (num1[i], nums2[i], i)
    // i è®°å½• nums2 å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    const pq = new PriorityQueue((a, b) => {
        // æŒ‰ç…§æ•°å¯¹çš„å…ƒç´ å’Œå‡åºæ’åº
        return (a[0] + a[1]) - (b[0] + b[1]);
    });
    // æŒ‰ç…§ 23 é¢˜çš„é€»è¾‘åˆå§‹åŒ–ä¼˜å…ˆçº§é˜Ÿåˆ—
    for (let i = 0; i < nums1.length; i++) {
        pq.offer([nums1[i], nums2[0], 0]);
    }

    const res = [];
    // æ‰§è¡Œåˆå¹¶å¤šä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
    while (!pq.isEmpty() && k > 0) {
        const cur = pq.poll();
        k--;
        // é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
        const next_index = cur[2] + 1;
        if (next_index < nums2.length) {
            pq.add([cur[0], nums2[next_index], next_index]);
        }

        const pair = [];
        pair.push(cur[0]);
        pair.push(cur[1]);
        res.push(pair);
    }
    return res;
};

// An implementation of the PriorityQueue.
class PriorityQueue {
    constructor(compare = (a, b) => a - b) {
        this.compare = compare;
        this.heap = [];
    }
    get size() {
        return this.heap.length;
    }
    isEmpty() {
        return this.size === 0;
    }
    peek() {
        return this.heap[0];
    }
    offer(node) {
        this.heap.push(node);
        this._siftUp();
    }
    poll() {
        const poppedValue = this.peek();
        const bottom = this.size - 1;
        if (bottom > 0) {
            this._swap(0, bottom);
        }
        this.heap.pop();
        this._siftDown();
        return poppedValue;
    }
    _greater(i, j) {
        return this.compare(this.heap[i], this.heap[j]) < 0;
    }
    _swap(i, j) {
        [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
    }
    _siftUp() {
        let nodeIdx = this.size - 1;
        while (nodeIdx > 0 && this._greater(nodeIdx, Math.floor((nodeIdx + 1) / 2) - 1)) {
            const parentIdx = Math.floor((nodeIdx + 1) / 2) - 1;
            this._swap(nodeIdx, parentIdx);
            nodeIdx = parentIdx;
        }
    }
    _siftDown() {
        let nodeIdx = 0;
        while (
            (2 * nodeIdx + 1 < this.size && this._greater(2 * nodeIdx + 1, nodeIdx)) ||
            (2 * nodeIdx + 2 < this.size && this._greater(2 * nodeIdx + 2, nodeIdx))
        ) {
            const greaterChildIdx =
                2 * nodeIdx + 2 >= this.size || this._greater(2 * nodeIdx + 1, 2 * nodeIdx + 2)
                    ? 2 * nodeIdx + 1
                    : 2 * nodeIdx + 2;
            this._swap(greaterChildIdx, nodeIdx);
            nodeIdx = greaterChildIdx;
        }
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        # å­˜å‚¨ä¸‰å…ƒç»„ (num1[i], nums2[i], i)
        # i è®°å½• nums2 å…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç”¨äºç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        pq = []
        for i in range(len(nums1)):
            heapq.heappush(pq, [nums1[i]+nums2[0], nums1[i], nums2[0], 0])

        res = []
        while pq and k > 0:
            _, num1, num2, idx2 = heapq.heappop(pq)
            res.append([num1, num2])
            k -= 1
            if idx2 < len(nums2)-1:
                heapq.heappush(pq, [num1+nums2[idx2+1], num1, nums2[idx2+1], idx2+1])
        return res
```

https://leetcode.cn/problems/qn8gGX çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/que-shi-de-shu-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        // æœç´¢å·¦ä¾§çš„äºŒåˆ†æœç´¢
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > mid) {
                // mid å’Œ nums[mid] ä¸å¯¹åº”ï¼Œè¯´æ˜å·¦è¾¹æœ‰å…ƒç´ ç¼ºå¤±
                right = mid - 1;
            } else {
                // mid å’Œ nums[mid] å¯¹åº”ï¼Œè¯´æ˜å…ƒç´ ç¼ºå¤±åœ¨å³è¾¹
                left = mid + 1;
            }
        }
        return left;
    }
};
```

```go
// by chatGPT (go)
// missingNumber returns the missing number in the given array using binary search
func missingNumber(nums []int) int {
    // æœç´¢å·¦ä¾§çš„äºŒåˆ†æœç´¢
    left, right := 0, len(nums)-1

    for left <= right {
        mid := left + (right - left) / 2
        if nums[mid] > mid {
            // mid å’Œ nums[mid] ä¸å¯¹åº”ï¼Œè¯´æ˜å·¦è¾¹æœ‰å…ƒç´ ç¼ºå¤±
            right = mid - 1
        } else {
            // mid å’Œ nums[mid] å¯¹åº”ï¼Œè¯´æ˜å…ƒç´ ç¼ºå¤±åœ¨å³è¾¹
            left = mid + 1
        }
    }

    return left
}
```

```java
// by labuladong (java)
class Solution {
    public int missingNumber(int[] nums) {
        // æœç´¢å·¦ä¾§çš„äºŒåˆ†æœç´¢
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > mid) {
                // mid å’Œ nums[mid] ä¸å¯¹åº”ï¼Œè¯´æ˜å·¦è¾¹æœ‰å…ƒç´ ç¼ºå¤±
                right = mid - 1;
            } else {
                // mid å’Œ nums[mid] å¯¹åº”ï¼Œè¯´æ˜å…ƒç´ ç¼ºå¤±åœ¨å³è¾¹
                left = mid + 1;
            }
        }
        return left;
    }
}
```

```javascript
// by chatGPT (javascript)
var missingNumber = function(nums) {
    // æœç´¢å·¦ä¾§çš„äºŒåˆ†æœç´¢
    var left = 0, right = nums.length - 1;
    while (left <= right) {
        var mid = left + Math.floor((right - left) / 2);
        if (nums[mid] > mid) {
            // mid å’Œ nums[mid] ä¸å¯¹åº”ï¼Œè¯´æ˜å·¦è¾¹æœ‰å…ƒç´ ç¼ºå¤±
            right = mid - 1;
        } else {
            // mid å’Œ nums[mid] å¯¹åº”ï¼Œè¯´æ˜å…ƒç´ ç¼ºå¤±åœ¨å³è¾¹
            left = mid + 1;
        }
    }
    return left;
}
```

```python
# by chatGPT (python)
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        # æœç´¢å·¦ä¾§çš„äºŒåˆ†æœç´¢
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] > mid:
                # mid å’Œ nums[mid] ä¸å¯¹åº”ï¼Œè¯´æ˜å·¦è¾¹æœ‰å…ƒç´ ç¼ºå¤±
                right = mid - 1
            else:
                # mid å’Œ nums[mid] å¯¹åº”ï¼Œè¯´æ˜å…ƒç´ ç¼ºå¤±åœ¨å³è¾¹
                left = mid + 1
        return left
```

https://leetcode.cn/problems/que-shi-de-shu-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/random-flip-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
private:
    int m, n;
    // æŠ½è±¡ä¸€ç»´æ•°ç»„çš„é•¿åº¦
    int len;
    // å·²åˆ é™¤å…ƒç´ åˆ°å°¾éƒ¨æœªåˆ é™¤å…ƒç´ çš„æ˜ å°„
    unordered_map<int, int> deletedToExist;
    // è¿™ä¸ª deletedToExist å­˜çš„åˆ°åº•æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿä¸¾ä¸ªä¾‹å­ä½ å°±æ˜ç™½äº†ï¼š
    // å‡è®¾æ•°ç»„ [1,2,3,4,5]ï¼Œæˆ‘ç¬¬ä¸€æ¬¡éšæœºé€‰æ‹©äº†å…ƒç´  2ï¼Œ
    // ç„¶åæˆ‘å°±ä¼šåœ¨ deletedToExist è®°å½•ä¸€ä¸ªæ˜ å°„ 2 -> 5ï¼Œå¹¶åˆ é™¤æœ€åçš„å…ƒç´  5
    // ç°åœ¨æ•°ç»„æ˜¯ [1,2,3,4]ï¼Œæˆ‘ç¬¬äºŒæ¬¡éšæœºé€‰æ‹©åˆé€‰åˆ°äº† 2ï¼Œ
    // ä½†ä¸èƒ½é‡å¤é€‰æ‹©åŒä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥æˆ‘é€‰æ‹© 5ï¼Œå› ä¸º deletedToExist[2] = 5
    // ç„¶åæˆ‘å†æ›´æ–° deletedToExistï¼Œè®°å½• 2 -> 4 å¹¶åˆ é™¤æœ€åçš„å…ƒç´  4
    // ä»¥æ­¤ç±»æ¨ï¼Œè¿™æ ·å°±èƒ½ä¿è¯éšæœºé€‰æ‹©åˆ°ç›¸åŒçš„å…ƒç´ æ—¶ä¹Ÿèƒ½ç­‰æ¦‚ç‡åœ°è¿”å›ä¸åŒçš„å…ƒç´ 

    mt19937 rand_engine = mt19937(time(nullptr));

public:
    Solution(int m, int n) {
        this->m = m;
        this->n = n;
        this->len = m * n;
        this->deletedToExist = unordered_map<int, int>();
    }

    vector<int> flip() {
        int rand_num = rand_engine() % len;
        // è¿™ä¸ªéšæœºæ•°å¯èƒ½å·²ç»è¢«åˆ æ‰äº†ï¼ˆåˆšæ‰å·²ç»è¢«é€‰è¿‡ï¼‰
        int res = rand_num;
        if (deletedToExist.count(rand_num)) {
            res = deletedToExist[rand_num];
        }
        // æŠŠ rand ç½®æ¢åˆ°æ•°ç»„å°¾éƒ¨
        int last = len - 1;
        // å°¾éƒ¨çš„é‚£ä¸ªå…ƒç´ ä¹Ÿå¯èƒ½å·²ç»è¢«åˆ æ‰äº†
        if (deletedToExist.count(last)) {
            last = deletedToExist[last];
        }
        deletedToExist[rand_num] = last;
        // æŠŠå°¾éƒ¨çš„è¿™ä¸ªå…ƒç´ åˆ æ‰
        len--;
        // ä¸€ç»´åæ ‡è½¬åŒ–æˆäºŒç»´åæ ‡
        return {res / n, res % n};
    }

    void reset() {
        this->len = this->m * this->n;
        this->deletedToExist.clear();
    }
};
```

```go
// by chatGPT (go)
type Solution struct {
    m, n int
    // æŠ½è±¡ä¸€ç»´æ•°ç»„çš„é•¿åº¦
    len int
    // å·²åˆ é™¤å…ƒç´ åˆ°å°¾éƒ¨æœªåˆ é™¤å…ƒç´ çš„æ˜ å°„
    deletedToExist map[int]int
    // è¿™ä¸ª deletedToExist å­˜çš„åˆ°åº•æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿä¸¾ä¸ªä¾‹å­ä½ å°±æ˜ç™½äº†ï¼š
    // å‡è®¾æ•°ç»„ [1,2,3,4,5]ï¼Œæˆ‘ç¬¬ä¸€æ¬¡éšæœºé€‰æ‹©äº†å…ƒç´  2ï¼Œ
    // ç„¶åæˆ‘å°±ä¼šåœ¨ deletedToExist è®°å½•ä¸€ä¸ªæ˜ å°„ 2 -> 5ï¼Œå¹¶åˆ é™¤æœ€åçš„å…ƒç´  5
    // ç°åœ¨æ•°ç»„æ˜¯ [1,2,3,4]ï¼Œæˆ‘ç¬¬äºŒæ¬¡éšæœºé€‰æ‹©åˆé€‰åˆ°äº† 2ï¼Œ
    // ä½†ä¸èƒ½é‡å¤é€‰æ‹©åŒä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥æˆ‘é€‰æ‹© 5ï¼Œå› ä¸º deletedToExist[2] = 5
    // ç„¶åæˆ‘å†æ›´æ–° deletedToExistï¼Œè®°å½• 2 -> 4 å¹¶åˆ é™¤æœ€åçš„å…ƒç´  4
    // ä»¥æ­¤ç±»æ¨ï¼Œè¿™æ ·å°±èƒ½ä¿è¯éšæœºé€‰æ‹©åˆ°ç›¸åŒçš„å…ƒç´ æ—¶ä¹Ÿèƒ½ç­‰æ¦‚ç‡åœ°è¿”å›ä¸åŒçš„å…ƒç´ 
    random *rand.Rand
}

func Constructor(m int, n int) Solution {
    return Solution{
        m:              m,
        n:              n,
        len:            m * n,
        deletedToExist: make(map[int]int),
        random:         rand.New(rand.NewSource(time.Now().Unix())),
    }
}

func (this *Solution) Flip() []int {
    rand := this.random.Intn(this.len)
    // è¿™ä¸ªéšæœºæ•°å¯èƒ½å·²ç»è¢«åˆ æ‰äº†ï¼ˆåˆšæ‰å·²ç»è¢«é€‰è¿‡ï¼‰
    res := rand
    if val, ok := this.deletedToExist[rand]; ok {
        res = val
    }
    // æŠŠ rand ç½®æ¢åˆ°æ•°ç»„å°¾éƒ¨
    last := this.len - 1
    // å°¾éƒ¨çš„é‚£ä¸ªå…ƒç´ ä¹Ÿå¯èƒ½å·²ç»è¢«åˆ æ‰äº†
    if val, ok := this.deletedToExist[last]; ok {
        last = val
    }
    this.deletedToExist[rand] = last
    // æŠŠå°¾éƒ¨çš„è¿™ä¸ªå…ƒç´ åˆ æ‰
    this.len--
    // ä¸€ç»´åæ ‡è½¬åŒ–æˆäºŒç»´åæ ‡
    return []int{res / this.n, res % this.n}
}

func (this *Solution) Reset() {
    this.len = this.m * this.n
    this.deletedToExist = make(map[int]int)
}
```

```java
// by labuladong (java)
class Solution {

    int m, n;
    // æŠ½è±¡ä¸€ç»´æ•°ç»„çš„é•¿åº¦
    int len;
    // å·²åˆ é™¤å…ƒç´ åˆ°å°¾éƒ¨æœªåˆ é™¤å…ƒç´ çš„æ˜ å°„
    HashMap<Integer, Integer> deletedToExist;
    // è¿™ä¸ª deletedToExist å­˜çš„åˆ°åº•æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿä¸¾ä¸ªä¾‹å­ä½ å°±æ˜ç™½äº†ï¼š
    // å‡è®¾æ•°ç»„ [1,2,3,4,5]ï¼Œæˆ‘ç¬¬ä¸€æ¬¡éšæœºé€‰æ‹©äº†å…ƒç´  2ï¼Œ
    // ç„¶åæˆ‘å°±ä¼šåœ¨ deletedToExist è®°å½•ä¸€ä¸ªæ˜ å°„ 2 -> 5ï¼Œå¹¶åˆ é™¤æœ€åçš„å…ƒç´  5
    // ç°åœ¨æ•°ç»„æ˜¯ [1,2,3,4]ï¼Œæˆ‘ç¬¬äºŒæ¬¡éšæœºé€‰æ‹©åˆé€‰åˆ°äº† 2ï¼Œ
    // ä½†ä¸èƒ½é‡å¤é€‰æ‹©åŒä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥æˆ‘é€‰æ‹© 5ï¼Œå› ä¸º deletedToExist[2] = 5
    // ç„¶åæˆ‘å†æ›´æ–° deletedToExistï¼Œè®°å½• 2 -> 4 å¹¶åˆ é™¤æœ€åçš„å…ƒç´  4
    // ä»¥æ­¤ç±»æ¨ï¼Œè¿™æ ·å°±èƒ½ä¿è¯éšæœºé€‰æ‹©åˆ°ç›¸åŒçš„å…ƒç´ æ—¶ä¹Ÿèƒ½ç­‰æ¦‚ç‡åœ°è¿”å›ä¸åŒçš„å…ƒç´ 

    Random random = new Random();

    public Solution(int m, int n) {
        this.m = m;
        this.n = n;
        this.len = m * n;
        this.deletedToExist = new HashMap<>();
    }

    public int[] flip() {
        int rand = random.nextInt(len);
        // è¿™ä¸ªéšæœºæ•°å¯èƒ½å·²ç»è¢«åˆ æ‰äº†ï¼ˆåˆšæ‰å·²ç»è¢«é€‰è¿‡ï¼‰
        int res = rand;
        if (deletedToExist.containsKey(rand)) {
            res = deletedToExist.get(rand);
        }
        // æŠŠ rand ç½®æ¢åˆ°æ•°ç»„å°¾éƒ¨
        int last = len - 1;
        // å°¾éƒ¨çš„é‚£ä¸ªå…ƒç´ ä¹Ÿå¯èƒ½å·²ç»è¢«åˆ æ‰äº†
        if (deletedToExist.containsKey(last)) {
            last = deletedToExist.get(last);
        }
        deletedToExist.put(rand, last);
        // æŠŠå°¾éƒ¨çš„è¿™ä¸ªå…ƒç´ åˆ æ‰
        len--;
        // ä¸€ç»´åæ ‡è½¬åŒ–æˆäºŒç»´åæ ‡
        return new int[]{res / n, res % n};
    }

    public void reset() {
        this.len = this.m * this.n;
        this.deletedToExist.clear();
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} m
 * @param {number} n
 */
var Solution = function(m, n) {
  this.m = m;
  this.n = n;
  //æŠ½è±¡ä¸€ç»´æ•°ç»„çš„é•¿åº¦
  this.len = m * n;
  //å·²åˆ é™¤å…ƒç´ åˆ°å°¾éƒ¨æœªåˆ é™¤å…ƒç´ çš„æ˜ å°„
  this.deletedToExist = new Map();
  //è¿™ä¸ªdeletedToExistå­˜çš„åˆ°åº•æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿä¸¾ä¸ªä¾‹å­ä½ å°±æ˜ç™½äº†ï¼š
  //å‡è®¾æ•°ç»„[1,2,3,4,5]ï¼Œæˆ‘ç¬¬ä¸€æ¬¡éšæœºé€‰æ‹©äº†å…ƒç´ 2ï¼Œ
  //ç„¶åæˆ‘å°±ä¼šåœ¨deletedToExistè®°å½•ä¸€ä¸ªæ˜ å°„2->5ï¼Œå¹¶åˆ é™¤æœ€åçš„å…ƒç´ 5
  //ç°åœ¨æ•°ç»„æ˜¯[1,2,3,4]ï¼Œæˆ‘ç¬¬äºŒæ¬¡éšæœºé€‰æ‹©åˆé€‰åˆ°äº†2ï¼Œ
  //ä½†ä¸èƒ½é‡å¤é€‰æ‹©åŒä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥æˆ‘é€‰æ‹©5ï¼Œå› ä¸ºdeletedToExist[2]=5
  //ç„¶åæˆ‘å†æ›´æ–°deletedToExistï¼Œè®°å½•2->4å¹¶åˆ é™¤æœ€åçš„å…ƒç´ 4
  //ä»¥æ­¤ç±»æ¨ï¼Œè¿™æ ·å°±èƒ½ä¿è¯éšæœºé€‰æ‹©åˆ°ç›¸åŒçš„å…ƒç´ æ—¶ä¹Ÿèƒ½ç­‰æ¦‚ç‡åœ°è¿”å›ä¸åŒçš„å…ƒç´ 
  this.random = Math.random;
};

/**
 * @return {number[]}
 */
Solution.prototype.flip = function() {
  let rand = Math.floor(this.random() * this.len);
  //è¿™ä¸ªéšæœºæ•°å¯èƒ½å·²ç»è¢«åˆ æ‰äº†ï¼ˆåˆšæ‰å·²ç»è¢«é€‰è¿‡ï¼‰
  let res = rand;
  if (this.deletedToExist.has(rand)) {
    res = this.deletedToExist.get(rand);
  }
  //æŠŠrandç½®æ¢åˆ°æ•°ç»„å°¾éƒ¨
  let last = this.len - 1;
  //å°¾éƒ¨çš„é‚£ä¸ªå…ƒç´ ä¹Ÿå¯èƒ½å·²ç»è¢«åˆ æ‰äº†
  if (this.deletedToExist.has(last)) {
    last = this.deletedToExist.get(last);
  }
  this.deletedToExist.set(rand, last);
  //æŠŠå°¾éƒ¨çš„è¿™ä¸ªå…ƒç´ åˆ æ‰
  this.len--;
  //ä¸€ç»´åæ ‡è½¬åŒ–æˆäºŒç»´åæ ‡
  return [Math.floor(res / this.n), res % this.n];
};

Solution.prototype.reset = function() {
  this.len = this.m * this.n;
  this.deletedToExist.clear();
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self, m: int, n: int):
        self.m = m  # çŸ©é˜µçš„è¡Œæ•°
        self.n = n  # çŸ©é˜µçš„åˆ—æ•°
        self.len = m * n  # æŠ½è±¡ä¸€ç»´æ•°ç»„çš„é•¿åº¦
        # å·²åˆ é™¤å…ƒç´ åˆ°å°¾éƒ¨æœªåˆ é™¤å…ƒç´ çš„æ˜ å°„
        self.deletedToExist = {}

    def flip(self) -> List[int]:
        rand = random.randint(0, self.len - 1)  # éšæœºé€‰æ‹©ä¸€ä¸ªå…ƒç´ 
        res = rand
        # è¿™ä¸ªéšæœºæ•°å¯èƒ½å·²ç»è¢«åˆ æ‰äº†ï¼ˆåˆšæ‰å·²ç»è¢«é€‰è¿‡ï¼‰
        if rand in self.deletedToExist:
            res = self.deletedToExist[rand]
        # æŠŠéšæœºé€‰æ‹©çš„å…ƒç´ ç½®æ¢åˆ°æ•°ç»„å°¾éƒ¨
        last = self.len - 1
        # å°¾éƒ¨çš„é‚£ä¸ªå…ƒç´ ä¹Ÿå¯èƒ½å·²ç»è¢«åˆ æ‰äº†
        if last in self.deletedToExist:
            last = self.deletedToExist[last]
        self.deletedToExist[rand] = last
        # æŠŠå°¾éƒ¨çš„å…ƒç´ æ ‡è®°ä¸ºå·²åˆ é™¤
        self.len -= 1
        # è¿”å›ä¸€ç»´æ•°ç»„ä¸­ç´¢å¼•ä¸º res çš„å…ƒç´ çš„äºŒç»´åæ ‡
        return [res // self.n, res % self.n]

    def reset(self) -> None:
        self.len = self.m * self.n  # é‡ç½®æŠ½è±¡ä¸€ç»´æ•°ç»„çš„é•¿åº¦
        self.deletedToExist.clear()  # æ¸…ç©ºå·²åˆ é™¤å…ƒç´ åˆ°å°¾éƒ¨æœªåˆ é™¤å…ƒç´ çš„æ˜ å°„
```

https://leetcode.cn/problems/random-flip-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/random-pick-index çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
private:
    vector<int> nums;
public:
    Solution(vector<int>& nums) {
        this->nums = nums;
    }
    
    int pick(int target) {
        int count = 0, res = -1;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] != target) {
                continue;
            }
            count++;
            if (rand() % count == 0) {
                res = i;
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
// Constructor function that receives a nums array and returns a solution struct
func Constructor(nums []int) Solution {
    randSource := rand.NewSource(time.Now().UnixNano())
    randGen := rand.New(randSource)
    return Solution{nums, randGen}
}

// Pick function receives a target value and returns the index of the element in the nums array
func Pick(s *Solution, target int) int {
    count := 0
    res := -1
    for i := 0; i < len(s.nums); i++ {
        if s.nums[i] != target {
            continue
        }
        count++
        if s.rand.Intn(count) == 0 {
            res = i
        }
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    int[] nums;
    Random rand;

    public Solution(int[] nums) {
        this.nums = nums;
        this.rand = new Random();
    }

    public int pick(int target) {
        int count = 0, res = -1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != target) {
                continue;
            }
            count++;
            if (rand.nextInt(count) == 0) {
                res = i;
            }
        }

        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 */
var Solution = function(nums) {
    this.nums = nums;
    this.rand = new Random();
};

/**
 * @param {number} target
 * @return {number}
 */
Solution.prototype.pick = function(target) {
    let count = 0;
    let res = -1;
    for (let i = 0; i < this.nums.length; i++) {
        if (this.nums[i] !== target) {
            continue;
        }
        count++;
        if (this.rand.nextInt(count) === 0) {
            res = i;
        }
    }
    return res;
};
```

```python
# by chatGPT (python)
import random

class Solution:
    def __init__(self, nums: List[int]):
        self.nums = nums
        self.rand = random.Random()

    def pick(self, target: int) -> int:
        count, res = 0, -1
        for i in range(len(self.nums)):
            if self.nums[i] != target:
                continue
            count += 1
            if self.rand.randint(1, count) == 1:
                res = i
        return res
```

https://leetcode.cn/problems/random-pick-index çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/random-pick-with-blacklist çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
public:
    int sz;
    unordered_map<int, int> mapping;

    Solution(int N, vector<int>& blacklist) {
        sz = N - blacklist.size();
        for (int b : blacklist) {
            mapping[b] = 666;
        }

        int last = N - 1;
        for (int b : blacklist) {
            // å¦‚æœ b å·²ç»åœ¨åŒºé—´ [sz, N)
            // å¯ä»¥ç›´æ¥å¿½ç•¥
            if (b >= sz) {
                continue;
            }
            while (mapping.count(last)) {
                last--;
            }
            mapping[b] = last;
            last--;
        }
    }

    int pick() {
        // éšæœºé€‰å–ä¸€ä¸ªç´¢å¼•
        int index = rand() % sz;
        // è¿™ä¸ªç´¢å¼•å‘½ä¸­äº†é»‘åå•ï¼Œ
        // éœ€è¦è¢«æ˜ å°„åˆ°å…¶ä»–ä½ç½®
        if (mapping.count(index)) {
            return mapping[index];
        }
        // è‹¥æ²¡å‘½ä¸­é»‘åå•ï¼Œåˆ™ç›´æ¥è¿”å›
        return index;
    }
};
```

```go
// by chatGPT (go)
type Solution struct {
    sz      int
    mapping map[int]int
}

// æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–é»‘åå•æ˜ å°„è¡¨
// N: [0, N) ä¸­çš„æ•°å­—
// blacklist: é»‘åå•ä¸­çš„æ•°å­—
func Constructor(N int, blacklist []int) Solution {
    s := Solution{}
    s.sz = N - len(blacklist)
    s.mapping = make(map[int]int)

    for _, b := range blacklist {
        s.mapping[b] = 666
    }

    last := N - 1
    for _, b := range blacklist {
        // å·²ç»åœ¨åŒºé—´ [sz, N) çš„æ•°å­—å¯ä»¥ç›´æ¥å¿½ç•¥
        if b >= s.sz {
            continue
        }
        // æ‰¾åˆ°å¯ä»¥æ˜ å°„åˆ°bçš„å€¼
        for _, ok := s.mapping[last]; ok; _, ok = s.mapping[last] {
            last--
        }
        s.mapping[b] = last
        last--
    }

    return s
}

// ä»é›†åˆä¸­éšæœºé€‰æ‹©ä¸€ä¸ªä¸åœ¨é»‘åå•ä¸­çš„æ•°å­—
func (this *Solution) Pick() int {
    index := rand.Intn(this.sz)
    if val, ok := this.mapping[index]; ok {
        return val
    }
    return index
}
```

```java
// by chatGPT (java)
class Solution {
    int sz;
    Map<Integer, Integer> mapping;

    public Solution(int N, int[] blacklist) {
        sz = N - blacklist.length;
        mapping = new HashMap<>();

        for (int b : blacklist) {
            mapping.put(b, 666); // æ ‡è®°é»‘åå•
        }

        int last = N - 1;
        for (int b : blacklist) {
            // å¦‚æœ b å·²ç»åœ¨åŒºé—´ [sz, N)ï¼Œå¯ä»¥ç›´æ¥å¿½ç•¥
            if (b >= sz) {
                continue;
            }
            while (mapping.containsKey(last)) { // æ‰¾åˆ°å¯ä»¥æ˜ å°„çš„ä½ç½®
                last--;
            }
            mapping.put(b, last); // æ˜ å°„
            last--;
        }
    }

    public int pick() {
        // éšæœºé€‰å–ä¸€ä¸ªç´¢å¼•
        int index = (int)(Math.random() * sz);
        // è¿™ä¸ªç´¢å¼•å‘½ä¸­äº†é»‘åå•ï¼Œéœ€è¦è¢«æ˜ å°„åˆ°å…¶ä»–ä½ç½®
        if (mapping.containsKey(index)) {
            return mapping.get(index);
        }
        // è‹¥æ²¡å‘½ä¸­é»‘åå•ï¼Œåˆ™ç›´æ¥è¿”å›
        return index;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} N
 * @param {number[]} blacklist
 */
var Solution = function(N, blacklist) {
   // æ±‚å‡ºç™½åå•çš„é•¿åº¦ 
   this.sz = N - blacklist.length;
   // åˆ›å»ºä¸€ä¸ªå­—å…¸ï¼Œç”¨äºå¿«é€ŸæŸ¥æ‰¾é»‘åå•ä¸­çš„å…ƒç´ 
   this.mapping = {};
   // å°†æ‰€æœ‰é»‘åå•ä¸­çš„å…ƒç´ æ ‡è®°ä¸º 666
   blacklist.forEach((b) => {
      this.mapping[b] = 666;
   });
   // éå†é»‘åå•ä¸­çš„å…ƒç´ ï¼Œä¸ºä¹‹ç»™å®šä¸€ä¸ªæ–°çš„ä½ç½®
   let last = N - 1;
   // æ³¨æ„éå†çš„é¡ºåºï¼Œéœ€è¦å°†æœ€åçš„é»‘åå•å°½é‡æ˜ å°„åˆ°ç™½åå•å‰é¢çš„ä½ç½®
   blacklist.forEach((b) => {
      // å¦‚æœè¯¥é»‘åå•å…ƒç´ å·²ç»åœ¨ç™½åå•çš„èŒƒå›´å†…äº†ï¼Œåˆ™ä¸éœ€è¦è¿›è¡Œæ˜ å°„
      if (b >= this.sz) {
         return;
      }
      // æ‰¾åˆ°è¿˜æœªè¢«æ˜ å°„çš„æœ€å¤§çš„ä½ç½®
      while (this.mapping.hasOwnProperty(last)) {
         last--;
      }
      // ä¸ºå½“å‰é»‘åå•å…ƒç´  b æŒ‡å®šä¸€ä¸ªæ–°çš„ä½ç½®
      this.mapping[b] = last;
      last--;
   });
};

/**
 * @return {number}
 */
Solution.prototype.pick = function() {
   // éšæœºé€‰å–ä¸€ä¸ªç´¢å¼•å€¼
   let index = Math.floor(Math.random() * this.sz);
   // å¦‚æœè¯¥ç´¢å¼•ä½æ˜¯é»‘åå•ä¸­çš„å…ƒç´ ï¼Œåˆ™å°†å…¶æ˜ å°„åˆ°æ–°çš„ä½ç½®ä¸Š
   if (this.mapping.hasOwnProperty(index)) {
      return this.mapping[index];
   }
   // å¦åˆ™ç›´æ¥è¿”å›è¯¥ç´¢å¼•å€¼
   return index;
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self, N: int, blacklist: List[int]):
        # éœ€è¦è¿”å›çš„æ•°å­—èŒƒå›´ä¸º[0, sz)
        self.sz = N - len(blacklist)
        # å°†é»‘åå•ä¸­çš„æ•°å­—æ˜ å°„åˆ°666ï¼Œå³é¿å…é€‰ä¸­
        self.mapping = {}
        for b in blacklist:
            self.mapping[b] = 666
        
        # å¯¹äºé»‘åå•ä¸­çš„æ•°å­—ï¼Œå¦‚æœå…¶åœ¨[0, sz)èŒƒå›´å†…ï¼Œ
        # ä¸”ä¸åœ¨mappingä¸­ï¼Œå¯¹å…¶è¿›è¡Œé‡æ–°æ˜ å°„
        last = N - 1
        for b in blacklist:
            if b >= self.sz:
                continue
            # åœ¨æ˜ å°„ä¸­æŸ¥æ‰¾ä¸åœ¨é»‘åå•ä¸­ï¼Œä¸”å°äºNçš„æœ€å¤§çš„æ•°last
            while last in self.mapping:
                last -= 1
            # å°†bæ˜ å°„åˆ°last
            self.mapping[b] = last
            last -= 1

    def pick(self) -> int:
        # éšæœºé€‰æ‹©ä¸€ä¸ªæ•°å­—
        index = random.randint(0, self.sz-1)
        # å¦‚æœæ‰€é€‰æ•°å­—åœ¨æ˜ å°„ä¸­ï¼Œè¿”å›å…¶æ˜ å°„å€¼
        if index in self.mapping:
            return self.mapping[index]
        # å¦‚æœæ‰€é€‰æ•°å­—ä¸åœ¨æ˜ å°„ä¸­ï¼Œç›´æ¥è¿”å›
        return index
```

https://leetcode.cn/problems/random-pick-with-blacklist çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/range-addition çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> getModifiedArray(int length, vector<vector<int>>& updates) {
        // nums åˆå§‹åŒ–ä¸ºå…¨ 0
        vector<int> nums(length, 0);
        // æ„é€ å·®åˆ†è§£æ³•
        Difference df(nums);
        for (auto update : updates) {
            int i = update[0];
            int j = update[1];
            int val = update[2];
            df.increment(i, j, val);
        }
        return df.result();
    }

    class Difference {
    private:
        // å·®åˆ†æ•°ç»„
        vector<int> diff;

    public:
        Difference(vector<int>& nums) {
            assert(nums.size() > 0);
            diff.resize(nums.size());
            // æ„é€ å·®åˆ†æ•°ç»„
            diff[0] = nums[0];
            for (int i = 1; i < nums.size(); i++) {
                diff[i] = nums[i] - nums[i - 1];
            }
        }

        /* ç»™é—­åŒºé—´ [i, j] å¢åŠ  valï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰*/
        void increment(int i, int j, int val) {
            diff[i] += val;
            if (j + 1 < diff.size()) {
                diff[j + 1] -= val;
            }
        }

        vector<int> result() {
            vector<int> res(diff.size());
            // æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
            res[0] = diff[0];
            for (int i = 1; i < diff.size(); i++) {
                res[i] = res[i - 1] + diff[i];
            }
            return res;
        }
    };
};
```

```go
// by chatGPT (go)
func getModifiedArray(length int, updates [][]int) []int {
    // nums åˆå§‹åŒ–ä¸ºå…¨ 0
    var nums = make([]int, length)

    // æ„é€ å·®åˆ†è§£æ³•
    df := Difference{nums}
    for _, update := range updates {
        i := update[0]
        j := update[1]
        val := update[2]
        df.increment(i, j, val)
    }
    return df.result()
}

type Difference struct {
    // å·®åˆ†æ•°ç»„
    diff []int
}

func (df *Difference) increment(i, j, val int) {
    df.diff[i] += val
    if j+1 < len(df.diff) {
        df.diff[j+1] -= val
    }
}

func (df *Difference) result() []int {
    res := make([]int, len(df.diff))
    // æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
    res[0] = df.diff[0]
    for i := 1; i < len(df.diff); i++ {
        res[i] = res[i-1] + df.diff[i]
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int[] getModifiedArray(int length, int[][] updates) {
        // nums åˆå§‹åŒ–ä¸ºå…¨ 0
        int[] nums = new int[length];
        // æ„é€ å·®åˆ†è§£æ³•
        Difference df = new Difference(nums);
        for (int[] update : updates) {
            int i = update[0];
            int j = update[1];
            int val = update[2];
            df.increment(i, j, val);
        }
        return df.result();
    }

    class Difference {
        // å·®åˆ†æ•°ç»„
        private int[] diff;

        public Difference(int[] nums) {
            assert nums.length > 0;
            diff = new int[nums.length];
            // æ„é€ å·®åˆ†æ•°ç»„
            diff[0] = nums[0];
            for (int i = 1; i < nums.length; i++) {
                diff[i] = nums[i] - nums[i - 1];
            }
        }

        /* ç»™é—­åŒºé—´ [i, j] å¢åŠ  valï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰*/
        public void increment(int i, int j, int val) {
            diff[i] += val;
            if (j + 1 < diff.length) {
                diff[j + 1] -= val;
            }
        }

        public int[] result() {
            int[] res = new int[diff.length];
            // æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
            res[0] = diff[0];
            for (int i = 1; i < diff.length; i++) {
                res[i] = res[i - 1] + diff[i];
            }
            return res;
        }
    }

}
```

```javascript
// by chatGPT (javascript)
var getModifiedArray = function(length, updates) {
    // nums åˆå§‹åŒ–ä¸ºå…¨ 0
    var nums = new Array(length);
    nums.fill(0);
    // æ„é€ å·®åˆ†è§£æ³•
    var df = new Difference(nums);
    for (var k = 0; k < updates.length; k++) {
        var i = updates[k][0];
        var j = updates[k][1];
        var val = updates[k][2];
        df.increment(i, j, val);
    }
    return df.result();
};

var Difference = function(nums) {
    // å·®åˆ†æ•°ç»„
    var diff = [];
    if (nums.length > 0) {
        // æ„é€ å·®åˆ†æ•°ç»„
        diff[0] = nums[0];
        for (var i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }

    /* ç»™é—­åŒºé—´ [i, j] å¢åŠ  valï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰*/
    this.increment = function(i, j, val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
        }
    }

    this.result = function() {
        var res = new Array(diff.length);
        // æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
        res[0] = diff[0];
        for (var i = 1; i < diff.length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def getModifiedArray(self, length: int, updates: List[List[int]]) -> List[int]:
        # nums åˆå§‹åŒ–ä¸ºå…¨ 0
        nums = [0]*length 
        # æ„é€ å·®åˆ†è§£æ³•
        df = Difference(nums)
        for update in updates:
            i = update[0]
            j = update[1]
            val = update[2]
            df.increment(i, j, val)
        return df.result()

    class Difference:
        # å·®åˆ†æ•°ç»„
        def __init__(self, nums: List[int]):
            assert len(nums) > 0
            self.diff = [0]*len(nums)
            # æ„é€ å·®åˆ†æ•°ç»„
            self.diff[0] = nums[0]
            for i in range(1, len(nums)):
                self.diff[i] = nums[i] - nums[i - 1]

        # ç»™é—­åŒºé—´ [i, j] å¢åŠ  valï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰
        def increment(self, i: int, j: int, val: int) -> None:
            self.diff[i] += val
            if j + 1 < len(self.diff):
                self.diff[j + 1] -= val
     
        def result(self) -> List[int]:
            res = [0]*len(self.diff)
            # æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
            res[0] = self.diff[0]
            for i in range(1, len(self.diff)):
                res[i] = res[i - 1] + self.diff[i]
            return res
```

https://leetcode.cn/problems/range-addition çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/range-sum-query-2d-immutable çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class NumMatrix {
private:
    // preSum[i][j] è®°å½•çŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
    vector<vector<int>> preSum;

public:
    NumMatrix(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        if (m == 0 || n == 0) return;
        // æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
        preSum = vector<vector<int>>(m + 1, vector<int>(n + 1, 0));
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];
            }
        }
    }

    // è®¡ç®—å­çŸ©é˜µ [x1, y1, x2, y2] çš„å…ƒç´ å’Œ
    int sumRegion(int x1, int y1, int x2, int y2) {
        // ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
        return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];
    }
};
```

```go
// by chatGPT (go)
type NumMatrix struct {
    // preSum[i][j] è®°å½•çŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
    preSum [][]int
}

func Constructor(matrix [][]int) NumMatrix {
    m, n := len(matrix), len(matrix[0])
    if m == 0 || n == 0 {
        return NumMatrix{}
    }
    // æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
    preSum := make([][]int, m+1)
    for i := 0; i <= m; i++ {
        preSum[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            // è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
            preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i-1][j-1] - preSum[i-1][j-1]
        }
    }
    return NumMatrix{preSum: preSum}
}

func (this *NumMatrix) SumRegion(x1 int, y1 int, x2 int, y2 int) int {
    // ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
    return this.preSum[x2+1][y2+1] - this.preSum[x1][y2+1] - this.preSum[x2+1][y1] + this.preSum[x1][y1]
}
```

```java
// by labuladong (java)
class NumMatrix {
    // preSum[i][j] è®°å½•çŸ©é˜µ [0, 0, i-1, j-1] çš„å…ƒç´ å’Œ
    private int[][] preSum;

    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        if (m == 0 || n == 0) return;
        // æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
        preSum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];
            }
        }
    }

    // è®¡ç®—å­çŸ©é˜µ [x1, y1, x2, y2] çš„å…ƒç´ å’Œ
    public int sumRegion(int x1, int y1, int x2, int y2) {
        // ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
        return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} matrix çŸ©é˜µ
 */
var NumMatrix = function(matrix) {
  const m = matrix.length, n = matrix[0].length;
  if (m == 0 || n == 0) return;
  // preSum[i][j] è®°å½•çŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
  this.preSum = new Array(m + 1).fill().map(() => new Array(n + 1).fill(0));
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      // è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
      this.preSum[i][j] = this.preSum[i - 1][j] + this.preSum[i][j - 1] + matrix[i - 1][j - 1] - this.preSum[i - 1][j - 1];
    }
  }
};

/**
 * @param {number} x1 å­çŸ©é˜µå·¦ä¸Šè§’åæ ‡x
 * @param {number} y1 å­çŸ©é˜µå·¦ä¸Šè§’åæ ‡y
 * @param {number} x2 å­çŸ©é˜µå³ä¸‹è§’åæ ‡x
 * @param {number} y2 å­çŸ©é˜µå³ä¸‹è§’åæ ‡y
 * @return {number} å­çŸ©é˜µå…ƒç´ å’Œ
 */
NumMatrix.prototype.sumRegion = function(x1, y1, x2, y2) {
  // ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
  return this.preSum[x2 + 1][y2 + 1] - this.preSum[x1][y2 + 1] - this.preSum[x2 + 1][y1] + this.preSum[x1][y1];
};
```

```python
# by chatGPT (python)
class NumMatrix:
    # preSum[i][j] è®°å½•çŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
    def __init__(self, matrix: List[List[int]]):
        m, n = len(matrix), len(matrix[0])
        if m == 0 or n == 0:
            return
        # æ„é€ å‰ç¼€å’ŒçŸ©é˜µ
        self.preSum = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # è®¡ç®—æ¯ä¸ªçŸ©é˜µ [0, 0, i, j] çš„å…ƒç´ å’Œ
                self.preSum[i][j] = self.preSum[i - 1][j] + self.preSum[i][j - 1] + matrix[i - 1][j - 1] - self.preSum[i - 1][j - 1]

    # è®¡ç®—å­çŸ©é˜µ [x1, y1, x2, y2] çš„å…ƒç´ å’Œ
    def sumRegion(self, x1: int, y1: int, x2: int, y2: int) -> int:
        # ç›®æ ‡çŸ©é˜µä¹‹å’Œç”±å››ä¸ªç›¸é‚»çŸ©é˜µè¿ç®—è·å¾—
        return self.preSum[x2 + 1][y2 + 1] - self.preSum[x1][y2 + 1] - self.preSum[x2 + 1][y1] + self.preSum[x1][y1]
```

https://leetcode.cn/problems/range-sum-query-2d-immutable çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/range-sum-query-immutable çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class NumArray {
    // å‰ç¼€å’Œæ•°ç»„
private:
    vector<int> preSum;

public:
    /* è¾“å…¥ä¸€ä¸ªæ•°ç»„ï¼Œæ„é€ å‰ç¼€å’Œ */
    NumArray(vector<int>& nums) {
        // preSum[0] = 0ï¼Œä¾¿äºè®¡ç®—ç´¯åŠ å’Œ
        preSum.resize(nums.size() + 1);
        // è®¡ç®— nums çš„ç´¯åŠ å’Œ
        for (int i = 1; i < preSum.size(); i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
    }

    /* æŸ¥è¯¢é—­åŒºé—´ [left, right] çš„ç´¯åŠ å’Œ */
    int sumRange(int left, int right) {
        return preSum[right + 1] - preSum[left];
    }
};
```

```go
// by chatGPT (go)
type NumArray struct {
    preSum []int
}

/* è¾“å…¥ä¸€ä¸ªæ•°ç»„ï¼Œæ„é€ å‰ç¼€å’Œ */
func Constructor(nums []int) NumArray {
    // preSum[0] = 0ï¼Œä¾¿äºè®¡ç®—ç´¯åŠ å’Œ
    preSum := make([]int, len(nums)+1)
    // è®¡ç®— nums çš„ç´¯åŠ å’Œ
    for i := 1; i < len(preSum); i++ {
        preSum[i] = preSum[i-1] + nums[i-1]
    }
    return NumArray{preSum}
}

/* æŸ¥è¯¢é—­åŒºé—´ [left, right] çš„ç´¯åŠ å’Œ */
func (this *NumArray) SumRange(left int, right int) int {
    return this.preSum[right+1] - this.preSum[left]
}
```

```java
// by labuladong (java)
class NumArray {
    // å‰ç¼€å’Œæ•°ç»„
    private int[] preSum;

    /* è¾“å…¥ä¸€ä¸ªæ•°ç»„ï¼Œæ„é€ å‰ç¼€å’Œ */
    public NumArray(int[] nums) {
        // preSum[0] = 0ï¼Œä¾¿äºè®¡ç®—ç´¯åŠ å’Œ
        preSum = new int[nums.length + 1];
        // è®¡ç®— nums çš„ç´¯åŠ å’Œ
        for (int i = 1; i < preSum.length; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
    }

    /* æŸ¥è¯¢é—­åŒºé—´ [left, right] çš„ç´¯åŠ å’Œ */
    public int sumRange(int left, int right) {
        return preSum[right + 1] - preSum[left];
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    // å‰ç¼€å’Œæ•°ç»„
    this.preSum = [];
    // preSum[0] = 0ï¼Œä¾¿äºè®¡ç®—ç´¯åŠ å’Œ
    this.preSum[0] = 0;
    // è®¡ç®— nums çš„ç´¯åŠ å’Œ
    for (let i = 1; i <= nums.length; i++) {
        this.preSum[i] = this.preSum[i - 1] + nums[i - 1];
    }
};

/** 
 * @param {number} left
 * @param {number} right
 * @return {number}
 */
NumArray.prototype.sumRange = function(left, right) {
    return this.preSum[right + 1] - this.preSum[left];
};
```

```python
# by chatGPT (python)
class NumArray:
    # å‰ç¼€å’Œæ•°ç»„
    def __init__(self, nums: List[int]):
        self.preSum = [0] * (len(nums) + 1)
        for i in range(1, len(self.preSum)):
            self.preSum[i] = self.preSum[i - 1] + nums[i - 1]
    
    # æŸ¥è¯¢é—­åŒºé—´ [left, right] çš„ç´¯åŠ å’Œ
    def sumRange(self, left: int, right: int) -> int:
        return self.preSum[right + 1] - self.preSum[left]
```

https://leetcode.cn/problems/range-sum-query-immutable çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/regular-expression-matching çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    // å¤‡å¿˜å½•
    vector<vector<int>> memo;

    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        memo = vector<vector<int>>(m, vector<int>(n, -1));
        // æŒ‡é’ˆ iï¼Œj ä»ç´¢å¼• 0 å¼€å§‹ç§»åŠ¨
        return dp(s, 0, p, 0);
    }

    /* è®¡ç®— p[j..] æ˜¯å¦åŒ¹é… s[i..] */
    bool dp(string& s, int i, string& p, int j) {
        int m = s.size(), n = p.size();
        // base case
        if (j == n) {
            return i == m;
        }
        if (i == m) {
            if ((n - j) % 2 == 1) {
                return false;
            }
            for (; j + 1 < n; j += 2) {
                if (p[j + 1] != '*') {
                    return false;
                }
            }
            return true;
        }

        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[i][j] != -1) {
            return memo[i][j];
        }

        bool res = false;

        if (s[i] == p[j] || p[j] == '.') {
            if (j < n - 1 && p[j + 1] == '*') {
                res = dp(s, i, p, j + 2)
                        || dp(s, i + 1, p, j);
            } else {
                res = dp(s, i + 1, p, j + 1);
            }
        } else {
            if (j < n - 1 && p[j + 1] == '*') {
                res = dp(s, i, p, j + 2);
            } else {
                res = false;
            }
        }
        // å°†å½“å‰ç»“æœè®°å…¥å¤‡å¿˜å½•
        memo[i][j] = res;
        return res;
    }
};
```

```go
// by chatGPT (go)
func isMatch(s string, p string) bool {
    // å¤‡å¿˜å½•
    memo := make([][]int, len(s))
    for i := range memo {
        memo[i] = make([]int, len(p))
        for j := range memo[i] {
            memo[i][j] = -1
        }
    }
    // æŒ‡é’ˆ iï¼Œj ä»ç´¢å¼• 0 å¼€å§‹ç§»åŠ¨
    return dp(s, 0, p, 0, memo)
}

/* è®¡ç®— p[j..] æ˜¯å¦åŒ¹é… s[i..] */
func dp(s string, i int, p string, j int, memo [][]int) bool {
    m, n := len(s), len(p)
    // base case
    if j == n {
        return i == m
    }
    if i == m {
        if (n-j)%2 == 1 {
            return false
        }
        for ; j+1 < n; j += 2 {
            if p[j+1] != '*' {
                return false
            }
        }
        return true
    }

    // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
    if memo[i][j] != -1 {
        return memo[i][j] == 1
    }

    var res bool

    if s[i] == p[j] || p[j] == '.' {
        if j < n-1 && p[j+1] == '*' {
            res = dp(s, i, p, j+2, memo) || dp(s, i+1, p, j, memo)
        } else {
            res = dp(s, i+1, p, j+1, memo)
        }
    } else {
        if j < n-1 && p[j+1] == '*' {
            res = dp(s, i, p, j+2, memo)
        } else {
            res = false
        }
    }
    // å°†å½“å‰ç»“æœè®°å…¥å¤‡å¿˜å½•
    memo[i][j] = 0
    if res {
        memo[i][j] = 1
    }
    return res
}
```

```java
// by chatGPT (java)
class Solution {
    // å¤‡å¿˜å½•
    int[][] memo;

    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        memo = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(memo[i], -1);
        }
        // æŒ‡é’ˆ iï¼Œj ä»ç´¢å¼• 0 å¼€å§‹ç§»åŠ¨
        return dp(s, 0, p, 0);
    }

    /* è®¡ç®— p[j..] æ˜¯å¦åŒ¹é… s[i..] */
    private boolean dp(String s, int i, String p, int j) {
        int m = s.length(), n = p.length();
        // base case
        if (j == n) {
            return i == m;
        }
        if (i == m) {
            if ((n - j) % 2 == 1) {
                return false;
            }
            for (; j + 1 < n; j += 2) {
                if (p.charAt(j + 1) != '*') {
                    return false;
                }
            }
            return true;
        }

        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[i][j] != -1) {
            return memo[i][j] == 1;
        }

        boolean res = false;

        if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') {
            if (j < n - 1 && p.charAt(j + 1) == '*') {
                res = dp(s, i, p, j + 2)
                        || dp(s, i + 1, p, j);
            } else {
                res = dp(s, i + 1, p, j + 1);
            }
        } else {
            if (j < n - 1 && p.charAt(j + 1) == '*') {
                res = dp(s, i, p, j + 2);
            } else {
                res = false;
            }
        }
        // å°†å½“å‰ç»“æœè®°å…¥å¤‡å¿˜å½•
        memo[i][j] = res ? 1 : 0;
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var isMatch = function(s, p) {
    let m = s.length, n = p.length;
    // å¤‡å¿˜å½•
    let memo = new Array(m + 1);
    for (let i = 0; i < memo.length; i++) {
        memo[i] = new Array(n + 1).fill(-1);
    }

    return dp(0, 0);

    /* è®¡ç®— p[j..] æ˜¯å¦åŒ¹é… s[i..] */
    function dp(i, j) {
        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[i][j] !== -1) {
            return memo[i][j];
        }
        let res = false;
        // base case
        if (j === n) {
            res = i === m;
        } else {
            let firstMatch = i < m && (p[j] === s[i] || p[j] === '.');
            if (j + 1 < n && p[j + 1] === '*') {
                res = dp(i, j + 2) || (firstMatch && dp(i + 1, j));
            } else {
                res = firstMatch && dp(i + 1, j + 1);
            }
        }
        // å°†å½“å‰ç»“æœè®°å…¥å¤‡å¿˜å½•
        memo[i][j] = res;
        return res;
    }
};
```

```python
# by chatGPT (python)
class Solution:
    # å¤‡å¿˜å½•
    memo = []

    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)
        self.memo = [[-1] * n for _ in range(m)]
        # æŒ‡é’ˆ iï¼Œj ä»ç´¢å¼• 0 å¼€å§‹ç§»åŠ¨
        return self.dp(s, 0, p, 0)

    # è®¡ç®— p[j..] æ˜¯å¦åŒ¹é… s[i..]
    def dp(self, s: str, i: int, p: str, j: int) -> bool:
        m, n = len(s), len(p)
        # base case
        if j == n:
            return i == m
        if i == m:
            if (n - j) % 2 == 1:
                return False
            for k in range(j + 1, n, 2):
                if p[k] != '*':
                    return False
            return True

        # æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if self.memo[i][j] != -1:
            return self.memo[i][j]

        res = False

        if s[i] == p[j] or p[j] == '.':
            if j < n - 1 and p[j + 1] == '*':
                res = self.dp(s, i, p, j + 2) or self.dp(s, i + 1, p, j)
            else:
                res = self.dp(s, i + 1, p, j + 1)
        else:
            if j < n - 1 and p[j + 1] == '*':
                res = self.dp(s, i, p, j + 2)
            else:
                res = False
        # å°†å½“å‰ç»“æœè®°å…¥å¤‡å¿˜å½•
        self.memo[i][j] = res
        return res
```

https://leetcode.cn/problems/regular-expression-matching çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/remove-covered-intervals çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int removeCoveredIntervals(vector<vector<int>>& intervals) {
        // æŒ‰ç…§èµ·ç‚¹å‡åºæ’åˆ—ï¼Œèµ·ç‚¹ç›¸åŒæ—¶é™åºæ’åˆ—
        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b) {
            if (a[0] == b[0]) {
                return b[1] < a[1];
            }
            return a[0] < b[0];
        });

        // è®°å½•åˆå¹¶åŒºé—´çš„èµ·ç‚¹å’Œç»ˆç‚¹
        int left = intervals[0][0];
        int right = intervals[0][1];

        int res = 0;
        for (int i = 1; i < intervals.size(); i++) {
            vector<int>& intv = intervals[i];
            // æƒ…å†µä¸€ï¼Œæ‰¾åˆ°è¦†ç›–åŒºé—´
            if (left <= intv[0] && right >= intv[1]) {
                res++;
            }
            // æƒ…å†µäºŒï¼Œæ‰¾åˆ°ç›¸äº¤åŒºé—´ï¼Œåˆå¹¶
            if (right >= intv[0] && right <= intv[1]) {
                right = intv[1];
            }
            // æƒ…å†µä¸‰ï¼Œå®Œå…¨ä¸ç›¸äº¤ï¼Œæ›´æ–°èµ·ç‚¹å’Œç»ˆç‚¹
            if (right < intv[0]) {
                left = intv[0];
                right = intv[1];
            }
        }

        return intervals.size() - res;
    }
};
```

```go
// by chatGPT (go)
import "sort"

func removeCoveredIntervals(intervals [][]int) int {
    // æŒ‰ç…§èµ·ç‚¹å‡åºæ’åˆ—ï¼Œèµ·ç‚¹ç›¸åŒæ—¶é™åºæ’åˆ—
    sort.Slice(intervals, func(i, j int) bool {
        if intervals[i][0] == intervals[j][0] {
            return intervals[j][1] < intervals[i][1]
        } 
        return intervals[i][0] < intervals[j][0]
    })

    // è®°å½•åˆå¹¶åŒºé—´çš„èµ·ç‚¹å’Œç»ˆç‚¹
    left, right := intervals[0][0], intervals[0][1]

    res := 0
    for i := 1; i < len(intervals); i++ {
        intv := intervals[i]
        // æƒ…å†µä¸€ï¼Œæ‰¾åˆ°è¦†ç›–åŒºé—´
        if left <= intv[0] && right >= intv[1] {
            res++
        }
        // æƒ…å†µäºŒï¼Œæ‰¾åˆ°ç›¸äº¤åŒºé—´ï¼Œåˆå¹¶
        if right >= intv[0] && right <= intv[1] {
            right = intv[1]
        }
        // æƒ…å†µä¸‰ï¼Œå®Œå…¨ä¸ç›¸äº¤ï¼Œæ›´æ–°èµ·ç‚¹å’Œç»ˆç‚¹
        if right < intv[0] {
            left, right = intv[0], intv[1]
        }
    }

    return len(intervals) - res
}
```

```java
// by labuladong (java)
class Solution {
    public int removeCoveredIntervals(int[][] intervals) {
        // æŒ‰ç…§èµ·ç‚¹å‡åºæ’åˆ—ï¼Œèµ·ç‚¹ç›¸åŒæ—¶é™åºæ’åˆ—
        Arrays.sort(intervals, (a, b) -> {
            if (a[0] == b[0]) {
                return b[1] - a[1];
            }
            return a[0] - b[0];
        });

        // è®°å½•åˆå¹¶åŒºé—´çš„èµ·ç‚¹å’Œç»ˆç‚¹
        int left = intervals[0][0];
        int right = intervals[0][1];

        int res = 0;
        for (int i = 1; i < intervals.length; i++) {
            int[] intv = intervals[i];
            // æƒ…å†µä¸€ï¼Œæ‰¾åˆ°è¦†ç›–åŒºé—´
            if (left <= intv[0] && right >= intv[1]) {
                res++;
            }
            // æƒ…å†µäºŒï¼Œæ‰¾åˆ°ç›¸äº¤åŒºé—´ï¼Œåˆå¹¶
            if (right >= intv[0] && right <= intv[1]) {
                right = intv[1];
            }
            // æƒ…å†µä¸‰ï¼Œå®Œå…¨ä¸ç›¸äº¤ï¼Œæ›´æ–°èµ·ç‚¹å’Œç»ˆç‚¹
            if (right < intv[0]) {
                left = intv[0];
                right = intv[1];
            }
        }

        return intervals.length - res;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var removeCoveredIntervals = function(intervals) {
    // æŒ‰ç…§èµ·ç‚¹å‡åºæ’åˆ—ï¼Œèµ·ç‚¹ç›¸åŒæ—¶é™åºæ’åˆ—
    intervals.sort((a, b) => {
        if (a[0] == b[0]) {
            return b[1] - a[1];
        }
        return a[0] - b[0];
    });

    // è®°å½•åˆå¹¶åŒºé—´çš„èµ·ç‚¹å’Œç»ˆç‚¹
    let left = intervals[0][0];
    let right = intervals[0][1];

    let res = 0;
    for (let i = 1; i < intervals.length; i++) {
        const intv = intervals[i];
        // æƒ…å†µä¸€ï¼Œæ‰¾åˆ°è¦†ç›–åŒºé—´
        if (left <= intv[0] && right >= intv[1]) {
            res++;
        }
        // æƒ…å†µäºŒï¼Œæ‰¾åˆ°ç›¸äº¤åŒºé—´ï¼Œåˆå¹¶
        if (right >= intv[0] && right <= intv[1]) {
            right = intv[1];
        }
        // æƒ…å†µä¸‰ï¼Œå®Œå…¨ä¸ç›¸äº¤ï¼Œæ›´æ–°èµ·ç‚¹å’Œç»ˆç‚¹
        if (right < intv[0]) {
            left = intv[0];
            right = intv[1];
        }
    }

    return intervals.length - res;
};
```

```python
# by chatGPT (python)
class Solution:
    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        """
        :type intervals: List[List[int]]
        :rtype: int
        """
        # æŒ‰ç…§èµ·ç‚¹å‡åºæ’åˆ—ï¼Œèµ·ç‚¹ç›¸åŒæ—¶é™åºæ’åˆ—
        intervals.sort(key=lambda a: (a[0], -a[1]))
        
        # è®°å½•åˆå¹¶åŒºé—´çš„èµ·ç‚¹å’Œç»ˆç‚¹
        left, right = intervals[0][0], intervals[0][1]
        res = 0
        for i in range(1, len(intervals)):
            intv = intervals[i]
            # æƒ…å†µä¸€ï¼Œæ‰¾åˆ°è¦†ç›–åŒºé—´
            if left <= intv[0] and right >= intv[1]:
                res += 1
            # æƒ…å†µäºŒï¼Œæ‰¾åˆ°ç›¸äº¤åŒºé—´ï¼Œåˆå¹¶
            if right >= intv[0] and right <= intv[1]:
                right = intv[1]
            # æƒ…å†µä¸‰ï¼Œå®Œå…¨ä¸ç›¸äº¤ï¼Œæ›´æ–°èµ·ç‚¹å’Œç»ˆç‚¹
            if right < intv[0]:
                left, right = intv[0], intv[1]
                
        return len(intervals) - res
```

https://leetcode.cn/problems/remove-covered-intervals çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/remove-duplicate-letters çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    string removeDuplicateLetters(string s) {
        stack<char> stk;

        // ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨è®°å½•å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ•°é‡
        // å› ä¸ºè¾“å…¥ä¸º ASCII å­—ç¬¦ï¼Œå¤§å° 256 å¤Ÿç”¨äº†
        int count[256] = {0};
        for (int i = 0; i < s.length(); i++) {
            count[s[i]]++;
        }

        bool inStack[256] = {false};
        for (char c : s) {
            // æ¯éå†è¿‡ä¸€ä¸ªå­—ç¬¦ï¼Œéƒ½å°†å¯¹åº”çš„è®¡æ•°å‡ä¸€
            count[c]--;

            if (inStack[c]) continue;

            while (!stk.empty() && stk.top() > c) {
                // è‹¥ä¹‹åä¸å­˜åœ¨æ ˆé¡¶å…ƒç´ äº†ï¼Œåˆ™åœæ­¢ pop
                if (count[stk.top()] == 0) {
                    break;
                }
                // è‹¥ä¹‹åè¿˜æœ‰ï¼Œåˆ™å¯ä»¥ pop
                inStack[stk.top()] = false;
                stk.pop();
            }
            stk.push(c);
            inStack[c] = true;
        }

        string res;
        while (!stk.empty()) {
            res.push_back(stk.top());
            stk.pop();
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

```go
// by chatGPT (go)
func removeDuplicateLetters(s string) string {
    stk := []rune{}

    // ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨è®°å½•å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ•°é‡
    // å› ä¸ºè¾“å…¥ä¸º ASCII å­—ç¬¦ï¼Œå¤§å° 256 å¤Ÿç”¨äº†
    count := [256]int{}
    for _, c := range s {
        count[c]++
    }

    inStack := [256]bool{}
    for _, c := range s {
        // æ¯éå†è¿‡ä¸€ä¸ªå­—ç¬¦ï¼Œéƒ½å°†å¯¹åº”çš„è®¡æ•°å‡ä¸€
        count[c]--

        if inStack[c] {
            continue
        }

        for len(stk) > 0 && stk[len(stk)-1] > c {
            // è‹¥ä¹‹åä¸å­˜åœ¨æ ˆé¡¶å…ƒç´ äº†ï¼Œåˆ™åœæ­¢ pop
            if count[stk[len(stk)-1]] == 0 {
                break
            }
            // è‹¥ä¹‹åè¿˜æœ‰ï¼Œåˆ™å¯ä»¥ pop
            inStack[stk[len(stk)-1]] = false
            stk = stk[:len(stk)-1]
        }
        stk = append(stk, c)
        inStack[c] = true
    }

    sb := strings.Builder{}
    for i := len(stk) - 1; i >= 0; i-- {
        sb.WriteRune(stk[i])
    }
    return sb.String()
}
```

```java
// by labuladong (java)
class Solution {
    public String removeDuplicateLetters(String s) {
        Stack<Character> stk = new Stack<>();

        // ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨è®°å½•å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ•°é‡
        // å› ä¸ºè¾“å…¥ä¸º ASCII å­—ç¬¦ï¼Œå¤§å° 256 å¤Ÿç”¨äº†
        int[] count = new int[256];
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i)]++;
        }

        boolean[] inStack = new boolean[256];
        for (char c : s.toCharArray()) {
            // æ¯éå†è¿‡ä¸€ä¸ªå­—ç¬¦ï¼Œéƒ½å°†å¯¹åº”çš„è®¡æ•°å‡ä¸€
            count[c]--;

            if (inStack[c]) continue;

            while (!stk.isEmpty() && stk.peek() > c) {
                // è‹¥ä¹‹åä¸å­˜åœ¨æ ˆé¡¶å…ƒç´ äº†ï¼Œåˆ™åœæ­¢ pop
                if (count[stk.peek()] == 0) {
                    break;
                }
                // è‹¥ä¹‹åè¿˜æœ‰ï¼Œåˆ™å¯ä»¥ pop
                inStack[stk.pop()] = false;
            }
            stk.push(c);
            inStack[c] = true;
        }

        StringBuilder sb = new StringBuilder();
        while (!stk.empty()) {
            sb.append(stk.pop());
        }
        return sb.reverse().toString();
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicateLetters = function(s) {
    let stk = [];

    // ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨è®°å½•å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ•°é‡
    // å› ä¸ºè¾“å…¥ä¸º ASCII å­—ç¬¦ï¼Œå¤§å° 256 å¤Ÿç”¨äº†
    let count = Array(256).fill(0);
    for (let i = 0; i < s.length; i++) {
        count[s.charCodeAt(i)]++;
    }

    let inStack = Array(256).fill(false);
    for (let i = 0; i < s.length; i++) {
        let c = s.charAt(i);
        // æ¯éå†è¿‡ä¸€ä¸ªå­—ç¬¦ï¼Œéƒ½å°†å¯¹åº”çš„è®¡æ•°å‡ä¸€
        count[c.charCodeAt(0)]--;

        if (inStack[c.charCodeAt(0)]) continue;

        while (stk.length > 0 && stk[stk.length - 1] > c) {
            // è‹¥ä¹‹åä¸å­˜åœ¨æ ˆé¡¶å…ƒç´ äº†ï¼Œåˆ™åœæ­¢ pop
            if (count[stk[stk.length - 1].charCodeAt(0)] == 0) {
                break;
            }
            // è‹¥ä¹‹åè¿˜æœ‰ï¼Œåˆ™å¯ä»¥ pop
            inStack[stk.pop().charCodeAt(0)] = false;
        }
        stk.push(c);
        inStack[c.charCodeAt(0)] = true;
    }

    let sb = "";
    while (stk.length > 0) {
        sb += stk.pop();
    }
    return sb.split("").reverse().join("");
};
```

```python
# by chatGPT (python)
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stk = []

        # ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨è®°å½•å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ•°é‡
        # å› ä¸ºè¾“å…¥ä¸º ASCII å­—ç¬¦ï¼Œå¤§å° 256 å¤Ÿç”¨äº†
        count = [0] * 256
        for i in range(len(s)):
            count[ord(s[i])] += 1

        inStack = [False] * 256
        for c in s:
            # æ¯éå†è¿‡ä¸€ä¸ªå­—ç¬¦ï¼Œéƒ½å°†å¯¹åº”çš„è®¡æ•°å‡ä¸€
            count[ord(c)] -= 1

            if inStack[ord(c)]:
                continue

            while len(stk) > 0 and stk[-1] > c:
                # è‹¥ä¹‹åä¸å­˜åœ¨æ ˆé¡¶å…ƒç´ äº†ï¼Œåˆ™åœæ­¢ pop
                if count[ord(stk[-1])] == 0:
                    break
                # è‹¥ä¹‹åè¿˜æœ‰ï¼Œåˆ™å¯ä»¥ pop
                inStack[ord(stk.pop())] = False
            stk.append(c)
            inStack[ord(c)] = True

        sb = []
        while len(stk) > 0:
            sb.append(stk.pop())
        return "".join(sb)[::-1]
```

https://leetcode.cn/problems/remove-duplicate-letters çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/remove-duplicates-from-sorted-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() == 0) {
            return 0;
        }
        int slow = 0, fast = 0;
        while (fast < nums.size()) {
            if (nums[fast] != nums[slow]) {
                slow++;
                // ç»´æŠ¤ nums[0..slow] æ— é‡å¤
                nums[slow] = nums[fast];
            }
            fast++;
        }
        // æ•°ç»„é•¿åº¦ä¸ºç´¢å¼• + 1
        return slow + 1;
    }
};
```

```go
// by chatGPT (go)
func removeDuplicates(nums []int) int {
    // å¦‚æœæ•°ç»„ä¸ºç©ºï¼Œç›´æ¥è¿”å› 0
    if len(nums) == 0 {
        return 0
    }
    // å®šä¹‰å¿«æ…¢æŒ‡é’ˆï¼Œåˆå§‹åŒ–éƒ½æŒ‡å‘æ•°ç»„å¤´éƒ¨
    slow, fast := 0, 0
    // å¿«æŒ‡é’ˆå‘åéå†æ•°ç»„ï¼Œç›´åˆ°æœ«å°¾
    for fast < len(nums) {
        // å¦‚æœä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å…ƒç´ ä¸ç›¸åŒ
        if nums[fast] != nums[slow] {
            // æ…¢æŒ‡é’ˆå‘åç§»åŠ¨ï¼Œå¹¶ä¸”å°†æ…¢æŒ‡é’ˆä½ç½®ä¸Šçš„å€¼è®¾ä¸ºå¿«æŒ‡é’ˆä½ç½®ä¸Šçš„å€¼
            slow++
            nums[slow] = nums[fast]
        }
        // å¿«æŒ‡é’ˆç»§ç»­å‘åç§»åŠ¨
        fast++
    }
    // slow æŒ‡å‘æ•°ç»„çš„æœ€åä¸€ä¸ªä¸é‡å¤å…ƒç´ çš„ä½ç½®
    // æ•°ç»„é•¿åº¦ä¸ºç´¢å¼• + 1
    return slow + 1
}
```

```java
// by labuladong (java)
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int slow = 0, fast = 0;
        while (fast < nums.length) {
            if (nums[fast] != nums[slow]) {
                slow++;
                // ç»´æŠ¤ nums[0..slow] æ— é‡å¤
                nums[slow] = nums[fast];
            }
            fast++;
        }
        // æ•°ç»„é•¿åº¦ä¸ºç´¢å¼• + 1
        return slow + 1;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    if (nums.length === 0) {
        return 0;
    }
    let slow = 0, fast = 0;
    while (fast < nums.length) {
        if (nums[fast] !== nums[slow]) {
            slow++;
            // ç»´æŠ¤ nums[0..slow] æ— é‡å¤
            nums[slow] = nums[fast];
        }
        fast++;
    }
    // æ•°ç»„é•¿åº¦ä¸ºç´¢å¼• + 1
    return slow + 1;
};
```

```python
# by chatGPT (python)
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        slow, fast = 0, 0
        while fast < len(nums):
            if nums[fast] != nums[slow]:
                slow += 1
                # ç»´æŠ¤ nums[0..slow] æ— é‡å¤
                nums[slow] = nums[fast]
            fast += 1
        # æ•°ç»„é•¿åº¦ä¸ºç´¢å¼• + 1
        return slow + 1
```

https://leetcode.cn/problems/remove-duplicates-from-sorted-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() == 0) {
            return 0;
        }
        // å¿«æ…¢æŒ‡é’ˆï¼Œç»´æŠ¤ nums[0..slow] ä¸ºç»“æœå­æ•°ç»„
        int slow = 0, fast = 0;
        // è®°å½•ä¸€ä¸ªå…ƒç´ é‡å¤çš„æ¬¡æ•°
        int count = 0;
        while (fast < nums.size()) {
            if (nums[fast] != nums[slow]) {
                slow++;
                nums[slow] = nums[fast];
            } else if (slow < fast && count < 2) {
                // å½“ä¸€ä¸ªå…ƒç´ é‡å¤æ¬¡æ•°ä¸åˆ° 2 æ¬¡æ—¶ï¼Œä¹Ÿ
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
            count++;
            if (fast < nums.size() && nums[fast] != nums[fast - 1]) {
                // é‡åˆ°ä¸åŒçš„å…ƒç´ 
                count = 0;
            }
        }
        // æ•°ç»„é•¿åº¦ä¸ºç´¢å¼• + 1
        return slow + 1;
    }
};
```

```go
// by chatGPT (go)
func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    // å¿«æ…¢æŒ‡é’ˆï¼Œç»´æŠ¤ nums[0..slow] ä¸ºç»“æœå­æ•°ç»„
    slow, fast := 0, 0
    // è®°å½•ä¸€ä¸ªå…ƒç´ é‡å¤çš„æ¬¡æ•°
    count := 0
    for fast < len(nums) {
        if nums[fast] != nums[slow] {
            slow++
            nums[slow] = nums[fast]
        } else if slow < fast && count < 2 {
            // å½“ä¸€ä¸ªå…ƒç´ é‡å¤æ¬¡æ•°ä¸åˆ° 2 æ¬¡æ—¶ï¼Œä¹Ÿ
            slow++
            nums[slow] = nums[fast]
        }
        fast++
        count++
        if fast < len(nums) && nums[fast] != nums[fast - 1] {
            // é‡åˆ°ä¸åŒçš„å…ƒç´ 
            count = 0
        }
    }
    // æ•°ç»„é•¿åº¦ä¸ºç´¢å¼• + 1
    return slow + 1
}
```

```java
// by labuladong (java)
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        // å¿«æ…¢æŒ‡é’ˆï¼Œç»´æŠ¤ nums[0..slow] ä¸ºç»“æœå­æ•°ç»„
        int slow = 0, fast = 0;
        // è®°å½•ä¸€ä¸ªå…ƒç´ é‡å¤çš„æ¬¡æ•°
        int count = 0;
        while (fast < nums.length) {
            if (nums[fast] != nums[slow]) {
                // æ­¤æ—¶ï¼Œå¯¹äº nums[0..slow] æ¥è¯´ï¼Œnums[fast] æ˜¯ä¸€ä¸ªæ–°çš„å…ƒç´ ï¼ŒåŠ è¿›æ¥
                slow++;
                nums[slow] = nums[fast];
            } else if (slow < fast && count < 2) {
                // æ­¤æ—¶ï¼Œå¯¹äº nums[0..slow] æ¥è¯´ï¼Œnums[fast] é‡å¤æ¬¡æ•°å°äº 2ï¼Œä¹ŸåŠ è¿›æ¥
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
            count++;
            if (fast < nums.length && nums[fast] != nums[fast - 1]) {
                // fast é‡åˆ°æ–°çš„ä¸åŒçš„å…ƒç´ æ—¶ï¼Œé‡ç½® count
                count = 0;
            }
        }
        // æ•°ç»„é•¿åº¦ä¸ºç´¢å¼• + 1
        return slow + 1;
    }
}
```

```javascript
// by chatGPT (javascript)
var removeDuplicates = function(nums) {
    if (nums.length == 0) {
        return 0;
    }
    // å¿«æ…¢æŒ‡é’ˆï¼Œç»´æŠ¤ nums[0..slow] ä¸ºç»“æœå­æ•°ç»„
    let slow = 0, fast = 0;
    // è®°å½•ä¸€ä¸ªå…ƒç´ é‡å¤çš„æ¬¡æ•°
    let count = 0;
    while (fast < nums.length) {
        if (nums[fast] != nums[slow]) {
            slow++;
            nums[slow] = nums[fast];
        } else if (slow < fast && count < 2) {
            // å½“ä¸€ä¸ªå…ƒç´ é‡å¤æ¬¡æ•°ä¸åˆ° 2 æ¬¡æ—¶ï¼Œä¹Ÿ
            slow++;
            nums[slow] = nums[fast];
        }
        fast++;
        count++;
        if (fast < nums.length && nums[fast] != nums[fast - 1]) {
            // é‡åˆ°ä¸åŒçš„å…ƒç´ 
            count = 0;
        }
    }
    // æ•°ç»„é•¿åº¦ä¸ºç´¢å¼• + 1
    return slow + 1;
};
```

```python
# by chatGPT (python)
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        # å¿«æ…¢æŒ‡é’ˆï¼Œç»´æŠ¤ nums[0..slow] ä¸ºç»“æœå­æ•°ç»„
        slow, fast = 0, 0
        # è®°å½•ä¸€ä¸ªå…ƒç´ é‡å¤çš„æ¬¡æ•°
        count = 0
        while fast < len(nums):
            if nums[fast] != nums[slow]:
                slow += 1
                nums[slow] = nums[fast]
            elif slow < fast and count < 2:
                # å½“ä¸€ä¸ªå…ƒç´ é‡å¤æ¬¡æ•°ä¸åˆ° 2 æ¬¡æ—¶ï¼Œä¹Ÿ
                slow += 1
                nums[slow] = nums[fast]
            fast += 1
            count += 1
            if fast < len(nums) and nums[fast] != nums[fast - 1]:
                # é‡åˆ°ä¸åŒçš„å…ƒç´ 
                count = 0
        # æ•°ç»„é•¿åº¦ä¸ºç´¢å¼• + 1
        return slow + 1
```

https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/remove-duplicates-from-sorted-list çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {  // åˆ é™¤é“¾è¡¨ä¸­é‡å¤çš„å…ƒç´ 
        if (head == NULL) return NULL;  // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œç›´æ¥è¿”å›NULL
        ListNode *slow = head, *fast = head;  // å®šä¹‰å¿«æ…¢æŒ‡é’ˆï¼Œåˆå§‹éƒ½æŒ‡å‘å¤´ç»“ç‚¹
        while (fast != NULL) {  // åªè¦å¿«æŒ‡é’ˆæ²¡æœ‰éå†å®Œæ•´ä¸ªé“¾è¡¨
            if (fast->val != slow->val) {  // å¿«æ…¢æŒ‡é’ˆå€¼ä¸åŒ
                slow->next = fast;  // æ…¢æŒ‡é’ˆè¿æ¥æ–°èŠ‚ç‚¹
                slow = slow->next;  // æ…¢æŒ‡é’ˆå‘åç§»åŠ¨ä¸€ä½
            }
            fast = fast->next;  // å¿«æŒ‡é’ˆå‘åç§»åŠ¨ä¸€ä½
        }
        slow->next = NULL;  // æ–­å¼€ä¸åé¢é‡å¤å…ƒç´ çš„è¿æ¥
        return head;  // è¿”å›å¤´ç»“ç‚¹
    }
};
```

```go
// by chatGPT (go)
func deleteDuplicates(head *ListNode) *ListNode {
    if head == nil {
        return nil
    }

    slow, fast := head, head
    for fast != nil {
        if fast.Val != slow.Val {
            // nums[slow] = nums[fast];
            slow.Next = fast
            // slow++;
            slow = slow.Next
        }
        // fast++
        fast = fast.Next
    }
    // æ–­å¼€ä¸åé¢é‡å¤å…ƒç´ çš„è¿æ¥
    slow.Next = nil
    return head
}
```

```java
// by labuladong (java)
class Solution {
    public deleteDuplicates(ListNode head) {
        if (head == null) return null;
        ListNode slow = head, fast = head;
        while (fast != null) {
            if (fast.val != slow.val) {
                // nums[slow] = nums[fast];
                slow.next = fast;
                // slow++;
                slow = slow.next;
            }
            // fast++
            fast = fast.next;
        }
        // æ–­å¼€ä¸åé¢é‡å¤å…ƒç´ çš„è¿æ¥
        slow.next = null;
        return head;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
  if (head === null) return null;
  var slow = head;
  var fast = head;
  while (fast !== null) {
    if (fast.val !== slow.val) {
      // nums[slow] = nums[fast];
      slow.next = fast;
      // slow++;
      slow = slow.next;
    }
    // fast++
    fast = fast.next;
  }
  // æ–­å¼€ä¸åé¢é‡å¤å…ƒç´ çš„è¿æ¥
  slow.next = null;
  return head;
};
```

```python
# by chatGPT (python)
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if head == None:
            return None
        slow = head
        fast = head
        while fast != None:
            if fast.val != slow.val:
                # nums[slow] = nums[fast];
                slow.next = fast
                # slow++;
                slow = slow.next
            # fast++
            fast = fast.next
        # æ–­å¼€ä¸åé¢é‡å¤å…ƒç´ çš„è¿æ¥
        slow.next = None
        return head
```

https://leetcode.cn/problems/remove-duplicates-from-sorted-list çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/remove-element çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int fast = 0, slow = 0;
        while (fast < nums.size()) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

```go
// by chatGPT (go)
// åŒæŒ‡é’ˆæ³•
func removeElement(nums []int, val int) int {
    var fast, slow int
    for fast < len(nums) {
        if nums[fast] != val {
            nums[slow] = nums[fast]
            slow++
        }
        fast++
    }
    return slow
}
```

```java
// by labuladong (java)
class Solution {
    public int removeElement(int[] nums, int val) {
        int fast = 0, slow = 0;
        while (fast < nums.length) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let fast = 0, slow = 0;
    while (fast < nums.length) {
        if (nums[fast] !== val) {
            nums[slow] = nums[fast];
            slow++;
        }
        fast++;
    }
    return slow;
};
```

```python
# by chatGPT (python)
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        fast, slow = 0, 0
        while fast < len(nums):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return slow
```

https://leetcode.cn/problems/remove-element çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/remove-nth-node-from-end-of-list çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        // åˆ é™¤å€’æ•°ç¬¬ n ä¸ªï¼Œè¦å…ˆæ‰¾å€’æ•°ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
        ListNode* x = findFromEnd(dummy, n + 1);
        // åˆ æ‰å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
        x->next = x->next->next;
        return dummy->next;
    }

    // è¿”å›é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
    ListNode* findFromEnd(ListNode* head, int k) {
        ListNode* p1 = head;
        // p1 å…ˆèµ° k æ­¥
        for (int i = 0; i < k; i++) {
            p1 = p1->next;
        }
        ListNode* p2 = head;
        // p1 å’Œ p2 åŒæ—¶èµ° n - k æ­¥
        while (p1 != NULL) {
            p2 = p2->next;
            p1 = p1->next;
        }
        // p2 ç°åœ¨æŒ‡å‘ç¬¬ n - k ä¸ªèŠ‚ç‚¹
        return p2;
    }
};
```

```go
// by chatGPT (go)
// ä¸»å‡½æ•°
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    dummy := &ListNode{Val: -1, Next: head}
    // åˆ é™¤å€’æ•°ç¬¬ n ä¸ªï¼Œè¦å…ˆæ‰¾å€’æ•°ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
    x := findFromEnd(dummy, n + 1)
    // åˆ æ‰å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
    x.Next = x.Next.Next
    return dummy.Next
}

// è¿”å›é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
func findFromEnd(head *ListNode, k int) *ListNode {
    p1, p2 := head, head
    // p1 å…ˆèµ° k æ­¥
    for i := 0; i < k; i++ {
        p1 = p1.Next
    }
    // p1 å’Œ p2 åŒæ—¶èµ° n - k æ­¥
    for p1 != nil {
        p1 = p1.Next
        p2 = p2.Next
    }
    // p2 ç°åœ¨æŒ‡å‘ç¬¬ n - k ä¸ªèŠ‚ç‚¹
    return p2
}
```

```java
// by labuladong (java)
class Solution {
    // ä¸»å‡½æ•°
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        // åˆ é™¤å€’æ•°ç¬¬ n ä¸ªï¼Œè¦å…ˆæ‰¾å€’æ•°ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
        ListNode x = findFromEnd(dummy, n + 1);
        // åˆ æ‰å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
        x.next = x.next.next;
        return dummy.next;
    }

    // è¿”å›é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
    ListNode findFromEnd(ListNode head, int k) {
        ListNode p1 = head;
        // p1 å…ˆèµ° k æ­¥
        for (int i = 0; i < k; i++) {
            p1 = p1.next;
        }
        ListNode p2 = head;
        // p1 å’Œ p2 åŒæ—¶èµ° n - k æ­¥
        while (p1 != null) {
            p2 = p2.next;
            p1 = p1.next;
        }
        // p2 ç°åœ¨æŒ‡å‘ç¬¬ n - k ä¸ªèŠ‚ç‚¹
        return p2;
    }
}
```

```javascript
// by chatGPT (javascript)
var removeNthFromEnd = function(head, n) {
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    let dummy = new ListNode(-1);
    dummy.next = head;
    // åˆ é™¤å€’æ•°ç¬¬ n ä¸ªï¼Œè¦å…ˆæ‰¾å€’æ•°ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
    let x = findFromEnd(dummy, n + 1);
    // åˆ æ‰å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
    x.next = x.next.next;
    return dummy.next;
};

// è¿”å›é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
var findFromEnd = function(head, k) {
    let p1 = head;
    // p1 å…ˆèµ° k æ­¥
    for (let i = 0; i < k; i++) {
        p1 = p1.next;
    }
    let p2 = head;
    // p1 å’Œ p2 åŒæ—¶èµ° n - k æ­¥
    while (p1 != null) {
        p2 = p2.next;
        p1 = p1.next;
    }
    // p2 ç°åœ¨æŒ‡å‘ç¬¬ n - k ä¸ªèŠ‚ç‚¹
    return p2;
};
```

```python
# by chatGPT (python)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        # è™šæ‹Ÿå¤´ç»“ç‚¹
        dummy = ListNode(-1)
        dummy.next = head
        # åˆ é™¤å€’æ•°ç¬¬ n ä¸ªï¼Œè¦å…ˆæ‰¾å€’æ•°ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
        x = self.findFromEnd(dummy, n + 1)
        # åˆ æ‰å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
        x.next = x.next.next
        return dummy.next

    # è¿”å›é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
    def findFromEnd(self, head: ListNode, k: int) -> ListNode:
        p1 = head
        # p1 å…ˆèµ° k æ­¥
        for i in range(k):
            p1 = p1.next
        p2 = head
        # p1 å’Œ p2 åŒæ—¶èµ° n - k æ­¥
        while p1 != None:
            p1 = p1.next
            p2 = p2.next
        # p2 ç°åœ¨æŒ‡å‘ç¬¬ n - k ä¸ªèŠ‚ç‚¹
        return p2
```

https://leetcode.cn/problems/remove-nth-node-from-end-of-list çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/reshape-the-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {
        int m = mat.size(), n = mat[0].size();
        // å¦‚æœæƒ³æˆåŠŸ reshapeï¼Œå…ƒç´ ä¸ªæ•°åº”è¯¥ç›¸åŒ
        if (r * c != m * n) {
            return mat;
        }

        vector<vector<int>> res(r, vector<int>(c, 0));
        for (int i = 0; i < m * n; i++) {
            set(res, i, get(mat, i));
        }
        return res;
    }

    // é€šè¿‡ä¸€ç»´åæ ‡è®¿é—®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
    int get(vector<vector<int>>& matrix, int index) {
        int m = matrix.size(), n = matrix[0].size();
        // è®¡ç®—äºŒç»´ä¸­çš„æ¨ªçºµåæ ‡
        int i = index / n, j = index % n;
        return matrix[i][j];
    }

    // é€šè¿‡ä¸€ç»´åæ ‡è®¾ç½®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
    void set(vector<vector<int>>& matrix, int index, int value) {
        int m = matrix.size(), n = matrix[0].size();
        // è®¡ç®—äºŒç»´ä¸­çš„æ¨ªçºµåæ ‡
        int i = index / n, j = index % n;
        matrix[i][j] = value;
    }
};
```

```go
// by chatGPT (go)
func matrixReshape(mat [][]int, r int, c int) [][]int {
    m := len(mat)
    n := len(mat[0])

    if r*c != m*n {
        return mat
    }

    res := make([][]int,r)
    for i := range res {
        res[i] = make([]int,c)
    }

    for i := 0; i < m * n; i++ {
        set(res, i, get(mat, i))
    }
    return res
}

// get é€šè¿‡ä¸€ç»´åæ ‡è®¿é—®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
func get(matrix [][]int, index int) int {
    n := len(matrix[0])
    i := index / n
    j := index % n
    return matrix[i][j]
}

// set é€šè¿‡ä¸€ç»´åæ ‡è®¾ç½®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
func set(matrix [][]int, index int, value int) {
    n := len(matrix[0])
    i := index / n
    j := index % n
    matrix[i][j] = value
}
```

```java
// by labuladong (java)
class Solution {
    public int[][] matrixReshape(int[][] mat, int r, int c) {
        int m = mat.length, n = mat[0].length;
        // å¦‚æœæƒ³æˆåŠŸ reshapeï¼Œå…ƒç´ ä¸ªæ•°åº”è¯¥ç›¸åŒ
        if (r * c != m * n) {
            return mat;
        }

        int[][] res = new int[r][c];
        for (int i = 0; i < m * n; i++) {
            set(res, i, get(mat, i));
        }
        return res;
    }

    // é€šè¿‡ä¸€ç»´åæ ‡è®¿é—®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
    int get(int[][] matrix, int index) {
        int m = matrix.length, n = matrix[0].length;
        // è®¡ç®—äºŒç»´ä¸­çš„æ¨ªçºµåæ ‡
        int i = index / n, j = index % n;
        return matrix[i][j];
    }

    // é€šè¿‡ä¸€ç»´åæ ‡è®¾ç½®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
    void set(int[][] matrix, int index, int value) {
        int m = matrix.length, n = matrix[0].length;
        // è®¡ç®—äºŒç»´ä¸­çš„æ¨ªçºµåæ ‡
        int i = index / n, j = index % n;
        matrix[i][j] = value;
    }
}
```

```javascript
// by chatGPT (javascript)
var matrixReshape = function(mat, r, c) {
    var m = mat.length, n = mat[0].length;
    // å¦‚æœæƒ³æˆåŠŸ reshapeï¼Œå…ƒç´ ä¸ªæ•°åº”è¯¥ç›¸åŒ
    if (r * c !== m * n) {
        return mat;
    }

    var res = new Array(r);
    for (var i = 0; i < r; i++) {
        res[i] = new Array(c);
    }

    for (var i = 0; i < m * n; i++) {
        set(res, i, get(mat, i));
    }
    return res;
}

// é€šè¿‡ä¸€ç»´åæ ‡è®¿é—®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
var get = function(matrix, index) {
    var m = matrix.length, n = matrix[0].length;
    // è®¡ç®—äºŒç»´ä¸­çš„æ¨ªçºµåæ ‡
    var i = Math.floor(index / n), j = index % n;
    return matrix[i][j];
}

// é€šè¿‡ä¸€ç»´åæ ‡è®¾ç½®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
var set = function(matrix, index, value) {
    var m = matrix.length, n = matrix[0].length;
    // è®¡ç®—äºŒç»´ä¸­çš„æ¨ªçºµåæ ‡
    var i = Math.floor(index / n), j = index % n;
    matrix[i][j] = value;
}
```

```python
# by chatGPT (python)
class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        # å¦‚æœæƒ³æˆåŠŸ reshapeï¼Œå…ƒç´ ä¸ªæ•°åº”è¯¥ç›¸åŒ
        if r * c != m * n:
            return mat

        res = [[0] * c for _ in range(r)]
        for i in range(m * n):
            self.set(res, i, self.get(mat, i))
        return res

    # é€šè¿‡ä¸€ç»´åæ ‡è®¿é—®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
    def get(self, matrix:List[List[int]], index:int) -> int:
        m, n = len(matrix), len(matrix[0])
        # è®¡ç®—äºŒç»´ä¸­çš„æ¨ªçºµåæ ‡
        i, j = index // n, index % n
        return matrix[i][j]

    # é€šè¿‡ä¸€ç»´åæ ‡è®¾ç½®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
    def set(self, matrix:List[List[int]], index:int, value:int) -> None:
        m, n = len(matrix), len(matrix[0])
        # è®¡ç®—äºŒç»´ä¸­çš„æ¨ªçºµåæ ‡
        i, j = index // n, index % n
        matrix[i][j] = value
```

https://leetcode.cn/problems/reshape-the-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/reverse-linked-list çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == NULL || head->next == NULL) {
            return head;
        }
        ListNode* last = reverseList(head->next);
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/3.jpg)
        */
        head->next->next = head;
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/4.jpg)
        */
        head->next = NULL;
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/5.jpg)
        */
        return last;
    }
};
```

```go
// by chatGPT (go)
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    last := reverseList(head.Next)
    /* <extend up - 200>
    ![](../pictures/åè½¬é“¾è¡¨/3.jpg)
    */
    head.Next.Next = head
    /* <extend up - 200>
    ![](../pictures/åè½¬é“¾è¡¨/4.jpg)
    */
    head.Next = nil
    /* <extend up - 200>
    ![](../pictures/åè½¬é“¾è¡¨/5.jpg)
    */
    return last
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode last = reverseList(head.next);
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/3.jpg)
        */
        head.next.next = head;
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/4.jpg)
        */
        head.next = null;
        /**<extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/5.jpg)
        */
        return last;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    if (head === null || head.next === null) {
        return head;
    }
    var last = reverseList(head.next);
    /**<extend up -200>
    ![](../pictures/åè½¬é“¾è¡¨/3.jpg)
    */
    head.next.next = head;
    /**<extend up -200>
    ![](../pictures/åè½¬é“¾è¡¨/4.jpg)
    */
    head.next = null;
    /**<extend up -200>
    ![](../pictures/åè½¬é“¾è¡¨/5.jpg)
    */
    return last;
};
```

```python
# by chatGPT (python)
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if head is None or head.next is None:
            return head
        last = self.reverseList(head.next)
        """
        <extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/3.jpg)
        """
        head.next.next = head
        """
        <extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/4.jpg)
        """
        head.next = None
        """
        <extend up -200>
        ![](../pictures/åè½¬é“¾è¡¨/5.jpg)
        """
        return last
```

https://leetcode.cn/problems/reverse-linked-list çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/reverse-linked-list-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        // base case
        if (m == 1) {
            return reverseN(head, n);
        }
        // å‰è¿›åˆ°åè½¬çš„èµ·ç‚¹è§¦å‘ base case
        head->next = reverseBetween(head->next, m - 1, n - 1);
        return head;
    }

private:
    ListNode* successor = nullptr; // åé©±èŠ‚ç‚¹
    // åè½¬ä»¥ head ä¸ºèµ·ç‚¹çš„ n ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›æ–°çš„å¤´ç»“ç‚¹
    ListNode* reverseN(ListNode* head, int n) {
        if (n == 1) {
            // è®°å½•ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
            successor = head->next;
            return head;
        }
        // ä»¥ head->next ä¸ºèµ·ç‚¹ï¼Œéœ€è¦åè½¬å‰ n - 1 ä¸ªèŠ‚ç‚¹
        ListNode* last = reverseN(head->next, n - 1);

        head->next->next = head;
        // è®©åè½¬ä¹‹åçš„ head èŠ‚ç‚¹å’Œåé¢çš„èŠ‚ç‚¹è¿èµ·æ¥
        head->next = successor;
        return last;
        /**<extend up -90>
        ![](../pictures/åè½¬é“¾è¡¨/7.jpg)
        */
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
 
func reverseBetween(head *ListNode, m int, n int) *ListNode {
    var successor *ListNode // åé©±èŠ‚ç‚¹

    // åè½¬ä»¥ head ä¸ºèµ·ç‚¹çš„ n ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›æ–°çš„å¤´ç»“ç‚¹
    var reverseN func(head *ListNode, n int) (*ListNode)
    reverseN = func(head *ListNode, n int) (*ListNode) {
        if n == 1 {
            // è®°å½•ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
            successor = head.Next
            return head
        }
        // ä»¥ head.Next ä¸ºèµ·ç‚¹ï¼Œéœ€è¦åè½¬å‰ n - 1 ä¸ªèŠ‚ç‚¹
        last := reverseN(head.Next, n - 1)

        head.Next.Next = head
        // è®©åè½¬ä¹‹åçš„ head èŠ‚ç‚¹å’Œåé¢çš„èŠ‚ç‚¹è¿èµ·æ¥
        head.Next = successor
        return last
    }

    // base case
    if m == 1 {
        return reverseN(head, n)
    }
    // å‰è¿›åˆ°åè½¬çš„èµ·ç‚¹è§¦å‘ base case
    head.Next = reverseBetween(head.Next, m - 1, n - 1)
    return head
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        // base case
        if (m == 1) {
            return reverseN(head, n);
        }
        // å‰è¿›åˆ°åè½¬çš„èµ·ç‚¹è§¦å‘ base case
        head.next = reverseBetween(head.next, m - 1, n - 1);
        return head;
    }

    ListNode successor = null; // åé©±èŠ‚ç‚¹
    // åè½¬ä»¥ head ä¸ºèµ·ç‚¹çš„ n ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›æ–°çš„å¤´ç»“ç‚¹
    ListNode reverseN(ListNode head, int n) {
        if (n == 1) {
            // è®°å½•ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
            successor = head.next;
            return head;
        }
        // ä»¥ head.next ä¸ºèµ·ç‚¹ï¼Œéœ€è¦åè½¬å‰ n - 1 ä¸ªèŠ‚ç‚¹
        ListNode last = reverseN(head.next, n - 1);

        head.next.next = head;
        // è®©åè½¬ä¹‹åçš„ head èŠ‚ç‚¹å’Œåé¢çš„èŠ‚ç‚¹è¿èµ·æ¥
        head.next = successor;
        return last;
        /**<extend up -90>
        ![](../pictures/åè½¬é“¾è¡¨/7.jpg)
        */
    }
}
```

```javascript
// by chatGPT (javascript)
var reverseBetween = function(head, m, n) {
    let successor = null;
    // åè½¬ä»¥ head ä¸ºèµ·ç‚¹çš„ n ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›æ–°çš„å¤´ç»“ç‚¹
    const reverseN = function(head, n) {
        if (n == 1) {
            // è®°å½•ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
            successor = head.next;
            return head;
        }
        const last = reverseN(head.next, n - 1);
        head.next.next = head;
        // è®©åè½¬ä¹‹åçš„ head èŠ‚ç‚¹å’Œåé¢çš„èŠ‚ç‚¹è¿èµ·æ¥
        head.next = successor;
        return last;
        /**<extend up -90>
        ![](../pictures/åè½¬é“¾è¡¨/7.jpg)
        */
    };
    // base case
    if (m == 1) {
        return reverseN(head, n);
    }
    // å‰è¿›åˆ°åè½¬çš„èµ·ç‚¹è§¦å‘ base case
    head.next = reverseBetween(head.next, m - 1, n - 1);
    return head;
};
```

```python
# by chatGPT (python)
class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        # base case
        if m == 1:
            return self.reverseN(head, n)
        # å‰è¿›åˆ°åè½¬çš„èµ·ç‚¹è§¦å‘ base case
        head.next = self.reverseBetween(head.next, m - 1, n - 1)
        return head

    successor = None # åé©±èŠ‚ç‚¹
    # åè½¬ä»¥ head ä¸ºèµ·ç‚¹çš„ n ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›æ–°çš„å¤´ç»“ç‚¹
    def reverseN(self, head: ListNode, n: int) -> ListNode:
        if n == 1:
            # è®°å½•ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
            self.successor = head.next
            return head
        # ä»¥ head.next ä¸ºèµ·ç‚¹ï¼Œéœ€è¦åè½¬å‰ n - 1 ä¸ªèŠ‚ç‚¹
        last = self.reverseN(head.next, n - 1)

        head.next.next = head
        # è®©åè½¬ä¹‹åçš„ head èŠ‚ç‚¹å’Œåé¢çš„èŠ‚ç‚¹è¿èµ·æ¥
        head.next = self.successor
        return last
        """
        <extend up -90>
        ![](../pictures/åè½¬é“¾è¡¨/7.jpg)
        """
```

https://leetcode.cn/problems/reverse-linked-list-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/reverse-nodes-in-k-group çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
         if(head == NULL) return NULL;
    	//åŒºé—´[a,b)åŒ…å«kä¸ªå¾…åè½¬å…ƒç´ 
    	ListNode *a, *b;
    	a = b = head;
    	for (int i = 0; i < k; i++) {
    		//ä¸è¶³kä¸ªï¼Œç›´æ¥è¿”å›
    		if (b == NULL) return head;
    		b = b->next;
    	}
    	//åè½¬å‰kä¸ªå…ƒç´ 
    	ListNode *newHead = reverse(a, b);
    	//é€’å½’åè½¬åç»­é“¾è¡¨å¹¶è¿æ¥èµ·æ¥
    	a->next = reverseKGroup(b, k);
    	return newHead;
    }
    ListNode *reverse(ListNode *a, ListNode *b) {
    	ListNode *pre, *cur, *nxt;
    	cur = a; pre = NULL;
    	while (cur != b) {
    		nxt = cur->next;
    		cur->next = pre;
    		pre = cur;
    		cur = nxt;
    	}
    	return pre;
    }
};
```

```go
// by chatGPT (go)
// ç»™å‡ºä¸€ä¸ªé“¾è¡¨å’Œä¸€ä¸ªæ•°kï¼Œæ¯”å¦‚1->2->3->4->5->6ï¼Œk=2ï¼Œé‚£ä¹ˆä½ éœ€è¦è¿”å›çš„ç»“æœæ˜¯2->1->4->3->6->5ã€‚
func reverseKGroup(head *ListNode, k int) *ListNode {
    if head == nil {
        return nil
    }
    
    a, b := head, head
    // æ‰¾åˆ°éœ€è¦ç¿»è½¬çš„åŒºé—´ [a, b)
    for i := 0; i < k; i++ {
        if b == nil {
            return head
        }
        b = b.Next
    }

    // åè½¬åŒºé—´å†…çš„é“¾è¡¨
    newHead := reverse(a, b)
    // é€’å½’å°†åç»­é“¾è¡¨çš„åŒºé—´ä¹Ÿç¿»è½¬ï¼Œç„¶åå†å°†å®ƒé“¾æ¥åˆ°æ–°çš„åŒºé—´å†…
    a.Next = reverseKGroup(b, k)
    /** <extend up -90>
    ![](../pictures/kgroup/6.jpg)
    */

    return newHead
}

// ç¿»è½¬åŒºé—´ [a, b)ï¼ŒåŒ…å¤´ä¸åŒ…å°¾
func reverse(a, b *ListNode) *ListNode {
    // åˆå§‹åŒ–ä¸‰ä¸ªæŒ‡é’ˆ
    pre, cur, nxt := (*ListNode)(nil), a, a

    // å¾ªç¯å°†å½“å‰èŠ‚ç‚¹æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç„¶åå°†å‰ä¸€ä¸ªèŠ‚ç‚¹å’Œå½“å‰èŠ‚ç‚¹å¾€åç§»åŠ¨
    for cur != b {
        nxt = cur.Next
        cur.Next = pre
        pre, cur = cur, nxt
    }

    // è¿”å›æ–°çš„å¤´ç»“ç‚¹
    return pre
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null) return null;
        // åŒºé—´ [a, b) åŒ…å« k ä¸ªå¾…åè½¬å…ƒç´ 
        ListNode a, b;
        a = b = head;
        for (int i = 0; i < k; i++) {
            // ä¸è¶³ k ä¸ªï¼Œä¸éœ€è¦åè½¬ï¼Œbase case
            if (b == null) return head;
            b = b.next;
        }
        // åè½¬å‰ k ä¸ªå…ƒç´ 
        ListNode newHead = reverse(a, b);
        // é€’å½’åè½¬åç»­é“¾è¡¨å¹¶è¿æ¥èµ·æ¥
        a.next = reverseKGroup(b, k);
        /**<extend up -90>
        ![](../pictures/kgroup/6.jpg)
        */
        return newHead;
    }

    /* åè½¬åŒºé—´ [a, b) çš„å…ƒç´ ï¼Œæ³¨æ„æ˜¯å·¦é—­å³å¼€ */
    ListNode reverse(ListNode a, ListNode b) {
        /**<extend up -300>
        ![](../pictures/kgroup/8.gif)
        */
        ListNode pre, cur, nxt;
        pre = null;
        cur = a;
        nxt = a;
        // while ç»ˆæ­¢çš„æ¡ä»¶æ”¹ä¸€ä¸‹å°±è¡Œäº†
        while (cur != b) {
            nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
        }
        // è¿”å›åè½¬åçš„å¤´ç»“ç‚¹
        return pre;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
    if (!head) return null;
    // åŒºé—´ [a, b) åŒ…å« k ä¸ªå¾…åè½¬å…ƒç´ 
    let a = head, b = head;
    for (let i = 0; i < k; i++) {
        // ä¸è¶³ k ä¸ªï¼Œä¸éœ€è¦åè½¬ï¼Œbase case
        if (!b) return head;
        b = b.next;
    }
    // åè½¬å‰ k ä¸ªå…ƒç´ 
    let newHead = reverse(a, b);
    // é€’å½’åè½¬åç»­é“¾è¡¨å¹¶è¿æ¥èµ·æ¥
    a.next = reverseKGroup(b, k);
    /** <extend up -90>
    ![](../pictures/kgroup/6.jpg)
    */
    return newHead;
};

/* åè½¬åŒºé—´ [a, b) çš„å…ƒç´ ï¼Œæ³¨æ„æ˜¯å·¦é—­å³å¼€ */
var reverse = function(a, b) {
    /** <extend up -300>
    ![](../pictures/kgroup/8.gif)
    */
    let pre = null, cur = a, nxt = a;
    // while ç»ˆæ­¢çš„æ¡ä»¶æ”¹ä¸€ä¸‹å°±è¡Œäº†
    while (cur !== b) {
        nxt = cur.next;
        cur.next = pre;
        pre = cur;
        cur = nxt;
    }
    // è¿”å›åè½¬åçš„å¤´ç»“ç‚¹
    return pre;
};
```

```python
# by chatGPT (python)
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        if not head:
            return None
        # åŒºé—´ [a, b) åŒ…å« k ä¸ªå¾…åè½¬å…ƒç´ 
        a = b = head
        for i in range(k):
            # ä¸è¶³ k ä¸ªï¼Œä¸éœ€è¦åè½¬ï¼Œbase case
            if not b:
                return head
            b = b.next
        # åè½¬å‰ k ä¸ªå…ƒç´ 
        newHead = self.reverse(a, b)
        # é€’å½’åè½¬åç»­é“¾è¡¨å¹¶è¿æ¥èµ·æ¥
        a.next = self.reverseKGroup(b, k)
        """
        <extend up -90>
        ![](../pictures/kgroup/6.jpg)
        """
        return newHead

    """ åè½¬åŒºé—´ [a, b) çš„å…ƒç´ ï¼Œæ³¨æ„æ˜¯å·¦é—­å³å¼€ """
    def reverse(self, a: ListNode, b: ListNode) -> ListNode:
        """
        <extend up -300>
        ![](../pictures/kgroup/8.gif)
        """
        pre, cur, nxt = None, a, a
        # while ç»ˆæ­¢çš„æ¡ä»¶æ”¹ä¸€ä¸‹å°±è¡Œäº†
        while cur != b:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        # è¿”å›åè½¬åçš„å¤´ç»“ç‚¹
        return pre
```

https://leetcode.cn/problems/reverse-nodes-in-k-group çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/reverse-words-in-a-string çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    string reverseWords(string s) {
        string res;
        // æ¸…æ´—ä¸€ä¸‹æ•°æ®ï¼Œå»é™¤å¤šä½™çš„ç©ºæ ¼
        for (int i = 0; i < s.size(); i++) {
            char c = s[i];
            if (c != ' ') {
                // å•è¯ä¸­çš„å­—æ¯/æ•°å­—
                res += c;
            }
 
            else if (res.back() != ' ') {
                // å•è¯ä¹‹é—´ä¿ç•™ä¸€ä¸ªç©ºæ ¼
                res += ' ';
            }
        }
        // æœ«å°¾å¦‚æœæœ‰ç©ºæ ¼ï¼Œæ¸…é™¤ä¹‹
        if (res.back() == ' ') {
            res.pop_back();
        }
 
        // æ¸…æ´—ä¹‹åçš„å­—ç¬¦ä¸²
        char *chars = new char[res.size() + 1];
        strcpy(chars, res.c_str());
        int n = strlen(chars);
        // è¿›è¡Œå•è¯çš„ç¿»è½¬ï¼Œå…ˆæ•´ä½“ç¿»è½¬
        reverse(chars, 0, n - 1);
        // å†æŠŠæ¯ä¸ªå•è¯ç¿»è½¬
        for (int i = 0; i < n; ) {
            for (int j = i; j < n; j++) {
                if (j + 1 == n || chars[j + 1] == ' ') {
                    // chars[i..j] æ˜¯ä¸€ä¸ªå•è¯ï¼Œç¿»è½¬ä¹‹
                    reverse(chars, i, j);
                    // æŠŠ i ç½®ä¸ºä¸‹ä¸€ä¸ªå•è¯çš„é¦–å­—æ¯
                    i = j + 2;
                    break;
                }
            }
        }
        // æœ€åå¾—åˆ°é¢˜ç›®æƒ³è¦çš„ç»“æœ
        return chars;
    }
 
    // ç¿»è½¬ arr[i..j]
    void reverse(char* arr, int i, int j) {
        while (i < j) {
            char temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
};
```

```go
// by chatGPT (go)
func reverseWords(s string) string {
    sb := strings.Builder{}
    // å…ˆæ¸…æ´—ä¸€ä¸‹æ•°æ®ï¼ŒæŠŠå¤šäºçš„ç©ºæ ¼éƒ½åˆ æ‰
    for i := 0; i < len(s); i++ {
        c := s[i]
        if c != ' ' {
            // å•è¯ä¸­çš„å­—æ¯/æ•°å­—
            sb.WriteByte(c)
        } else if sb.Len() > 0 && sb.String()[sb.Len()-1] != ' ' {
            // å•è¯ä¹‹é—´ä¿ç•™ä¸€ä¸ªç©ºæ ¼
            sb.WriteByte(' ')
        }
    }
    // æœ«å°¾å¦‚æœæœ‰ç©ºæ ¼ï¼Œæ¸…é™¤ä¹‹
    str := sb.String()
    if len(str) > 0 && str[len(str)-1] == ' ' {
        str = str[:len(str)-1]
    }

    // æ¸…æ´—ä¹‹åçš„å­—ç¬¦ä¸²
    chars := []byte(str)
    n := len(chars)
    // è¿›è¡Œå•è¯çš„ç¿»è½¬ï¼Œå…ˆæ•´ä½“ç¿»è½¬
    reverse(chars, 0, n-1)
    // å†æŠŠæ¯ä¸ªå•è¯ç¿»è½¬
    for i := 0; i < n; {
        for j := i; j < n; j++ {
            if j+1 == n || chars[j+1] == ' ' {
                // chars[i..j] æ˜¯ä¸€ä¸ªå•è¯ï¼Œç¿»è½¬ä¹‹
                reverse(chars, i, j)
                // æŠŠ i ç½®ä¸ºä¸‹ä¸€ä¸ªå•è¯çš„é¦–å­—æ¯
                i = j + 2
                break
            }
        }
    }
    // æœ€åå¾—åˆ°é¢˜ç›®æƒ³è¦çš„ç»“æœ
    return string(chars)
}

// ç¿»è½¬ arr[i..j]
func reverse(arr []byte, i, j int) {
    for i < j {
        arr[i], arr[j] = arr[j], arr[i]
        i++
        j--
    }
}
```

```java
// by labuladong (java)
class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = new StringBuilder();
        // å…ˆæ¸…æ´—ä¸€ä¸‹æ•°æ®ï¼ŒæŠŠå¤šäºçš„ç©ºæ ¼éƒ½åˆ æ‰
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c != ' ') {
                // å•è¯ä¸­çš„å­—æ¯/æ•°å­—
                sb.append(c);
            } else if (!sb.isEmpty() && sb.charAt(sb.length() - 1) != ' ') {
                // å•è¯ä¹‹é—´ä¿ç•™ä¸€ä¸ªç©ºæ ¼
                sb.append(' ');
            }
        }
        if (sb.isEmpty()) {
            return "";
        }
        // æœ«å°¾å¦‚æœæœ‰ç©ºæ ¼ï¼Œæ¸…é™¤ä¹‹
        if (sb.charAt(sb.length() - 1) == ' ') {
            sb.deleteCharAt(sb.length() - 1);
        }

        // æ¸…æ´—ä¹‹åçš„å­—ç¬¦ä¸²
        char[] chars = sb.toString().toCharArray();
        int n = chars.length;
        // è¿›è¡Œå•è¯çš„ç¿»è½¬ï¼Œå…ˆæ•´ä½“ç¿»è½¬
        reverse(chars, 0, n - 1);
        // å†æŠŠæ¯ä¸ªå•è¯ç¿»è½¬
        for (int i = 0; i < n; ) {
            for (int j = i; j < n; j++) {
                if (j + 1 == n || chars[j + 1] == ' ') {
                    // chars[i..j] æ˜¯ä¸€ä¸ªå•è¯ï¼Œç¿»è½¬ä¹‹
                    reverse(chars, i, j);
                    // æŠŠ i ç½®ä¸ºä¸‹ä¸€ä¸ªå•è¯çš„é¦–å­—æ¯
                    i = j + 2;
                    break;
                }
            }
        }
        // æœ€åå¾—åˆ°é¢˜ç›®æƒ³è¦çš„ç»“æœ
        return new String(chars);
    }

    // ç¿»è½¬ arr[i..j]
    void reverse(char[] arr, int i, int j) {
        while (i < j) {
            char temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var reverseWords = function(s) {
    let sb = "";
    // å…ˆæ¸…æ´—ä¸€ä¸‹æ•°æ®ï¼ŒæŠŠå¤šäºçš„ç©ºæ ¼éƒ½åˆ æ‰
    for (let i = 0; i < s.length; i++) {
        let c = s.charAt(i);
        if (c !== ' ') {
            // å•è¯ä¸­çš„å­—æ¯/æ•°å­—
            sb += c;
        } else if (sb !== "" && sb[sb.length - 1] !== ' ') {
            // å•è¯ä¹‹é—´ä¿ç•™ä¸€ä¸ªç©ºæ ¼
            sb += ' ';
        }
    }
    // æœ«å°¾å¦‚æœæœ‰ç©ºæ ¼ï¼Œæ¸…é™¤ä¹‹
    if (sb[sb.length - 1] === ' ') {
        sb = sb.substring(0, sb.length - 1);
    }

    // æ¸…æ´—ä¹‹åçš„å­—ç¬¦ä¸²
    let chars = sb.split('');
    let n = chars.length;
    // è¿›è¡Œå•è¯çš„ç¿»è½¬ï¼Œå…ˆæ•´ä½“ç¿»è½¬
    reverse(chars, 0, n - 1);
    // å†æŠŠæ¯ä¸ªå•è¯ç¿»è½¬
    for (let i = 0; i < n;) {
        for (let j = i; j < n; j++) {
            if (j + 1 === n || chars[j + 1] === ' ') {
                // chars[i..j] æ˜¯ä¸€ä¸ªå•è¯ï¼Œç¿»è½¬ä¹‹
                reverse(chars, i, j);
                // æŠŠ i ç½®ä¸ºä¸‹ä¸€ä¸ªå•è¯çš„é¦–å­—æ¯
                i = j + 2;
                break;
            }
        }
    }
    // æœ€åå¾—åˆ°é¢˜ç›®æƒ³è¦çš„ç»“æœ
    return chars.join("");
};

// ç¿»è½¬ arr[i..j]
function reverse(arr, i, j) {
    while (i < j) {
        let temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        i++;
        j--;
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def reverseWords(self, s: str) -> str:
        sb = []
        # å…ˆæ¸…æ´—ä¸€ä¸‹æ•°æ®ï¼ŒæŠŠå¤šä½™çš„ç©ºæ ¼éƒ½åˆ æ‰
        for c in s:
            if c != ' ':
                # å•è¯ä¸­çš„å­—æ¯/æ•°å­—
                sb.append(c)
            elif sb and sb[-1] != ' ':
                # å•è¯ä¹‹é—´ä¿ç•™ä¸€ä¸ªç©ºæ ¼
                sb.append(' ')
        # æœ«å°¾å¦‚æœæœ‰ç©ºæ ¼ï¼Œæ¸…é™¤ä¹‹
        if sb and sb[-1] == ' ':
            sb.pop()
        
        # æ¸…æ´—ä¹‹åçš„å­—ç¬¦ä¸²
        chars = sb

        # è¿›è¡Œå•è¯çš„ç¿»è½¬ï¼Œå…ˆæ•´ä½“ç¿»è½¬
        def reverse(l, r):
            while l < r:
                chars[l], chars[r] = chars[r], chars[l]
                l += 1
                r -= 1
        
        n = len(chars)
        reverse(0, n-1)
        
        # å†æŠŠæ¯ä¸ªå•è¯ç¿»è½¬
        start = end = 0
        while end < n:
            if chars[end] == ' ':
                reverse(start, end-1)
                start = end + 1
            end += 1
        
        # ç¿»è½¬æœ€åä¸€ä¸ªå•è¯
        reverse(start, n-1)
        
        # æœ€åå¾—åˆ°é¢˜ç›®æƒ³è¦çš„ç»“æœ
        return "".join(chars)
```

https://leetcode.cn/problems/reverse-words-in-a-string çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/rotate-image çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        // å…ˆæ²¿å¯¹è§’çº¿åè½¬äºŒç»´çŸ©é˜µ
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                // swap(matrix[i][j], matrix[j][i]);
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        // ç„¶ååè½¬äºŒç»´çŸ©é˜µçš„æ¯ä¸€è¡Œ
        for (auto& row : matrix) {
            ::reverse(row.begin(), row.end());
        }
    }

    // åè½¬ä¸€ç»´æ•°ç»„
    void reverse(vector<int>& arr) {
        int i = 0, j = arr.size() - 1;
        while (j > i) {
            // swap(arr[i], arr[j]);
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
};
```

```go
// by chatGPT (go)
func rotate(matrix [][]int) {
    n := len(matrix)
    // å…ˆæ²¿å¯¹è§’çº¿åè½¬äºŒç»´çŸ©é˜µ
    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
    // ç„¶ååè½¬äºŒç»´çŸ©é˜µçš„æ¯ä¸€è¡Œ
    for _, row := range matrix {
        reverse(row)
    }
}

// åè½¬ä¸€ç»´æ•°ç»„
func reverse(arr []int) {
    i, j := 0, len(arr) - 1
    for j > i {
        arr[i], arr[j] = arr[j], arr[i]
        i++
        j--
    }
}
```

```java
// by labuladong (java)
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // å…ˆæ²¿å¯¹è§’çº¿åè½¬äºŒç»´çŸ©é˜µ
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                // swap(matrix[i][j], matrix[j][i]);
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        // ç„¶ååè½¬äºŒç»´çŸ©é˜µçš„æ¯ä¸€è¡Œ
        for (int[] row : matrix) {
            reverse(row);
        }
    }

    // åè½¬ä¸€ç»´æ•°ç»„
    void reverse(int[] arr) {
        int i = 0, j = arr.length - 1;
        while (j > i) {
            // swap(arr[i], arr[j]);
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
    var n = matrix.length;
    // å…ˆæ²¿å¯¹è§’çº¿åè½¬äºŒç»´çŸ©é˜µ
    for (var i = 0; i < n; i++) {
        for (var j = i; j < n; j++) {
            // swap(matrix[i][j], matrix[j][i]);
            var temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
    // ç„¶ååè½¬äºŒç»´çŸ©é˜µçš„æ¯ä¸€è¡Œ
    for (var row of matrix) {
        reverse(row);
    }
}

// åè½¬ä¸€ç»´æ•°ç»„
function reverse(arr) {
    var i = 0, j = arr.length - 1;
    while (j > i) {
        // swap(arr[i], arr[j]);
        var temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        i++;
        j--;
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        n = len(matrix)
        # å…ˆæ²¿å¯¹è§’çº¿åè½¬äºŒç»´çŸ©é˜µ
        for i in range(n):
            for j in range(i, n):
                # swap(matrix[i][j], matrix[j][i]);
                temp = matrix[i][j]
                matrix[i][j] = matrix[j][i]
                matrix[j][i] = temp
        # ç„¶ååè½¬äºŒç»´çŸ©é˜µçš„æ¯ä¸€è¡Œ
        for row in matrix:
            self.reverse(row)
    
    # åè½¬ä¸€ç»´æ•°ç»„
    def reverse(self, arr: List[int]) -> None:
        i, j = 0, len(arr) - 1
        while j > i:
            # swap(arr[i], arr[j]);
            temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
            i += 1
            j -= 1
```

https://leetcode.cn/problems/rotate-image çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/russian-doll-envelopes çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        int n = envelopes.size();
        // æŒ‰å®½åº¦å‡åºæ’åˆ—ï¼Œå¦‚æœå®½åº¦ä¸€æ ·ï¼Œåˆ™æŒ‰é«˜åº¦é™åºæ’åˆ—
        sort(envelopes.begin(), envelopes.end(), [](vector<int>& a, vector<int>& b){
            if(a[0] == b[0]){
                return b[1] < a[1];
            }else{
                return a[0] < b[0];
            }
        });
        // å¯¹é«˜åº¦æ•°ç»„å¯»æ‰¾ LIS
        vector<int> height(n);
        for (int i = 0; i < n; i++){
            height[i] = envelopes[i][1];
        }
        return lengthOfLIS(height);
    }

    /* è¿”å› nums ä¸­ LIS çš„é•¿åº¦ */
    int lengthOfLIS(vector<int>& nums) {
        int piles = 0, n = nums.size();
        vector<int> top(n);
        for (int i = 0; i < n; i++) {
            // è¦å¤„ç†çš„æ‰‘å…‹ç‰Œ
            int poker = nums[i];
            int left = 0, right = piles;
            // äºŒåˆ†æŸ¥æ‰¾æ’å…¥ä½ç½®
            while (left < right) {
                int mid = (left + right) / 2;
                if (top[mid] >= poker)
                    right = mid;
                else
                    left = mid + 1;
            }
            if (left == piles) piles++;
            // æŠŠè¿™å¼ ç‰Œæ”¾åˆ°ç‰Œå †é¡¶
            top[left] = poker;
        }
        // ç‰Œå †æ•°å°±æ˜¯ LIS é•¿åº¦
        return piles;
    }
};
```

```go
// by chatGPT (go)
import "sort"

func maxEnvelopes(envelopes [][]int) int {
    n := len(envelopes)
    // æŒ‰å®½åº¦å‡åºæ’åˆ—ï¼Œå¦‚æœå®½åº¦ä¸€æ ·ï¼Œåˆ™æŒ‰é«˜åº¦é™åºæ’åˆ—
    sort.Slice(envelopes, func(i, j int) bool {
        if envelopes[i][0] < envelopes[j][0] {
            return true
        }
        if envelopes[i][0] == envelopes[j][0] {
            return envelopes[i][1] > envelopes[j][1]
        }
        return false
    })
    // å¯¹é«˜åº¦æ•°ç»„å¯»æ‰¾ LIS
    height := make([]int, n)
    for i := 0; i < n; i++ {
        height[i] = envelopes[i][1]
    }

    return lengthOfLIS(height)
}

/* è¿”å› nums ä¸­ LIS çš„é•¿åº¦ */
func lengthOfLIS(nums []int) int {
    piles, n := 0, len(nums)
    top := make([]int, n)
    for i := 0; i < n; i++ {
        // è¦å¤„ç†çš„æ‰‘å…‹ç‰Œ
        poker := nums[i]
        left, right := 0, piles
        // äºŒåˆ†æŸ¥æ‰¾æ’å…¥ä½ç½®
        for left < right {
            mid := (left + right) / 2
            if top[mid] >= poker {
                right = mid
            } else {
                left = mid + 1
            }
        }
        if left == piles {
            piles++
        }
        // æŠŠè¿™å¼ ç‰Œæ”¾åˆ°ç‰Œå †é¡¶
        top[left] = poker
    }
    // ç‰Œå †æ•°å°±æ˜¯ LIS é•¿åº¦
    return piles
}
```

```java
// by labuladong (java)
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        int n = envelopes.length;
        // æŒ‰å®½åº¦å‡åºæ’åˆ—ï¼Œå¦‚æœå®½åº¦ä¸€æ ·ï¼Œåˆ™æŒ‰é«˜åº¦é™åºæ’åˆ—
        Arrays.sort(envelopes, new Comparator<int[]>() 
        {
            public int compare(int[] a, int[] b) {
                return a[0] == b[0] ? 
                    b[1] - a[1] : a[0] - b[0];
            }
        });
        // å¯¹é«˜åº¦æ•°ç»„å¯»æ‰¾ LIS
        int[] height = new int[n];
        for (int i = 0; i < n; i++)
            height[i] = envelopes[i][1];

        return lengthOfLIS(height);
    }

    /* è¿”å› nums ä¸­ LIS çš„é•¿åº¦ */
    public int lengthOfLIS(int[] nums) {
        int piles = 0, n = nums.length;
        int[] top = new int[n];
        for (int i = 0; i < n; i++) {
            // è¦å¤„ç†çš„æ‰‘å…‹ç‰Œ
            int poker = nums[i];
            int left = 0, right = piles;
            // äºŒåˆ†æŸ¥æ‰¾æ’å…¥ä½ç½®
            while (left < right) {
                int mid = (left + right) / 2;
                if (top[mid] >= poker)
                    right = mid;
                else
                    left = mid + 1;
            }
            if (left == piles) piles++;
            // æŠŠè¿™å¼ ç‰Œæ”¾åˆ°ç‰Œå †é¡¶
            top[left] = poker;
        }
        // ç‰Œå †æ•°å°±æ˜¯ LIS é•¿åº¦
        return piles;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} envelopes
 * @return {number}
 */
var maxEnvelopes = function(envelopes) {
    const n = envelopes.length;
    // æŒ‰å®½åº¦å‡åºæ’åˆ—ï¼Œå¦‚æœå®½åº¦ä¸€æ ·ï¼Œåˆ™æŒ‰é«˜åº¦é™åºæ’åˆ—
    envelopes.sort((a, b) => {
        if (a[0] === b[0]) {
            return b[1] - a[1];
        } else {
            return a[0] - b[0];
        }
    });

    // å¯¹é«˜åº¦æ•°ç»„å¯»æ‰¾ LIS
    const height = new Array(n).fill(0).map((_, i) => envelopes[i][1]);
    return lengthOfLIS(height);
}

/**
 * @param {number[]} nums
 * @return {number}
 */
const lengthOfLIS = (nums) => {
    // piles è¡¨ç¤ºç‰Œå †æ•°
    let piles = 0;
    const n = nums.length;
    const top = new Array(n).fill(0);

    for (let i = 0; i < n; i++) {
        // è¦å¤„ç†çš„æ‰‘å…‹ç‰Œ
        let poker = nums[i];
        let left = 0;
        let right = piles;

        // äºŒåˆ†æŸ¥æ‰¾æ’å…¥ä½ç½®
        while (left < right) {
            let mid = Math.floor((left + right) / 2);
            if (top[mid] >= poker) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        if (left === piles) piles++;
        // æŠŠè¿™å¼ ç‰Œæ”¾åˆ°ç‰Œå †é¡¶
        top[left] = poker;
    }

    // ç‰Œå †æ•°å°±æ˜¯ LIS é•¿åº¦
    return piles;
};
```

```python
# by chatGPT (python)
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        n = len(envelopes)
        # æŒ‰å®½åº¦å‡åºæ’åˆ—ï¼Œå¦‚æœå®½åº¦ä¸€æ ·ï¼Œåˆ™æŒ‰é«˜åº¦é™åºæ’åˆ—
        envelopes.sort(key=lambda x: (x[0], -x[1]))
        # å¯¹é«˜åº¦æ•°ç»„å¯»æ‰¾ LIS
        height = [0] * n
        for i in range(n):
            height[i] = envelopes[i][1]

        return self.lengthOfLIS(height)

    def lengthOfLIS(self, nums: List[int]) -> int:
        piles = 0
        n = len(nums)
        top = [0] * n
        for i in range(n):
            # è¦å¤„ç†çš„æ‰‘å…‹ç‰Œ
            poker = nums[i]
            left, right = 0, piles
            # äºŒåˆ†æŸ¥æ‰¾æ’å…¥ä½ç½®
            while left < right:
                mid = (left + right) // 2
                if top[mid] >= poker:
                    right = mid
                else:
                    left = mid + 1
            if left == piles:
                piles += 1
            # æŠŠè¿™å¼ ç‰Œæ”¾åˆ°ç‰Œå †é¡¶
            top[left] = poker
        # ç‰Œå †æ•°å°±æ˜¯ LIS é•¿åº¦
        return piles
```

https://leetcode.cn/problems/russian-doll-envelopes çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/same-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
// å®šä¹‰ï¼šè¾“å…¥ä¸¤ä¸ªæ ¹èŠ‚ç‚¹ï¼Œè¿”å›ä»¥å®ƒä»¬ä¸ºæ ¹çš„ä¸¤æ£µäºŒå‰æ ‘æ˜¯å¦ç›¸åŒ
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // åˆ¤æ–­ä¸€å¯¹èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ
        if (p == nullptr && q == nullptr) {
            return true;
        }
        if (p == nullptr || q == nullptr) {
            return false;
        }
        if (p->val != q->val) {
            return false;
        }
        // åˆ¤æ–­å…¶ä»–èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

```go
// by chatGPT (go)
// å®šä¹‰ï¼šè¾“å…¥ä¸¤ä¸ªæ ¹èŠ‚ç‚¹ï¼Œè¿”å›ä»¥å®ƒä»¬ä¸ºæ ¹çš„ä¸¤æ£µäºŒå‰æ ‘æ˜¯å¦ç›¸åŒ
 func isSameTree(p *TreeNode, q *TreeNode) bool {
     // åˆ¤æ–­ä¸€å¯¹èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ
     if p == nil && q == nil {
         return true
     }
     if p == nil || q == nil {
         return false
     }
     if p.Val != q.Val {
         return false
     }
     // åˆ¤æ–­å…¶ä»–èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ
     return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)
 }
```

```java
// by labuladong (java)
class Solution {
    // å®šä¹‰ï¼šè¾“å…¥ä¸¤ä¸ªæ ¹èŠ‚ç‚¹ï¼Œè¿”å›ä»¥å®ƒä»¬ä¸ºæ ¹çš„ä¸¤æ£µäºŒå‰æ ‘æ˜¯å¦ç›¸åŒ
    public boolean isSameTree(TreeNode p, TreeNode q) {
        // åˆ¤æ–­ä¸€å¯¹èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        if (p.val != q.val) {
            return false;
        }
        // åˆ¤æ–­å…¶ä»–èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * å®šä¹‰ï¼šè¾“å…¥ä¸¤ä¸ªæ ¹èŠ‚ç‚¹ï¼Œè¿”å›ä»¥å®ƒä»¬ä¸ºæ ¹çš„ä¸¤æ£µäºŒå‰æ ‘æ˜¯å¦ç›¸åŒ
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    // åˆ¤æ–­ä¸€å¯¹èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ
    if (p == null && q == null) {
        return true;
    }
    if (p == null || q == null) {
        return false;
    }
    if (p.val != q.val) {
        return false;
    }
    // åˆ¤æ–­å…¶ä»–èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
};
```

```python
# by chatGPT (python)
# å®šä¹‰ï¼šè¾“å…¥ä¸¤ä¸ªæ ¹èŠ‚ç‚¹ï¼Œè¿”å›ä»¥å®ƒä»¬ä¸ºæ ¹çš„ä¸¤æ£µäºŒå‰æ ‘æ˜¯å¦ç›¸åŒ
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        # åˆ¤æ–­ä¸€å¯¹èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ
        if p == None and q == None:
            return True
        if p == None or q == None:
            return False
        if p.val != q.val:
            return False
        # åˆ¤æ–­å…¶ä»–èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

https://leetcode.cn/problems/same-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/satisfiability-of-equality-equations çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        // 26 ä¸ªè‹±æ–‡å­—æ¯
        UF uf(26);
        // å…ˆè®©ç›¸ç­‰çš„å­—æ¯å½¢æˆè¿é€šåˆ†é‡
        for (string eq : equations) {
            if (eq[1] == '=') {
                char x = eq[0];
                char y = eq[3];
                uf.union_(x - 'a', y - 'a');
            }
        }
        // æ£€æŸ¥ä¸ç­‰å…³ç³»æ˜¯å¦æ‰“ç ´ç›¸ç­‰å…³ç³»çš„è¿é€šæ€§
        for (string eq : equations) {
            if (eq[1] == '!') {
                char x = eq[0];
                char y = eq[3];
                // å¦‚æœç›¸ç­‰å…³ç³»æˆç«‹ï¼Œå°±æ˜¯é€»è¾‘å†²çª
                if (uf.connected(x - 'a', y - 'a'))
                    return false;
            }
        }
        return true;
    }
};

class UF {
public:
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    int count;
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    vector<int> parent;
    // è®°å½•æ ‘çš„â€œé‡é‡â€
    vector<int> size;

    UF(int n) {
        this->count = n;
        parent.resize(n);
        size.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    /* å°† p å’Œ q è¿é€š */
    void union_(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    /* åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š */
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP == rootQ;
    }

    /* è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹ */
    int find(int x) {
        while (parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    int getCount() {
        return count;
    }
};
```

```go
// by chatGPT (go)
type UF struct {
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    Count int
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    Parent []int
    // è®°å½•æ ‘çš„â€œé‡é‡â€
    Size []int
}

func NewUF(n int) *UF {
    u := UF{}
    u.Count = n
    u.Parent = make([]int, n)
    u.Size = make([]int, n)
    for i := 0; i < n; i++ {
        u.Parent[i] = i
        u.Size[i] = 1
    }
    return &u
}

/* å°† p å’Œ q è¿é€š */
func (u *UF) Union(p, q int) {
    rootP := u.find(p)
    rootQ := u.find(q)
    if rootP == rootQ {
        return
    }

    // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
    if u.Size[rootP] > u.Size[rootQ] {
        u.Parent[rootQ] = rootP
        u.Size[rootP] += u.Size[rootQ]
    } else {
        u.Parent[rootP] = rootQ
        u.Size[rootQ] += u.Size[rootP]
    }
    u.Count--
}

/* åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š */
func (u *UF) Connected(p, q int) bool {
    rootP := u.find(p)
    rootQ := u.find(q)
    // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
    return rootP == rootQ
}

/* è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹ */
func (u *UF) find(x int) int {
    for u.Parent[x] != x {
        // è¿›è¡Œè·¯å¾„å‹ç¼©
        u.Parent[x] = u.Parent[u.Parent[x]]
        x = u.Parent[x]
    }
    return x
}

func equationsPossible(equations []string) bool {
    // 26 ä¸ªè‹±æ–‡å­—æ¯
    uf := NewUF(26)
    // å…ˆè®©ç›¸ç­‰çš„å­—æ¯å½¢æˆè¿é€šåˆ†é‡
    for _, eq := range equations {
        if eq[1] == '=' {
            x := eq[0]
            y := eq[3]
            uf.Union(int(x-'a'), int(y-'a'))
        }
    }
    // æ£€æŸ¥ä¸ç­‰å…³ç³»æ˜¯å¦æ‰“ç ´ç›¸ç­‰å…³ç³»çš„è¿é€šæ€§
    for _, eq := range equations {
        if eq[1] == '!' {
            x := eq[0]
            y := eq[3]
            // å¦‚æœç›¸ç­‰å…³ç³»æˆç«‹ï¼Œå°±æ˜¯é€»è¾‘å†²çª
            if uf.Connected(int(x-'a'), int(y-'a')) {
                return false
            }
        }
    }
    return true
}
```

```java
// by labuladong (java)
class Solution {
    public boolean equationsPossible(String[] equations) {
        // 26 ä¸ªè‹±æ–‡å­—æ¯
        UF uf = new UF(26);
        // å…ˆè®©ç›¸ç­‰çš„å­—æ¯å½¢æˆè¿é€šåˆ†é‡
        for (String eq : equations) {
            if (eq.charAt(1) == '=') {
                char x = eq.charAt(0);
                char y = eq.charAt(3);
                uf.union(x - 'a', y - 'a');
            }
        }
        // æ£€æŸ¥ä¸ç­‰å…³ç³»æ˜¯å¦æ‰“ç ´ç›¸ç­‰å…³ç³»çš„è¿é€šæ€§
        for (String eq : equations) {
            if (eq.charAt(1) == '!') {
                char x = eq.charAt(0);
                char y = eq.charAt(3);
                // å¦‚æœç›¸ç­‰å…³ç³»æˆç«‹ï¼Œå°±æ˜¯é€»è¾‘å†²çª
                if (uf.connected(x - 'a', y - 'a'))
                    return false;
            }
        }
        return true;
    }
}

class UF {
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    private int count;
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    private int[] parent;
    // è®°å½•æ ‘çš„â€œé‡é‡â€
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    /* å°† p å’Œ q è¿é€š */
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    /* åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š */
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP == rootQ;
    }

    /* è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹ */
    private int find(int x) {
        while (parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public int count() {
        return count;
    }
}
```

```javascript
// by chatGPT (javascript)
var equationsPossible = function(equations) {
    // 26 ä¸ªè‹±æ–‡å­—æ¯
  let uf = new ufFunc(26);
  // å…ˆè®©ç›¸ç­‰çš„å­—æ¯å½¢æˆè¿é€šåˆ†é‡
  for (let i = 0 ; i <equations.length; i++) {
    let eq = equations[i];
    if (eq.charAt(1) == '=') {
      let x = eq.charAt(0);
      let y = eq.charAt(3);
      uf.union(x.charCodeAt()-97, y.charCodeAt()-97);
    }
  }
  // æ£€æŸ¥ä¸ç­‰å…³ç³»æ˜¯å¦æ‰“ç ´ç›¸ç­‰å…³ç³»çš„è¿é€šæ€§
  for (let i = 0 ; i <equations.length; i++) {
    let eq = equations[i];
    if (eq.charAt(1) == '!') {
      let x = eq.charAt(0);
      let y = eq.charAt(3);
      // å¦‚æœç›¸ç­‰å…³ç³»æˆç«‹ï¼Œå°±æ˜¯é€»è¾‘å†²çª
      if (uf.connected(x.charCodeAt()-97, y.charCodeAt()-97))
        return false;
      }
  }
  return true;
 }

class ufFunc {
  // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
  constructor(n) {
    this.count = n;
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    this.parent = [];
    // è®°å½•æ ‘çš„â€œé‡é‡â€
    this.size = [];
    for (let i = 0; i < n; i++) {
      this.parent.push(i);
      this.size.push(1);
    }
  }

  /* å°† p å’Œ q è¿é€š */
  union(p, q) {
    let rootP = this.find(p);
    let rootQ = this.find(q);
    if (rootP == rootQ)
      return;

    // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
    if (this.size[rootP] > this.size[rootQ]) {
      this.parent[rootQ] = rootP;
      this.size[rootP] += this.size[rootQ];
    } else {
      this.parent[rootP] = rootQ;
      this.size[rootQ] += this.size[rootP];
    }
    this.count--;
  }

  /* åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š */
  connected(p, q) {
    let rootP = this.find(p);
    let rootQ = this.find(q);
    // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
    return rootP == rootQ;
  }

  /* è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹ */
  find(x) {
    while (this.parent[x] != x) {
      // è¿›è¡Œè·¯å¾„å‹ç¼©
      this.parent[x] = this.parent[this.parent[x]];
      x = this.parent[x];
    }
    return x;
  }

  count() {
      return this.count;
  }
}
```

```python
# by chatGPT (python)
class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        uf = UF(26) #26ä¸ªå­—æ¯
        # å…ˆè®©ç›¸ç­‰çš„å­—æ¯å½¢æˆè¿é€šåˆ†é‡
        for eq in equations:
            if eq[1] == "=":
                x = ord(eq[0]) - ord('a')
                y = ord(eq[3]) - ord('a')
                uf.union(x, y)

        # æ£€æŸ¥ä¸ç­‰å…³ç³»æ˜¯å¦æ‰“ç ´ç›¸ç­‰å…³ç³»çš„è¿é€šæ€§
        for eq in equations:
            if eq[1] == "!":
                x = ord(eq[0]) - ord('a')
                y = ord(eq[3]) - ord('a')
                # å¦‚æœç›¸ç­‰å…³ç³»æˆç«‹ï¼Œå°±æ˜¯é€»è¾‘å†²çª
                if uf.connected(x, y):
                    return False
        return True

class UF:
    # è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    def __init__(self, n):
        self.count = n
        # å­˜å‚¨è‹¥å¹²æ£µæ ‘
        self.parent = [i for i in range(n)]
        # è®°å½•æ ‘çš„â€œé‡é‡â€
        self.size = [1] * n

    # å°† p å’Œ q è¿é€š
    def union(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP == rootQ:
            return

        # å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if self.size[rootP] > self.size[rootQ]:
            self.parent[rootQ] = rootP
            self.size[rootP] += self.size[rootQ]
        else:
            self.parent[rootP] = rootQ
            self.size[rootQ] += self.size[rootP]
        self.count -= 1

    # åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š
    def connected(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        # å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP == rootQ

    # è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹
    def find(self, x):
        while self.parent[x] != x:
            # è¿›è¡Œè·¯å¾„å‹ç¼©
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def count(self):
        return self.count
```

https://leetcode.cn/problems/satisfiability-of-equality-equations çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/search-a-2d-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        // æŠŠäºŒç»´æ•°ç»„æ˜ å°„åˆ°ä¸€ç»´
        int left = 0, right = m * n - 1;
        // å‰æ–‡è®²çš„æ ‡å‡†çš„äºŒåˆ†æœç´¢æ¡†æ¶
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(get(matrix, mid) == target)
                return true;
            else if (get(matrix, mid) < target)
                left = mid + 1;
            else if (get(matrix, mid) > target)
                right = mid - 1;
        }
        return false;
    }

    // é€šè¿‡ä¸€ç»´åæ ‡è®¿é—®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
    int get(vector<vector<int>>& matrix, int index) {
        int m = matrix.size(), n = matrix[0].size();
        // è®¡ç®—äºŒç»´ä¸­çš„æ¨ªçºµåæ ‡
        int i = index / n, j = index % n;
        return matrix[i][j];
    }
};
```

```go
// by chatGPT (go)
func searchMatrix(matrix [][]int, target int) bool {
    m, n := len(matrix), len(matrix[0])
    // æŠŠäºŒç»´æ•°ç»„æ˜ å°„åˆ°ä¸€ç»´
    left, right := 0, m*n-1
    // å‰æ–‡è®²çš„æ ‡å‡†çš„äºŒåˆ†æœç´¢æ¡†æ¶
    for left <= right {
        mid := left + (right-left)/2
        if get(matrix, mid) == target {
            return true
        } else if get(matrix, mid) < target {
            left = mid + 1
        } else if get(matrix, mid) > target {
            right = mid - 1
        }
    }
    return false
}

// é€šè¿‡ä¸€ç»´åæ ‡è®¿é—®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
func get(matrix [][]int, index int) int {
    n := len(matrix[0])
    // è®¡ç®—äºŒç»´ä¸­çš„æ¨ªçºµåæ ‡
    i, j := index/n, index%n
    return matrix[i][j]
}
```

```java
// by labuladong (java)
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length;
        // æŠŠäºŒç»´æ•°ç»„æ˜ å°„åˆ°ä¸€ç»´
        int left = 0, right = m * n - 1;
        // å‰æ–‡è®²çš„æ ‡å‡†çš„äºŒåˆ†æœç´¢æ¡†æ¶
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(get(matrix, mid) == target)
                return true;
            else if (get(matrix, mid) < target)
                left = mid + 1;
            else if (get(matrix, mid) > target)
                right = mid - 1;
        }
        return false;
    }

    // é€šè¿‡ä¸€ç»´åæ ‡è®¿é—®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
    int get(int[][] matrix, int index) {
        int m = matrix.length, n = matrix[0].length;
        // è®¡ç®—äºŒç»´ä¸­çš„æ¨ªçºµåæ ‡
        int i = index / n, j = index % n;
        return matrix[i][j];
    }
}
```

```javascript
// by chatGPT (javascript)
var searchMatrix = function(matrix, target) {
    var m = matrix.length, n = matrix[0].length;
    // æŠŠäºŒç»´æ•°ç»„æ˜ å°„åˆ°ä¸€ç»´
    var left = 0, right = m * n - 1;
    // å‰æ–‡è®²çš„æ ‡å‡†çš„äºŒåˆ†æœç´¢æ¡†æ¶
    while(left <= right) {
        var mid = left + Math.floor((right - left) / 2);
        if(get(matrix, mid) == target)
            return true;
        else if (get(matrix, mid) < target)
            left = mid + 1;
        else if (get(matrix, mid) > target)
            right = mid - 1;
    }
    return false;
};

// é€šè¿‡ä¸€ç»´åæ ‡è®¿é—®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
var get = function(matrix, index) {
    var m = matrix.length, n = matrix[0].length;
    // è®¡ç®—äºŒç»´ä¸­çš„æ¨ªçºµåæ ‡
    var i = Math.floor(index / n), j = index % n;
    return matrix[i][j];
};
```

```python
# by chatGPT (python)
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m, n = len(matrix), len(matrix[0])
        # æŠŠäºŒç»´æ•°ç»„æ˜ å°„åˆ°ä¸€ç»´
        left, right = 0, m * n - 1
        # å‰æ–‡è®²çš„æ ‡å‡†çš„äºŒåˆ†æœç´¢æ¡†æ¶
        while(left <= right):
            mid = left + (right - left) // 2
            if(self.get(matrix, mid) == target):
                return True
            elif self.get(matrix, mid) < target:
                left = mid + 1
            elif self.get(matrix, mid) > target:
                right = mid - 1
        return False

    # é€šè¿‡ä¸€ç»´åæ ‡è®¿é—®äºŒç»´æ•°ç»„ä¸­çš„å…ƒç´ 
    def get(self, matrix: List[List[int]], index: int) -> int:
        m, n = len(matrix), len(matrix[0])
        # è®¡ç®—äºŒç»´ä¸­çš„æ¨ªçºµåæ ‡
        i, j = index // n, index % n
        return matrix[i][j]
```

https://leetcode.cn/problems/search-a-2d-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/search-a-2d-matrix-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        // åˆå§‹åŒ–åœ¨å³ä¸Šè§’
        int i = 0, j = n - 1;
        while (i < m && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            }
            if (matrix[i][j] < target) {
                // éœ€è¦å¤§ä¸€ç‚¹ï¼Œå¾€ä¸‹ç§»åŠ¨
                i++;
            } else {
                // éœ€è¦å°ä¸€ç‚¹ï¼Œå¾€å·¦ç§»åŠ¨
                j--;
            }
        }
        // while å¾ªç¯ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™ target ä¸å­˜åœ¨
        return false;
    }
};
```

```go
// by chatGPT (go)
func searchMatrix(matrix [][]int, target int) bool {
    m, n := len(matrix), len(matrix[0])
    // åˆå§‹åŒ–åœ¨å³ä¸Šè§’
    i, j := 0, n-1
    for i < m && j >= 0 {
        if matrix[i][j] == target {
            return true
        }
        if matrix[i][j] < target {
            // éœ€è¦å¤§ä¸€ç‚¹ï¼Œå¾€ä¸‹ç§»åŠ¨
            i++
        } else {
            // éœ€è¦å°ä¸€ç‚¹ï¼Œå¾€å·¦ç§»åŠ¨
            j--
        }
    }
    // for å¾ªç¯ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™ target ä¸å­˜åœ¨
    return false
}
```

```java
// by labuladong (java)
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length;
        // åˆå§‹åŒ–åœ¨å³ä¸Šè§’
        int i = 0, j = n - 1;
        while (i < m && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            }
            if (matrix[i][j] < target) {
                // éœ€è¦å¤§ä¸€ç‚¹ï¼Œå¾€ä¸‹ç§»åŠ¨
                i++;
            } else {
                // éœ€è¦å°ä¸€ç‚¹ï¼Œå¾€å·¦ç§»åŠ¨
                j--;
            }
        }
        // while å¾ªç¯ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™ target ä¸å­˜åœ¨
        return false;
    }
}
```

```javascript
// by chatGPT (javascript)
var searchMatrix = function(matrix, target) {
    var m = matrix.length, n = matrix[0].length;
    // åˆå§‹åŒ–åœ¨å³ä¸Šè§’
    var i = 0, j = n - 1;
    while (i < m && j >= 0) {
        if (matrix[i][j] == target) {
            return true;
        }
        if (matrix[i][j] < target) {
            // éœ€è¦å¤§ä¸€ç‚¹ï¼Œå¾€ä¸‹ç§»åŠ¨
            i++;
        } else {
            // éœ€è¦å°ä¸€ç‚¹ï¼Œå¾€å·¦ç§»åŠ¨
            j--;
        }
    }
    // while å¾ªç¯ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™ target ä¸å­˜åœ¨
    return false;
};
```

```python
# by chatGPT (python)
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m, n = len(matrix), len(matrix[0])
        # åˆå§‹åŒ–åœ¨å³ä¸Šè§’
        i, j = 0, n - 1
        while i < m and j >= 0:
            if matrix[i][j] == target:
                return True
            if matrix[i][j] < target:
                # éœ€è¦å¤§ä¸€ç‚¹ï¼Œå¾€ä¸‹ç§»åŠ¨
                i += 1
            else:
                # éœ€è¦å°ä¸€ç‚¹ï¼Œå¾€å·¦ç§»åŠ¨
                j -= 1
        # while å¾ªç¯ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™ target ä¸å­˜åœ¨
        return False
```

https://leetcode.cn/problems/search-a-2d-matrix-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/search-in-a-binary-search-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int target) {
        if (root == NULL) {
            return NULL;
        }
        // å»å·¦å­æ ‘æœç´¢
        if (root->val > target) {
            return searchBST(root->left, target);
        }
        // å»å³å­æ ‘æœç´¢
        if (root->val < target) {
            return searchBST(root->right, target);
        }
        return root;
    }
};
```

```go
// by chatGPT (go)
func searchBST(root *TreeNode, target int) *TreeNode {
    if root == nil {
        return nil
    }
    // å»å·¦å­æ ‘æœç´¢
    if root.Val > target {
        return searchBST(root.Left, target)
    }
    // å»å³å­æ ‘æœç´¢
    if root.Val < target {
        return searchBST(root.Right, target)
    }
    return root
}
```

```java
// by labuladong (java)
class Solution {
    public TreeNode searchBST(TreeNode root, int target) {
        if (root == null) {
            return null;
        }
        // å»å·¦å­æ ‘æœç´¢
        if (root.val > target) {
            return searchBST(root.left, target);
        }
        // å»å³å­æ ‘æœç´¢
        if (root.val < target) {
            return searchBST(root.right, target);
        }
        return root;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
var searchBST = function(root, val) {
    if (root === null) {
        return null;
    }
    // å»å·¦å­æ ‘æœç´¢
    if (root.val > val) {
        return searchBST(root.left, val);
    }
    // å»å³å­æ ‘æœç´¢
    if (root.val < val) {
        return searchBST(root.right, val);
    }
    return root;
};
```

```python
# by chatGPT (python)
class Solution:
    def searchBST(self, root: TreeNode, target: int) -> TreeNode:
        if not root:
            return None
        # å»å·¦å­æ ‘æœç´¢
        if root.val > target:
            return self.searchBST(root.left, target)
        # å»å³å­æ ‘æœç´¢
        if root.val < target:
            return self.searchBST(root.right, target)
        return root
```

https://leetcode.cn/problems/search-in-a-binary-search-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/search-insert-position çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        return left_bound(nums, target);
    }

    // æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†ç®—æ³•
    int left_bound(vector<int>& nums, int target) {
        if (nums.size() == 0) return -1;
        int left = 0;
        int right = nums.size(); // æ³¨æ„

        while (left < right) { // æ³¨æ„
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid; // æ³¨æ„
            }
        }
        return left;
    }
};
```

```go
// by chatGPT (go)
import "fmt"

func searchInsert(nums []int, target int) int {
    return leftBound(nums, target)
}

// leftBound is a binary search algorithm that searches for the left boundary
func leftBound(nums []int, target int) int {
    if len(nums) == 0 {
        return -1
    }
    left, right := 0, len(nums) // æ³¨æ„

    for left < right { // æ³¨æ„
        mid := left + (right-left)/2
        if nums[mid] == target {
            right = mid
        } else if nums[mid] < target {
            left = mid + 1
        } else if nums[mid] > target {
            right = mid // æ³¨æ„
        }
    }
    return left
}
```

```java
// by labuladong (java)
class Solution {
    public int searchInsert(int[] nums, int target) {
        return left_bound(nums, target);
    }

    // æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†ç®—æ³•
    int left_bound(int[] nums, int target) {
        if (nums.length == 0) return -1;
        int left = 0;
        int right = nums.length; // æ³¨æ„

        while (left < right) { // æ³¨æ„
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid; // æ³¨æ„
            }
        }
        return left;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    return left_bound(nums, target);
};

/**
 * æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†ç®—æ³•
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var left_bound = function(nums, target) {
    if (nums.length == 0) return -1;
    let left = 0;
    let right = nums.length; // æ³¨æ„

    while (left < right) { // æ³¨æ„
        let mid = left + Math.floor((right - left) / 2);
        if (nums[mid] == target) {
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // æ³¨æ„
        }
    }
    return left;
};
```

```python
# by chatGPT (python)
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        return self.left_bound(nums, target)

    # æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†ç®—æ³•
    def left_bound(self, nums: List[int], target: int) -> int:
        if not nums:
            return -1
        left = 0
        right = len(nums)  # æ³¨æ„

        while left < right:  # æ³¨æ„
            mid = left + (right - left) // 2
            if nums[mid] == target:
                right = mid
            elif nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid  # æ³¨æ„

        return left
```

https://leetcode.cn/problems/search-insert-position çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/seat-reservation-manager çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class SeatManager {
    // åˆ©ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—è‡ªåŠ¨æ’åºï¼Œé˜Ÿå¤´çš„å…ƒç´ å°±æ˜¯æœ€å°çš„
    priority_queue<int, vector<int>, greater<int>> pq;

public:
    SeatManager(int n) {
        // åˆå§‹åŒ–æ‰€æœ‰ç©ºé—²åº§ä½
        for (int i = 1; i <= n; i++) {
            pq.push(i);
        }
    }

    int reserve() {
        // æ‹¿å‡ºé˜Ÿå¤´å…ƒç´ ï¼ˆæœ€å°ï¼‰
        int seat = pq.top();
        pq.pop();
        return seat;
    }

    void unreserve(int i) {
        pq.push(i);
    }
};
```

```go
// by chatGPT (go)
import "container/heap"

// å®šä¹‰ä¸€ä¸ªæ•°ç»„ç±»å‹ï¼Œå¹¶é‡å†™ Len(), Less(), Swap() æ–¹æ³•ï¼Œå®ç°å † heap çš„æ¥å£
type PriorityQueue []int

func (pq PriorityQueue) Len() int {
    return len(pq)
}

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i] < pq[j]
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    *pq = append(*pq, x.(int))
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    x := old[n-1]
    *pq = old[0 : n-1]
    return x
}

type SeatManager struct {
    pq PriorityQueue
}

func Constructor(n int) SeatManager {
    pq := make([]int, n)
    for i := 0; i < n; i++ {
        pq[i] = i + 1
    }
    return SeatManager{pq: pq}
}

func (this *SeatManager) Reserve() int {
    return heap.Pop(&this.pq).(int)
}

func (this *SeatManager) Unreserve(seatNumber int) {
    heap.Push(&this.pq, seatNumber)
}
```

```java
// by labuladong (java)
class SeatManager {
    // åˆ©ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—è‡ªåŠ¨æ’åºï¼Œé˜Ÿå¤´çš„å…ƒç´ å°±æ˜¯æœ€å°çš„
    PriorityQueue<Integer> pq = new PriorityQueue<>();

    public SeatManager(int n) {
        // åˆå§‹åŒ–æ‰€æœ‰ç©ºé—²åº§ä½
        for (int i = 1; i <= n; i++) {
            pq.offer(i);
        }
    }

    public int reserve() {
        // æ‹¿å‡ºé˜Ÿå¤´å…ƒç´ ï¼ˆæœ€å°ï¼‰
        return pq.poll();
    }

    public void unreserve(int i) {
        pq.offer(i);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 */
var SeatManager = function(n) {
  /**
   * åˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆæœ€å°å †ï¼‰è‡ªåŠ¨æ’åºï¼Œé˜Ÿå¤´çš„å…ƒç´ å°±æ˜¯æœ€å°çš„
   * PriorityQueue æ˜¯ Java é‡Œçš„ä¸€ä¸ªå†…ç½®ç±»ï¼ŒJavaScript ä¸­æ²¡æœ‰
   * å¯ä»¥æ‰‹å†™å®ç°ä¸€ä¸ªæœ€å°å †ï¼Œä¹Ÿå¯ä»¥è½¬æ¢ä¸ºæ•°ç»„ï¼Œä½¿ç”¨æ•°ç»„ API æ¥æ¨¡æ‹Ÿä¼˜å…ˆé˜Ÿåˆ—
   */
  this.pq = [];
  for (let i = 1; i <= n; i++) {
    this.pq.push(i);
  }
  this.pq.sort((a, b) => a - b);
};

/**
 * @return {number}
 */
SeatManager.prototype.reserve = function() {
  /**
   * æ‹¿å‡ºé˜Ÿå¤´å…ƒç´ ï¼ˆæœ€å°ï¼‰
   */
  return this.pq.shift();
};

/**
 * @param {number} i
 * @return {void}
 */
SeatManager.prototype.unreserve = function(i) {
  this.pq.push(i);
  this.pq.sort((a, b) => a - b);
};

/**
 * Your SeatManager object will be instantiated and called as such:
 * var obj = new SeatManager(n)
 * var param_1 = obj.reserve()
 * obj.unreserve(i)
 */
```

```python
# by chatGPT (python)
import heapq 

class SeatManager:
    # åˆ©ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—è‡ªåŠ¨æ’åºï¼Œé˜Ÿå¤´çš„å…ƒç´ å°±æ˜¯æœ€å°çš„
    def __init__(self, n: int):
        self.pq = [i for i in range(1,n+1)]
        heapq.heapify(self.pq)

    def reserve(self) -> int:
        # æ‹¿å‡ºé˜Ÿå¤´å…ƒç´ ï¼ˆæœ€å°ï¼‰
        return heapq.heappop(self.pq)

    def unreserve(self, seatNumber: int) -> None:
        heapq.heappush(self.pq, seatNumber)
```

https://leetcode.cn/problems/seat-reservation-manager çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/serialize-and-deserialize-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Codec {
public:
    string SEP = ",";
    string NULL_STR = "#";

    /* ä¸»å‡½æ•°ï¼Œå°†äºŒå‰æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸² */
    string serialize(TreeNode* root) {
        if(!root) return string(NULL_STR) + SEP;
        /* å‰åºéå†ä½ç½® */
        string res = to_string(root->val) + SEP;
        /******************/
        res += serialize(root->left);
        res += serialize(root->right);
        return res;
    }

    /* ä¸»å‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„ */
    TreeNode* deserialize(string data) {
        LinkedList<string> nodes;
        string cur = "";
        for(char &c: data) {
            if(c == SEP) {
                nodes.push_back(cur);
                cur = "";
            } else cur += c;
        }
        return deserialize(nodes);
    }

    /* è¾…åŠ©å‡½æ•°ï¼Œé€šè¿‡ nodes åˆ—è¡¨æ„é€ äºŒå‰æ ‘ */
    TreeNode* deserialize(LinkedList<string> &nodes) {
        if(nodes.empty()) return NULL_STRptr;

        /* å‰åºéå†ä½ç½® */
        string first = nodes.front(); nodes.pop_front();
        if(first == NULL_STR) return NULL_STRptr;
        TreeNode* root = new TreeNode(stoi(first));
        /******************/

        root->left = deserialize(nodes);
        root->right = deserialize(nodes);

        return root;
    }
};
```

```go
// by chatGPT (go)
import (
    "strconv"
    "strings"
)


type Codec struct {
    SEP  string
    NULL string
}

func Constructor() Codec {
    return Codec{
        SEP:  ",",
        NULL: "#",
    }
}

/* è¾…åŠ©å‡½æ•°ï¼Œå°†äºŒå‰æ ‘å­˜å…¥ StringBuilder */
func (this *Codec) serialize(root *TreeNode, sb *strings.Builder) {
    if root == nil {
        sb.WriteString(this.NULL)
        sb.WriteString(this.SEP)
        return
    }

    /******å‰åºéå†ä½ç½®******/
    sb.WriteString(strconv.Itoa(root.Val))
    sb.WriteString(this.SEP)
    /***********************/

    this.serialize(root.Left, sb)
    this.serialize(root.Right, sb)
}

/* ä¸»å‡½æ•°ï¼Œå°†äºŒå‰æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸² */
func (this *Codec) serializeTree(root *TreeNode) string {
    sb := &strings.Builder{}
    this.serialize(root, sb)
    return sb.String()
}

/* è¾…åŠ©å‡½æ•°ï¼Œé€šè¿‡ nodes åˆ—è¡¨æ„é€ äºŒå‰æ ‘ */
func (this *Codec) deserialize(nodes *[]string) *TreeNode {
    if len(*nodes) == 0 {
        return nil
    }

    /******å‰åºéå†ä½ç½®******/
    // åˆ—è¡¨æœ€å·¦ä¾§å°±æ˜¯æ ¹èŠ‚ç‚¹
    first := (*nodes)[0]
    *nodes = (*nodes)[1:]
    if first == this.NULL {
        return nil
    }
    root := &TreeNode{
        Val: atoi(first),
    }
    /***********************/

    root.Left = this.deserialize(nodes)
    root.Right = this.deserialize(nodes)

    return root
}

/* ä¸»å‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„ */
func (this *Codec) deserializeTree(data string) *TreeNode {
    // å°†å­—ç¬¦ä¸²è½¬åŒ–æˆåˆ—è¡¨
    nodes := strings.Split(data, this.SEP)
    return this.deserialize(&nodes)
}

func atoi(s string) int {
    n, _ := strconv.Atoi(s)
    return n
}
```

```java
// by labuladong (java)
public class Codec {
    String SEP = ",";
    String NULL = "#";

    /* ä¸»å‡½æ•°ï¼Œå°†äºŒå‰æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸² */
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serialize(root, sb);
        return sb.toString();
    }

    /* è¾…åŠ©å‡½æ•°ï¼Œå°†äºŒå‰æ ‘å­˜å…¥ StringBuilder */
    void serialize(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(NULL).append(SEP);
            return;
        }

        /******å‰åºéå†ä½ç½®******/
        sb.append(root.val).append(SEP);
        /***********************/

        serialize(root.left, sb);
        serialize(root.right, sb);
    }

    /* ä¸»å‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„ */
    public TreeNode deserialize(String data) {
        // å°†å­—ç¬¦ä¸²è½¬åŒ–æˆåˆ—è¡¨
        LinkedList<String> nodes = new LinkedList<>();
        for (String s : data.split(SEP)) {
            nodes.addLast(s);
        }
        return deserialize(nodes);
    }

    /* è¾…åŠ©å‡½æ•°ï¼Œé€šè¿‡ nodes åˆ—è¡¨æ„é€ äºŒå‰æ ‘ */
    TreeNode deserialize(LinkedList<String> nodes) {
        if (nodes.isEmpty()) return null;

        /******å‰åºéå†ä½ç½®******/
        // åˆ—è¡¨æœ€å·¦ä¾§å°±æ˜¯æ ¹èŠ‚ç‚¹
        String first = nodes.removeFirst();
        if (first.equals(NULL)) return null;
        TreeNode root = new TreeNode(Integer.parseInt(first));
        /***********************/

        root.left = deserialize(nodes);
        root.right = deserialize(nodes);

        return root;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @constructor
 */
var Codec = function() {
    // ç”¨äºè¿æ¥èŠ‚ç‚¹å­—ç¬¦ä¸²çš„åˆ†éš”ç¬¦
    this.SEP = ",";
    // ç©ºèŠ‚ç‚¹çš„è¡¨ç¤º
    this.NULL = "#";
};

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
Codec.prototype.serialize = function(root) {
    var sb = [];
    this.serializeHelper(root, sb);
    return sb.join("");
};

/**
 * å°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
Codec.prototype.deserialize = function(data) {
    // å°†å­—ç¬¦ä¸²è½¬åŒ–æˆåˆ—è¡¨
    var nodes = data.split(this.SEP);
    return this.deserializeHelper(nodes);
};

Codec.prototype.serializeHelper = function(root, sb) {
    if (root === null) {
        sb.push(this.NULL, this.SEP);
        return;
    }
    // å‰åºéå†ä½ç½®
    sb.push(root.val, this.SEP);
    this.serializeHelper(root.left, sb);
    this.serializeHelper(root.right, sb);
};

Codec.prototype.deserializeHelper = function(nodes) {
    if (nodes.length === 0) return null;
    // å‰åºéå†ä½ç½®ï¼šåˆ—è¡¨æœ€å·¦ä¾§å°±æ˜¯æ ¹èŠ‚ç‚¹
    var val = nodes.shift();
    if (val === this.NULL) return null;
    var root = new TreeNode(parseInt(val));
    root.left = this.deserializeHelper(nodes);
    root.right = this.deserializeHelper(nodes);
    return root;
};
```

```python
# by chatGPT (python)
class Codec:
    def __init__(self):
        self.SEP = ','
        self.NULL = '#'

    # å°†äºŒå‰æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²
    def serialize(self, root: TreeNode) -> str:
        sb = []
        self._serialize(root, sb)
        return ''.join(sb)

    # å°†äºŒå‰æ ‘å­˜å…¥åˆ—è¡¨
    def _serialize(self, root, sb):
        if not root:
            sb.append(self.NULL).append(self.SEP)
            return 

        # å‰åºéå†ä½ç½®
        sb.append(str(root.val)).append(self.SEP)

        self._serialize(root.left, sb)
        self._serialize(root.right, sb)

    # å°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„
    def deserialize(self, data: str) -> TreeNode:
        # å°†å­—ç¬¦ä¸²è½¬åŒ–æˆåˆ—è¡¨
        nodes = data.split(self.SEP)
        return self._deserialize(nodes)

    # é€šè¿‡ nodes åˆ—è¡¨æ„é€ äºŒå‰æ ‘
    def _deserialize(self, nodes):
        if not nodes:
            return None

        # å‰åºéå†ä½ç½®
        val = nodes.pop(0)
        if val == self.NULL:
            return None
        root = TreeNode(int(val))

        root.left = self._deserialize(nodes)
        root.right = self._deserialize(nodes)

        return root
```

https://leetcode.cn/problems/serialize-and-deserialize-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/set-mismatch çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        int n=nums.size();
        int dup=-1;
        for(int i=0;i<n;i++){
            // ç°åœ¨çš„å…ƒç´ æ˜¯ä»1å¼€å§‹çš„
            int index = abs(nums[i])-1;
            if(nums[index]<0)
                dup = abs(nums[i]);
            else
                nums[index]*=-1;
        }
        int missing=-1;
        for(int i=0;i<n;i++)
            if(nums[i]>0)
                // å°†ç´¢å¼•è½¬æ¢æˆå…ƒç´ 
                missing=i+1;
        return {dup,missing};
    }
};
```

```go
// by chatGPT (go)
func findErrorNums(nums []int) []int {
    n := len(nums)
    dup := -1
    for i := 0; i < n; i++ {
        // ç°åœ¨çš„å…ƒç´ æ˜¯ä» 1 å¼€å§‹çš„
        index := abs(nums[i]) - 1
        if nums[index] < 0 {
            dup = abs(nums[i])
        } else {
            nums[index] *= -1
        }
    }

    missing := -1
    for i := 0; i < n; i++ {
        if nums[i] > 0 {
            // å°†ç´¢å¼•è½¬æ¢æˆå…ƒç´ 
            missing = i + 1
        }
    }

    return []int{dup, missing}
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```

```java
// by labuladong (java)
class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int dup = -1;
        for (int i = 0; i < n; i++) {
            // ç°åœ¨çš„å…ƒç´ æ˜¯ä» 1 å¼€å§‹çš„
            int index = Math.abs(nums[i]) - 1;
            if (nums[index] < 0)
                dup = Math.abs(nums[i]);
            else
                nums[index] *= -1;
        }

        int missing = -1;
        for (int i = 0; i < n; i++)
            if (nums[i] > 0)
                // å°†ç´¢å¼•è½¬æ¢æˆå…ƒç´ 
                missing = i + 1;

        return new int[]{dup, missing};
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findErrorNums = function(nums) {
    var n = nums.length;
    var dup = -1;
    for (var i = 0; i < n; i++) {
        // ç°åœ¨çš„å…ƒç´ æ˜¯ä» 1 å¼€å§‹çš„
        var index = Math.abs(nums[i]) - 1;
        if (nums[index] < 0)
            dup = Math.abs(nums[i]);
        else
            nums[index] *= -1;
    }

    var missing = -1;
    for (var i = 0; i < n; i++)
        if (nums[i] > 0)
            // å°†ç´¢å¼•è½¬æ¢æˆå…ƒç´ 
            missing = i + 1;

    return [dup, missing];
};
```

```python
# by chatGPT (python)
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        n = len(nums)
        dup = -1
        for i in range(n):
            # ç°åœ¨çš„å…ƒç´ æ˜¯ä» 1 å¼€å§‹çš„
            index = abs(nums[i]) - 1
            if nums[index] < 0:
                dup = abs(nums[i])
            else:
                nums[index] *= -1

        missing = -1
        for i in range(n):
            if nums[i] > 0:
                # å°†ç´¢å¼•è½¬æ¢æˆå…ƒç´ 
                missing = i + 1

        return [dup, missing]
```

https://leetcode.cn/problems/set-mismatch çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        // å­˜æ”¾åˆ é™¤ val çš„é“¾è¡¨
        ListNode* dummy = new ListNode(-1);
        // q æŒ‡é’ˆè´Ÿè´£ç”Ÿæˆç»“æœé“¾è¡¨
        ListNode* q = dummy;
        // p è´Ÿè´£éå†åŸé“¾è¡¨
        ListNode* p = head;
        while (p != nullptr) {
            if (p->val != val) {
                // æŠŠå€¼ä¸ä¸º val çš„èŠ‚ç‚¹æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
                q->next = p;
                q = q->next;
            }
            // æ–­å¼€åŸé“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹çš„ next æŒ‡é’ˆ
            ListNode* temp = p->next;
            p->next = nullptr;
            p = temp;
        }

        return dummy->next;
    }
};
```

```go
// by chatGPT (go)
func deleteNode(head *ListNode, val int) *ListNode {
    // å­˜æ”¾åˆ é™¤ val çš„é“¾è¡¨
    dummy := &ListNode{
        Val: -1,
        Next: nil,
    }
    // q æŒ‡é’ˆè´Ÿè´£ç”Ÿæˆç»“æœé“¾è¡¨
    q := dummy
    // p è´Ÿè´£éå†åŸé“¾è¡¨
    p := head
    for p != nil {
        if p.Val != val {
            // æŠŠå€¼ä¸ä¸º val çš„èŠ‚ç‚¹æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
            q.Next = p
            q = q.Next
        }
        // æ–­å¼€åŸé“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹çš„ next æŒ‡é’ˆ
        temp := p.Next
        p.Next = nil
        p = temp
    }

    return dummy.Next
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        // å­˜æ”¾åˆ é™¤ val çš„é“¾è¡¨
        ListNode dummy = new ListNode(-1);
        // q æŒ‡é’ˆè´Ÿè´£ç”Ÿæˆç»“æœé“¾è¡¨
        ListNode q = dummy;
        // p è´Ÿè´£éå†åŸé“¾è¡¨
        ListNode p = head;
        while (p != null) {
            if (p.val != val) {
                // æŠŠå€¼ä¸ä¸º val çš„èŠ‚ç‚¹æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
                q.next = p;
                q = q.next;
            }
            // æ–­å¼€åŸé“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹çš„ next æŒ‡é’ˆ
            ListNode temp = p.next;
            p.next = null;
            p = temp;
        }

        return dummy.next;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var deleteNode = function(head, val) {
    // å­˜æ”¾åˆ é™¤ val çš„é“¾è¡¨
    let dummy = new ListNode(-1);
    // q æŒ‡é’ˆè´Ÿè´£ç”Ÿæˆç»“æœé“¾è¡¨
    let q = dummy;
    // p è´Ÿè´£éå†åŸé“¾è¡¨
    let p = head;
    while (p != null) {
        if (p.val != val) {
            // æŠŠå€¼ä¸ä¸º val çš„èŠ‚ç‚¹æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
            q.next = p;
            q = q.next;
        }
        // æ–­å¼€åŸé“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹çš„ next æŒ‡é’ˆ
        let temp = p.next;
        p.next = null;
        p = temp;
    }

    return dummy.next;
};
```

```python
# by chatGPT (python)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def deleteNode(self, head: ListNode, val: int) -> ListNode:
        # å­˜æ”¾åˆ é™¤ val çš„é“¾è¡¨
        dummy = ListNode(-1)
        # q æŒ‡é’ˆè´Ÿè´£ç”Ÿæˆç»“æœé“¾è¡¨
        q = dummy
        # p è´Ÿè´£éå†åŸé“¾è¡¨
        p = head
        while p:
            if p.val != val:
                # æŠŠå€¼ä¸ä¸º val çš„èŠ‚ç‚¹æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
                q.next = p
                q = q.next
            # æ–­å¼€åŸé“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹çš„ next æŒ‡é’ˆ
            temp = p.next
            p.next = None
            p = temp

        return dummy.next
```

https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/shortest-path-in-binary-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) {
            return -1;
        }

        queue<pair<int, int>> q;
        // éœ€è¦è®°å½•èµ°è¿‡çš„è·¯å¾„ï¼Œé¿å…æ­»å¾ªç¯
        vector<vector<bool>> visited(m, vector<bool>(n, false));

        // åˆå§‹åŒ–é˜Ÿåˆ—ï¼Œä» (0, 0) å‡ºå‘
        q.push({0, 0});
        visited[0][0] = true;
        int pathLen = 1;

        // æ‰§è¡Œ BFS ç®—æ³•æ¡†æ¶ï¼Œä»å€¼ä¸º 0 çš„åæ ‡å¼€å§‹å‘å…«ä¸ªæ–¹å‘æ‰©æ•£
        vector<vector<int>> dirs = {
                {0, 1}, {0, -1}, {1, 0}, {-1, 0},
                {1, 1}, {1, -1}, {-1, 1}, {-1, -1}
        };
        while (!q.empty()) {
            int sz = q.size();
            for (int __ = 0; __ < sz; __++) {
                auto cur = q.front();
                q.pop();
                int x = cur.first, y = cur.second;
                if (x == m - 1 && y == n - 1) {
                    return pathLen;
                }
                // å‘å…«ä¸ªæ–¹å‘æ‰©æ•£
                for (int i = 0; i < 8; i++) {
                    int nextX = x + dirs[i][0];
                    int nextY = y + dirs[i][1];
                    // ç¡®ä¿ç›¸é‚»çš„è¿™ä¸ªåæ ‡æ²¡æœ‰è¶Šç•Œä¸”å€¼ä¸º 0 ä¸”ä¹‹å‰æ²¡æœ‰èµ°è¿‡
                    if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n
                            && grid[nextX][nextY] == 0 && !visited[nextX][nextY]) {
                        q.push({nextX, nextY});
                        visited[nextX][nextY] = true;
                    }
                }
            }
            pathLen++;
        }
        return -1;
    }
};
```

```go
// by chatGPT (go)
func shortestPathBinaryMatrix(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    if grid[0][0] == 1 || grid[m-1][n-1] == 1 {
        return -1
    }

    q := make([][]int, 0)
    // éœ€è¦è®°å½•èµ°è¿‡çš„è·¯å¾„ï¼Œé¿å…æ­»å¾ªç¯
    visited := make([][]bool, m)
    for i := 0; i < m; i++ {
        visited[i] = make([]bool, n)
    }

    // åˆå§‹åŒ–é˜Ÿåˆ—ï¼Œä» (0, 0) å‡ºå‘
    q = append(q, []int{0, 0})
    visited[0][0] = true
    pathLen := 1

    // æ‰§è¡Œ BFS ç®—æ³•æ¡†æ¶ï¼Œä»å€¼ä¸º 0 çš„åæ ‡å¼€å§‹å‘å…«ä¸ªæ–¹å‘æ‰©æ•£
    dirs := [][]int{
        {0, 1}, {0, -1}, {1, 0}, {-1, 0},
        {1, 1}, {1, -1}, {-1, 1}, {-1, -1},
    }
    for len(q) > 0 {
        sz := len(q)
        for i := 0; i < sz; i++ {
            cur := q[i]
            x, y := cur[0], cur[1]
            if x == m-1 && y == n-1 {
                return pathLen
            }
            // å‘å…«ä¸ªæ–¹å‘æ‰©æ•£
            for j := 0; j < 8; j++ {
                nextX := x + dirs[j][0]
                nextY := y + dirs[j][1]
                // ç¡®ä¿ç›¸é‚»çš„è¿™ä¸ªåæ ‡æ²¡æœ‰è¶Šç•Œä¸”å€¼ä¸º 0 ä¸”ä¹‹å‰æ²¡æœ‰èµ°è¿‡
                if nextX >= 0 && nextX < m && nextY >= 0 && nextY < n &&
                    grid[nextX][nextY] == 0 && !visited[nextX][nextY] {
                    q = append(q, []int{nextX, nextY})
                    visited[nextX][nextY] = true
                }
            }
        }
        pathLen++
        q = q[sz:]
    }
    return -1
}
```

```java
// by labuladong (java)
class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) {
            return -1;
        }

        Queue<int[]> q = new LinkedList<>();
        // éœ€è¦è®°å½•èµ°è¿‡çš„è·¯å¾„ï¼Œé¿å…æ­»å¾ªç¯
        boolean[][] visited = new boolean[m][n];

        // åˆå§‹åŒ–é˜Ÿåˆ—ï¼Œä» (0, 0) å‡ºå‘
        q.offer(new int[]{0, 0});
        visited[0][0] = true;
        int pathLen = 1;

        // æ‰§è¡Œ BFS ç®—æ³•æ¡†æ¶ï¼Œä»å€¼ä¸º 0 çš„åæ ‡å¼€å§‹å‘å…«ä¸ªæ–¹å‘æ‰©æ•£
        int[][] dirs = new int[][]{
                {0, 1}, {0, -1}, {1, 0}, {-1, 0},
                {1, 1}, {1, -1}, {-1, 1}, {-1, -1}
        };
        while (!q.isEmpty()) {
            int sz = q.size();
            for (int __ = 0; __ < sz; __++) {
                int[] cur = q.poll();
                int x = cur[0], y = cur[1];
                if (x == m - 1 && y == n - 1) {
                    return pathLen;
                }
                // å‘å…«ä¸ªæ–¹å‘æ‰©æ•£
                for (int i = 0; i < 8; i++) {
                    int nextX = x + dirs[i][0];
                    int nextY = y + dirs[i][1];
                    // ç¡®ä¿ç›¸é‚»çš„è¿™ä¸ªåæ ‡æ²¡æœ‰è¶Šç•Œä¸”å€¼ä¸º 0 ä¸”ä¹‹å‰æ²¡æœ‰èµ°è¿‡
                    if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n
                            && grid[nextX][nextY] == 0 && !visited[nextX][nextY]) {
                        q.offer(new int[]{nextX, nextY});
                        visited[nextX][nextY] = true;
                    }
                }
            }
            pathLen++;
        }
        return -1;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} grid
 * @return {number}
 */
var shortestPathBinaryMatrix = function(grid) {
    const m = grid.length, n = grid[0].length;
    if (grid[0][0] === 1 || grid[m - 1][n - 1] === 1) {
        return -1;
    }

    const q = [];
    // éœ€è¦è®°å½•èµ°è¿‡çš„è·¯å¾„ï¼Œé¿å…æ­»å¾ªç¯
    const visited = new Array(m).fill(0).map(() => new Array(n).fill(false));

    // åˆå§‹åŒ–é˜Ÿåˆ—ï¼Œä» (0, 0) å‡ºå‘
    q.push([0, 0]);
    visited[0][0] = true;
    let pathLen = 1;

    // æ‰§è¡Œ BFS ç®—æ³•æ¡†æ¶ï¼Œä»å€¼ä¸º 0 çš„åæ ‡å¼€å§‹å‘å…«ä¸ªæ–¹å‘æ‰©æ•£
    const dirs = [
        [0, 1], [0, -1], [1, 0], [-1, 0],
        [1, 1], [1, -1], [-1, 1], [-1, -1]
    ];
    while (q.length) {
        const sz = q.length;
        for (let __ = 0; __ < sz; __++) {
            const cur = q.shift();
            const x = cur[0], y = cur[1];
            if (x === m - 1 && y === n - 1) {
                return pathLen;
            }
            // å‘å…«ä¸ªæ–¹å‘æ‰©æ•£
            for (let i = 0; i < 8; i++) {
                const nextX = x + dirs[i][0];
                const nextY = y + dirs[i][1];
                // ç¡®ä¿ç›¸é‚»çš„è¿™ä¸ªåæ ‡æ²¡æœ‰è¶Šç•Œä¸”å€¼ä¸º 0 ä¸”ä¹‹å‰æ²¡æœ‰èµ°è¿‡
                if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n
                        && grid[nextX][nextY] === 0 && !visited[nextX][nextY]) {
                    q.push([nextX, nextY]);
                    visited[nextX][nextY] = true;
                }
            }
        }
        pathLen++;
    }
    return -1;
};
```

```python
# by chatGPT (python)
from collections import deque

class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        # è·å–çŸ©é˜µå¤§å°
        m, n = len(grid), len(grid[0])
        # å¦‚æœèµ·ç‚¹æˆ–ç»ˆç‚¹ä¸ºéšœç¢ç‰©ï¼Œåˆ™æ— æ³•åˆ°è¾¾ç»ˆç‚¹
        if grid[0][0] == 1 or grid[m - 1][n - 1] == 1:
            return -1
        
        # åˆå§‹åŒ–é˜Ÿåˆ—ã€visitedæ•°ç»„
        q = deque()
        visited = [[False for _ in range(n)] for _ in range(m)]
        
        # å°†èµ·ç‚¹åŠ å…¥é˜Ÿåˆ—ï¼Œå¹¶æ ‡è®°ä¸ºå·²è®¿é—®
        q.append([0, 0])
        visited[0][0] = True
        # è®°å½•è·¯å¾„é•¿åº¦
        pathLen = 1
        
        # å®šä¹‰8ä¸ªæ–¹å‘æ•°ç»„
        dirs = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]
        while q:
            sz = len(q)
            # éå†å½“å‰å±‚çš„æ‰€æœ‰ç»“ç‚¹
            for _ in range(sz):
                cur = q.popleft()
                x, y = cur[0], cur[1]
                # å¦‚æœå½“å‰ç»“ç‚¹æ˜¯ç›®æ ‡ç‚¹ï¼Œåˆ™è¿”å›è·¯å¾„é•¿åº¦
                if x == m - 1 and y == n - 1:
                    return pathLen
                # å‘å…«ä¸ªæ–¹å‘æ‰©æ•£
                for i in range(8):
                    nextX = x + dirs[i][0]
                    nextY = y + dirs[i][1]
                    # ç¡®ä¿ç›¸é‚»çš„è¿™ä¸ªåæ ‡æ²¡æœ‰è¶Šç•Œä¸”å€¼ä¸º 0 ä¸”ä¹‹å‰æ²¡æœ‰èµ°è¿‡
                    if 0 <= nextX < m and 0 <= nextY < n and not visited[nextX][nextY] and grid[nextX][nextY] == 0:
                        q.append([nextX, nextY])
                        visited[nextX][nextY] = True
            # å±‚æ•°å¢åŠ 
            pathLen += 1
        # å¦‚æœæ— æ³•åˆ°è¾¾ç»ˆç‚¹ï¼Œåˆ™è¿”å› -1
        return -1
```

https://leetcode.cn/problems/shortest-path-in-binary-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class MedianFinder {
private:
    priority_queue<int, vector<int>, greater<int>> large; // å°é¡¶å †
    priority_queue<int, vector<int>, less<int>> small; // å¤§é¡¶å †
public:
    MedianFinder() {}
    
    /**<extend up -100>
    ![](../pictures/ä¸­ä½æ•°/2.jpeg)
    */
    double findMedian() {
        if(large.size() < small.size()) {
            return small.top();
        } else if(large.size() > small.size()) {
            return large.top();
        }
        return (large.top() + small.top()) / 2.0; //å¦‚æœå…ƒç´ ä¸€æ ·å¤šï¼Œä¸­ä½æ•°å°±æ˜¯ä¸¤ä¸ªå †é¡¶å…ƒç´ å¹³å‡æ•°
        /**<extend up -100>
        ![](../pictures/ä¸­ä½æ•°/1.jpeg)
        */
    }
    
    void addNum(int num) {
        if(small.size() >= large.size()) {
            small.push(num);
            large.push(small.top());
            small.pop();
        } else {
            large.push(num);
            small.push(large.top());
            large.pop();
        }
    }
};
```

```go
// by chatGPT (go)
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    var carry int
    var result *ListNode
    var head *ListNode
    for l1 != nil || l2 != nil || carry != 0 {
        sum := 0
        if l1 != nil {
            sum += l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            sum += l2.Val
            l2 = l2.Next
        }
        sum += carry
        carry = sum / 10
        node := &ListNode{Val: sum % 10} // æ±‚å’Œçš„å¤„ç†
        if result == nil {
            result = node
            head = node
        } else {
            result.Next = node
            result = result.Next
        }
    }
    return head
}
```

```java
// by labuladong (java)
class MedianFinder {
    private PriorityQueue<Integer> large;
    private PriorityQueue<Integer> small;

    public MedianFinder() {
        // å°é¡¶å †
        large = new PriorityQueue<>();
        // å¤§é¡¶å †
        small = new PriorityQueue<>((a, b) -> {
            return b - a;
        });
    }

    public double findMedian() {
        /**<extend up -100>
        ![](../pictures/ä¸­ä½æ•°/2.jpeg)
        */
        // å¦‚æœå…ƒç´ ä¸ä¸€æ ·å¤šï¼Œå¤šçš„é‚£ä¸ªå †çš„å †é¡¶å…ƒç´ å°±æ˜¯ä¸­ä½æ•°
        if (large.size() < small.size()) {
            return small.peek();
        } else if (large.size() > small.size()) {
            return large.peek();
        }
        // å¦‚æœå…ƒç´ ä¸€æ ·å¤šï¼Œä¸¤ä¸ªå †å †é¡¶å…ƒç´ çš„å¹³å‡æ•°æ˜¯ä¸­ä½æ•°
        return (large.peek() + small.peek()) / 2.0;
        /**<extend up -100>
        ![](../pictures/ä¸­ä½æ•°/1.jpeg)
        */
    }

    public void addNum(int num) {
        if (small.size() >= large.size()) {
            small.offer(num);
            large.offer(small.poll());
        } else {
            large.offer(num);
            small.offer(large.poll());
        }
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * ç°æœ‰ä¸€ä¸ªæŒ‰éé€’å‡é¡ºåºæ’åºçš„æ•´æ•°æ•°ç»„ numsã€‚
 * è¯·ä½ åˆ é™¤é‡å¤å‡ºç°çš„å…ƒç´ ï¼Œä½¿æ¯ä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ã€‚
 * è¿”å›åˆ é™¤åæ•°ç»„çš„æ–°é•¿åº¦ã€‚
 * ä¸è¦ä½¿ç”¨é¢å¤–çš„æ•°ç»„ç©ºé—´ï¼Œå¿…é¡»åœ¨åŸåœ°ä¿®æ”¹è¾“å…¥æ•°ç»„å¹¶åœ¨ä½¿ç”¨ O(1) é¢å¤–ç©ºé—´çš„æ¡ä»¶ä¸‹å®Œæˆã€‚
 * 
 * ç»™å®š nums = [0,0,1,1,1,2,2,3,3,4],
 * 
 * è¿”å› æ–°é•¿åº¦5, å¹¶ä¸”åŸæ•°ç»„ nums çš„å‰äº”ä¸ªå…ƒç´ ä¸º 0ã€1ã€2ã€3 å’Œ 4ã€‚
 * 
 * ä½ ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚
 */

/**
 * æ€è·¯å¾ˆç®€å•ï¼Œå› ä¸ºæ•°ç»„å·²ç»æ˜¯éé€’å‡æ’åˆ—çš„äº†ï¼Œæ„æ€å°±æ˜¯æ•°ç»„ä¸­ä¹‹åä¼šå‡ºç°æ¯”å½“å‰ä¸‹æ ‡çš„å€¼è¿˜å°çš„å€¼éƒ½ä¼šåœ¨ä¹‹å‰å‡ºç°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è€ƒè™‘åŒæŒ‡é’ˆæ³•ã€‚
 * æ—¢ç„¶æƒ³åˆ°äº†åŒæŒ‡é’ˆï¼Œé‚£ä¹ˆè¦å¼€ä¸€ä¸ªå˜é‡å‚¨å­˜æ•°ç»„ä¸­ä¸é‡å¤çš„ä¸ªæ•°ï¼Œè¿™ä¸ªå˜é‡å‘½åä¸ºNonDuplicateå³å¯ã€‚å¼€å§‹çš„æ—¶å€™å®ƒçš„å€¼æ˜¯1ï¼Œå› ä¸ºç¬¬ä¸€ä¸ªæ•°ä¸€å®šæ˜¯ä¸é‡å¤çš„ã€‚
 * éšåï¼Œæˆ‘ä»¬éå†æ•°ç»„ï¼Œæ¯”è¾ƒiå’Œi+1ä½ç½®çš„å€¼ï¼š
 *  if(nums[i]!==nums[i+1])ï¼Œåˆ™è¯´æ˜num[i+1]æ˜¯ä¸é‡å¤çš„ï¼Œæ­¤æ—¶å°±å°†nums[j]èµ‹å€¼ä¸ºnums[i+1], éé‡å¤æ•°çš„ä¸ªæ•°NonDuplicate++
 * æœ€åå†æŠŠnumsæ•°ç»„ä¸­å‰NonDuplicateä¸ªæ•°èµ‹å€¼ä¸ºnumsä¸­å„ä¸ªå…ƒç´ ï¼Œæœ€åNonDuplicateå°±æ˜¯æ•°ç»„ä¸­ä¸é‡å¤çš„ä¸ªæ•°ã€‚
 * æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå› ä¸ºæ•°ç»„åªéå†äº†ä¸€æ¬¡ã€‚
 * ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼Œæ²¡æœ‰åˆ©ç”¨é¢å¤–çš„ç©ºé—´
 */

var removeDuplicates = function(nums) {
    let NonDuplicate =1;
    let n = nums.length;
    let j=0;
    for(let i=0; i<n-1; i++){
        if(nums[i]!==nums[i+1]){
            nums[j] = nums[i+1];
            NonDuplicate++;
            j++;
        }else{
            continue;
        }
    }
    for (;j<n;j++){
        nums.pop();
    }
    return NonDuplicate;
};
```

```python
# by chatGPT (python)
from queue import PriorityQueue

class MedianFinder:
    def __init__(self):
        # å°é¡¶å †
        self.large = PriorityQueue()
        # å¤§é¡¶å †
        self.small = PriorityQueue(lambda a,b : b-a)

    def findMedian(self) -> float:
        """
        <extend up -100>
        ![](../pictures/ä¸­ä½æ•°/2.jpeg)
        """
        # å¦‚æœå…ƒç´ ä¸ä¸€æ ·å¤šï¼Œå¤šçš„é‚£ä¸ªå †çš„å †é¡¶å…ƒç´ å°±æ˜¯ä¸­ä½æ•°
        if self.large.qsize() < self.small.qsize():
            return self.small.queue[0]
        elif self.large.qsize() > self.small.qsize():
            return self.large.queue[0]
        # å¦‚æœå…ƒç´ ä¸€æ ·å¤šï¼Œä¸¤ä¸ªå †å †é¡¶å…ƒç´ çš„å¹³å‡æ•°æ˜¯ä¸­ä½æ•°
        return (self.large.queue[0] + self.small.queue[0]) / 2.0
        """
        <extend up -100>
        ![](../pictures/ä¸­ä½æ•°/1.jpeg)
        """

    def addNum(self, num: int) -> None:
        if self.small.qsize() >= self.large.qsize():
            self.small.put(num)
            self.large.put(self.small.get())
        else:
            self.large.put(num)
            self.small.put(self.large.get())
```

https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    double myPow(double a, int k) {
        if (k == 0) return 1;

        if (k == INT_MIN) {
            // æŠŠ k æ˜¯ INT_MIN çš„æƒ…å†µå•ç‹¬æ‹¿å‡ºæ¥å¤„ç†
            // é¿å… -k æ•´å‹æº¢å‡º
            return myPow(1 / a, -(k + 1)) / a;
        }

        if (k < 0) {
            return myPow(1 / a, -k);
        }

        if (k % 2 == 1) {
            // k æ˜¯å¥‡æ•°
            return (a * myPow(a, k - 1));
        } else {
            // k æ˜¯å¶æ•°
            double sub = myPow(a, k / 2);
            return (sub * sub);
        }
    }
};
```

```go
// by chatGPT (go)
func myPow(a float64, k int) float64 {
    if k == 0 { // å¦‚æœ k ç­‰äº 0ï¼Œç›´æ¥è¿”å› 1
        return 1
    }

    if k == -2147483648 { // æŠŠ k æ˜¯ INT_MIN çš„æƒ…å†µå•ç‹¬æ‹¿å‡ºæ¥å¤„ç†
        // é¿å… -k æ•´å‹æº¢å‡º
        return myPow(1 / a, -(k + 1)) / a
    }

    if k < 0 { // å¦‚æœ k å°äº 0ï¼Œé€’å½’è½¬æ¢æˆ 1 / a çš„ç›¸åæ•°
        return myPow(1 / a, -k)
    }

    if k % 2 == 1 { // å¦‚æœ k æ˜¯å¥‡æ•°ï¼Œé€’å½’è¿ç®— k - 1
        return a * myPow(a, k - 1)
    } else { // å¦‚æœ k æ˜¯å¶æ•°ï¼Œé€’å½’è¿ç®— k / 2
        sub := myPow(a, k / 2)
        return sub * sub
    }
}
```

```java
// by labuladong (java)
class Solution {
    public double myPow(double a, int k) {
        if (k == 0) return 1;

        if (k == Integer.MIN_VALUE) {
            // æŠŠ k æ˜¯ INT_MIN çš„æƒ…å†µå•ç‹¬æ‹¿å‡ºæ¥å¤„ç†
            // é¿å… -k æ•´å‹æº¢å‡º
            return myPow(1 / a, -(k + 1)) / a;
        }

        if (k < 0) {
            return myPow(1 / a, -k);
        }

        if (k % 2 == 1) {
            // k æ˜¯å¥‡æ•°
            return (a * myPow(a, k - 1));
        } else {
            // k æ˜¯å¶æ•°
            double sub = myPow(a, k / 2);
            return (sub * sub);
        }
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} a
 * @param {number} k
 * @return {number}
 */
var myPow = function(a, k) {
    if (k === 0) return 1;

    if (k === -2147483648) {
        // æŠŠ k æ˜¯ INT_MIN çš„æƒ…å†µå•ç‹¬æ‹¿å‡ºæ¥å¤„ç†
        // é¿å… -k æ•´å‹æº¢å‡º
        return myPow(1 / a, -(k + 1)) / a;
    }

    if (k < 0) {
        return myPow(1 / a, -k);
    }

    if (k % 2 === 1) {
        // k æ˜¯å¥‡æ•°
        return (a * myPow(a, k - 1));
    } else {
        // k æ˜¯å¶æ•°
        var sub = myPow(a, k / 2);
        return (sub * sub);
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def myPow(self, a: float, k: int) -> float:
        if k == 0:
            return 1

        if k == -2147483648:  # k æ˜¯ INT_MIN çš„æƒ…å†µå•ç‹¬æ‹¿å‡ºæ¥å¤„ç†
            # é¿å… -k æ•´å‹æº¢å‡º
            return self.myPow(1 / a, -(k + 1)) / a

        if k < 0:
            return self.myPow(1 / a, -k)

        if k % 2 == 1:  # k æ˜¯å¥‡æ•°
            return a * self.myPow(a, k - 1)
        else:  # k æ˜¯å¶æ•°
            sub = self.myPow(a, k // 2)
            return sub * sub
```

https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int findNthDigit(int n) {
        if (n == 0) {
            return 0;
        }
        return findNthDigit_100(n);
    }

    // ç¬¬ 400 é¢˜çš„è§£æ³•ä»£ç 
    int findNthDigit_400(int n) {
        // ä½æ•°ï¼ˆä¸€ä½æ•°ï¼Œä¸¤ä½æ•°...ï¼‰
        int digit = 1;
        // 1,10,100, 1000 è¿™æ ·çš„åç¼€
        long base = 1;

        while (n > 9 * base * digit) {
            n -= 9 * base * digit;
            base *= 10;
            digit++;
        }

        // æ­¤æ—¶å‡è®¾ base = 1000ï¼Œé‚£ä¹ˆè¯´æ˜ n æ˜¯ 100~999 ä¸­çš„æŸä¸ªä¸‰ä½æ•°çš„æŸä¸€ä½
        // å“ªä¸ªä¸‰ä½æ•°å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        long val = base + (n - 1) / digit;
        // æ˜¯è¿™ä¸ªä¸‰ä½æ•°çš„ç¬¬å‡ ä½å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        int index = (n - 1) % digit;

        // æ€ä¹ˆæŠŠ val çš„ç¬¬ index è¿™ä¸€ä½æ•°å­—æŠ å‡ºæ¥å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        return (to_string(val))[index] - '0';
    }

    int findNthDigit_100(int n) {
        // æŒ‰ä½è®¡æ•°æ˜¯ä» 0 å¼€å§‹çš„ï¼Œæ•…éœ€å…ˆ -1
        n--;

        for (int bit = 1; bit <= 11; bit++) {
            int firstNum = pow(10, bit - 1);
            int lastNum = pow(10, bit) - 1;
            int bitNums = lastNum - firstNum + 1;
            int totalNums = bitNums * bit;
            if (n < totalNums) {
                int numTimes = n / bit;
                int numIndex = n % bit;
                int targetNum = firstNum + numTimes;
                string targetStr = to_string(targetNum);
                return targetStr[numIndex] - '0';
            }
            n -= totalNums;
        }
        return -1;
    }
};
```

```go
// by chatGPT (go)
import "strconv"

func findNthDigit(n int) int {
	if n == 0 {
		return 0
	}
	return findNthDigit400(n)
}

// ç¬¬ 400 é¢˜çš„è§£æ³•ä»£ç 
func findNthDigit400(n int) int {
	// ä½æ•°ï¼ˆä¸€ä½æ•°ï¼Œä¸¤ä½æ•°...ï¼‰
	digit := 1
	// 1,10,100, 1000 è¿™æ ·çš„åç¼€
	base := 1
	for n > 9*base*digit {
		n -= 9 * base * digit
		base *= 10
		digit++
	}

	// æ­¤æ—¶å‡è®¾ base = 1000ï¼Œé‚£ä¹ˆè¯´æ˜ n æ˜¯ 100~999 ä¸­çš„æŸä¸ªä¸‰ä½æ•°çš„æŸä¸€ä½
	// å“ªä¸ªä¸‰ä½æ•°å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
	val := base + (n-1)/digit
	// æ˜¯è¿™ä¸ªä¸‰ä½æ•°çš„ç¬¬å‡ ä½å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
	index := (n - 1) % digit
	// æ€ä¹ˆæŠŠ val çš„ç¬¬ index è¿™ä¸€ä½æ•°å­—æŠ å‡ºæ¥å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
	return int(strconv.Itoa(val)[index] - '0')
}
```

```java
// by labuladong (java)
class Solution {
    public int findNthDigit(int n) {
        if (n == 0) {
            return 0;
        }
        return findNthDigit_100(n);
    }

    // ç¬¬ 400 é¢˜çš„è§£æ³•ä»£ç 
    int findNthDigit_400(int n) {
        // ä½æ•°ï¼ˆä¸€ä½æ•°ï¼Œä¸¤ä½æ•°...ï¼‰
        int digit = 1;
        // 1,10,100, 1000 è¿™æ ·çš„åç¼€
        long base = 1;

        while (n > 9 * base * digit) {
            n -= 9 * base * digit;
            base *= 10;
            digit++;
        }

        // æ­¤æ—¶å‡è®¾ base = 1000ï¼Œé‚£ä¹ˆè¯´æ˜ n æ˜¯ 100~999 ä¸­çš„æŸä¸ªä¸‰ä½æ•°çš„æŸä¸€ä½
        // å“ªä¸ªä¸‰ä½æ•°å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        long val = base + (n - 1) / digit;
        // æ˜¯è¿™ä¸ªä¸‰ä½æ•°çš„ç¬¬å‡ ä½å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        int index = (n - 1) % digit;

        // æ€ä¹ˆæŠŠ val çš„ç¬¬ index è¿™ä¸€ä½æ•°å­—æŠ å‡ºæ¥å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        return ("" + val).charAt(index) - '0';
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @return {number}
 */
var findNthDigit = function(n) {
    if (n == 0) {
        return 0;
    }
    return findNthDigit_100(n);
};

// ç¬¬ 400 é¢˜çš„è§£æ³•ä»£ç 
var findNthDigit_400 = function(n) {
    // ä½æ•°ï¼ˆä¸€ä½æ•°ï¼Œä¸¤ä½æ•°...ï¼‰
    var digit = 1;
    // 1,10,100, 1000 è¿™æ ·çš„åç¼€
    var base = 1;

    while (n > 9 * base * digit) {
        n -= 9 * base * digit;
        base *= 10;
        digit++;
    }

    // æ­¤æ—¶å‡è®¾ base = 1000ï¼Œé‚£ä¹ˆè¯´æ˜ n æ˜¯ 100~999 ä¸­çš„æŸä¸ªä¸‰ä½æ•°çš„æŸä¸€ä½
    // å“ªä¸ªä¸‰ä½æ•°å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
    var val = base + Math.floor((n - 1) / digit);
    // æ˜¯è¿™ä¸ªä¸‰ä½æ•°çš„ç¬¬å‡ ä½å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
    var index = (n - 1) % digit;

    // æ€ä¹ˆæŠŠ val çš„ç¬¬ index è¿™ä¸€ä½æ•°å­—æŠ å‡ºæ¥å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
    return parseInt(("" + val).charAt(index));
};
```

```python
# by chatGPT (python)
class Solution:
    def findNthDigit(self, n: int) -> int:
        if n == 0:
            return 0
        return self.findNthDigit_400(n)

    # ç¬¬ 400 é¢˜çš„è§£æ³•ä»£ç 
    def findNthDigit_400(self, n: int) -> int:
        # ä½æ•°ï¼ˆä¸€ä½æ•°ï¼Œä¸¤ä½æ•°...ï¼‰
        digit = 1
        # 1,10,100, 1000 è¿™æ ·çš„åç¼€
        base = 1

        while n > 9 * base * digit:
            n -= 9 * base * digit
            base *= 10
            digit += 1

        # æ­¤æ—¶å‡è®¾ base = 1000ï¼Œé‚£ä¹ˆè¯´æ˜ n æ˜¯ 100~999 ä¸­çš„æŸä¸ªä¸‰ä½æ•°çš„æŸä¸€ä½
        # å“ªä¸ªä¸‰ä½æ•°å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        val = base + (n - 1) // digit
        # æ˜¯è¿™ä¸ªä¸‰ä½æ•°çš„ç¬¬å‡ ä½å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        index = (n - 1) % digit

        # æ€ä¹ˆæŠŠ val çš„ç¬¬ index è¿™ä¸€ä½æ•°å­—æŠ å‡ºæ¥å‘¢ï¼Ÿè¿™æ ·ç®—ï¼š
        return int(str(val)[index])
```

https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        // æˆ‘ä»¬æƒ³å¯»æ‰¾çš„é‚£ä¸ªä¼—æ•°
        int target = 0;
        // è®¡æ•°å™¨ï¼ˆç±»æ¯”å¸¦ç”µç²’å­ä¾‹å­ä¸­çš„å¸¦ç”µæ€§ï¼‰
        int count = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (count == 0) {
                // å½“è®¡æ•°å™¨ä¸º 0 æ—¶ï¼Œå‡è®¾ nums[i] å°±æ˜¯ä¼—æ•°
                target = nums[i];
                // ä¼—æ•°å‡ºç°äº†ä¸€æ¬¡
                count = 1;
            } else if (nums[i] == target) {
                // å¦‚æœé‡åˆ°çš„æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨ç´¯åŠ 
                count++;
            } else {
                // å¦‚æœé‡åˆ°çš„ä¸æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨é€’å‡
                count--;
            }
        }
        // å›æƒ³å¸¦ç”µç²’å­çš„ä¾‹å­
        // æ­¤æ—¶çš„ count å¿…ç„¶å¤§äº 0ï¼Œæ­¤æ—¶çš„ target å¿…ç„¶å°±æ˜¯ç›®æ ‡ä¼—æ•°
        return target;
    }
};
```

```go
// by chatGPT (go)
func majorityElement(nums []int) int {
    // æˆ‘ä»¬æƒ³å¯»æ‰¾çš„é‚£ä¸ªä¼—æ•°
    target := 0
    // è®¡æ•°å™¨ï¼ˆç±»æ¯”å¸¦ç”µç²’å­ä¾‹å­ä¸­çš„å¸¦ç”µæ€§ï¼‰
    count := 0

    for i := 0; i < len(nums); i++ {
        if count == 0 {
            // å½“è®¡æ•°å™¨ä¸º 0 æ—¶ï¼Œå‡è®¾ nums[i] å°±æ˜¯ä¼—æ•°
            target = nums[i]
            // ä¼—æ•°å‡ºç°äº†ä¸€æ¬¡
            count = 1
        } else if nums[i] == target {
            // å¦‚æœé‡åˆ°çš„æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨ç´¯åŠ 
            count++
        } else {
            // å¦‚æœé‡åˆ°çš„ä¸æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨é€’å‡
            count--
        }
    }

    // å›æƒ³å¸¦ç”µç²’å­çš„ä¾‹å­
    // æ­¤æ—¶çš„ count å¿…ç„¶å¤§äº 0ï¼Œæ­¤æ—¶çš„ target å¿…ç„¶å°±æ˜¯ç›®æ ‡ä¼—æ•°
    return target
}
```

```java
// by labuladong (java)
class Solution {
    public int majorityElement(int[] nums) {
        // æˆ‘ä»¬æƒ³å¯»æ‰¾çš„é‚£ä¸ªä¼—æ•°
        int target = 0;
        // è®¡æ•°å™¨ï¼ˆç±»æ¯”å¸¦ç”µç²’å­ä¾‹å­ä¸­çš„å¸¦ç”µæ€§ï¼‰
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            if (count == 0) {
                // å½“è®¡æ•°å™¨ä¸º 0 æ—¶ï¼Œå‡è®¾ nums[i] å°±æ˜¯ä¼—æ•°
                target = nums[i];
                // ä¼—æ•°å‡ºç°äº†ä¸€æ¬¡
                count = 1;
            } else if (nums[i] == target) {
                // å¦‚æœé‡åˆ°çš„æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨ç´¯åŠ 
                count++;
            } else {
                // å¦‚æœé‡åˆ°çš„ä¸æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨é€’å‡
                count--;
            }
        }
        // å›æƒ³å¸¦ç”µç²’å­çš„ä¾‹å­
        // æ­¤æ—¶çš„ count å¿…ç„¶å¤§äº 0ï¼Œæ­¤æ—¶çš„ target å¿…ç„¶å°±æ˜¯ç›®æ ‡ä¼—æ•°
        return target;
    }
}
```

```javascript
// by chatGPT (javascript)
var majorityElement = function(nums) {
    // æˆ‘ä»¬æƒ³å¯»æ‰¾çš„é‚£ä¸ªä¼—æ•°
    let target = 0;
    // è®¡æ•°å™¨ï¼ˆç±»æ¯”å¸¦ç”µç²’å­ä¾‹å­ä¸­çš„å¸¦ç”µæ€§ï¼‰
    let count = 0;
    for (let i = 0; i < nums.length; i++) {
        if (count == 0) {
            // å½“è®¡æ•°å™¨ä¸º 0 æ—¶ï¼Œå‡è®¾ nums[i] å°±æ˜¯ä¼—æ•°
            target = nums[i];
            // ä¼—æ•°å‡ºç°äº†ä¸€æ¬¡
            count = 1;
        } else if (nums[i] == target) {
            // å¦‚æœé‡åˆ°çš„æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨ç´¯åŠ 
            count++;
        } else {
            // å¦‚æœé‡åˆ°çš„ä¸æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨é€’å‡
            count--;
        }
    }
    // å›æƒ³å¸¦ç”µç²’å­çš„ä¾‹å­
    // æ­¤æ—¶çš„ count å¿…ç„¶å¤§äº 0ï¼Œæ­¤æ—¶çš„ target å¿…ç„¶å°±æ˜¯ç›®æ ‡ä¼—æ•°
    return target;
};
```

```python
# by chatGPT (python)
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        # æˆ‘ä»¬æƒ³å¯»æ‰¾çš„é‚£ä¸ªä¼—æ•°
        target = 0
        # è®¡æ•°å™¨ï¼ˆç±»æ¯”å¸¦ç”µç²’å­ä¾‹å­ä¸­çš„å¸¦ç”µæ€§ï¼‰
        count = 0
        for i in range(len(nums)):
            if count == 0:
                # å½“è®¡æ•°å™¨ä¸º 0 æ—¶ï¼Œå‡è®¾ nums[i] å°±æ˜¯ä¼—æ•°
                target = nums[i]
                # ä¼—æ•°å‡ºç°äº†ä¸€æ¬¡
                count = 1
            elif nums[i] == target:
                # å¦‚æœé‡åˆ°çš„æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨ç´¯åŠ 
                count += 1
            else:
                # å¦‚æœé‡åˆ°çš„ä¸æ˜¯ç›®æ ‡ä¼—æ•°ï¼Œè®¡æ•°å™¨é€’å‡
                count -= 1
        # å›æƒ³å¸¦ç”µç²’å­çš„ä¾‹å­
        # æ­¤æ—¶çš„ count å¿…ç„¶å¤§äº 0ï¼Œæ­¤æ—¶çš„ target å¿…ç„¶å°±æ˜¯ç›®æ ‡ä¼—æ•°
        return target
```

https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int reversePairs(vector<int>& nums) {
        if (nums.size() == 0) {
            return 0;
        }
        // æ‰§è¡Œå½’å¹¶æ’åº
        sort(nums);
        return count;
    }

    void sort(vector<int>& nums) {
        temp.resize(nums.size());
        sort(nums, 0, nums.size() - 1);
    }

    // å½’å¹¶æ’åº
    void sort(vector<int>& nums, int lo, int hi) {
        if (lo == hi) {
            return;
        }
        int mid = lo + (hi - lo) / 2;
        sort(nums, lo, mid);
        sort(nums, mid + 1, hi);
        merge(nums, lo, mid, hi);
    }

    // è®°å½•ã€Œç¿»è½¬å¯¹ã€çš„ä¸ªæ•°
    int count = 0;

    void merge(vector<int>& nums, int lo, int mid, int hi) {
        for (int i = lo; i <= hi; i++) {
            temp[i] = nums[i];
        }

        // è¿›è¡Œæ•ˆç‡ä¼˜åŒ–ï¼Œç»´æŠ¤å·¦é—­å³å¼€åŒºé—´ [mid+1, end) ä¸­çš„å…ƒç´ ä¹˜ 2 å°äº nums[i]
        // ä¸ºä»€ä¹ˆ end æ˜¯å¼€åŒºé—´ï¼Ÿå› ä¸ºè¿™æ ·çš„è¯å¯ä»¥ä¿è¯åˆå§‹åŒºé—´ [mid+1, mid+1) æ˜¯ä¸€ä¸ªç©ºåŒºé—´
        int end = mid + 1;
        for (int i = lo; i <= mid; i++) {
            // nums ä¸­çš„å…ƒç´ å¯èƒ½è¾ƒå¤§ï¼Œä¹˜ 2 å¯èƒ½æº¢å‡ºï¼Œæ‰€ä»¥è½¬åŒ–æˆ long
            while (end <= hi && nums[i] > nums[end]) {
                end++;
            }
            count += end - (mid + 1);
        }

        // æ•°ç»„åŒæŒ‡é’ˆæŠ€å·§ï¼Œåˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„
        int i = lo, j = mid + 1;
        for (int p = lo; p <= hi; p++) {
            if (i == mid + 1) {
                nums[p] = temp[j++];
            } else if (j == hi + 1) {
                nums[p] = temp[i++];
            } else if (temp[i] > temp[j]) {
                nums[p] = temp[j++];
            } else {
                nums[p] = temp[i++];
            }
        }
    }

private:
    vector<int> temp;
};
```

```go
// by chatGPT (go)
func reversePairs(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    // æ‰§è¡Œå½’å¹¶æ’åºå¹¶ç»Ÿè®¡ã€Œç¿»è½¬å¯¹ã€çš„ä¸ªæ•°
    return sort(nums)
}

func sort(nums []int) int {
    var temp = make([]int, len(nums))
    var count = 0 // ç»Ÿè®¡ç¿»è½¬å¯¹ä¸ªæ•°
    sortHelper(nums, 0, len(nums) - 1, temp, &count)
    return count
}

// å½’å¹¶æ’åº
func sortHelper(nums []int, lo, hi int, temp []int, count *int) {
    if lo == hi {
        return
    }
    mid := lo + (hi - lo) / 2
    sortHelper(nums, lo, mid, temp, count)
    sortHelper(nums, mid + 1, hi, temp, count)
    merge(nums, lo, mid, hi, temp, count)
}

func merge(nums []int, lo, mid, hi int, temp []int, count *int) {
    // å…ˆå°† nums ä¸­ [lo, hi] çš„æ•°å¤åˆ¶åˆ° temp ä¸­
    for i := lo; i <= hi; i++ {
        temp[i] = nums[i]
    }

    // è¿›è¡Œæ•ˆç‡ä¼˜åŒ–ï¼Œç»´æŠ¤å·¦é—­å³å¼€åŒºé—´ [mid+1, end) ä¸­çš„å…ƒç´ ä¹˜ 2 å°äº nums[i]
    // ä¸ºä»€ä¹ˆ end æ˜¯å¼€åŒºé—´ï¼Ÿå› ä¸ºè¿™æ ·çš„è¯å¯ä»¥ä¿è¯åˆå§‹åŒºé—´ [mid+1, mid+1) æ˜¯ä¸€ä¸ªç©ºåŒºé—´
    end := mid + 1
    for i := lo; i <= mid; i++ {
        // nums ä¸­çš„å…ƒç´ å¯èƒ½è¾ƒå¤§ï¼Œä¹˜ 2 å¯èƒ½æº¢å‡ºï¼Œæ‰€ä»¥è½¬åŒ–æˆ int64
        for end <= hi && int64(nums[i]) > int64(nums[end]) * 2 {
            end++
        }
        *count += end - (mid + 1)
    }

    // æ•°ç»„åŒæŒ‡é’ˆæŠ€å·§ï¼Œåˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„
    i, j := lo, mid + 1
    for p := lo; p <= hi; p++ {
        if i == mid + 1 {
            nums[p] = temp[j]
            j++
        } else if j == hi + 1 {
            nums[p] = temp[i]
            i++
        } else if temp[i] > temp[j] {
            nums[p] = temp[j]
            j++
        } else {
            nums[p] = temp[i]
            i++
        }
    }
}
```

```java
// by labuladong (java)
class Solution {
    public int reversePairs(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        // æ‰§è¡Œå½’å¹¶æ’åº
        sort(nums);
        return count;
    }

    private int[] temp;

    public void sort(int[] nums) {
        temp = new int[nums.length];
        sort(nums, 0, nums.length - 1);
    }

    // å½’å¹¶æ’åº
    private void sort(int[] nums, int lo, int hi) {
        if (lo == hi) {
            return;
        }
        int mid = lo + (hi - lo) / 2;
        sort(nums, lo, mid);
        sort(nums, mid + 1, hi);
        merge(nums, lo, mid, hi);
    }

    // è®°å½•ã€Œç¿»è½¬å¯¹ã€çš„ä¸ªæ•°
    private int count = 0;

    private void merge(int[] nums, int lo, int mid, int hi) {
        for (int i = lo; i <= hi; i++) {
            temp[i] = nums[i];
        }

        // è¿›è¡Œæ•ˆç‡ä¼˜åŒ–ï¼Œç»´æŠ¤å·¦é—­å³å¼€åŒºé—´ [mid+1, end) ä¸­çš„å…ƒç´ ä¹˜ 2 å°äº nums[i]
        // ä¸ºä»€ä¹ˆ end æ˜¯å¼€åŒºé—´ï¼Ÿå› ä¸ºè¿™æ ·çš„è¯å¯ä»¥ä¿è¯åˆå§‹åŒºé—´ [mid+1, mid+1) æ˜¯ä¸€ä¸ªç©ºåŒºé—´
        int end = mid + 1;
        for (int i = lo; i <= mid; i++) {
            // nums ä¸­çš„å…ƒç´ å¯èƒ½è¾ƒå¤§ï¼Œä¹˜ 2 å¯èƒ½æº¢å‡ºï¼Œæ‰€ä»¥è½¬åŒ–æˆ long
            while (end <= hi && nums[i] > nums[end]) {
                end++;
            }
            count += end - (mid + 1);
        }

        // æ•°ç»„åŒæŒ‡é’ˆæŠ€å·§ï¼Œåˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„
        int i = lo, j = mid + 1;
        for (int p = lo; p <= hi; p++) {
            if (i == mid + 1) {
                nums[p] = temp[j++];
            } else if (j == hi + 1) {
                nums[p] = temp[i++];
            } else if (temp[i] > temp[j]) {
                nums[p] = temp[j++];
            } else {
                nums[p] = temp[i++];
            }
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var reversePairs = function(nums) {
    if (nums.length == 0) {
        return 0;
    }
    // æ‰§è¡Œå½’å¹¶æ’åº
    sort(nums);
    return count;
};

function sort(nums) {
    var temp = new Array(nums.length);
    var count = new Array(1);
    sortUtil(nums, 0, nums.length - 1, temp, count);
}

// å½’å¹¶æ’åº
function sortUtil(nums, lo, hi, temp, count) {
    if (lo == hi) {
        return;
    }
    var mid = parseInt(lo + (hi - lo) / 2);
    sortUtil(nums, lo, mid, temp, count);
    sortUtil(nums, mid + 1, hi, temp, count);
    merge(nums, lo, mid, hi, temp, count);
}

// è®°å½•ã€Œç¿»è½¬å¯¹ã€çš„ä¸ªæ•°
function merge(nums, lo, mid, hi, temp, count) {
    for (var i = lo; i <= hi; i++) {
        temp[i] = nums[i];
    }

    // è¿›è¡Œæ•ˆç‡ä¼˜åŒ–ï¼Œç»´æŠ¤å·¦é—­å³å¼€åŒºé—´ [mid+1, end) ä¸­çš„å…ƒç´ ä¹˜ 2 å°äº nums[i]
    // ä¸ºä»€ä¹ˆ end æ˜¯å¼€åŒºé—´ï¼Ÿå› ä¸ºè¿™æ ·çš„è¯å¯ä»¥ä¿è¯åˆå§‹åŒºé—´ [mid+1, mid+1) æ˜¯ä¸€ä¸ªç©ºåŒºé—´
    var end = mid + 1;
    for (var i = lo; i <= mid; i++) {
        // nums ä¸­çš„å…ƒç´ å¯èƒ½è¾ƒå¤§ï¼Œä¹˜ 2 å¯èƒ½æº¢å‡ºï¼Œæ‰€ä»¥è½¬åŒ–æˆ long
        while (end <= hi && nums[i] > nums[end]) {
            end++;
        }
        count[0] += end - (mid + 1);
    }

    // æ•°ç»„åŒæŒ‡é’ˆæŠ€å·§ï¼Œåˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„
    var i = lo, j = mid + 1;
    for (var p = lo; p <= hi; p++) {
        if (i == mid + 1) {
            nums[p] = temp[j++];
        } else if (j == hi + 1) {
            nums[p] = temp[i++];
        } else if (temp[i] > temp[j]) {
            nums[p] = temp[j++];
        } else {
            nums[p] = temp[i++];
        }
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.count = 0
        self.tmp = []

    # åŒ…è£…æ–¹æ³•
    def reversePairs(self, nums: List[int]) -> int:
        if not nums:
            return 0
        # æ‰§è¡Œå½’å¹¶æ’åº
        self.ms(nums, 0, len(nums) - 1)
        return self.count

    # å½’å¹¶æ’åº
    def ms(self, nums, left, right):
        if left >= right:
            return
        mid = (left + right) >> 1
        self.ms(nums, left, mid)
        self.ms(nums, mid + 1, right)
        self.merge(nums, left, mid, right)

    # åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„
    def merge(self, nums, left, mid, right):
        i, j = left, mid + 1
        t = []
        # è¿›è¡Œæ•ˆç‡ä¼˜åŒ–ï¼Œç»´æŠ¤å·¦é—­å³å¼€åŒºé—´ [mid+1, end) ä¸­çš„å…ƒç´ ä¹˜ 2 å°äº nums[i]
        # ä¸ºä»€ä¹ˆ end æ˜¯å¼€åŒºé—´ï¼Ÿå› ä¸ºè¿™æ ·çš„è¯å¯ä»¥ä¿è¯åˆå§‹åŒºé—´ [mid+1, mid+1) æ˜¯ä¸€ä¸ªç©ºåŒºé—´
        end = mid + 1
        while i <= mid and j <= right:
            if nums[i] <= nums[j]:
                t.append(nums[i])
                i += 1
            else:
                t.append(nums[j])
                j += 1
                self.count += (mid - i + 1)

        while i <= mid:
            t.append(nums[i])
            i += 1

        while j <= right:
            t.append(nums[j])
            j += 1

        nums[left:right + 1] = t
```

https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        for (int num : nums) {
            if (nums[abs(num)] < 0) {
                // ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
                // è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡
                return abs(num);
            } else {
                // æŠŠç´¢å¼• num çš„å…ƒç´ ç½®ä¸ºè´Ÿæ•°
                nums[abs(num)] *= -1;
            }
        }
        // å¦‚æœæ²¡æœ‰åœ¨ for å¾ªç¯ä¸­è¿”å›ï¼Œè¯´æ˜é‡å¤çš„é‚£ä¸ªå…ƒç´ æ˜¯ 0
        return 0;
    }
};
```

```go
// by chatGPT (go)
func findRepeatNumber(nums []int) int {
    for _, num := range nums {
        if nums[abs(num)] < 0 {
            // ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
            // è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡
            return abs(num)
        } else {
            // æŠŠç´¢å¼• num çš„å…ƒç´ ç½®ä¸ºè´Ÿæ•°
            nums[abs(num)] *= -1
        }
    }
    // å¦‚æœæ²¡æœ‰åœ¨ for å¾ªç¯ä¸­è¿”å›ï¼Œè¯´æ˜é‡å¤çš„é‚£ä¸ªå…ƒç´ æ˜¯ 0
    return 0
}

func abs(num int) int {
    if num < 0 {
        return -num
    }
    return num
}
```

```java
// by labuladong (java)
class Solution {
    public int findRepeatNumber(int[] nums) {
        // å…ˆæŠŠ nums æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½åŠ ä¸€ï¼Œé¿å… 0 çš„å½±å“
        for (int i = 0; i < nums.length; i++) {
            nums[i] = nums[i] + 1;
        }

        for (int num : nums) {
            // è¯¥å…ƒç´ å¯¹åº”çš„ç´¢å¼•
            int index = Math.abs(num) - 1;
            if (nums[index] < 0) {
                // ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
                // è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡
                // æ³¨æ„ç»“æœè¦å‡ä¸€
                return Math.abs(num) - 1;
            } else {
                // æŠŠç´¢å¼• num çš„å…ƒç´ ç½®ä¸ºè´Ÿæ•°
                nums[index] *= -1;
            }
        }
        return -1;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @return {number}
 */
var findRepeatNumber = function(nums) {
    for (let num of nums) {
        if (nums[Math.abs(num)] < 0) {
            // ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
            // è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡
            return Math.abs(num);
        } else {
            // æŠŠç´¢å¼• num çš„å…ƒç´ ç½®ä¸ºè´Ÿæ•°
            nums[Math.abs(num)] *= -1;
        }
    }
    // å¦‚æœæ²¡æœ‰åœ¨ for å¾ªç¯ä¸­è¿”å›ï¼Œè¯´æ˜é‡å¤çš„é‚£ä¸ªå…ƒç´ æ˜¯ 0
    return 0;
};
```

```python
# by chatGPT (python)
class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        for num in nums:
            if nums[abs(num)] < 0:
                # ä¹‹å‰å·²ç»æŠŠå¯¹åº”ç´¢å¼•çš„å…ƒç´ å˜æˆè´Ÿæ•°äº†ï¼Œ
                # è¿™è¯´æ˜ num é‡å¤å‡ºç°äº†ä¸¤æ¬¡
                return abs(num)
            else:
                # æŠŠç´¢å¼• num çš„å…ƒç´ ç½®ä¸ºè´Ÿæ•°
                nums[abs(num)] *= -1
        # å¦‚æœæ²¡æœ‰åœ¨ for å¾ªç¯ä¸­è¿”å›ï¼Œè¯´æ˜é‡å¤çš„é‚£ä¸ªå…ƒç´ æ˜¯ 0
        return 0
```

https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/simplify-path çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    string simplifyPath(string path) {
        vector<string> parts;
        int start = 0;
        for (int i = 1; i <= path.size(); ++i) {
            if (path[i] == '/' || i == path.size()) {
                string part = path.substr(start + 1, i - start - 1);
                if (part == "" || part == ".") {
                    // part ä¸ºç©ºæˆ–ä¸º . ï¼Œå¿½ç•¥
                } else if (part == "..") {
                    if (!parts.empty()) parts.pop_back();
                } else {
                    parts.push_back(part);
                }
                start = i;
            }
        }
        string res = "";
        for (string part : parts) {
            res += "/" + part;
        }
        return res.empty() ? "/" : res;
    }
};
```

```go
// by chatGPT (go)
import (
    "strings"
)

func simplifyPath(path string) string {
    parts := strings.Split(path, "/")
    stk := make([]string, 0)
    // å€ŸåŠ©æ ˆè®¡ç®—æœ€ç»ˆçš„æ–‡ä»¶å¤¹è·¯å¾„
    for _, part := range parts {
        if part == "" || part == "." {
            continue
        }
        if part == ".." {
            if len(stk) != 0 {
                stk = stk[:len(stk)-1]
            }
        } else {
            stk = append(stk, part)
        }
    }
    // æ ˆä¸­å­˜å‚¨çš„æ–‡ä»¶å¤¹ç»„æˆè·¯å¾„
    res := ""
    for i := len(stk) - 1; i >= 0; i-- {
        res = "/" + stk[i] + res
    }
    if res == "" {
        res = "/"
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public String simplifyPath(String path) {
        String[] parts = path.split("/");
        Stack<String> stk = new Stack<>();
        // å€ŸåŠ©æ ˆè®¡ç®—æœ€ç»ˆçš„æ–‡ä»¶å¤¹è·¯å¾„
        for (String part : parts) {
            if (part.isEmpty() || part.equals(".")) {
                continue;
            }
            if (part.equals("..")) {
                if (!stk.isEmpty()) stk.pop();
                continue;
            }
            stk.push(part);
        }
        // æ ˆä¸­å­˜å‚¨çš„æ–‡ä»¶å¤¹ç»„æˆè·¯å¾„
        String res = "";
        while (!stk.isEmpty()) {
            res = "/" + stk.pop() + res;
        }
        return res.isEmpty() ? "/" : res;
    }
}
```

```javascript
// by chatGPT (javascript)
var simplifyPath = function(path) {
    var parts = path.split("/");
    var stk = [];
    // å€ŸåŠ©æ ˆè®¡ç®—æœ€ç»ˆçš„æ–‡ä»¶å¤¹è·¯å¾„
    for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (part === "" || part === ".") {
            continue;
        }
        if (part === "..") {
            if (stk.length !== 0) stk.pop();
            continue;
        }
        stk.push(part);
    }
    // æ ˆä¸­å­˜å‚¨çš„æ–‡ä»¶å¤¹ç»„æˆè·¯å¾„
    var res = "";
    while (stk.length !== 0) {
        res = "/" + stk.pop() + res;
    }
    return res === "" ? "/" : res;
};
```

```python
# by chatGPT (python)
class Solution:
    def simplifyPath(self, path: str) -> str:
        parts = path.split("/")
        stk = []
        # å€ŸåŠ©æ ˆè®¡ç®—æœ€ç»ˆçš„æ–‡ä»¶å¤¹è·¯å¾„
        for part in parts:
            if part == '' or part == '.':
                continue
            if part == '..':
                if stk:
                    stk.pop()
                continue
            stk.append(part)
        # æ ˆä¸­å­˜å‚¨çš„æ–‡ä»¶å¤¹ç»„æˆè·¯å¾„
        res = ""
        while stk:
            res = '/' + stk.pop() + res
        return res if res else '/'
```

https://leetcode.cn/problems/simplify-path çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/single-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for (int n : nums) {
            res ^= n;
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
/**
 * @param nums: List[int]
 * @return: int
 */
func singleNumber(nums []int) int {
    res := 0
    for _, n := range nums {
        res ^= n
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for (int n : nums) {
            res ^= n;
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    let res = 0;
    for (let n of nums) {
        res ^= n;
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        res = 0
        for n in nums:
            res ^= n
        return res
```

https://leetcode.cn/problems/single-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/single-threaded-cpu çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> getOrder(vector<vector<int>>& tasks) {
        int n = tasks.size();
        // æŠŠåŸå§‹ç´¢å¼•ä¹Ÿæ·»åŠ ä¸Šï¼Œæ–¹ä¾¿åé¢æ’åºç”¨
        vector<vector<int>> triples;
        for (int i = 0; i < n; i++) {
            triples.push_back({tasks[i][0], tasks[i][1], i});
        }
        // æ•°ç»„å…ˆæŒ‰ç…§ä»»åŠ¡çš„å¼€å§‹æ—¶é—´æ’åº
        sort(triples.begin(), triples.end(), [](auto a, auto b){
            return a[0] < b[0];
        });

        // æŒ‰ç…§ä»»åŠ¡çš„å¤„ç†æ—¶é—´æ’åºï¼Œå¦‚æœå¤„ç†æ—¶é—´ç›¸åŒï¼ŒæŒ‰ç…§åŸå§‹ç´¢å¼•æ’åº
        auto cmp = [](vector<int>& a, vector<int>& b){
            if (a[1] != b[1]) {
                // æ¯”è¾ƒå¤„ç†æ—¶é—´
                return a[1] > b[1];
            }
            // æ¯”è¾ƒåŸå§‹ç´¢å¼•
            return a[2] > b[2];
        };
        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pq(cmp);

        vector<int> res;
        // è®°å½•å®Œæˆä»»åŠ¡çš„æ—¶é—´çº¿
        int now = 0;
        int i = 0;
        while (res.size() < n) {
            if (!pq.empty()) {
                // å®Œæˆé˜Ÿåˆ—ä¸­çš„ä¸€ä¸ªä»»åŠ¡
                vector<int> triple = pq.top();
                pq.pop();
                res.push_back(triple[2]);
                // æ¯å®Œæˆä¸€ä¸ªä»»åŠ¡ï¼Œå°±è¦æ¨è¿›æ—¶é—´çº¿
                now += triple[1];
            } else if (i < n && triples[i][0] > now) {
                // é˜Ÿåˆ—ä¸ºç©ºå¯èƒ½å› ä¸ºè¿˜æ²¡åˆ°å¼€å§‹æ—¶é—´ï¼Œ
                // ç›´æ¥æŠŠæ—¶é—´çº¿æ¨è¿›åˆ°æœ€è¿‘ä»»åŠ¡çš„å¼€å§‹æ—¶é—´
                now = triples[i][0];
            }

            // ç”±äºæ—¶é—´çº¿çš„æ¨è¿›ï¼Œä¼šäº§ç”Ÿå¯ä»¥å¼€å§‹æ‰§è¡Œçš„ä»»åŠ¡
            for (; i < n && triples[i][0] <= now; i++) {
                pq.push(triples[i]);
            }
        }

        return res;
    }
};
```

```go
// by chatGPT (go)
// å®šä¹‰ä»»åŠ¡
type task struct {
    // å…¥é˜Ÿæ—¶é—´ï¼Œå³å¼€å§‹æ—¶é—´
    enqueTime int
    // å¤„ç†æ—¶é—´
    interval int
    // åŸå§‹ç´¢å¼•
    id int
}

// è‡ªå®šä¹‰ä¼˜å…ˆé˜Ÿåˆ—ï¼ŒæŒ‰ç…§ä»»åŠ¡å¤„ç†æ—¶é—´æ’åºï¼Œå¦‚æœå¤„ç†æ—¶é—´ç›¸åŒï¼ŒæŒ‰ç…§åŸå§‹ç´¢å¼•æ’åº
type queue []task

// æ¯”è¾ƒå™¨ï¼Œå¦‚æœæƒ³è¦å½“å‰å…ƒç´ åœ¨é˜Ÿé¦–ï¼Œé‚£ä¹ˆè¿”å› true
func (q queue) Less(i, j int) bool {
    if q[i].interval == q[j].interval {
        return q[i].id < q[j].id
    }
    return q[i].interval < q[j].interval
}

// è®¡ç®—é˜Ÿåˆ—é•¿åº¦
func (q queue) Len() int {
    return len(q)
}

// äº¤æ¢å…ƒç´ 
func (q queue) Swap(i, j int) {
    q[i], q[j] = q[j], q[i]
}

// å…¥é˜Ÿ
func (q *queue) Push(p interface{}) {
    *q = append(*q, p.(task))
}

// å‡ºé˜Ÿ
func (q *queue) Pop() interface{} {
    top := (*q)[len(*q)-1]
    *q = (*q)[:len(*q)-1]
    return top
}

func getOrder(tasks [][]int) []int {
    // ä»»åŠ¡æ•°é‡
    n := len(tasks)
    // æŠŠåŸå§‹ç´¢å¼•ä¹Ÿæ·»åŠ ä¸Šï¼Œæ–¹ä¾¿åé¢æ’åºç”¨
    tasksWithID := make([]task, n)
    for i := range tasks {
        tasksWithID[i] = task{tasks[i][0], tasks[i][1], i}
    }
    // æ•°ç»„å…ˆæŒ‰ç…§ä»»åŠ¡çš„å¼€å§‹æ—¶é—´æ’åº
    sort.Slice(tasksWithID, func(i, j int) bool {
        return tasksWithID[i].enqueTime < tasksWithID[j].enqueTime
    })

    // ä»»åŠ¡é˜Ÿåˆ—
    q := make(queue, 0, n)
    // ç»“æœæ•°ç»„
    res := make([]int, 0, n)
    // è®°å½•ç°åœ¨çš„æ—¶é—´çº¿
    i, now := 0, 0
    // å½“å‰è¿˜æœªå®Œæˆçš„ä»»åŠ¡æ•°ç›®
    for len(res) < n {
        // æ—¶é—´çº¿è¢«æ¨è¿›ï¼Œäº§ç”Ÿæ–°ä»»åŠ¡
        for ; i < n && tasksWithID[i].enqueTime <= now; i++ {
            q = append(q, tasksWithID[i])
        }
        // å¦‚æœå½“å‰é˜Ÿåˆ—ä¸ºç©ºï¼Œå› ä¸ºæ—¶é—´çº¿è¿˜æœªåˆ°ç¬¬ä¸€ä¸ªä»»åŠ¡çš„å¼€å§‹æ—¶é—´ï¼Œç›´æ¥å°†æ—¶é—´çº¿æ¨è¿›åˆ°ç¬¬ä¸€ä¸ªä»»åŠ¡çš„å¼€å§‹æ—¶é—´ï¼Œå¹¶å°† i ç§»å‘ä¸‹ä¸€ä¸ªä»»åŠ¡
        if len(q) == 0 {
            now = tasksWithID[i].enqueTime
            i++
        } else { // å¤„ç†é˜Ÿåˆ—ä¸­ä»»åŠ¡
            heap.Init(&q)
            top := heap.Pop(&q).(task)
            res = append(res, top.id)
            now += top.interval
        }
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int[] getOrder(int[][] tasks) {
        int n = tasks.length;
        // æŠŠåŸå§‹ç´¢å¼•ä¹Ÿæ·»åŠ ä¸Šï¼Œæ–¹ä¾¿åé¢æ’åºç”¨
        ArrayList<int[]> triples = new ArrayList<>();
        for (int i = 0; i < tasks.length; i++) {
            triples.add(new int[]{tasks[i][0], tasks[i][1], i});
        }
        // æ•°ç»„å…ˆæŒ‰ç…§ä»»åŠ¡çš„å¼€å§‹æ—¶é—´æ’åº
        triples.sort((a, b) -> {
            return a[0] - b[0];
        });

        // æŒ‰ç…§ä»»åŠ¡çš„å¤„ç†æ—¶é—´æ’åºï¼Œå¦‚æœå¤„ç†æ—¶é—´ç›¸åŒï¼ŒæŒ‰ç…§åŸå§‹ç´¢å¼•æ’åº
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            if (a[1] != b[1]) {
                // æ¯”è¾ƒå¤„ç†æ—¶é—´
                return a[1] - b[1];
            }
            // æ¯”è¾ƒåŸå§‹ç´¢å¼•
            return a[2] - b[2];
        });

        ArrayList<Integer> res = new ArrayList<>();
        // è®°å½•å®Œæˆä»»åŠ¡çš„æ—¶é—´çº¿
        int now = 0;
        int i = 0;
        while (res.size() < n) {
            if (!pq.isEmpty()) {
                // å®Œæˆé˜Ÿåˆ—ä¸­çš„ä¸€ä¸ªä»»åŠ¡
                int[] triple = pq.poll();
                res.add(triple[2]);
                // æ¯å®Œæˆä¸€ä¸ªä»»åŠ¡ï¼Œå°±è¦æ¨è¿›æ—¶é—´çº¿
                now += triple[1];
            } else if (i < n && triples.get(i)[0] > now) {
                // é˜Ÿåˆ—ä¸ºç©ºå¯èƒ½å› ä¸ºè¿˜æ²¡åˆ°å¼€å§‹æ—¶é—´ï¼Œ
                // ç›´æ¥æŠŠæ—¶é—´çº¿æ¨è¿›åˆ°æœ€è¿‘ä»»åŠ¡çš„å¼€å§‹æ—¶é—´
                now = triples.get(i)[0];
            }

            // ç”±äºæ—¶é—´çº¿çš„æ¨è¿›ï¼Œä¼šäº§ç”Ÿå¯ä»¥å¼€å§‹æ‰§è¡Œçš„ä»»åŠ¡
            for (; i < n && triples.get(i)[0] <= now; i++) {
                pq.offer(triples.get(i));
            }
        }

        // Java è¯­è¨€ç‰¹æ€§ï¼Œå°† List è½¬åŒ–æˆ int[] æ ¼å¼
        int[] arr = new int[n];
        for (int j = 0; j < n; j++) {
            arr[j] = res.get(j);
        }
        return arr;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} tasks
 * @return {number[]}
 */
var getOrder = function(tasks) {
    const n = tasks.length;

    // æŠŠåŸå§‹ç´¢å¼•ä¹Ÿæ·»åŠ ä¸Šï¼Œæ–¹ä¾¿åé¢æ’åºç”¨
    const triples = [];
    for (let i = 0; i < tasks.length; i++) {
        triples.push([tasks[i][0], tasks[i][1], i]);
    }

    // æ•°ç»„å…ˆæŒ‰ç…§ä»»åŠ¡çš„å¼€å§‹æ—¶é—´æ’åº
    triples.sort((a, b) => {
        return a[0] - b[0];
    });

    // æŒ‰ç…§ä»»åŠ¡çš„å¤„ç†æ—¶é—´æ’åºï¼Œå¦‚æœå¤„ç†æ—¶é—´ç›¸åŒï¼ŒæŒ‰ç…§åŸå§‹ç´¢å¼•æ’åº
    const pq = new PriorityQueue((a, b) => {
        if (a[1] !== b[1]) {
            // æ¯”è¾ƒå¤„ç†æ—¶é—´
            return a[1] - b[1];
        }
        // æ¯”è¾ƒåŸå§‹ç´¢å¼•
        return a[2] - b[2];
    });

    const res = [];
    // è®°å½•å®Œæˆä»»åŠ¡çš„æ—¶é—´çº¿
    let now = 0;
    let i = 0;
    while (res.length < n) {
        if (!pq.isEmpty()) {
            // å®Œæˆé˜Ÿåˆ—ä¸­çš„ä¸€ä¸ªä»»åŠ¡
            const triple = pq.poll();
            res.push(triple[2]);
            // æ¯å®Œæˆä¸€ä¸ªä»»åŠ¡ï¼Œå°±è¦æ¨è¿›æ—¶é—´çº¿
            now += triple[1];
        } else if (i < n && triples[i][0] > now) {
            // é˜Ÿåˆ—ä¸ºç©ºå¯èƒ½å› ä¸ºè¿˜æ²¡åˆ°å¼€å§‹æ—¶é—´ï¼Œ
            // ç›´æ¥æŠŠæ—¶é—´çº¿æ¨è¿›åˆ°æœ€è¿‘ä»»åŠ¡çš„å¼€å§‹æ—¶é—´
            now = triples[i][0];
        }

        // ç”±äºæ—¶é—´çº¿çš„æ¨è¿›ï¼Œä¼šäº§ç”Ÿå¯ä»¥å¼€å§‹æ‰§è¡Œçš„ä»»åŠ¡
        for (; i < n && triples[i][0] <= now; i++) {
            pq.offer(triples[i]);
        }
    }

    // JavaScriptè¯­è¨€ç‰¹æ€§ï¼Œä¸éœ€è¦è½¬åŒ–æˆint[]æ ¼å¼
    return res;
};

class PriorityQueue {
    constructor(comparator) {
        this.heap = [];
        this.comparator = comparator;
    }

    isEmpty() {
        return this.heap.length === 0;
    }

    size() {
        return this.heap.length;
    }

    peek() {
        return this.isEmpty() ? null : this.heap[0];
    }

    offer(item) {
        this.heap.push(item);
        this.siftUp(this.heap.length - 1);
    }

    poll() {
        if (this.isEmpty()) {
            return null;
        }

        const item = this.heap[0];
        this.heap[0] = this.heap[this.heap.length - 1];
        this.heap.pop();
        this.siftDown(0);
        return item;
    }

    heapify() {
        if (this.isEmpty()) {
            return;
        }

        for (let i = Math.floor(this.size() / 2) - 1; i >= 0; i--) {
            this.siftDown(i);
        }
    }

    siftUp(index) {
        let parent = Math.floor((index - 1) / 2);

        while (index > 0 && this.comparator(this.heap[index], this.heap[parent]) < 0) {
            const tmp = this.heap[index];
            this.heap[index] = this.heap[parent];
            this.heap[parent] = tmp;

            index = parent;
            parent = Math.floor((index - 1) / 2);
        }
    }

    siftDown(index) {
        let child = index * 2 + 1;

        while (child < this.size()) {
            if (child + 1 < this.size() && this.comparator(this.heap[child + 1], this.heap[child]) < 0) {
                child++;
            }

            if (this.comparator(this.heap[child], this.heap[index]) < 0) {
                const tmp = this.heap[index];
                this.heap[index] = this.heap[child];
                this.heap[child] = tmp;

                index = child;
                child = index * 2 + 1;
            } else {
                break;
            }
        }
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def getOrder(self, tasks: List[List[int]]) -> List[int]:
        n = len(tasks)
        # æŠŠåŸå§‹ç´¢å¼•ä¹Ÿæ·»åŠ ä¸Šï¼Œæ–¹ä¾¿åé¢æ’åºç”¨
        triples = []
        for i in range(n):
            triples.append([tasks[i][0], tasks[i][1], i])
        # æ•°ç»„å…ˆæŒ‰ç…§ä»»åŠ¡çš„å¼€å§‹æ—¶é—´æ’åº
        triples.sort(key=lambda a: a[0])

        # æŒ‰ç…§ä»»åŠ¡çš„å¤„ç†æ—¶é—´æ’åºï¼Œå¦‚æœå¤„ç†æ—¶é—´ç›¸åŒï¼ŒæŒ‰ç…§åŸå§‹ç´¢å¼•æ’åº
        pq = []
        heapq.heapify(pq)
        for a in triples:
            heapq.heappush(pq, (a[1], a[2]))

        res = []
        # è®°å½•å®Œæˆä»»åŠ¡çš„æ—¶é—´çº¿
        now = 0
        while len(res) < n:
            if pq:
                # å®Œæˆé˜Ÿåˆ—ä¸­çš„ä¸€ä¸ªä»»åŠ¡
                triple = heapq.heappop(pq)
                res.append(triple[1])
                # æ¯å®Œæˆä¸€ä¸ªä»»åŠ¡ï¼Œå°±è¦æ¨è¿›æ—¶é—´çº¿
                now += triple[0]
            elif triples[0][0] > now:
                # é˜Ÿåˆ—ä¸ºç©ºå¯èƒ½å› ä¸ºè¿˜æ²¡åˆ°å¼€å§‹æ—¶é—´ï¼Œ
                # ç›´æ¥æŠŠæ—¶é—´çº¿æ¨è¿›åˆ°æœ€è¿‘ä»»åŠ¡çš„å¼€å§‹æ—¶é—´
                now = triples[0][0]
            else:
                # ç”±äºæ—¶é—´çº¿çš„æ¨è¿›ï¼Œä¼šäº§ç”Ÿå¯ä»¥å¼€å§‹æ‰§è¡Œçš„ä»»åŠ¡
                while triples and triples[0][0] <= now:
                    a = triples.pop(0)
                    heapq.heappush(pq, (a[1], a[2]))

        # Java è¯­è¨€ç‰¹æ€§ï¼Œå°† List è½¬åŒ–æˆ int[] æ ¼å¼
        return res
```

https://leetcode.cn/problems/single-threaded-cpu çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/sliding-puzzle çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int slidingPuzzle(vector<vector<int>>& board) {
        int m = 2, n = 3;
        string target = "123450";
        // å°† 2x3 çš„æ•°ç»„è½¬åŒ–æˆå­—ç¬¦ä¸²ä½œä¸º BFS çš„èµ·ç‚¹
        string start = "";
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                start += to_string(board[i][j]);
            }
        }

        // è®°å½•ä¸€ç»´å­—ç¬¦ä¸²çš„ç›¸é‚»ç´¢å¼•
        int neighbor[6][3] = {
            {1, 3},
            {0, 4, 2},
            {1, 5},
            {0, 4},
            {3, 1, 5},
            {4, 2}
        };

        /******* BFS ç®—æ³•æ¡†æ¶å¼€å§‹ *******/
        queue<string> q;
        unordered_set<string> visited;
        // ä»èµ·ç‚¹å¼€å§‹ BFS æœç´¢
        q.push(start);
        visited.insert(start);

        int step = 0;
        while (!q.empty()) {
            int sz = q.size();
            for (int i = 0; i < sz; i++) {
                string cur = q.front();
                q.pop();
                // åˆ¤æ–­æ˜¯å¦è¾¾åˆ°ç›®æ ‡å±€é¢
                if (target == cur) {
                    return step;
                }
                // æ‰¾åˆ°æ•°å­— 0 çš„ç´¢å¼•
                int idx = 0;
                for (; cur[idx] != '0'; idx++) ;
                // å°†æ•°å­— 0 å’Œç›¸é‚»çš„æ•°å­—äº¤æ¢ä½ç½®
                for (int j = 0; j < 3; j++) {
                    int adj = neighbor[idx][j];
                    string new_board = swap(cur, adj, idx);
                    // é˜²æ­¢èµ°å›å¤´è·¯
                    if (visited.find(new_board) == visited.end()) {
                        q.push(new_board);
                        visited.insert(new_board);
                    }
                }
            }
            step++;
        }
        /******* BFS ç®—æ³•æ¡†æ¶ç»“æŸ *******/
        return -1;
    }

    string swap(string str, int i, int j) {
        char temp = str[i];
        str[i] = str[j];
        str[j] = temp;
        return str;
    }
};
```

```go
// by chatGPT (go)
import "fmt"

func slidingPuzzle(board [][]int) int {
    m, n := 2, 3
    sb := make([]byte, 0, 6)
    target := "123450"
    // å°† 2x3 çš„æ•°ç»„è½¬åŒ–æˆå­—ç¬¦ä¸²ä½œä¸º BFS çš„èµ·ç‚¹
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            sb = append(sb, byte(board[i][j]+'0'))
        }
    }
    start := string(sb)

    // è®°å½•ä¸€ç»´å­—ç¬¦ä¸²çš„ç›¸é‚»ç´¢å¼•
    neighbor := [][]int{
        {1, 3},
        {0, 4, 2},
        {1, 5},
        {0, 4},
        {3, 1, 5},
        {4, 2},
    }

    /******* BFS ç®—æ³•æ¡†æ¶å¼€å§‹ *******/
    q := []string{start}
    visited := make(map[string]bool)
    // ä»èµ·ç‚¹å¼€å§‹ BFS æœç´¢
    visited[start] = true

    step := 0
    for len(q) > 0 {
        sz := len(q)
        for i := 0; i < sz; i++ {
            cur := q[i]
            // åˆ¤æ–­æ˜¯å¦è¾¾åˆ°ç›®æ ‡å±€é¢
            if cur == target {
                return step
            }
            // æ‰¾åˆ°æ•°å­— 0 çš„ç´¢å¼•
            idx := 0
            for cur[idx] != '0' {
                idx++
            }
            // å°†æ•°å­— 0 å’Œç›¸é‚»çš„æ•°å­—äº¤æ¢ä½ç½®
            for _, adj := range neighbor[idx] {
                newBoard := swap([]byte(cur), adj, idx)
                // é˜²æ­¢èµ°å›å¤´è·¯
                if !visited[newBoard] {
                    q = append(q, newBoard)
                    visited[newBoard] = true
                }
            }
        }
        q = q[sz:]
        step++
    }
    /******* BFS ç®—æ³•æ¡†æ¶ç»“æŸ *******/
    return -1
}

func swap(chars []byte, i, j int) string {
    temp := chars[i]
    chars[i] = chars[j]
    chars[j] = temp
    return string(chars)
}
```

```java
// by labuladong (java)
class Solution {
    public int slidingPuzzle(int[][] board) {
        int m = 2, n = 3;
        StringBuilder sb = new StringBuilder();
        String target = "123450";
        // å°† 2x3 çš„æ•°ç»„è½¬åŒ–æˆå­—ç¬¦ä¸²ä½œä¸º BFS çš„èµ·ç‚¹
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                sb.append(board[i][j]);
            }
        }
        String start = sb.toString();

        // è®°å½•ä¸€ç»´å­—ç¬¦ä¸²çš„ç›¸é‚»ç´¢å¼•
        int[][] neighbor = new int[][]{
                {1, 3},
                {0, 4, 2},
                {1, 5},
                {0, 4},
                {3, 1, 5},
                {4, 2}
        };

        /******* BFS ç®—æ³•æ¡†æ¶å¼€å§‹ *******/
        Queue<String> q = new LinkedList<>();
        HashSet<String> visited = new HashSet<>();
        // ä»èµ·ç‚¹å¼€å§‹ BFS æœç´¢
        q.offer(start);
        visited.add(start);

        int step = 0;
        while (!q.isEmpty()) {
            int sz = q.size();
            for (int i = 0; i < sz; i++) {
                String cur = q.poll();
                // åˆ¤æ–­æ˜¯å¦è¾¾åˆ°ç›®æ ‡å±€é¢
                if (target.equals(cur)) {
                    return step;
                }
                // æ‰¾åˆ°æ•°å­— 0 çš„ç´¢å¼•
                int idx = 0;
                for (; cur.charAt(idx) != '0'; idx++) ;
                // å°†æ•°å­— 0 å’Œç›¸é‚»çš„æ•°å­—äº¤æ¢ä½ç½®
                for (int adj : neighbor[idx]) {
                    String new_board = swap(cur.toCharArray(), adj, idx);
                    // é˜²æ­¢èµ°å›å¤´è·¯
                    if (!visited.contains(new_board)) {
                        q.offer(new_board);
                        visited.add(new_board);
                    }
                }
            }
            step++;
        }
        /******* BFS ç®—æ³•æ¡†æ¶ç»“æŸ *******/
        return -1;
    }

    private String swap(char[] chars, int i, int j) {
        char temp = chars[i];
        chars[i] = chars[j];
        chars[j] = temp;
        return new String(chars);
    }

}
```

```javascript
// by chatGPT (javascript)
var slidingPuzzle = function(board) {
  const m = 2, n = 3;
  
  let sb = '';
  const target = '123450';
  // å°† 2x3 çš„æ•°ç»„è½¬åŒ–æˆå­—ç¬¦ä¸²ä½œä¸º BFS çš„èµ·ç‚¹
  for (let i = 0; i < m; i++) {
      for (let j = 0; j < n; j++) {
          sb += board[i][j];
      }
  }
  let start = sb.toString();

  // è®°å½•ä¸€ç»´å­—ç¬¦ä¸²çš„ç›¸é‚»ç´¢å¼•
  const neighbor = [
      [1, 3],
      [0, 4, 2],
      [1, 5],
      [0, 4],
      [3, 1, 5],
      [4, 2]
  ];
  
  /******* BFS ç®—æ³•æ¡†æ¶å¼€å§‹ *******/
  let q = [];
  const visited = new Set();
  // ä»èµ·ç‚¹å¼€å§‹ BFS æœç´¢
  q.push(start);
  visited.add(start);

  let step = 0;
  while (q.length) {
      const sz = q.length;
      for (let i = 0; i < sz; i++) {
          const cur = q.shift();
          // åˆ¤æ–­æ˜¯å¦è¾¾åˆ°ç›®æ ‡å±€é¢
          if (target === cur) {
              return step;
          }
          // æ‰¾åˆ°æ•°å­— 0 çš„ç´¢å¼•
          let idx = 0;
          for (; cur.charAt(idx) !== '0'; idx++) ;
          // å°†æ•°å­— 0 å’Œç›¸é‚»çš„æ•°å­—äº¤æ¢ä½ç½®
          for (const adj of neighbor[idx]) {
              const new_board = swap(cur.slice(0), adj, idx);
              // é˜²æ­¢èµ°å›å¤´è·¯
              if (!visited.has(new_board)) {
                  q.push(new_board);
                  visited.add(new_board);
              }
          }
      }
      step++;
  }
  /******* BFS ç®—æ³•æ¡†æ¶ç»“æŸ *******/
  return -1;
};

var swap = function(chars, i, j) {
  [chars[i], chars[j]] = [chars[j], chars[i]];
  return chars.join('');
};
```

```python
# by chatGPT (python)
class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        m, n = 2, 3
        sb = []
        target = "123450"
        # å°† 2x3 çš„æ•°ç»„è½¬åŒ–æˆå­—ç¬¦ä¸²ä½œä¸º BFS çš„èµ·ç‚¹
        for i in range(m):
            for j in range(n):
                sb.append(str(board[i][j]))
        start = ''.join(sb)

        # è®°å½•ä¸€ç»´å­—ç¬¦ä¸²çš„ç›¸é‚»ç´¢å¼•
        neighbor = [
            [1, 3],
            [0, 4, 2],
            [1, 5],
            [0, 4],
            [3, 1, 5],
            [4, 2]
        ]

        # BFS ç®—æ³•æ¡†æ¶å¼€å§‹
        q = collections.deque()
        visited = set()
        # ä»èµ·ç‚¹å¼€å§‹ BFS æœç´¢
        q.append(start)
        visited.add(start)

        step = 0
        while q:
            sz = len(q)
            for i in range(sz):
                cur = q.popleft()
                # åˆ¤æ–­æ˜¯å¦è¾¾åˆ°ç›®æ ‡å±€é¢
                if target == cur:
                    return step
                # æ‰¾åˆ°æ•°å­— 0 çš„ç´¢å¼•
                idx = cur.find('0')
                # å°†æ•°å­— 0 å’Œç›¸é‚»çš„æ•°å­—äº¤æ¢ä½ç½®
                for adj in neighbor[idx]:
                    new_board = self.swap(cur, adj, idx)
                    # é˜²æ­¢èµ°å›å¤´è·¯
                    if new_board not in visited:
                        q.append(new_board)
                        visited.add(new_board)
            step += 1
        # BFS ç®—æ³•æ¡†æ¶ç»“æŸ
        return -1

    def swap(self, chars, i, j):
        chars = list(chars)
        chars[i], chars[j] = chars[j], chars[i]
        return ''.join(chars)
```

https://leetcode.cn/problems/sliding-puzzle çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/sliding-window-maximum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    /* å•è°ƒé˜Ÿåˆ—çš„å®ç° */
    class MonotonicQueue {
    private:
        deque<int> q;
    public:
        void push(int n) {
            // å°†å°äº n çš„å…ƒç´ å…¨éƒ¨åˆ é™¤
            while (!q.empty() && q.back() < n) {
                q.pop_back();
            }
            // ç„¶åå°† n åŠ å…¥å°¾éƒ¨
            q.push_back(n);
        }

        int max() {
            return q.front();
        }

        void pop(int n) {
            if (n == q.front()) {
                q.pop_front();
            }
        }
    };

    /* è§£é¢˜å‡½æ•°çš„å®ç° */
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MonotonicQueue window;
        vector<int> res;

        for (int i = 0; i < nums.size(); i++) {
            if (i < k - 1) {
                //å…ˆå¡«æ»¡çª—å£çš„å‰ k - 1
                window.push(nums[i]);
            } else {
                // çª—å£å‘å‰æ»‘åŠ¨ï¼ŒåŠ å…¥æ–°æ•°å­—
                window.push(nums[i]);
                // è®°å½•å½“å‰çª—å£çš„æœ€å¤§å€¼
                res.push_back(window.max());
                // ç§»å‡ºæ—§æ•°å­—
                window.pop(nums[i - k + 1]);
            }
        }

        return res;
    }
};
```

```go
// by chatGPT (go)
/* å•è°ƒé˜Ÿåˆ—çš„å®ç° */
type MonotonicQueue struct {
    q []int
}

func (mq *MonotonicQueue) push(n int) {
    // å°†å°äº n çš„å…ƒç´ å…¨éƒ¨åˆ é™¤
    for len(mq.q) > 0 && mq.q[len(mq.q)-1] < n {
        mq.q = mq.q[:len(mq.q)-1]
    }
    // ç„¶åå°† n åŠ å…¥å°¾éƒ¨
    mq.q = append(mq.q, n)
}

func (mq *MonotonicQueue) max() int {
    return mq.q[0]
}

func (mq *MonotonicQueue) pop(n int) {
    if n == mq.q[0] {
        mq.q = mq.q[1:]
    }
}

/* è§£é¢˜å‡½æ•°çš„å®ç° */
func maxSlidingWindow(nums []int, k int) []int {
    window := MonotonicQueue{make([]int, 0)}
    res := make([]int, 0)

    for i := 0; i < len(nums); i++ {
        if i < k-1 {
            // å…ˆå¡«æ»¡çª—å£çš„å‰ k - 1
            window.push(nums[i])
        } else {
            // çª—å£å‘å‰æ»‘åŠ¨ï¼ŒåŠ å…¥æ–°æ•°å­—
            window.push(nums[i])
            // è®°å½•å½“å‰çª—å£çš„æœ€å¤§å€¼
            res = append(res, window.max())
            // ç§»å‡ºæ—§æ•°å­—
            window.pop(nums[i-k+1])
        }
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    /* å•è°ƒé˜Ÿåˆ—çš„å®ç° */
    class MonotonicQueue {
        LinkedList<Integer> q = new LinkedList<>();
        public void push(int n) {
            // å°†å°äº n çš„å…ƒç´ å…¨éƒ¨åˆ é™¤
            while (!q.isEmpty() && q.getLast() < n) {
                 /**<extend down -300>
                ![](../pictures/å•è°ƒé˜Ÿåˆ—/3.png)
                */
                q.pollLast();
            }
            // ç„¶åå°† n åŠ å…¥å°¾éƒ¨
            q.addLast(n);
        }

        public int max() {
            return q.getFirst();
        }

        public void pop(int n) {
            if (n == q.getFirst()) {
                q.pollFirst();
            }
        }
    }

    /* è§£é¢˜å‡½æ•°çš„å®ç° */
    public int[] maxSlidingWindow(int[] nums, int k) {
        MonotonicQueue window = new MonotonicQueue();
        List<Integer> res = new ArrayList<>();

        for (int i = 0; i < nums.length; i++) {
            if (i < k - 1) {
                //å…ˆå¡«æ»¡çª—å£çš„å‰ k - 1
                window.push(nums[i]);
            } else {
                /**<extend up -150>
                ![](../pictures/å•è°ƒé˜Ÿåˆ—/1.png)
                */
                // çª—å£å‘å‰æ»‘åŠ¨ï¼ŒåŠ å…¥æ–°æ•°å­—
                window.push(nums[i]);
                // è®°å½•å½“å‰çª—å£çš„æœ€å¤§å€¼
                res.add(window.max());
                // ç§»å‡ºæ—§æ•°å­—
                window.pop(nums[i - k + 1]);
            }
        }
        // éœ€è¦è½¬æˆ int[] æ•°ç»„å†è¿”å›
        int[] arr = new int[res.size()];
        for (int i = 0; i < res.size(); i++) {
            arr[i] = res.get(i);
        }
        return arr;
    }
}
```

```javascript
// by chatGPT (javascript)
var maxSlidingWindow = function(nums, k) {
    /**
     * å•è°ƒé˜Ÿåˆ—çš„å®ç°
     */
    class MonotonicQueue {
        constructor() {
            this.q = []
        }
        
        push(n) {
            // å°†å°äº n çš„å…ƒç´ å…¨éƒ¨åˆ é™¤
            while (this.q.length !== 0 && this.q[this.q.length - 1] < n) {
                /**<extend down -300>
                ![](../pictures/å•è°ƒé˜Ÿåˆ—/3.png)
                */
                this.q.pop()
            }
            // ç„¶åå°† n åŠ å…¥å°¾éƒ¨
            this.q.push(n)
        }

        max() {
            return this.q[0]
        }

        pop(n) {
            if (this.q[0] === n) {
                this.q.shift()
            }
        }
    }

    /**
     * è§£é¢˜å‡½æ•°çš„å®ç°
     */
    const window = new MonotonicQueue()
    const res = []

    for (let i = 0; i < nums.length; i++) {
        if (i < k - 1) {
            //å…ˆå¡«æ»¡çª—å£çš„å‰ k - 1
            window.push(nums[i])
        } else {
            /**<extend up -150>
            ![](../pictures/å•è°ƒé˜Ÿåˆ—/1.png)
            */
            // çª—å£å‘å‰æ»‘åŠ¨ï¼ŒåŠ å…¥æ–°æ•°å­—
            window.push(nums[i])
            // è®°å½•å½“å‰çª—å£çš„æœ€å¤§å€¼
            res.push(window.max())
            // ç§»å‡ºæ—§æ•°å­—
            window.pop(nums[i - k + 1])
        }
    }
    return res
}
```

```python
# by chatGPT (python)
class Solution:
    # Monotonic Queue Implementation
    class MonotonicQueue:
        def __init__(self):
            self.q = []
        
        # Push elements into the queue
        def push(self, n):
            # remove all elements smaller than n from the tail of the queue
            while self.q and self.q[-1] < n:
                # extend down -300
                # ![](../pictures/å•è°ƒé˜Ÿåˆ—/3.png)
                self.q.pop()
            # then insert n at the tail
            self.q.append(n)
        
        # Get maximum element in the queue
        def max(self):
            return self.q[0]
        
        # Remove element n from the queue
        def pop(self, n):
            if n == self.q[0]:
                self.q.pop(0)

    # Implementing the solution function
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        window = self.MonotonicQueue()
        res = []

        for i in range(len(nums)):
            if i < k - 1:
                # fill up the first k-1 elements of the window initially
                window.push(nums[i])
            else:
                # slide the window forward and add the new element
                window.push(nums[i])
                # record the maximum value of the current window
                res.append(window.max())
                # remove the old element
                window.pop(nums[i - k + 1])
        
        # converting the recorded elements into an integer array
        return res
```

https://leetcode.cn/problems/sliding-window-maximum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    string smallestSubsequence(string s) {
        stack<char> stk;

        // ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨è®°å½•å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ•°é‡
        // å› ä¸ºè¾“å…¥ä¸º ASCII å­—ç¬¦ï¼Œå¤§å° 256 å¤Ÿç”¨äº†
        int count[256] = {0};
        for (int i = 0; i < s.length(); i++) {
            count[s[i]]++;
        }

        bool inStack[256] = {false};
        for (char c : s) {
            // æ¯éå†è¿‡ä¸€ä¸ªå­—ç¬¦ï¼Œéƒ½å°†å¯¹åº”çš„è®¡æ•°å‡ä¸€
            count[c]--;

            if (inStack[c]) continue;

            while (!stk.empty() && stk.top() > c) {
                // è‹¥ä¹‹åä¸å­˜åœ¨æ ˆé¡¶å…ƒç´ äº†ï¼Œåˆ™åœæ­¢ pop
                if (count[stk.top()] == 0) {
                    break;
                }
                // è‹¥ä¹‹åè¿˜æœ‰ï¼Œåˆ™å¯ä»¥ pop
                inStack[stk.top()] = false;
                stk.pop();
            }
            stk.push(c);
            inStack[c] = true;
        }

        string res;
        while (!stk.empty()) {
            res += stk.top();
            stk.pop();
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

```go
// by chatGPT (go)
func smallestSubsequence(s string) string {
    stk := make([]byte, 0)

    // ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨è®°å½•å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ•°é‡
    // å› ä¸ºè¾“å…¥ä¸º ASCII å­—ç¬¦ï¼Œå¤§å° 256 å¤Ÿç”¨äº†
    count := make([]int, 256)
    for i := 0; i < len(s); i++ {
        count[s[i]]++
    }

    inStack := make([]bool, 256)
    for _, c := range s {
        // æ¯éå†è¿‡ä¸€ä¸ªå­—ç¬¦ï¼Œéƒ½å°†å¯¹åº”çš„è®¡æ•°å‡ä¸€
        count[c]--

        if inStack[c] {
            continue
        }

        for len(stk) > 0 && stk[len(stk)-1] > byte(c) {
            // è‹¥ä¹‹åä¸å­˜åœ¨æ ˆé¡¶å…ƒç´ äº†ï¼Œåˆ™åœæ­¢ pop
            if count[stk[len(stk)-1]] == 0 {
                break
            }
            // è‹¥ä¹‹åè¿˜æœ‰ï¼Œåˆ™å¯ä»¥ pop
            inStack[stk[len(stk)-1]] = false
            stk = stk[:len(stk)-1]
        }
        stk = append(stk, byte(c))
        inStack[c] = true
    }

    sb := make([]byte, 0, len(s))
    for i := len(stk) - 1; i >= 0; i-- {
        sb = append(sb, stk[i])
    }
    return string(sb)
}
```

```java
// by labuladong (java)
class Solution {
    public String smallestSubsequence(String s) {
        Stack<Character> stk = new Stack<>();

        // ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨è®°å½•å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ•°é‡
        // å› ä¸ºè¾“å…¥ä¸º ASCII å­—ç¬¦ï¼Œå¤§å° 256 å¤Ÿç”¨äº†
        int[] count = new int[256];
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i)]++;
        }

        boolean[] inStack = new boolean[256];
        for (char c : s.toCharArray()) {
            // æ¯éå†è¿‡ä¸€ä¸ªå­—ç¬¦ï¼Œéƒ½å°†å¯¹åº”çš„è®¡æ•°å‡ä¸€
            count[c]--;

            if (inStack[c]) continue;

            while (!stk.isEmpty() && stk.peek() > c) {
                // è‹¥ä¹‹åä¸å­˜åœ¨æ ˆé¡¶å…ƒç´ äº†ï¼Œåˆ™åœæ­¢ pop
                if (count[stk.peek()] == 0) {
                    break;
                }
                // è‹¥ä¹‹åè¿˜æœ‰ï¼Œåˆ™å¯ä»¥ pop
                inStack[stk.pop()] = false;
            }
            stk.push(c);
            inStack[c] = true;
        }

        StringBuilder sb = new StringBuilder();
        while (!stk.empty()) {
            sb.append(stk.pop());
        }
        return sb.reverse().toString();
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {string} s
 * @return {string}
 */
var smallestSubsequence = function(s) {
  // åˆ›å»ºä¸€ä¸ªâ€œæ ˆâ€ data structureï¼ˆä½¿ç”¨ array å®ç°ï¼‰æ¥å¤„ç†å­—ç¬¦ä¸²
  const stk = [];
  // åˆ›å»ºä¸€ä¸ªæ•°ç»„ç”¨äºè®°å½•å­—ç¬¦æ•°é‡
  // å› ä¸ºè¾“å…¥ä¸º ASCII å­—ç¬¦ï¼Œå¤§å° 256 å¤Ÿç”¨äº†
  const count = new Array(256).fill(0);
  for(let i = 0; i < s.length; i++) {
      count[s.charCodeAt(i)]++;
  }

  // åˆ›å»ºä¸€ä¸ª boolean æ•°ç»„æ¥è®°å½•å­—ç¬¦æ˜¯å¦å‡ºç°åœ¨â€œæ ˆâ€ä¸­
  const inStack = new Array(256).fill(false);
  for(let c of s) {
      // æ¯éå†è¿‡ä¸€ä¸ªå­—ç¬¦ï¼Œéƒ½å°†å¯¹åº”çš„è®¡æ•°å‡ä¸€
      count[c.charCodeAt()]--;
      // å¦‚æœè¯¥å­—ç¬¦å·²ç»åœ¨â€œæ ˆâ€ä¸­ï¼Œåˆ™è·³è¿‡
      if(inStack[c.charCodeAt()]) continue;
      // å¦‚æœè¯¥å­—ç¬¦ä¸åœ¨â€œæ ˆâ€ä¸­ï¼Œåˆ™éœ€è¦å°†â€œæ ˆâ€ä¸­æ¯”è¯¥å­—ç¬¦å¤§çš„å­—ç¬¦å‡ºæ ˆ
      while(stk.length && stk[stk.length - 1] > c) {
          // å¦‚æœå¼¹å‡ºçš„å­—ç¬¦åœ¨åé¢è¿˜ä¼šå‡ºç°ï¼Œåˆ™éœ€è¦æ·»åŠ å›æ¥ï¼Œåœæ­¢å‡ºæ ˆ
          if(count[stk[stk.length - 1].charCodeAt()] === 0) break;
          // å¦‚æœå¼¹å‡ºçš„å­—ç¬¦åœ¨åé¢ä¸å†å‡ºç°ï¼Œåˆ™å¯ä»¥ç»§ç»­å‡ºæ ˆ
          inStack[stk.pop().charCodeAt()] = false;
      }
      // å°†å­—ç¬¦å‹å…¥â€œæ ˆâ€ä¸­ï¼Œæ ‡è®°ä¸ºå‡ºç°
      stk.push(c);
      inStack[c.charCodeAt()] = true;
  }
  // æ„é€ ç»“æœå­—ç¬¦ä¸²
  return stk.join('');
};
```

```python
# by chatGPT (python)
class Solution:
    def smallestSubsequence(self, s: str) -> str:
        stk = []
        # ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨è®°å½•å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ•°é‡
        # å› ä¸ºè¾“å…¥ä¸º ASCII å­—ç¬¦ï¼Œå¤§å° 256 å¤Ÿç”¨äº†
        count = [0] * 256
        for i in range(len(s)):
            count[ord(s[i])] += 1

        inStack = [False] * 256
        for c in s:
            # æ¯éå†è¿‡ä¸€ä¸ªå­—ç¬¦ï¼Œéƒ½å°†å¯¹åº”çš„è®¡æ•°å‡ä¸€
            count[ord(c)] -= 1

            if inStack[ord(c)]:
                continue

            while stk and stk[-1] > c:
                # è‹¥ä¹‹åä¸å­˜åœ¨æ ˆé¡¶å…ƒç´ äº†ï¼Œåˆ™åœæ­¢ pop
                if count[ord(stk[-1])] == 0:
                    break
                # è‹¥ä¹‹åè¿˜æœ‰ï¼Œåˆ™å¯ä»¥ pop
                inStack[ord(stk.pop())] = False

            stk.append(c)
            inStack[ord(c)] = True

        return ''.join(stk)
```

https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/sort-characters-by-frequency çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    string frequencySort(string s) {
        vector<char> chars(s.begin(), s.end());
        // s ä¸­çš„å­—ç¬¦ -> è¯¥å­—ç¬¦å‡ºç°çš„é¢‘ç‡
        unordered_map<char, int> charToFreq;
        for (char ch : chars) {
            charToFreq[ch]++;
        }

        auto cmp = [](pair<char, int>& entry1, pair<char, int>& entry2) {
            return entry1.second < entry2.second;
        };
        // é˜Ÿåˆ—æŒ‰ç…§é”®å€¼å¯¹ä¸­çš„å€¼ï¼ˆå­—ç¬¦å‡ºç°é¢‘ç‡ï¼‰ä»å¤§åˆ°å°æ’åº
        priority_queue<pair<char, int>, vector<pair<char, int>>, decltype(cmp)> pq(cmp);

        // æŒ‰ç…§å­—ç¬¦é¢‘ç‡æ’åº
        for (auto& entry : charToFreq) {
            pq.push(entry);
        }

        string res = "";
        while (!pq.empty()) {
            // æŠŠé¢‘ç‡æœ€é«˜çš„å­—ç¬¦æ’åœ¨å‰é¢
            pair<char, int> entry = pq.top();
            pq.pop();
            res += string(entry.second, entry.first);
        }

        return res;
    }
};
```

```go
// by chatGPT (go)
// é¢˜ç›®åœ°å€ https://leetcode-cn.com/problems/sort-characters-by-frequency/
func frequencySort(s string) string {
    chars := []rune(s)
    // s ä¸­çš„å­—ç¬¦ -> è¯¥å­—ç¬¦å‡ºç°çš„é¢‘ç‡
    charToFreq := make(map[rune]int)
    for _, ch := range chars {
        charToFreq[ch]++
    }

    pq := priorityQueue{}
    // é˜Ÿåˆ—æŒ‰ç…§é”®å€¼å¯¹ä¸­çš„å€¼ï¼ˆå­—ç¬¦å‡ºç°é¢‘ç‡ï¼‰ä»å¤§åˆ°å°æ’åº
    for k, v := range charToFreq {
        pq = append(pq, entry{k, v})
    }
    sort.Sort(sort.Reverse(pq))

    var sb strings.Builder
    for _, e := range pq {
        // æŠŠé¢‘ç‡æœ€é«˜çš„å­—ç¬¦æ’åœ¨å‰é¢
        s := strings.Repeat(string(e.ch), e.count)
        sb.WriteString(s)
    }

    return sb.String()
}

type entry struct {
    ch    rune
    count int
}

type priorityQueue []entry

func (pq priorityQueue) Len() int           { return len(pq) }
func (pq priorityQueue) Less(i, j int) bool { return pq[i].count < pq[j].count }
func (pq priorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }
func (pq *priorityQueue) Push(x interface{}) {
    *pq = append(*pq, x.(entry))
}
func (pq *priorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    x := old[n-1]
    *pq = old[0 : n-1]
    return x
}
```

```java
// by labuladong (java)
class Solution {
    public String frequencySort(String s) {
        char[] chars = s.toCharArray();
        // s ä¸­çš„å­—ç¬¦ -> è¯¥å­—ç¬¦å‡ºç°çš„é¢‘ç‡
        HashMap<Character, Integer> charToFreq = new HashMap<>();
        for (char ch : chars) {
            charToFreq.put(ch, charToFreq.getOrDefault(ch, 0) + 1);
        }

        PriorityQueue<Map.Entry<Character, Integer>>
                pq = new PriorityQueue<>((entry1, entry2) -> {
            // é˜Ÿåˆ—æŒ‰ç…§é”®å€¼å¯¹ä¸­çš„å€¼ï¼ˆå­—ç¬¦å‡ºç°é¢‘ç‡ï¼‰ä»å¤§åˆ°å°æ’åº
            return entry2.getValue().compareTo(entry1.getValue());
        });

        // æŒ‰ç…§å­—ç¬¦é¢‘ç‡æ’åº
        for (Map.Entry<Character, Integer> entry : charToFreq.entrySet()) {
            pq.offer(entry);
        }

        StringBuilder sb = new StringBuilder();
        while (!pq.isEmpty()) {
            // æŠŠé¢‘ç‡æœ€é«˜çš„å­—ç¬¦æ’åœ¨å‰é¢
            Map.Entry<Character, Integer> entry = pq.poll();
            String part = String.valueOf(entry.getKey()).repeat(entry.getValue());
            sb.append(part);
        }

        return sb.toString();
    }
}
```

```javascript
// by chatGPT (javascript)
/**
* @param {string} s
* @return {string}
*/
var frequencySort = function(s) {
    let chars = s.split('');
    let charToFreq = new Map();
    chars.forEach(ch => {
        charToFreq.set(ch, charToFreq.get(ch) + 1 || 1);
    });

    let pq = new PriorityQueue((a, b) => {
        // é˜Ÿåˆ—æŒ‰ç…§é”®å€¼å¯¹ä¸­çš„å€¼ï¼ˆå­—ç¬¦å‡ºç°é¢‘ç‡ï¼‰ä»å¤§åˆ°å°æ’åº
        return b.value - a.value;
    });

    // æŒ‰ç…§å­—ç¬¦é¢‘ç‡æ’åº
    charToFreq.forEach((value, key) => {
        pq.offer({key, value});
    });

    let sb = [];
    while (!pq.isEmpty()) {
        // æŠŠé¢‘ç‡æœ€é«˜çš„å­—ç¬¦æ’åœ¨å‰é¢
        let {key, value} = pq.poll();
        let part = key.repeat(value);
        sb.push(part);
    }

    return sb.join('');
};

class PriorityQueue {
    constructor(compareFn) {
        this.queue = [];
        this.compareFn = compareFn;
    }

    isEmpty() {
        return this.queue.length === 0;
    }

    offer(item) {
        this.queue.push(item);
        this.queue.sort(this.compareFn);
    }

    poll() {
        return this.queue.shift();
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def frequencySort(self, s: str) -> str:
        chars = list(s)
        # s ä¸­çš„å­—ç¬¦ -> è¯¥å­—ç¬¦å‡ºç°çš„é¢‘ç‡
        charToFreq = {}
        for ch in chars:
            charToFreq[ch] = charToFreq.get(ch, 0) + 1

        pq = []
        for key, value in charToFreq.items():
            # åˆ›å»ºä¼˜å…ˆé˜Ÿåˆ—
            pq.append((value, key))
        
        # å¯¹ä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„å…ƒç´ æŒ‰ç…§å‡ºç°é¢‘ç‡è¿›è¡Œæ’åº
        pq.sort(reverse=True)
        
        res = ''
        for freq, ch in pq:
            # æŠŠé¢‘ç‡æœ€é«˜çš„å­—ç¬¦æ’åœ¨å‰é¢
            part = ch * freq
            res += part

        return res
```

https://leetcode.cn/problems/sort-characters-by-frequency çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/sort-the-matrix-diagonally çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {
        int m = mat.size(), n = mat[0].size();

        // å­˜å‚¨æ‰€æœ‰å¯¹è§’çº¿çš„å…ƒç´ åˆ—è¡¨
        unordered_map<int, vector<int>> diagonals;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // æ¨ªçºµåæ ‡ä¹‹å·®å¯ä»¥ä½œä¸ºä¸€æ¡å¯¹è§’çº¿çš„ ID
                int diagonalID = i - j;
                diagonals[diagonalID].push_back(mat[i][j]);
            }
        }

        // ä»æ•°ç»„æœ«å°¾åˆ é™¤å…ƒç´ æ•ˆç‡è¾ƒé«˜ï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠ vector å€’åºæ’åº
        for (auto& diagonal: diagonals) {
            sort(diagonal.second.rbegin(), diagonal.second.rend());
        }

        // æŠŠæ’åºç»“æœå›å¡«äºŒç»´çŸ©é˜µ
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                vector<int>& diagonal = diagonals[i - j];
                mat[i][j] = diagonal.back();
                diagonal.pop_back();
            }
        }

        return mat;
    }
};
```

```go
// by chatGPT (go)
// DiagonalSort function
func DiagonalSort(mat [][]int) [][]int {
    m, n := len(mat), len(mat[0])

    // å­˜å‚¨æ‰€æœ‰å¯¹è§’çº¿çš„å…ƒç´ åˆ—è¡¨
    diagonals := make(map[int][]int)

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            // æ¨ªçºµåæ ‡ä¹‹å·®å¯ä»¥ä½œä¸ºä¸€æ¡å¯¹è§’çº¿çš„ ID
            diagonalID := i - j
            if _, ok := diagonals[diagonalID]; !ok {
                diagonals[diagonalID] = make([]int, 0)
            }
            diagonals[diagonalID] = append(diagonals[diagonalID], mat[i][j])
        }
    }

    // ä»æ•°ç»„æœ«å°¾åˆ é™¤å…ƒç´ æ•ˆç‡è¾ƒé«˜ï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠ []int å€’åºæ’åº
    for _, v := range diagonals {
        sort.Sort(sort.Reverse(sort.IntSlice(v)))
    }

    // æŠŠæ’åºç»“æœå›å¡«äºŒç»´çŸ©é˜µ
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            diagonal := diagonals[i-j]
            mat[i][j] = diagonal[len(diagonal)-1]
            diagonals[i-j] = diagonal[:len(diagonal)-1]
        }
    }

    return mat
}
```

```java
// by labuladong (java)
class Solution {
    public int[][] diagonalSort(int[][] mat) {
        int m = mat.length, n = mat[0].length;

        // å­˜å‚¨æ‰€æœ‰å¯¹è§’çº¿çš„å…ƒç´ åˆ—è¡¨
        HashMap<Integer, ArrayList<Integer>> diagonals = new HashMap<>();

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // æ¨ªçºµåæ ‡ä¹‹å·®å¯ä»¥ä½œä¸ºä¸€æ¡å¯¹è§’çº¿çš„ ID
                int diagonalID = i - j;
                diagonals.putIfAbsent(diagonalID, new ArrayList<>());
                diagonals.get(diagonalID).add(mat[i][j]);
            }
        }

        // ä»æ•°ç»„æœ«å°¾åˆ é™¤å…ƒç´ æ•ˆç‡è¾ƒé«˜ï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠ ArrayList å€’åºæ’åº
        for (List<Integer> diagonal: diagonals.values()) {
            Collections.sort(diagonal, Collections.reverseOrder());
        }

        // æŠŠæ’åºç»“æœå›å¡«äºŒç»´çŸ©é˜µ
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                ArrayList<Integer> diagonal = diagonals.get(i - j);
                mat[i][j] = diagonal.remove(diagonal.size() - 1);
            }
        }

        return mat;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} mat
 * @return {number[][]}
 */
var diagonalSort = function(mat) {
    let m = mat.length, n = mat[0].length;

    // å­˜å‚¨æ‰€æœ‰å¯¹è§’çº¿çš„å…ƒç´ åˆ—è¡¨
    let diagonals = new Map();

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            // æ¨ªçºµåæ ‡ä¹‹å·®å¯ä»¥ä½œä¸ºä¸€æ¡å¯¹è§’çº¿çš„ ID
            let diagonalID = i - j;
            if (!diagonals.has(diagonalID)) {
                diagonals.set(diagonalID, []);
            }
            diagonals.get(diagonalID).push(mat[i][j]);
        }
    }

    // ä»æ•°ç»„æœ«å°¾åˆ é™¤å…ƒç´ æ•ˆç‡è¾ƒé«˜ï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠæ•°ç»„å€’åºæ’åº
    for (let diagonal of diagonals.values()) {
        diagonal.sort((a, b) => b - a);
    }

    // æŠŠæ’åºç»“æœå›å¡«äºŒç»´çŸ©é˜µ
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            let diagonal = diagonals.get(i - j);
            mat[i][j] = diagonal.pop();
        }
    }

    return mat;
};
```

```python
# by chatGPT (python)
class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        
        # å­˜å‚¨æ‰€æœ‰å¯¹è§’çº¿çš„å…ƒç´ åˆ—è¡¨
        diagonals = {}
        
        for i in range(m):
            for j in range(n):
                # æ¨ªçºµåæ ‡ä¹‹å·®å¯ä»¥ä½œä¸ºä¸€æ¡å¯¹è§’çº¿çš„ ID
                diagonalID = i - j
                if diagonalID not in diagonals:
                    diagonals[diagonalID] = []
                diagonals[diagonalID].append(mat[i][j])
                
        # ä»æ•°ç»„æœ«å°¾åˆ é™¤å…ƒç´ æ•ˆç‡è¾ƒé«˜ï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠåˆ—è¡¨å€’åºæ’åº
        for diagonal in diagonals.values():
            diagonal.sort(reverse=True)
        
        # æŠŠæ’åºç»“æœå›å¡«çŸ©é˜µ
        for i in range(m):
            for j in range(n):
                diagonal = diagonals[i - j]
                mat[i][j] = diagonal.pop()

        return mat
```

https://leetcode.cn/problems/sort-the-matrix-diagonally çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/squares-of-a-sorted-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        // ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«åˆå§‹åŒ–åœ¨æ­£è´Ÿå­æ•°ç»„ç»å¯¹å€¼æœ€å¤§çš„å…ƒç´ ç´¢å¼•
        int i = 0, j = n - 1;
        // å¾—åˆ°çš„æœ‰åºç»“æœæ˜¯é™åºçš„
        int p = n - 1;
        vector<int> res(n);
        // æ‰§è¡ŒåŒæŒ‡é’ˆåˆå¹¶æœ‰åºæ•°ç»„çš„é€»è¾‘
        while (i <= j) {
            if (abs(nums[i]) > abs(nums[j])) {
                res[p] = nums[i] * nums[i];
                i++;
            } else {
                res[p] = nums[j] * nums[j];
                j--;
            }
            p--;
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func sortedSquares(nums []int) []int {
    n := len(nums)
    // ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«åˆå§‹åŒ–åœ¨æ­£è´Ÿå­æ•°ç»„ç»å¯¹å€¼æœ€å¤§çš„å…ƒç´ ç´¢å¼•
    i, j := 0, n-1
    // å¾—åˆ°çš„æœ‰åºç»“æœæ˜¯é™åºçš„
    p := n - 1
    res := make([]int, n)
    // æ‰§è¡ŒåŒæŒ‡é’ˆåˆå¹¶æœ‰åºæ•°ç»„çš„é€»è¾‘
    for i <= j {
        if math.Abs(float64(nums[i])) > math.Abs(float64(nums[j])) {
            res[p] = nums[i] * nums[i]
            i++
        } else {
            res[p] = nums[j] * nums[j]
            j--
        }
        p--
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int[] sortedSquares(int[] nums) {
        int n = nums.length;
        // ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«åˆå§‹åŒ–åœ¨æ­£è´Ÿå­æ•°ç»„ç»å¯¹å€¼æœ€å¤§çš„å…ƒç´ ç´¢å¼•
        int i = 0, j = n - 1;
        // å¾—åˆ°çš„æœ‰åºç»“æœæ˜¯é™åºçš„
        int p = n - 1;
        int[] res = new int[n];
        // æ‰§è¡ŒåŒæŒ‡é’ˆåˆå¹¶æœ‰åºæ•°ç»„çš„é€»è¾‘
        while (i <= j) {
            if (Math.abs(nums[i]) > Math.abs(nums[j])) {
                res[p] = nums[i] * nums[i];
                i++;
            } else {
                res[p] = nums[j] * nums[j];
                j--;
            }
            p--;
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function(nums) {
    let n = nums.length;
    // ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«åˆå§‹åŒ–åœ¨æ­£è´Ÿå­æ•°ç»„ç»å¯¹å€¼æœ€å¤§çš„å…ƒç´ ç´¢å¼•
    let i = 0, j = n - 1;
    // å¾—åˆ°çš„æœ‰åºç»“æœæ˜¯é™åºçš„
    let p = n - 1;
    let res = new Array(n);
    // æ‰§è¡ŒåŒæŒ‡é’ˆåˆå¹¶æœ‰åºæ•°ç»„çš„é€»è¾‘
    while (i <= j) {
        if (Math.abs(nums[i]) > Math.abs(nums[j])) {
            res[p] = nums[i] * nums[i];
            i++;
        } else {
            res[p] = nums[j] * nums[j];
            j--;
        }
        p--;
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        n = len(nums)
        # ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«åˆå§‹åŒ–åœ¨æ­£è´Ÿå­æ•°ç»„ç»å¯¹å€¼æœ€å¤§çš„å…ƒç´ ç´¢å¼•
        i, j = 0, n - 1
        # å¾—åˆ°çš„æœ‰åºç»“æœæ˜¯é™åºçš„
        p = n - 1
        res = [0] * n
        # æ‰§è¡ŒåŒæŒ‡é’ˆåˆå¹¶æœ‰åºæ•°ç»„çš„é€»è¾‘
        while i <= j:
            if abs(nums[i]) > abs(nums[j]):
                res[p] = nums[i] * nums[i]
                i += 1
            else:
                res[p] = nums[j] * nums[j]
                j -= 1
            p -= 1
        return res
```

https://leetcode.cn/problems/squares-of-a-sorted-array çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/stone-game çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool stoneGame(vector<int>& piles) {
        return true;
    }
};
```

```go
// by chatGPT (go)
func stoneGame(piles []int) bool {
    return true
}
```

```java
// by labuladong (java)
class Solution {
    public boolean stoneGame(int[] piles) {
        return true;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} piles
 * @return {boolean}
 */
var stoneGame = function(piles) {
    return true;
};
```

```python
# by chatGPT (python)
class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        return True
```

https://leetcode.cn/problems/stone-game çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/string-to-integer-atoi çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int myAtoi(string str) {
        int n = str.length();
        int i = 0;
        // è®°å½•æ­£è´Ÿå·
        int sign = 1;
        // ç”¨ long é¿å… int æº¢å‡º
        long res = 0;
        // è·³è¿‡å‰å¯¼ç©ºæ ¼
        while (i < n && str[i] == ' ') {
            i++;
        }
        if (i == n) {
            return 0;
        }

        // è®°å½•ç¬¦å·ä½
        if (str[i] == '-') {
            sign = -1;
            i++;
        } else if (str[i] == '+') {
            i++;
        }
        if (i == n) {
            return 0;
        }

        // ç»Ÿè®¡æ•°å­—ä½
        while (i < n && '0' <= str[i] && str[i] <= '9') {
            res = res * 10 + str[i] - '0';
            if (res > INT_MAX) {
                break;
            }
            i++;
        }
        // å¦‚æœæº¢å‡ºï¼Œå¼ºè½¬æˆ int å°±ä¼šå’ŒçœŸå®å€¼ä¸åŒ
        if ((int) res != res) {
            return sign == 1 ? INT_MAX : INT_MIN;
        }
        return (int) res * sign;
    }
};
```

```go
// by chatGPT (go)
import "math"

func myAtoi(str string) int {
    n := len(str)
    i := 0
    // è®°å½•æ­£è´Ÿå·
    sign := 1
    // ç”¨ long é¿å… int æº¢å‡º
    var res int64 = 0
    // è·³è¿‡å‰å¯¼ç©ºæ ¼
    for i < n && str[i] == ' ' {
        i++
    }
    if i == n {
        return 0
    }
    // è®°å½•ç¬¦å·ä½
    if str[i] == '-' {
        sign = -1
        i++
    } else if str[i] == '+' {
        i++
    }
    if i == n {
        return 0
    }
    // ç»Ÿè®¡æ•°å­—ä½
    for i < n && '0' <= str[i] && str[i] <= '9' {
        res = res * 10 + int64(str[i]-'0')
        if res > math.MaxInt32 {
            break
        }
        i++
    }
    // å¦‚æœæº¢å‡ºï¼Œå¼ºè½¬æˆ int å°±ä¼šå’ŒçœŸå®å€¼ä¸åŒ
    if res > math.MaxInt32 {
        if sign == 1 {
            return math.MaxInt32
        } else {
            return math.MinInt32
        }
    }
    return int(res) * sign
}
```

```java
// by labuladong (java)
class Solution {
    public int myAtoi(String str) {
        int n = str.length();
        int i = 0;
        // è®°å½•æ­£è´Ÿå·
        int sign = 1;
        // ç”¨ long é¿å… int æº¢å‡º
        long res = 0;
        // è·³è¿‡å‰å¯¼ç©ºæ ¼
        while (i < n && str.charAt(i) == ' ') {
            i++;
        }
        if (i == n) {
            return 0;
        }

        // è®°å½•ç¬¦å·ä½
        if (str.charAt(i) == '-') {
            sign = -1;
            i++;
        } else if (str.charAt(i) == '+') {
            i++;
        }
        if (i == n) {
            return 0;
        }

        // ç»Ÿè®¡æ•°å­—ä½
        while (i < n && '0' <= str.charAt(i) && str.charAt(i) <= '9') {
            res = res * 10 + str.charAt(i) - '0';
            if (res > Integer.MAX_VALUE) {
                break;
            }
            i++;
        }
        // å¦‚æœæº¢å‡ºï¼Œå¼ºè½¬æˆ int å°±ä¼šå’ŒçœŸå®å€¼ä¸åŒ
        if ((int) res != res) {
            return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
        }
        return (int) res * sign;
    }
}
```

```javascript
// by chatGPT (javascript)
var myAtoi = function(str) {
    var n = str.length;
    var i = 0;
    // è®°å½•æ­£è´Ÿå·
    var sign = 1;
    // ç”¨ long é¿å… int æº¢å‡º
    var res = 0;
    // è·³è¿‡å‰å¯¼ç©ºæ ¼
    while (i < n && str.charAt(i) == ' ') {
        i++;
    }
    if (i === n) {
        return 0;
    }

    // è®°å½•ç¬¦å·ä½
    if (str.charAt(i) == '-') {
        sign = -1;
        i++;
    } else if (str.charAt(i) == '+') {
        i++;
    }
    if (i === n) {
        return 0;
    }

    // ç»Ÿè®¡æ•°å­—ä½
    while (i < n && '0' <= str.charAt(i) && str.charAt(i) <= '9') {
        res = res * 10 + str.charAt(i) - '0';
        if (res > 2147483647) {
            break;
        }
        i++;
    }
    // å¦‚æœæº¢å‡ºï¼Œå¼ºè½¬æˆ int å°±ä¼šå’ŒçœŸå®å€¼ä¸åŒ
    if (Math.trunc(res) !== res) {
        return sign === 1 ? 2147483647 : -2147483648;
    }
    return res * sign;
};
```

```python
# by chatGPT (python)
class Solution:
    def myAtoi(self, str: str) -> int:
        n = len(str)
        i = 0
        # è®°å½•æ­£è´Ÿå·
        sign = 1
        # ç”¨ long é¿å… int æº¢å‡º
        res = 0
        # è·³è¿‡å‰å¯¼ç©ºæ ¼
        while i < n and str[i] == ' ':
            i += 1
        if i == n:
            return 0

        # è®°å½•ç¬¦å·ä½
        if str[i] == '-':
            sign = -1
            i += 1
        elif str[i] == '+':
            i += 1
        if i == n:
            return 0

        # ç»Ÿè®¡æ•°å­—ä½
        while i < n and '0' <= str[i] <= '9':
            res = res * 10 + ord(str[i]) - ord('0')
            if res > 2 ** 31 - 1:
                break
            i += 1
        # å¦‚æœæº¢å‡ºï¼Œå¼ºè½¬æˆ int å°±ä¼šå’ŒçœŸå®å€¼ä¸åŒ
        if res != int(res):
            return sign * (2 ** 31 - 1) if sign == 1 else -2 ** 31
        return int(res) * sign
```

https://leetcode.cn/problems/string-to-integer-atoi çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/subsets çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    vector<vector<int>> res;
    vector<vector<int>> subsets(vector<int>& nums) {
        // è®°å½•èµ°è¿‡çš„è·¯å¾„
        vector<int> track;
        backtrack(nums, 0, track);
        return res;
    }

    void backtrack(vector<int>& nums, int start, vector<int>& track) {
        res.push_back(track);
        for (int i = start; i < nums.size(); i++) {
            // åšé€‰æ‹©
            track.push_back(nums[i]);
            // å›æº¯
            backtrack(nums, i + 1, track);
            // æ’¤é”€é€‰æ‹©
            track.pop_back();
        }
    }
};
```

```go
// by chatGPT (go)
// 
// subsets is a function that returns all possible subsets of an array of integers.
func subsets(nums []int) [][]int {
	res := [][]int{}
	track := []int{}
	backtrack(nums, 0, track, &res)
	return res
}

func backtrack(nums []int, start int, track []int, res *[][]int) {
	temp := make([]int, len(track))
	copy(temp, track)
	*res = append(*res, temp)
	for i := start; i < len(nums); i++ {
		// åšé€‰æ‹©
		track = append(track, nums[i])
		// å›æº¯
		backtrack(nums, i+1, track, res)
		// æ’¤é”€é€‰æ‹©
		track = track[:len(track)-1]
	}
}
```

```java
// by chatGPT (java)
class Solution {
    //å®šä¹‰äºŒç»´æ•°ç»„resç”¨äºå­˜å‚¨ç»“æœ
    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> subsets(int[] nums) {
        //å®šä¹‰è·¯å¾„æ•°ç»„
        List<Integer> track = new LinkedList<>();
        backtrack(nums, 0, track);

        return res;
    }

    public void backtrack(int[] nums, int start, List<Integer> track) {
        //æ·»åŠ è·¯å¾„æ•°ç»„åˆ°ç»“æœæ•°ç»„ä¸­
        res.add(new LinkedList<>(track));
        //forå¾ªç¯éå†æ•°ç»„nums
        for (int i = start; i < nums.length; i++) {
            //åšé€‰æ‹©ï¼Œå°†é€‰æ‹©æ·»åŠ åˆ°è·¯å¾„æ•°ç»„ä¸­
            track.add(nums[i]);
            //å›æº¯ï¼Œç»§ç»­å‘åéå†
            backtrack(nums, i + 1, track);
            //æ’¤é”€é€‰æ‹©ï¼Œå°†é€‰æ‹©ä»è·¯å¾„ä¸­åˆ é™¤
            track.remove(track.size() - 1);
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var subsets = function(nums) {
    var res = [];
    var track = [];
    // è®°å½•èµ°è¿‡çš„è·¯å¾„
    backtrack(nums, 0, track);
    return res;

    function backtrack(nums, start, track) {
        res.push([...track]);
        for (var i = start; i < nums.length; i++) {
            // åšé€‰æ‹©
            track.push(nums[i]);
            // å›æº¯
            backtrack(nums, i + 1, track);
            // æ’¤é”€é€‰æ‹©
            track.pop();
        }
    }
};
```

```python
# by chatGPT (python)
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        track = []
        # è®°å½•èµ°è¿‡çš„è·¯å¾„
        self.backtrack(nums, 0, track, res)
        return res
    
    def backtrack(self, nums, start, track, res):
        res.append(track[:])
        for i in range(start, len(nums)):
            # åšé€‰æ‹©
            track.append(nums[i])
            # å›æº¯
            self.backtrack(nums, i + 1, track, res)
            # æ’¤é”€é€‰æ‹©
            track.pop()
```

https://leetcode.cn/problems/subsets çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/sudoku-solver çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        backtrack(board, 0, 0);
    }

    bool backtrack(vector<vector<char>>& board, int i, int j) {
        int m = 9, n = 9;
        if (j == n) {
            // ç©·ä¸¾åˆ°æœ€åä¸€åˆ—çš„è¯å°±æ¢åˆ°ä¸‹ä¸€è¡Œé‡æ–°å¼€å§‹ã€‚
            return backtrack(board, i + 1, 0);
        }
        if (i == m) {
            // æ‰¾åˆ°ä¸€ä¸ªå¯è¡Œè§£ï¼Œè§¦å‘ base case
            return true;
        }

        if (board[i][j] != '.') {
            // å¦‚æœæœ‰é¢„è®¾æ•°å­—ï¼Œä¸ç”¨æˆ‘ä»¬ç©·ä¸¾
            return backtrack(board, i, j + 1);
        }

        for (char ch = '1'; ch <= '9'; ch++) {
            // å¦‚æœé‡åˆ°ä¸åˆæ³•çš„æ•°å­—ï¼Œå°±è·³è¿‡
            if (!isValid(board, i, j, ch))
                continue;

            board[i][j] = ch;
            // å¦‚æœæ‰¾åˆ°ä¸€ä¸ªå¯è¡Œè§£ï¼Œç«‹å³ç»“æŸ
            if (backtrack(board, i, j + 1)) {
                return true;
            }
            board[i][j] = '.';
        }
        // ç©·ä¸¾å®Œ 1~9ï¼Œä¾ç„¶æ²¡æœ‰æ‰¾åˆ°å¯è¡Œè§£ï¼Œæ­¤è·¯ä¸é€š
        return false;
    }

    bool isValid(vector<vector<char>>& board, int r, int c, char n) {
        for (int i = 0; i < 9; i++) {
            // åˆ¤æ–­è¡Œæ˜¯å¦å­˜åœ¨é‡å¤
            if (board[r][i] == n) return false;
            // åˆ¤æ–­åˆ—æ˜¯å¦å­˜åœ¨é‡å¤
            if (board[i][c] == n) return false;
            // åˆ¤æ–­ 3 x 3 æ–¹æ¡†æ˜¯å¦å­˜åœ¨é‡å¤
            if (board[(r/3)*3 + i/3][(c/3)*3 + i%3] == n)
                return false;
        }
        return true;
    }
};
```

```go
// by chatGPT (go)
func solveSudoku(board [][]byte) {
    backtrack(board, 0, 0)
}

func backtrack(board [][]byte, i int, j int) bool {
    m, n := 9, 9
    if j == n {
        // ç©·ä¸¾åˆ°æœ€åä¸€åˆ—çš„è¯å°±æ¢åˆ°ä¸‹ä¸€è¡Œé‡æ–°å¼€å§‹ã€‚
        return backtrack(board, i+1, 0)
    }
    if i == m {
        // æ‰¾åˆ°ä¸€ä¸ªå¯è¡Œè§£ï¼Œè§¦å‘ base case
        return true
    }

    if board[i][j] != '.' {
        // å¦‚æœæœ‰é¢„è®¾æ•°å­—ï¼Œä¸ç”¨æˆ‘ä»¬ç©·ä¸¾
        return backtrack(board, i, j+1)
    }

    for ch := '1'; ch <= '9'; ch++ {
        // å¦‚æœé‡åˆ°ä¸åˆæ³•çš„æ•°å­—ï¼Œå°±è·³è¿‡
        if !isValid(board, i, j, byte(ch)) {
            continue
        }

        board[i][j] = byte(ch)
        // å¦‚æœæ‰¾åˆ°ä¸€ä¸ªå¯è¡Œè§£ï¼Œç«‹å³ç»“æŸ
        if backtrack(board, i, j+1) {
            return true
        }
        board[i][j] = '.'
    }
    // ç©·ä¸¾å®Œ 1~9ï¼Œä¾ç„¶æ²¡æœ‰æ‰¾åˆ°å¯è¡Œè§£ï¼Œæ­¤è·¯ä¸é€š
    return false
}

// åˆ¤æ–­ board[i][j] æ˜¯å¦å¯ä»¥å¡«å…¥ n
func isValid(board [][]byte, r int, c int, n byte) bool {
    for i := 0; i < 9; i++ {
        // åˆ¤æ–­è¡Œæ˜¯å¦å­˜åœ¨é‡å¤
        if board[r][i] == n {
            return false
        }
        // åˆ¤æ–­åˆ—æ˜¯å¦å­˜åœ¨é‡å¤
        if board[i][c] == n {
            return false
        }
        // åˆ¤æ–­ 3 x 3 æ–¹æ¡†æ˜¯å¦å­˜åœ¨é‡å¤
        if board[(r/3)*3+i/3][(c/3)*3+i%3] == n {
            return false
        }
    }
    return true
}
```

```java
// by labuladong (java)
class Solution {
    public void solveSudoku(char[][] board) {
        backtrack(board, 0, 0);
    }

    boolean backtrack(char[][] board, int i, int j) {
        int m = 9, n = 9;
        if (j == n) {
            // ç©·ä¸¾åˆ°æœ€åä¸€åˆ—çš„è¯å°±æ¢åˆ°ä¸‹ä¸€è¡Œé‡æ–°å¼€å§‹ã€‚
            return backtrack(board, i + 1, 0);
        }
        if (i == m) {
            // æ‰¾åˆ°ä¸€ä¸ªå¯è¡Œè§£ï¼Œè§¦å‘ base case
            return true;
        }

        if (board[i][j] != '.') {
            // å¦‚æœæœ‰é¢„è®¾æ•°å­—ï¼Œä¸ç”¨æˆ‘ä»¬ç©·ä¸¾
            return backtrack(board, i, j + 1);
        }

        for (char ch = '1'; ch <= '9'; ch++) {
            // å¦‚æœé‡åˆ°ä¸åˆæ³•çš„æ•°å­—ï¼Œå°±è·³è¿‡
            if (!isValid(board, i, j, ch))
                continue;

            board[i][j] = ch;
            // å¦‚æœæ‰¾åˆ°ä¸€ä¸ªå¯è¡Œè§£ï¼Œç«‹å³ç»“æŸ
            if (backtrack(board, i, j + 1)) {
                return true;
            }
            board[i][j] = '.';
        }
        // ç©·ä¸¾å®Œ 1~9ï¼Œä¾ç„¶æ²¡æœ‰æ‰¾åˆ°å¯è¡Œè§£ï¼Œæ­¤è·¯ä¸é€š
        return false;
    }

    // åˆ¤æ–­ board[i][j] æ˜¯å¦å¯ä»¥å¡«å…¥ n
    boolean isValid(char[][] board, int r, int c, char n) {
        for (int i = 0; i < 9; i++) {
            // åˆ¤æ–­è¡Œæ˜¯å¦å­˜åœ¨é‡å¤
            if (board[r][i] == n) return false;
            // åˆ¤æ–­åˆ—æ˜¯å¦å­˜åœ¨é‡å¤
            if (board[i][c] == n) return false;
            // åˆ¤æ–­ 3 x 3 æ–¹æ¡†æ˜¯å¦å­˜åœ¨é‡å¤
            if (board[(r/3)*3 + i/3][(c/3)*3 + i%3] == n)
                return false;
        }
        return true;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solveSudoku = function(board) {
    backtrack(board, 0, 0);
};

var backtrack = function(board, i, j) {
    const m = 9, n = 9;
    if (j == n) {
        // ç©·ä¸¾åˆ°æœ€åä¸€åˆ—çš„è¯å°±æ¢åˆ°ä¸‹ä¸€è¡Œé‡æ–°å¼€å§‹ã€‚
        return backtrack(board, i + 1, 0);
    }
    if (i == m) {
        // æ‰¾åˆ°ä¸€ä¸ªå¯è¡Œè§£ï¼Œè§¦å‘ base case
        return true;
    }

    if (board[i][j] != '.') {
        // å¦‚æœæœ‰é¢„è®¾æ•°å­—ï¼Œä¸ç”¨æˆ‘ä»¬ç©·ä¸¾
        return backtrack(board, i, j + 1);
    }

    for (let ch = '1'; ch <= '9'; ch++) {
        // å¦‚æœé‡åˆ°ä¸åˆæ³•çš„æ•°å­—ï¼Œå°±è·³è¿‡
        if (!isValid(board, i, j, ch))
            continue;

        board[i][j] = ch;
        // å¦‚æœæ‰¾åˆ°ä¸€ä¸ªå¯è¡Œè§£ï¼Œç«‹å³ç»“æŸ
        if (backtrack(board, i, j + 1)) {
            return true;
        }
        board[i][j] = '.';
    }
    // ç©·ä¸¾å®Œ 1~9ï¼Œä¾ç„¶æ²¡æœ‰æ‰¾åˆ°å¯è¡Œè§£ï¼Œæ­¤è·¯ä¸é€š
    return false;
}

var isValid = function(board, r, c, n) {
    for (let i = 0; i < 9; i++) {
        // åˆ¤æ–­è¡Œæ˜¯å¦å­˜åœ¨é‡å¤
        if (board[r][i] == n) return false;
        // åˆ¤æ–­åˆ—æ˜¯å¦å­˜åœ¨é‡å¤
        if (board[i][c] == n) return false;
        // åˆ¤æ–­ 3 x 3 æ–¹æ¡†æ˜¯å¦å­˜åœ¨é‡å¤
        if (board[Math.floor(r/3)*3 + Math.floor(i/3)][Math.floor(c/3)*3 + i%3] == n)
            return false;
    }
    return true;
};
```

```python
# by chatGPT (python)
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        self.backtrack(board, 0, 0)

    def backtrack(self, board: List[List[str]], i: int, j: int) -> bool:
        m, n = 9, 9
        if j == n:
            # ç©·ä¸¾åˆ°æœ€åä¸€åˆ—çš„è¯å°±æ¢åˆ°ä¸‹ä¸€è¡Œé‡æ–°å¼€å§‹ã€‚
            return self.backtrack(board, i + 1, 0)
        if i == m:
            # æ‰¾åˆ°ä¸€ä¸ªå¯è¡Œè§£ï¼Œè§¦å‘ base case
            return True

        if board[i][j] != '.':
            # å¦‚æœæœ‰é¢„è®¾æ•°å­—ï¼Œä¸ç”¨æˆ‘ä»¬ç©·ä¸¾
            return self.backtrack(board, i, j + 1)

        for ch in range(1, 10):
            ch = str(ch)
            # å¦‚æœé‡åˆ°ä¸åˆæ³•çš„æ•°å­—ï¼Œå°±è·³è¿‡
            if not self.isValid(board, i, j, ch):
                continue

            board[i][j] = ch
            # å¦‚æœæ‰¾åˆ°ä¸€ä¸ªå¯è¡Œè§£ï¼Œç«‹å³ç»“æŸ
            if self.backtrack(board, i, j + 1):
                return True
            board[i][j] = '.'
        # ç©·ä¸¾å®Œ 1~9ï¼Œä¾ç„¶æ²¡æœ‰æ‰¾åˆ°å¯è¡Œè§£ï¼Œæ­¤è·¯ä¸é€š
        return False

    # åˆ¤æ–­ board[i][j] æ˜¯å¦å¯ä»¥å¡«å…¥ n
    def isValid(self, board: List[List[str]], r: int, c: int, n: str) -> bool:
        for i in range(9):
            # åˆ¤æ–­è¡Œæ˜¯å¦å­˜åœ¨é‡å¤
            if board[r][i] == n:
                return False
            # åˆ¤æ–­åˆ—æ˜¯å¦å­˜åœ¨é‡å¤
            if board[i][c] == n:
                return False
            # åˆ¤æ–­ 3 x 3 æ–¹æ¡†æ˜¯å¦å­˜åœ¨é‡å¤
            if board[(r // 3) * 3 + i // 3][(c // 3) * 3 + i % 3] == n:
                return False
        return True
```

https://leetcode.cn/problems/sudoku-solver çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/super-egg-drop çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int superEggDrop(int K, int N) {
        // m æœ€å¤šä¸ä¼šè¶…è¿‡ N æ¬¡ï¼ˆçº¿æ€§æ‰«æï¼‰
        vector<vector<int>> dp(K + 1, vector<int>(N + 1));
        // base case:
        // dp[0][..] = 0
        // dp[..][0] = 0
        // C++é»˜è®¤åˆå§‹åŒ–ä¸º0
        int m = 0;
        while (dp[K][m] < N) {
            m++;
            for (int k = 1; k <= K; k++)
                dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;
        }
        return m;
    }
};
```

```go
// by chatGPT (go)
func superEggDrop(K int, N int) int {
  // m æœ€å¤šä¸ä¼šè¶…è¿‡ N æ¬¡ï¼ˆçº¿æ€§æ‰«æï¼‰
  dp := make([][]int, K + 1)
  for i := 0; i <= K; i++ {
    dp[i] = make([]int, N + 1)
  }
  // base case:
  // dp[0][..] = 0
  // dp[..][0] = 0
  // Go é»˜è®¤åˆå§‹åŒ–æ•°ç»„éƒ½ä¸º 0
  m := 0
  for dp[K][m] < N {
    m++
    for k := 1; k <= K; k++ {
      dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1
    }
  }
  return m
}
```

```java
// by labuladong (java)
class Solution {
    public int superEggDrop(int K, int N) {
        // m æœ€å¤šä¸ä¼šè¶…è¿‡ N æ¬¡ï¼ˆçº¿æ€§æ‰«æï¼‰
        int[][] dp = new int[K + 1][N + 1];
        // base case:
        // dp[0][..] = 0
        // dp[..][0] = 0
        // Java é»˜è®¤åˆå§‹åŒ–æ•°ç»„éƒ½ä¸º 0
        int m = 0;
        while (dp[K][m] < N) {
            m++;
            for (int k = 1; k <= K; k++)
                dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;
        }
        return m;
    }
}
```

```javascript
// by chatGPT (javascript)
var superEggDrop = function(K, N) {
    // m æœ€å¤šä¸ä¼šè¶…è¿‡ N æ¬¡ï¼ˆçº¿æ€§æ‰«æï¼‰
    var dp = new Array(K + 1).fill(0).map(x => new Array(N + 1).fill(0));
    // base case:
    // dp[0][..] = 0
    // dp[..][0] = 0
    // JavaScript é»˜è®¤åˆå§‹åŒ–æ•°ç»„éƒ½ä¸º undefined

    var m = 0;
    while (dp[K][m] < N) {
        m++;
        for (var k = 1; k <= K; k++)
            dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;
    }
    return m;
};
```

```python
# by chatGPT (python)
class Solution:
    def superEggDrop(self, K: int, N: int) -> int:
        # m æœ€å¤šä¸ä¼šè¶…è¿‡ N æ¬¡ï¼ˆçº¿æ€§æ‰«æï¼‰
        dp = [[0] * (N + 1) for _ in range(K + 1)]
        # base case:
        # dp[0][..] = 0
        # dp[..][0] = 0
        # Java é»˜è®¤åˆå§‹åŒ–æ•°ç»„éƒ½ä¸º 0
        m = 0
        while dp[K][m] < N:
            m += 1
            for k in range(1, K + 1):
                dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1
        return m
```

https://leetcode.cn/problems/super-egg-drop çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/super-pow çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:

    int base = 1337;

    // è®¡ç®— a çš„ k æ¬¡æ–¹ç„¶åä¸ base æ±‚æ¨¡çš„ç»“æœ
    int mypow(int a, int k) {
        // å¯¹å› å­æ±‚æ¨¡
        a %= base;
        int res = 1;
        for (int _ = 0; _ < k; _++) {
            // è¿™é‡Œæœ‰ä¹˜æ³•ï¼Œæ˜¯æ½œåœ¨çš„æº¢å‡ºç‚¹
            res *= a;
            // å¯¹ä¹˜æ³•ç»“æœæ±‚æ¨¡
            res %= base;
        }
        return res;
    }

    int superPow(int a, vector<int>& b) {
        if (b.empty()) return 1;
        int last = b.back();
        b.pop_back();

        int part1 = mypow(a, last);
        int part2 = mypow(superPow(a, b), 10);
        // æ¯æ¬¡ä¹˜æ³•éƒ½è¦æ±‚æ¨¡
        return (part1 * part2) % base;
    }
};
```

```go
// by chatGPT (go)
const base = 1337

// è®¡ç®— a çš„ k æ¬¡æ–¹ç„¶åä¸ base æ±‚æ¨¡çš„ç»“æœ
func mypow(a, k int) int {
	// å¯¹å› å­æ±‚æ¨¡
	a %= base
	res := 1
	for i := 0; i < k; i++ {
		// è¿™é‡Œæœ‰ä¹˜æ³•ï¼Œæ˜¯æ½œåœ¨çš„æº¢å‡ºç‚¹
		res *= a
		// å¯¹ä¹˜æ³•ç»“æœæ±‚æ¨¡
		res %= base
	}
	return res
}

func superPow(a int, b []int) int {
	if len(b) == 0 {
		return 1
	}
	last := b[len(b)-1]
	b = b[:len(b)-1]

	part1 := mypow(a, last)
	part2 := mypow(superPow(a, b), 10)
	// æ¯æ¬¡ä¹˜æ³•éƒ½è¦æ±‚æ¨¡
	return (part1 * part2) % base
}
```

```java
// by chatGPT (java)
class Solution {
    int base = 1337;

    // è®¡ç®— a çš„ k æ¬¡æ–¹ç„¶åä¸ base æ±‚æ¨¡çš„ç»“æœ
    private int mypow(int a, int k) {
        // å¯¹å› å­æ±‚æ¨¡
        a %= base;
        int res = 1;
        for (int i = 0; i < k; i++) {
            // è¿™é‡Œæœ‰ä¹˜æ³•ï¼Œæ˜¯æ½œåœ¨çš„æº¢å‡ºç‚¹
            res *= a;
            // å¯¹ä¹˜æ³•ç»“æœæ±‚æ¨¡
            res %= base;
        }
        return res;
    }

    public int superPow(int a, int[] b) {
        if (b.length == 0) return 1;
        int last = b[b.length - 1];
        int[] newB = Arrays.copyOf(b, b.length - 1);

        int part1 = mypow(a, last);
        int part2 = mypow(superPow(a, newB), 10);
        // æ¯æ¬¡ä¹˜æ³•éƒ½è¦æ±‚æ¨¡
        return (part1 * part2) % base;
    }
}
```

```javascript
// by chatGPT (javascript)
var superPow = function(a, b) {
  const base = 1337;
  
  function mypow(a, k) {
    // å¯¹å› å­æ±‚æ¨¡
    a %= base;
    let res = 1;
    for (let _ = 0; _ < k; _++) {
      // è¿™é‡Œæœ‰ä¹˜æ³•ï¼Œæ˜¯æ½œåœ¨çš„æº¢å‡ºç‚¹
      res *= a;
      // å¯¹ä¹˜æ³•ç»“æœæ±‚æ¨¡
      res %= base;
    }
    return res;
  }

  if (b.length === 0) return 1;
  const last = b.pop();

  const part1 = mypow(a, last);
  const part2 = mypow(superPow(a, b), 10);
  // æ¯æ¬¡ä¹˜æ³•éƒ½è¦æ±‚æ¨¡
  return (part1 * part2) % base;
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.base = 1337

    # è®¡ç®— a çš„ k æ¬¡æ–¹ç„¶åä¸ base æ±‚æ¨¡çš„ç»“æœ
    def mypow(self, a: int, k: int) -> int:
        # å¯¹å› å­æ±‚æ¨¡
        a %= self.base
        res = 1
        for _ in range(k):
            # è¿™é‡Œæœ‰ä¹˜æ³•ï¼Œæ˜¯æ½œåœ¨çš„æº¢å‡ºç‚¹
            res = (res * a) % self.base
        return res

    def superPow(self, a: int, b: List[int]) -> int:
        if not b:
            return 1
        last = b.pop()

        part1 = self.mypow(a, last)
        part2 = self.mypow(self.superPow(a, b), 10)
        # æ¯æ¬¡ä¹˜æ³•éƒ½è¦æ±‚æ¨¡
        return (part1 * part2) % self.base
```

https://leetcode.cn/problems/super-pow çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/super-ugly-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) {
        // ä¼˜å…ˆé˜Ÿåˆ—ä¸­è£…ä¸‰å…ƒç»„ int[] {product, prime, pi}
        // å…¶ä¸­ product ä»£è¡¨é“¾è¡¨èŠ‚ç‚¹çš„å€¼ï¼Œprime æ˜¯è®¡ç®—ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ‰€éœ€çš„è´¨æ•°å› å­ï¼Œpi ä»£è¡¨é“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;

        // æŠŠå¤šæ¡é“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
        for (int i = 0; i < primes.size(); i++) {
            pq.push({ 1, primes[i], 1 });
        }

        // å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
        vector<int> ugly(n + 1);
        // å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        int p = 1;

        while (p <= n) {
            // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
            vector<int> pair = pq.top();
            pq.pop();
            int product = pair[0];
            int prime = pair[1];
            int index = pair[2];

            // é¿å…ç»“æœé“¾è¡¨å‡ºç°é‡å¤å…ƒç´ 
            if (product != ugly[p - 1]) {
                // æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
                ugly[p] = product;
                p++;
            }

            // ç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
            vector<int> nextPair = { ugly[index] * prime, prime, index + 1 };
            pq.push(nextPair);
        }
        return ugly[n];
    }
};
```

```go
// by chatGPT (go)
func nthSuperUglyNumber(n int, primes []int) int {
    // ä¼˜å…ˆé˜Ÿåˆ—ä¸­è£…ä¸‰å…ƒç»„ int[] {product, prime, pi}
    // å…¶ä¸­ product ä»£è¡¨é“¾è¡¨èŠ‚ç‚¹çš„å€¼ï¼Œprime æ˜¯è®¡ç®—ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ‰€éœ€çš„è´¨æ•°å› å­ï¼Œpi ä»£è¡¨é“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
    pq := make(PriorityQueue, 0)
    heap.Init(&pq)

    // æŠŠå¤šæ¡é“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
    for i := 0; i < len(primes); i++ {
        pq.Push(&IntTriples{product: 1, prime: primes[i], pi: 1})
    }

    // å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
    ugly := make([]int, n+1)
    // å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
    p := 1

    for p <= n {
        // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
        pair := heap.Pop(&pq).(*IntTriples)
        product, prime, index := pair.product, pair.prime, pair.pi

        // é¿å…ç»“æœé“¾è¡¨å‡ºç°é‡å¤å…ƒç´ 
        if product != ugly[p-1] {
            // æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
            ugly[p] = product
            p++
        }

        // ç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
        nextPair := &IntTriples{product: ugly[index] * prime, prime: prime, pi: index + 1}
        heap.Push(&pq, nextPair)
    }

    return ugly[n]
}

// ä¼˜å…ˆé˜Ÿåˆ—çš„å°è£…
type PriorityQueue []*IntTriples

func (pq PriorityQueue) Len() int {
    return len(pq)
}

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i].product < pq[j].product
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    item := x.(*IntTriples)
    *pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
}

// å°è£…ä¸‰å…ƒç»„
type IntTriples struct {
    product int
    prime   int
    pi      int
}
```

```java
// by labuladong (java)
class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
        // ä¼˜å…ˆé˜Ÿåˆ—ä¸­è£…ä¸‰å…ƒç»„ int[] {product, prime, pi}
        // å…¶ä¸­ product ä»£è¡¨é“¾è¡¨èŠ‚ç‚¹çš„å€¼ï¼Œprime æ˜¯è®¡ç®—ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ‰€éœ€çš„è´¨æ•°å› å­ï¼Œpi ä»£è¡¨é“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            return a[0] - b[0];
        });

        // æŠŠå¤šæ¡é“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
        for (int i = 0; i < primes.length; i++) {
            pq.offer(new int[]{ 1, primes[i], 1 });
        }

        // å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
        int[] ugly = new int[n + 1];
        // å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        int p = 1;

        while (p <= n) {
            // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
            int[] pair = pq.poll();
            int product = pair[0];
            int prime = pair[1];
            int index = pair[2];

            // é¿å…ç»“æœé“¾è¡¨å‡ºç°é‡å¤å…ƒç´ 
            if (product != ugly[p - 1]) {
                // æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
                ugly[p] = product;
                p++;
            }

            // ç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
            int[] nextPair = new int[]{ugly[index] * prime, prime, index + 1};
            pq.offer(nextPair);
        }
        return ugly[n];
    }
}
```

```javascript
// by chatGPT (javascript)
var nthSuperUglyNumber = function(n, primes) {
    // ä¼˜å…ˆé˜Ÿåˆ—ä¸­è£…ä¸‰å…ƒç»„ int[] {product, prime, pi}
    // å…¶ä¸­ product ä»£è¡¨é“¾è¡¨èŠ‚ç‚¹çš„å€¼ï¼Œprime æ˜¯è®¡ç®—ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ‰€éœ€çš„è´¨æ•°å› å­ï¼Œpi ä»£è¡¨é“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
    let pq = new PriorityQueue((a, b) => {
        return a[0] - b[0];
    });

    // æŠŠå¤šæ¡é“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
    for (let i = 0; i < primes.length; i++) {
        pq.offer([ 1, primes[i], 1 ]);
    }

    // å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
    let ugly = new Array(n + 1);
    // å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
    let p = 1;

    while (p <= n) {
        // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
        let pair = pq.poll();
        let product = pair[0];
        let prime = pair[1];
        let index = pair[2];

        // é¿å…ç»“æœé“¾è¡¨å‡ºç°é‡å¤å…ƒç´ 
        if (product != ugly[p - 1]) {
            // æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
            ugly[p] = product;
            p++;
        }

        // ç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
        let nextPair = [ugly[index] * prime, prime, index + 1];
        pq.offer(nextPair);
    }
    return ugly[n];
};
```

```python
# by chatGPT (python)
import heapq

class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        # ä¼˜å…ˆé˜Ÿåˆ—ä¸­è£…ä¸‰å…ƒç»„ int[] {product, prime, pi}
        # å…¶ä¸­ product ä»£è¡¨é“¾è¡¨èŠ‚ç‚¹çš„å€¼ï¼Œprime æ˜¯è®¡ç®—ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ‰€éœ€çš„è´¨æ•°å› å­ï¼Œpi ä»£è¡¨é“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        pq = []

        # æŠŠå¤šæ¡é“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
        for i in range(len(primes)):
            heapq.heappush(pq, [1, primes[i], 1])

        # å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
        ugly = [0] * (n+1)
        # å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        p = 1

        while p <= n:
            # å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
            product, prime, index = heapq.heappop(pq)

            # é¿å…ç»“æœé“¾è¡¨å‡ºç°é‡å¤å…ƒç´ 
            if product != ugly[p - 1]:
                # æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
                ugly[p] = product
                p += 1

            # ç”Ÿæˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—
            nextPair = [ugly[index] * prime, prime, index + 1]
            heapq.heappush(pq, nextPair)

        return ugly[n]
```

https://leetcode.cn/problems/super-ugly-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/surrounded-regions çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    void solve(vector<vector<char>>& board) {
        if (board.empty()) return;

        int m = board.size();
        int n = board[0].size();
        // ç»™ dummy ç•™ä¸€ä¸ªé¢å¤–ä½ç½®
        UF uf = UF(m * n + 1);
        int dummy = m * n;
        // å°†é¦–åˆ—å’Œæœ«åˆ—çš„ O ä¸ dummy è¿é€š
        for (int i = 0; i < m; i++) {
            if (board[i][0] == 'O')
                uf.union(i * n, dummy);
            if (board[i][n - 1] == 'O')
                uf.union(i * n + n - 1, dummy);
        }
        // å°†é¦–è¡Œå’Œæœ«è¡Œçš„ O ä¸ dummy è¿é€š
        for (int j = 0; j < n; j++) {
            /**<extend up -150>
            ![](../pictures/unionfindåº”ç”¨/3.jpg)
            */
            if (board[0][j] == 'O')
                uf.union(j, dummy);
            if (board[m - 1][j] == 'O')
                uf.union(n * (m - 1) + j, dummy);
        }
        // æ–¹å‘æ•°ç»„ d æ˜¯ä¸Šä¸‹å·¦å³æœç´¢çš„å¸¸ç”¨æ‰‹æ³•
        vector<vector<int>> d = {{1, 0}, {0, 1}, {0, -1}, {-1, 0}};
        for (int i = 1; i < m - 1; i++)
            for (int j = 1; j < n - 1; j++)
                if (board[i][j] == 'O')
                    // å°†æ­¤ O ä¸ä¸Šä¸‹å·¦å³çš„ O è¿é€š
                    for (int k = 0; k < 4; k++) {
                        int x = i + d[k][0];
                        int y = j + d[k][1];
                        if (board[x][y] == 'O')
                            uf.union(x * n + y, i * n + j);
                    }
        // æ‰€æœ‰ä¸å’Œ dummy è¿é€šçš„ Oï¼Œéƒ½è¦è¢«æ›¿æ¢
        for (int i = 1; i < m - 1; i++)
            for (int j = 1; j < n - 1; j++)
                if (!uf.connected(dummy, i * n + j))
                    board[i][j] = 'X';
    }
};

class UF {
public:
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    int count;
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    vector<int> parent;
    // è®°å½•æ ‘çš„â€œé‡é‡â€
    vector<int> size;

    UF(int n) {
        this->count = n;
        parent = vector<int>(n);
        size = vector<int>(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    /* å°† p å’Œ q è¿é€š */
    void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    /* åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š */
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP == rootQ;
    }

    /* è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹ */
    int find(int x) {
        while (parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
};
```

```go
// by chatGPT (go)
func solve(board [][]byte) {
    if len(board) == 0 {
        return
    }

    m := len(board)
    n := len(board[0])
    // ç»™ dummy ç•™ä¸€ä¸ªé¢å¤–ä½ç½®
    uf := NewUF(m*n + 1)
    dummy := m*n
    // å°†é¦–åˆ—å’Œæœ«åˆ—çš„ O ä¸ dummy è¿é€š
    for i := 0; i < m; i++ {
        if board[i][0] == 'O' {
            uf.union(i*n, dummy)
        }
        if board[i][n-1] == 'O' {
            uf.union(i*n+n-1, dummy)
        }
    }
    // å°†é¦–è¡Œå’Œæœ«è¡Œçš„ O ä¸ dummy è¿é€š
    for j := 0; j < n; j++ {
        if board[0][j] == 'O' {
            uf.union(j, dummy)
        }
        if board[m-1][j] == 'O' {
            uf.union(n*(m-1)+j, dummy)
        }
    }
    // æ–¹å‘æ•°ç»„ d æ˜¯ä¸Šä¸‹å·¦å³æœç´¢çš„å¸¸ç”¨æ‰‹æ³•
    d := [][]int{{1, 0}, {0, 1}, {0, -1}, {-1, 0}}
    for i := 1; i < m-1; i++ {
        for j := 1; j < n-1; j++ {
            if board[i][j] == 'O' {
                // å°†æ­¤ O ä¸ä¸Šä¸‹å·¦å³çš„ O è¿é€š
                for k := 0; k < 4; k++ {
                    x := i + d[k][0]
                    y := j + d[k][1]
                    if board[x][y] == 'O' {
                        uf.union(x*n+y, i*n+j)
                    }
                }
            }
        }
    }
    // æ‰€æœ‰ä¸å’Œ dummy è¿é€šçš„ Oï¼Œéƒ½è¦è¢«æ›¿æ¢
    for i := 1; i < m-1; i++ {
        for j := 1; j < n-1; j++ {
            if !uf.connected(dummy, i*n+j) {
                board[i][j] = 'X'
            }
        }
    }
}

type UF struct {
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    count int
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    parent []int
    // è®°å½•æ ‘çš„â€œé‡é‡â€
    size []int
}

func NewUF(n int) *UF {
    u := &UF{count: n, parent: make([]int, n), size: make([]int, n)}
    for i := 0; i < n; i++ {
        u.parent[i] = i
        u.size[i] = 1
    }
    return u
}

/* å°† p å’Œ q è¿é€š */
func (u *UF) union(p, q int) {
    rootP := u.find(p)
    rootQ := u.find(q)
    if rootP == rootQ {
        return
    }

    // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
    if u.size[rootP] > u.size[rootQ] {
        u.parent[rootQ] = rootP
        u.size[rootP] += u.size[rootQ]
    } else {
        u.parent[rootP] = rootQ
        u.size[rootQ] += u.size[rootP]
    }
    u.count--
}

/* åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š */
func (u *UF) connected(p, q int) bool {
    return u.find(p) == u.find(q)
}

/* è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹ */
func (u *UF) find(x int) int {
    for u.parent[x] != x {
        // è¿›è¡Œè·¯å¾„å‹ç¼©
        u.parent[x] = u.parent[u.parent[x]]
        x = u.parent[x]
    }
    return x
}

func (u *UF) Count() int {
    return u.count
}
```

```java
// by labuladong (java)
class Solution {
    public void solve(char[][] board) {
        if (board.length == 0) return;

        int m = board.length;
        int n = board[0].length;
        // ç»™ dummy ç•™ä¸€ä¸ªé¢å¤–ä½ç½®
        UF uf = new UF(m * n + 1);
        int dummy = m * n;
        // å°†é¦–åˆ—å’Œæœ«åˆ—çš„ O ä¸ dummy è¿é€š
        for (int i = 0; i < m; i++) {
            if (board[i][0] == 'O')
                uf.union(i * n, dummy);
            if (board[i][n - 1] == 'O')
                uf.union(i * n + n - 1, dummy);
        }
        // å°†é¦–è¡Œå’Œæœ«è¡Œçš„ O ä¸ dummy è¿é€š
        for (int j = 0; j < n; j++) {
            /**<extend up -150>
            ![](../pictures/unionfindåº”ç”¨/3.jpg)
            */
            if (board[0][j] == 'O')
                uf.union(j, dummy);
            if (board[m - 1][j] == 'O')
                uf.union(n * (m - 1) + j, dummy);
        }
        // æ–¹å‘æ•°ç»„ d æ˜¯ä¸Šä¸‹å·¦å³æœç´¢çš„å¸¸ç”¨æ‰‹æ³•
        int[][] d = new int[][]{{1, 0}, {0, 1}, {0, -1}, {-1, 0}};
        for (int i = 1; i < m - 1; i++)
            for (int j = 1; j < n - 1; j++)
                if (board[i][j] == 'O')
                    // å°†æ­¤ O ä¸ä¸Šä¸‹å·¦å³çš„ O è¿é€š
                    for (int k = 0; k < 4; k++) {
                        int x = i + d[k][0];
                        int y = j + d[k][1];
                        if (board[x][y] == 'O')
                            uf.union(x * n + y, i * n + j);
                    }
        // æ‰€æœ‰ä¸å’Œ dummy è¿é€šçš„ Oï¼Œéƒ½è¦è¢«æ›¿æ¢
        for (int i = 1; i < m - 1; i++)
            for (int j = 1; j < n - 1; j++)
                if (!uf.connected(dummy, i * n + j))
                    board[i][j] = 'X';
    }
}

class UF {
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    private int count;
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    private int[] parent;
    // è®°å½•æ ‘çš„â€œé‡é‡â€
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    /* å°† p å’Œ q è¿é€š */
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    /* åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š */
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP == rootQ;
    }

    /* è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹ */
    private int find(int x) {
        while (parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public int count() {
        return count;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solve = function(board) {
    if (board.length == 0) return;

    const m = board.length;
    const n = board[0].length;
    // ç»™ dummy ç•™ä¸€ä¸ªé¢å¤–ä½ç½®
    const uf = new UF(m * n + 1);
    const dummy = m * n;
    // å°†é¦–åˆ—å’Œæœ«åˆ—çš„ O ä¸ dummy è¿é€š
    for (let i = 0; i < m; i++) {
        if (board[i][0] == 'O')
            uf.union(i * n, dummy);
        if (board[i][n - 1] == 'O')
            uf.union(i * n + n - 1, dummy);
    }
    // å°†é¦–è¡Œå’Œæœ«è¡Œçš„ O ä¸ dummy è¿é€š
    
    const d = [[1, 0], [0, 1], [0, -1], [-1, 0]];
    for (let j = 0; j < n; j++) {
        /**<extend up -150>
        ![](../pictures/unionfindåº”ç”¨/3.jpg)
        */
        if (board[0][j] == 'O')
            uf.union(j, dummy);
        if (board[m - 1][j] == 'O')
            uf.union(n * (m - 1) + j, dummy);
    }
    // æ–¹å‘æ•°ç»„ d æ˜¯ä¸Šä¸‹å·¦å³æœç´¢çš„å¸¸ç”¨æ‰‹æ³•

    for (let i = 1; i < m - 1; i++)
        for (let j = 1; j < n - 1; j++)
            if (board[i][j] == 'O')
                // å°†æ­¤ O ä¸ä¸Šä¸‹å·¦å³çš„ O è¿é€š
                for (let k = 0; k < 4; k++) {
                    const x = i + d[k][0];
                    const y = j + d[k][1];
                    if (board[x][y] == 'O')
                        uf.union(x * n + y, i * n + j);
                }
    // æ‰€æœ‰ä¸å’Œ dummy è¿é€šçš„ Oï¼Œéƒ½è¦è¢«æ›¿æ¢
    for (let i = 1; i < m - 1; i++)
        for (let j = 1; j < n - 1; j++)
            if (!uf.connected(dummy, i * n + j))
                board[i][j] = 'X';
}

class UF {
    // è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    count;
    // å­˜å‚¨è‹¥å¹²æ£µæ ‘
    parent;
    // è®°å½•æ ‘çš„â€œé‡é‡â€
    size;

    constructor(n) {
        this.count = n;
        this.parent = [];
        this.size = [];
        for (let i = 0; i < n; i++) {
            this.parent[i] = i;
            this.size[i] = 1;
        }
    }

    /* å°† p å’Œ q è¿é€š */
    union(p, q) {
        const rootP = this.find(p);
        const rootQ = this.find(q);
        if (rootP == rootQ)
            return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (this.size[rootP] > this.size[rootQ]) {
            this.parent[rootQ] = rootP;
            this.size[rootP] += this.size[rootQ];
        } else {
            this.parent[rootP] = rootQ;
            this.size[rootQ] += this.size[rootP];
        }
        this.count--;
    }

    /* åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š */
    connected(p, q) {
        const rootP = this.find(p);
        const rootQ = this.find(q);
        // å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP == rootQ;
    }

    /* è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹ */
    find(x) {
        while (this.parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            this.parent[x] = this.parent[this.parent[x]];
            x = this.parent[x];
        }
        return x;
    }

    count() {
        return this.count;
    }
}
```

```python
# by chatGPT (python)
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        if not board:
            return

        m, n = len(board), len(board[0])
        # ç»™ dummy ç•™ä¸€ä¸ªé¢å¤–ä½ç½®
        uf = UF(m * n + 1)
        dummy = m * n
        # å°†é¦–åˆ—å’Œæœ«åˆ—çš„ O ä¸ dummy è¿é€š
        for i in range(m):
            if board[i][0] == 'O':
                uf.union(i * n, dummy)
            if board[i][n - 1] == 'O':
                uf.union(i * n + n - 1, dummy)
        # å°†é¦–è¡Œå’Œæœ«è¡Œçš„ O ä¸ dummy è¿é€š
        for j in range(n):
            # extend up -150
            if board[0][j] == 'O':
                uf.union(j, dummy)
            if board[m - 1][j] == 'O':
                uf.union(n * (m - 1) + j, dummy)
        # æ–¹å‘æ•°ç»„ d æ˜¯ä¸Šä¸‹å·¦å³æœç´¢çš„å¸¸ç”¨æ‰‹æ³•
        d = [[1, 0], [0, 1], [0, -1], [-1, 0]]
        for i in range(1, m - 1):
            for j in range(1, n - 1):
                if board[i][j] == 'O':
                    # å°†æ­¤ O ä¸ä¸Šä¸‹å·¦å³çš„ O è¿é€š
                    for k in range(4):
                        x = i + d[k][0]
                        y = j + d[k][1]
                        if board[x][y] == 'O':
                            uf.union(x * n + y, i * n + j)
        # æ‰€æœ‰ä¸å’Œ dummy è¿é€šçš„ Oï¼Œéƒ½è¦è¢«æ›¿æ¢
        for i in range(1, m - 1):
            for j in range(1, n - 1):
                if not uf.connected(dummy, i * n + j):
                    board[i][j] = 'X'

class UF:
    # è®°å½•è¿é€šåˆ†é‡ä¸ªæ•°
    def __init__(self, n: int):
        self.count = n
        # å­˜å‚¨è‹¥å¹²æ£µæ ‘
        self.parent = list(range(n))
        # è®°å½•æ ‘çš„â€œé‡é‡â€
        self.size = [1] * n

    # å°† p å’Œ q è¿é€š
    def union(self, p: int, q: int) -> None:
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP == rootQ:
            return

        # å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if self.size[rootP] > self.size[rootQ]:
            self.parent[rootQ] = rootP
            self.size[rootP] += self.size[rootQ]
        else:
            self.parent[rootP] = rootQ
            self.size[rootQ] += self.size[rootP]
        self.count -= 1

    # åˆ¤æ–­ p å’Œ q æ˜¯å¦äº’ç›¸è¿é€š
    def connected(self, p: int, q: int) -> bool:
        rootP = self.find(p)
        rootQ = self.find(q)
        # å¤„äºåŒä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œç›¸äº’è¿é€š
        return rootP == rootQ

    # è¿”å›èŠ‚ç‚¹ x çš„æ ¹èŠ‚ç‚¹
    def find(self, x: int) -> int:
        while self.parent[x] != x:
            # è¿›è¡Œè·¯å¾„å‹ç¼©
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def count(self) -> int:
        return self.count
```

https://leetcode.cn/problems/surrounded-regions çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/swap-nodes-in-pairs çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    // å®šä¹‰ï¼šè¾“å…¥ä»¥ head å¼€å¤´çš„å•é“¾è¡¨ï¼Œå°†è¿™ä¸ªå•é“¾è¡¨ä¸­çš„æ¯ä¸¤ä¸ªå…ƒç´ ç¿»è½¬ï¼Œ
    // è¿”å›ç¿»è½¬åçš„é“¾è¡¨å¤´ç»“ç‚¹
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == nullptr || head->next == nullptr) { //é€’å½’ç»“æŸæ¡ä»¶
            return head;
        }
        ListNode* first = head;
        ListNode* second = head->next;
        ListNode* others = head->next->next;
        // å…ˆæŠŠå‰ä¸¤ä¸ªå…ƒç´ ç¿»è½¬
        second->next = first;
        // åˆ©ç”¨é€’å½’å®šä¹‰ï¼Œå°†å‰©ä¸‹çš„é“¾è¡¨èŠ‚ç‚¹ä¸¤ä¸¤ç¿»è½¬ï¼Œæ¥åˆ°åé¢
        first->next = swapPairs(others);
        // ç°åœ¨æ•´ä¸ªé“¾è¡¨éƒ½æˆåŠŸç¿»è½¬äº†ï¼Œè¿”å›æ–°çš„å¤´ç»“ç‚¹
        return second;
        /**<extend up -200>
        ![](../pictures/kgroup/7.jpg)
        */
    }
};
```

```go
// by chatGPT (go)
// å®šä¹‰ï¼šè¾“å…¥ä»¥ head å¼€å¤´çš„å•é“¾è¡¨ï¼Œå°†è¿™ä¸ªå•é“¾è¡¨ä¸­çš„æ¯ä¸¤ä¸ªå…ƒç´ ç¿»è½¬ï¼Œ
// è¿”å›ç¿»è½¬åçš„é“¾è¡¨å¤´ç»“ç‚¹
func swapPairs(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    first := head
    second := head.Next
    others := head.Next.Next
    // å…ˆæŠŠå‰ä¸¤ä¸ªå…ƒç´ ç¿»è½¬
    second.Next = first
    // åˆ©ç”¨é€’å½’å®šä¹‰ï¼Œå°†å‰©ä¸‹çš„é“¾è¡¨èŠ‚ç‚¹ä¸¤ä¸¤ç¿»è½¬ï¼Œæ¥åˆ°åé¢
    first.Next = swapPairs(others)
    // ç°åœ¨æ•´ä¸ªé“¾è¡¨éƒ½æˆåŠŸç¿»è½¬äº†ï¼Œè¿”å›æ–°çš„å¤´ç»“ç‚¹
    return second
}
```

```java
// by labuladong (java)
class Solution {
    // å®šä¹‰ï¼šè¾“å…¥ä»¥ head å¼€å¤´çš„å•é“¾è¡¨ï¼Œå°†è¿™ä¸ªå•é“¾è¡¨ä¸­çš„æ¯ä¸¤ä¸ªå…ƒç´ ç¿»è½¬ï¼Œ
    // è¿”å›ç¿»è½¬åçš„é“¾è¡¨å¤´ç»“ç‚¹
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode first = head;
        ListNode second = head.next;
        ListNode others = head.next.next;
        // å…ˆæŠŠå‰ä¸¤ä¸ªå…ƒç´ ç¿»è½¬
        second.next = first;
        // åˆ©ç”¨é€’å½’å®šä¹‰ï¼Œå°†å‰©ä¸‹çš„é“¾è¡¨èŠ‚ç‚¹ä¸¤ä¸¤ç¿»è½¬ï¼Œæ¥åˆ°åé¢
        first.next = swapPairs(others);
        // ç°åœ¨æ•´ä¸ªé“¾è¡¨éƒ½æˆåŠŸç¿»è½¬äº†ï¼Œè¿”å›æ–°çš„å¤´ç»“ç‚¹
        return second;
        /**<extend up -200>
        ![](../pictures/kgroup/7.jpg)
        */
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * å®šä¹‰ï¼šè¾“å…¥ä»¥ head å¼€å¤´çš„å•é“¾è¡¨ï¼Œå°†è¿™ä¸ªå•é“¾è¡¨ä¸­çš„æ¯ä¸¤ä¸ªå…ƒç´ ç¿»è½¬ï¼Œ
 * è¿”å›ç¿»è½¬åçš„é“¾è¡¨å¤´ç»“ç‚¹
 */
var swapPairs = function(head) {
    if (head == null || head.next == null) {
        return head;
    }
    // å…ˆæŠŠå‰ä¸¤ä¸ªå…ƒç´ ç¿»è½¬
    let first = head;
    let second = head.next;
    let others = head.next.next;
    second.next = first;
    // åˆ©ç”¨é€’å½’å®šä¹‰ï¼Œå°†å‰©ä¸‹çš„é“¾è¡¨èŠ‚ç‚¹ä¸¤ä¸¤ç¿»è½¬ï¼Œæ¥åˆ°åé¢
    first.next = swapPairs(others);
    // ç°åœ¨æ•´ä¸ªé“¾è¡¨éƒ½æˆåŠŸç¿»è½¬äº†ï¼Œè¿”å›æ–°çš„å¤´ç»“ç‚¹
    return second;
    /**<extend up -200>
    ![](../pictures/kgroup/7.jpg)
    */
};
```

```python
# by chatGPT (python)
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        """
        :type head: ListNode
        :rtype: ListNode
        è¾“å…¥ä»¥ head å¼€å¤´çš„å•é“¾è¡¨ï¼Œå°†è¿™ä¸ªå•é“¾è¡¨ä¸­çš„æ¯ä¸¤ä¸ªå…ƒç´ ç¿»è½¬ï¼Œ
        è¿”å›ç¿»è½¬åçš„é“¾è¡¨å¤´ç»“ç‚¹
        """
        if not head or not head.next:
            # å¦‚æœå½“å‰èŠ‚ç‚¹ head ä¸ºç©º, æˆ–è€…ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ head.next ä¸ºç©º, å°† head ç›´æ¥è¿”å›
            return head
        # å®šä¹‰ä¸‰ä¸ªå˜é‡, åˆ†åˆ«ä¸ºå½“å‰èŠ‚ç‚¹, å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å’Œä¸‹ä¸‹ä¸ªèŠ‚ç‚¹
        first, second, others = head, head.next, head.next.next
        # å…ˆæŠŠå‰ä¸¤ä¸ªå…ƒç´ ç¿»è½¬
        second.next = first
        # åˆ©ç”¨é€’å½’å®šä¹‰, å°†å‰©ä¸‹çš„é“¾è¡¨èŠ‚ç‚¹ä¸¤ä¸¤ç¿»è½¬, æ¥åˆ°åé¢
        first.next = self.swapPairs(others)
        # ç°åœ¨æ•´ä¸ªé“¾è¡¨éƒ½æˆåŠŸç¿»è½¬äº†, è¿”å›æ–°çš„å¤´ç»“ç‚¹
        return second
        """
        åŸé“¾è¡¨ä¸ºï¼šhead â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ nullï¼Œ
        è¦æ±‚é“¾è¡¨ä¸ºï¼šhead â†’ 2 â†’ 1 â†’ 4 â†’ 3 â†’ nullã€‚
        ![](../pictures/kgroup/7.jpg)
        """
```

https://leetcode.cn/problems/swap-nodes-in-pairs çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/target-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        if (nums.empty()) return 0;
        return dp(nums, 0, target);
    }

    // å¤‡å¿˜å½•
    unordered_map<string, int> memo;

    int dp(vector<int>& nums, int i, int remain) {
        // base case
        if (i == nums.size()) {
            if (remain == 0) return 1;
            return 0;
        }
        // æŠŠå®ƒä¿©è½¬æˆå­—ç¬¦ä¸²æ‰èƒ½ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®
        string key = to_string(i) + "," + to_string(remain);
        // é¿å…é‡å¤è®¡ç®—
        if (memo.count(key)) {
            return memo[key];
        }
        // è¿˜æ˜¯ç©·ä¸¾
        int result = dp(nums, i + 1, remain - nums[i]) + dp(nums, i + 1, remain + nums[i]);
        // è®°å…¥å¤‡å¿˜å½•
        memo[key] = result;
        return result;
    }
};
```

```go
// by chatGPT (go)
func findTargetSumWays(nums []int, target int) int {
    // å¦‚æœnumsä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿”å›0
    if len(nums) == 0 {
        return 0
    }
    // å®šä¹‰å¤‡å¿˜å½•
    memo := make(map[string]int)
    // è°ƒç”¨DPå‡½æ•°
    return dp(nums, 0, target, memo)
}

func dp(nums []int, i, remain int, memo map[string]int) int {
    // base case
    if i == len(nums) {
        if remain == 0 {
            return 1
        }
        return 0
    }
    // æŠŠå®ƒä¿©è½¬æˆå­—ç¬¦ä¸²æ‰èƒ½ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®
    key := strconv.Itoa(i) + "," + strconv.Itoa(remain)
    // é¿å…é‡å¤è®¡ç®—
    if val, ok := memo[key]; ok {
        return val
    }
    // è¿˜æ˜¯ç©·ä¸¾
    result := dp(nums, i+1, remain-nums[i], memo) + dp(nums, i+1, remain+nums[i], memo)
    // è®°å…¥å¤‡å¿˜å½•
    memo[key] = result
    return result
}
```

```java
// by labuladong (java)
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        if (nums.length == 0) return 0;
        return dp(nums, 0, target);
    }

    // å¤‡å¿˜å½•
    HashMap<String, Integer> memo = new HashMap<>();

    int dp(int[] nums, int i, int remain) {
        // base case
        if (i == nums.length) {
            if (remain == 0) return 1;
            return 0;
        }
        // æŠŠå®ƒä¿©è½¬æˆå­—ç¬¦ä¸²æ‰èƒ½ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®
        String key = i + "," + remain;
        // é¿å…é‡å¤è®¡ç®—
        if (memo.containsKey(key)) {
            return memo.get(key);
        }
        // è¿˜æ˜¯ç©·ä¸¾
        int result = dp(nums, i + 1, remain - nums[i]) + dp(nums, i + 1, remain + nums[i]);
        // è®°å…¥å¤‡å¿˜å½•
        memo.put(key, result);
        return result;
    }
}
```

```javascript
// by chatGPT (javascript)
// ä¼ å…¥ä¸€ä¸ªæ•´æ•°æ•°ç»„å’Œç›®æ ‡å€¼targetï¼Œæ±‚æœ‰å¤šå°‘ç§æ–¹æ³•ä½¿å¾—æ•°ç»„ä¸­çš„å…ƒç´ ä¹‹å’Œä¸ºtargetï¼Œæ¯ä¸ªå…ƒç´ å¯ä»¥é€‰æ‹©åŠ æˆ–è€…å‡
var findTargetSumWays = function (nums, target) {
  // æ•°ç»„é•¿åº¦ä¸º0ç›´æ¥è¿”å›0
  if (nums.length === 0) return 0;

  // å¤‡å¿˜å½•å“ˆå¸Œè¡¨ï¼Œè®°å½•å·²ç»è®¡ç®—è¿‡çš„å­é—®é¢˜çš„ç»“æœï¼Œé¿å…é‡å¤è®¡ç®—
  const memo = new Map();

  // é€’å½’å‡½æ•°
  const dp = (nums, i, remain) => {
    // å¦‚æœå·²ç»éå†åˆ°äº†æ•°ç»„çš„æœ«å°¾ï¼Œåˆ¤æ–­remainæ˜¯å¦ç­‰äº0ï¼Œå¦‚æœç­‰äº0åˆ™è¿”å›1ï¼Œå¦åˆ™è¿”å›0
    if (i === nums.length) {
      if (remain === 0) return 1;
      return 0;
    }

    // ç”¨iå’Œremainä½œä¸ºé”®ï¼Œåˆ¤æ–­æ˜¯å¦å·²ç»è®¡ç®—è¿‡è¿™ä¸ªå­é—®é¢˜ï¼Œå¦‚æœå·²ç»è®¡ç®—ï¼Œåˆ™ç›´æ¥è¿”å›ç»“æœï¼Œå¦åˆ™ç»§ç»­è®¡ç®—
    const key = i + "," + remain;

    if (memo.has(key)) {
      return memo.get(key);
    }

    // åˆ†åˆ«é€’å½’è®¡ç®—åŠ ä¸Šå’Œå‡å»å½“å‰å…ƒç´ åèƒ½å¤Ÿå¾—åˆ°ç›®æ ‡å€¼çš„æ–¹æ¡ˆæ•°é‡ï¼Œç›¸åŠ å¾—åˆ°å½“å‰å­é—®é¢˜çš„è§£
    const result =
      dp(nums, i + 1, remain - nums[i]) + dp(nums, i + 1, remain + nums[i]);

    // æŠŠè®¡ç®—ç»“æœå­˜å…¥å¤‡å¿˜å½•
    memo.set(key, result);

    // è¿”å›å½“å‰å­é—®é¢˜çš„è§£
    return result;
  };

  // ä»0å¼€å§‹éå†æ•°ç»„ï¼Œè®¡ç®—ä»æ¯ä¸ªç´¢å¼•å¼€å§‹çš„å­é—®é¢˜ï¼Œæœ€ç»ˆå¾—åˆ°é—®é¢˜çš„è§£
  return dp(nums, 0, target);
};
```

```python
# by chatGPT (python)
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        if len(nums) == 0: return 0
        # è°ƒç”¨å¤‡å¿˜å½•å‡½æ•°
        return self.dp(nums, 0, target, {})

    def dp(self, nums, i, remain, memo): 
        # base case
        if i == len(nums):
            if remain == 0: return 1
            return 0
        # æŠŠå®ƒä¿©è½¬æˆå­—ç¬¦ä¸²æ‰èƒ½ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®
        key = str(i) + "," + str(remain)
        # é¿å…é‡å¤è®¡ç®—
        if key in memo:
            return memo[key]
        # è¿˜æ˜¯ç©·ä¸¾
        result = self.dp(nums, i + 1, remain - nums[i], memo) + self.dp(nums, i + 1, remain + nums[i], memo)
        # è®°å…¥å¤‡å¿˜å½•
        memo[key] = result
        return result
```

https://leetcode.cn/problems/target-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/the-maze çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool hasPath(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {
        int m = maze.size(), n = maze[0].size();
        // æ–¹å‘æ•°ç»„ï¼Œæ–¹ä¾¿ä¸Šä¸‹å·¦å³ç§»åŠ¨
        int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};

        // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
        queue<vector<int>> q;
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        // åŠ å…¥èµ·ç‚¹
        q.push(start);
        visited[start[0]][start[1]] = true;
        // å¯åŠ¨ BFS ç®—æ³•æ¡†æ¶
        while (!q.empty()) {
            vector<int> cur = q.front();
            q.pop();
            // å‘å››ä¸ªæ–¹å‘æ‰©å±•
            for (auto dir : dirs) {
                int x = cur[0], y = cur[1];
                // å’Œå…¶ä»–é¢˜ç›®ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œä¸€ç›´èµ°åˆ°å¢™ï¼Œè€Œä¸æ˜¯åªèµ°ä¸€æ­¥
                while (x >= 0 && x < m && y >= 0 && y < n && maze[x][y] == 0) {
                    x += dir[0];
                    y += dir[1];
                }
                x -= dir[0];
                y -= dir[1];
                // åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
                if (x == destination[0] && y == destination[1]) {
                    return true;
                }
                if (!visited[x][y]) {
                    visited[x][y] = true;
                    q.push({x, y});
                }
            }
        }
        return false;
    }
};
```

```go
// by chatGPT (go)
import "fmt"

func hasPath(maze [][]int, start []int, destination []int) bool {
    m, n := len(maze), len(maze[0])
    // æ–¹å‘æ•°ç»„ï¼Œæ–¹ä¾¿ä¸Šä¸‹å·¦å³ç§»åŠ¨
    dirs := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}

    q := [][]int{start}
    visited := make([][]bool, m)
    for i := range visited {
        visited[i] = make([]bool, n)
    }
    visited[start[0]][start[1]] = true

    // å¯åŠ¨ BFS ç®—æ³•æ¡†æ¶
    for len(q) > 0 {
        cur := q[0]
        q = q[1:]
        // å‘å››ä¸ªæ–¹å‘æ‰©å±•
        for _, dir := range dirs {
            x, y := cur[0], cur[1]
            // å’Œå…¶ä»–é¢˜ç›®ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œä¸€ç›´èµ°åˆ°å¢™ï¼Œè€Œä¸æ˜¯åªèµ°ä¸€æ­¥
            for x >= 0 && x < m && y >= 0 && y < n && maze[x][y] == 0 {
                x += dir[0]
                y += dir[1]
            }
            x -= dir[0]
            y -= dir[1]
            // åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
            if x == destination[0] && y == destination[1] {
                return true
            }
            if !visited[x][y] {
                visited[x][y] = true
                q = append(q, []int{x, y})
            }
        }
    }
    return false
}

func main() {
    maze := [][]int{
        {0,0,1,0,0},
        {0,0,0,0,0},
        {0,0,0,1,0},
        {1,1,0,1,1},
        {0,0,0,0,0},
    }
    start := []int{0, 4}
    destination := []int{4, 4}
    fmt.Println(hasPath(maze, start, destination)) // Output: true
}
```

```java
// by labuladong (java)
class Solution {
    public boolean hasPath(int[][] maze, int[] start, int[] destination) {
        int m = maze.length, n = maze[0].length;
        // æ–¹å‘æ•°ç»„ï¼Œæ–¹ä¾¿ä¸Šä¸‹å·¦å³ç§»åŠ¨
        int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};

        // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
        Queue<int[]> q = new LinkedList<>();
        boolean[][] visited = new boolean[m][n];
        // åŠ å…¥èµ·ç‚¹
        q.offer(start);
        visited[start[0]][start[1]] = true;
        // å¯åŠ¨ BFS ç®—æ³•æ¡†æ¶
        while (!q.isEmpty()) {
            int[] cur = q.poll();
            // å‘å››ä¸ªæ–¹å‘æ‰©å±•
            for (int[] dir : dirs) {
                int x = cur[0], y = cur[1];
                // å’Œå…¶ä»–é¢˜ç›®ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œä¸€ç›´èµ°åˆ°å¢™ï¼Œè€Œä¸æ˜¯åªèµ°ä¸€æ­¥
                while (x >= 0 && x < m && y >= 0 && y < n && maze[x][y] == 0) {
                    x += dir[0];
                    y += dir[1];
                }
                x -= dir[0];
                y -= dir[1];
                // åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
                if (x == destination[0] && y == destination[1]) {
                    return true;
                }
                if (!visited[x][y]) {
                    visited[x][y] = true;
                    q.offer(new int[]{x, y});
                }
            }
        }
        return false;
    }
}
```

```javascript
// by chatGPT (javascript)
var hasPath = function(maze, start, destination) {
    var m = maze.length, n = maze[0].length;
    // æ–¹å‘æ•°ç»„ï¼Œæ–¹ä¾¿ä¸Šä¸‹å·¦å³ç§»åŠ¨
    var dirs = [[0,1],[0,-1],[1,0],[-1,0]];

    // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
    var q = [];
    var visited = new Array(m);
    for (var i = 0; i < m; i++) {
        visited[i] = new Array(n).fill(false);
    }
    // åŠ å…¥èµ·ç‚¹
    q.push(start);
    visited[start[0]][start[1]] = true;
    // å¯åŠ¨ BFS ç®—æ³•æ¡†æ¶
    while (q.length > 0) {
        var cur = q.shift();
        // å‘å››ä¸ªæ–¹å‘æ‰©å±•
        for (var i = 0; i < 4; i++) {
            var dir = dirs[i];
            var x = cur[0], y = cur[1];
            // å’Œå…¶ä»–é¢˜ç›®ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œä¸€ç›´èµ°åˆ°å¢™ï¼Œè€Œä¸æ˜¯åªèµ°ä¸€æ­¥
            while (x >= 0 && x < m && y >= 0 && y < n && maze[x][y] == 0) {
                x += dir[0];
                y += dir[1];
            }
            x -= dir[0];
            y -= dir[1];
            // åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
            if (x == destination[0] && y == destination[1]) {
                return true;
            }
            if (!visited[x][y]) {
                visited[x][y] = true;
                q.push([x, y]);
            }
        }
    }
    return false;
};
```

```python
# by chatGPT (python)
from typing import List
from queue import Queue

class Solution:
    def hasPath(self, maze: List[List[int]], start: List[int], destination: List[int]) -> bool:
        m, n = len(maze), len(maze[0])   # è·å–çŸ©é˜µçš„è¡Œå’Œåˆ—
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]   # å››ä¸ªæ–¹å‘

        q = Queue()   # BFS ç®—æ³•çš„é˜Ÿåˆ—
        visited = [[False for _ in range(n)] for _ in range(m)]   # visited æ•°ç»„
        q.put(start)   # åŠ å…¥èµ·ç‚¹
        visited[start[0]][start[1]] = True   # è®¾ç½®è¯¥ç‚¹å·²è®¿é—®
        # å¯åŠ¨ BFS ç®—æ³•æ¡†æ¶
        while not q.empty():
            x, y = q.get()
            # å‘å››ä¸ªæ–¹å‘æ‰©å±•
            for dir in dirs:
                # å’Œå…¶ä»–é¢˜ç›®ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œä¸€ç›´èµ°åˆ°å¢™ï¼Œè€Œä¸æ˜¯åªèµ°ä¸€æ­¥
                nr, nc = x, y
                while 0 <= nr < m and 0 <= nc < n and not maze[nr][nc]:
                    nr += dir[0]
                    nc += dir[1]
                nr -= dir[0]   # èµ°è¿‡å¢™åéœ€è¦å›é€€ä¸€æ­¥
                nc -= dir[1]
                # åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
                if (nr, nc) == tuple(destination):
                    return True
                if not visited[nr][nc]:
                    visited[nr][nc] = True   # è®¾ç½®è¯¥ç‚¹å·²è®¿é—®
                    q.put((nr, nc))

        return False
```

https://leetcode.cn/problems/the-maze çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/the-maze-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int shortestDistance(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {
        int m = maze.size(), n = maze[0].size();
        // æ–¹å‘æ•°ç»„ï¼Œæ–¹ä¾¿ä¸Šä¸‹å·¦å³ç§»åŠ¨
        vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
        queue<vector<int>> q;
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        // åŠ å…¥èµ·ç‚¹
        q.push(start);
        visited[start[0]][start[1]] = true;
        // å¯åŠ¨ BFS ç®—æ³•æ¡†æ¶
        while (!q.empty()) {
            vector<int> cur = q.front();
            q.pop();
            // å‘å››ä¸ªæ–¹å‘æ‰©å±•
            for (auto dir : dirs) {
                int x = cur[0], y = cur[1];
                int step = 0;
                // å’Œå…¶ä»–é¢˜ç›®ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œä¸€ç›´èµ°åˆ°å¢™ï¼Œè€Œä¸æ˜¯åªèµ°ä¸€æ­¥ï¼ŒåŒæ—¶è¦è®°å½•èµ°è¿‡çš„æ­¥æ•°
                while (x >= 0 && x < m && y >= 0 && y < n && maze[x][y] == 0) {
                    x += dir[0];
                    y += dir[1];
                    step++;
                }
                x -= dir[0];
                y -= dir[1];
                step--;
                // åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
                if (x == destination[0] && y == destination[1]) {
                    return step;
                }
                if (!visited[x][y]) {
                    visited[x][y] = true;
                    q.push({x, y});
                }
            }
        }
        return -1;
    }
};
```

```go
// by chatGPT (go)
import "container/list"

func shortestDistance(maze [][]int, start []int, destination []int) int {
    m, n := len(maze), len(maze[0])
    // æ–¹å‘æ•°ç»„ï¼Œæ–¹ä¾¿ä¸Šä¸‹å·¦å³ç§»åŠ¨
    dirs := [][]int{{0,1},{0,-1},{1,0},{-1,0}}

    // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
    q := list.New()
    visited := make([][]bool, m)
    for i := range visited {
        visited[i] = make([]bool, n)
    }
    // åŠ å…¥èµ·ç‚¹
    q.PushBack(start)
    visited[start[0]][start[1]] = true
    // å¯åŠ¨ BFS ç®—æ³•æ¡†æ¶
    for q.Len() != 0 {
        cur := q.Front().Value.([]int)
        q.Remove(q.Front())
        // å‘å››ä¸ªæ–¹å‘æ‰©å±•
        for _, dir := range dirs {
            x, y := cur[0], cur[1]
            step := 0
            // å’Œå…¶ä»–é¢˜ç›®ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œä¸€ç›´èµ°åˆ°å¢™ï¼Œè€Œä¸æ˜¯åªèµ°ä¸€æ­¥ï¼ŒåŒæ—¶è¦è®°å½•èµ°è¿‡çš„æ­¥æ•°
            for x >= 0 && x < m && y >= 0 && y < n && maze[x][y] == 0 {
                x += dir[0]
                y += dir[1]
                step++
            }
            x -= dir[0]
            y -= dir[1]
            step--
            // åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
            if x == destination[0] && y == destination[1] {
                return step
            }
            if !visited[x][y] {
                visited[x][y] = true
                q.PushBack([]int{x, y})
            }
        }
    }
    return -1
}
```

```java
// by labuladong (java)
class Solution {
    public int shortestDistance(int[][] maze, int[] start, int[] destination) {
        int m = maze.length, n = maze[0].length;
        // æ–¹å‘æ•°ç»„ï¼Œæ–¹ä¾¿ä¸Šä¸‹å·¦å³ç§»åŠ¨
        int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};

        // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
        Queue<int[]> q = new LinkedList<>();
        boolean[][] visited = new boolean[m][n];
        // åŠ å…¥èµ·ç‚¹
        q.offer(start);
        visited[start[0]][start[1]] = true;
        int step = 0;
        // å¯åŠ¨ BFS ç®—æ³•æ¡†æ¶
        while (!q.isEmpty()) {
            int[] cur = q.poll();
            // å‘å››ä¸ªæ–¹å‘æ‰©å±•
            for (int[] dir : dirs) {
                int x = cur[0], y = cur[1];
                // å’Œå…¶ä»–é¢˜ç›®ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œä¸€ç›´èµ°åˆ°å¢™ï¼Œè€Œä¸æ˜¯åªèµ°ä¸€æ­¥ï¼ŒåŒæ—¶è¦è®°å½•èµ°è¿‡çš„æ­¥æ•°
                while (x >= 0 && x < m && y >= 0 && y < n && maze[x][y] == 0) {
                    x += dir[0];
                    y += dir[1];
                    step++;
                }
                x -= dir[0];
                y -= dir[1];
                step--;
                // åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
                if (x == destination[0] && y == destination[1]) {
                    return step;
                }
                if (!visited[x][y]) {
                    visited[x][y] = true;
                    q.offer(new int[]{x, y});
                }
            }
        }
        return -1;
    }
}
```

```javascript
// by chatGPT (javascript)
var shortestDistance = function(maze, start, destination) {
    var m = maze.length, n = maze[0].length;
    // æ–¹å‘æ•°ç»„ï¼Œæ–¹ä¾¿ä¸Šä¸‹å·¦å³ç§»åŠ¨
    var dirs = [[0,1],[0,-1],[1,0],[-1,0]];

    // BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
    var q = [];
    var visited = new Array(m);
    for (var i = 0; i < m; i++) {
        visited[i] = new Array(n).fill(false);
    }
    // åŠ å…¥èµ·ç‚¹
    q.push(start);
    visited[start[0]][start[1]] = true;
    // å¯åŠ¨ BFS ç®—æ³•æ¡†æ¶
    while (q.length > 0) {
        var cur = q.shift();
        // å‘å››ä¸ªæ–¹å‘æ‰©å±•
        for (var dir of dirs) {
            var x = cur[0], y = cur[1];
            var step = 0;
            // å’Œå…¶ä»–é¢˜ç›®ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œä¸€ç›´èµ°åˆ°å¢™ï¼Œè€Œä¸æ˜¯åªèµ°ä¸€æ­¥ï¼ŒåŒæ—¶è¦è®°å½•èµ°è¿‡çš„æ­¥æ•°
            while (x >= 0 && x < m && y >= 0 && y < n && maze[x][y] == 0) {
                x += dir[0];
                y += dir[1];
                step++;
            }
            x -= dir[0];
            y -= dir[1];
            step--;
            // åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
            if (x == destination[0] && y == destination[1]) {
                return step;
            }
            if (!visited[x][y]) {
                visited[x][y] = true;
                q.push([x, y]);
            }
        }
    }
    return -1;
};
```

```python
# by chatGPT (python)
from queue import Queue

class Solution:
    def shortestDistance(self, maze: List[List[int]], start: List[int], destination: List[int]) -> int:
        m, n = len(maze), len(maze[0])

        # æ–¹å‘æ•°ç»„ï¼Œæ–¹ä¾¿ä¸Šä¸‹å·¦å³ç§»åŠ¨
        dirs = [(0,1), (0,-1), (1,0), (-1,0)]

        # BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
        q = Queue()
        visited = [[False for _ in range(n)] for _ in range(m)]
        # åŠ å…¥èµ·ç‚¹
        q.put(start)
        visited[start[0]][start[1]] = True
        # å¯åŠ¨ BFS ç®—æ³•æ¡†æ¶
        while not q.empty():
            cur = q.get()
            # å‘å››ä¸ªæ–¹å‘æ‰©å±•
            for dir in dirs:
                x, y = cur[0], cur[1]
                step = 0
                # å’Œå…¶ä»–é¢˜ç›®ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œä¸€ç›´èµ°åˆ°å¢™ï¼Œè€Œä¸æ˜¯åªèµ°ä¸€æ­¥ï¼ŒåŒæ—¶è¦è®°å½•èµ°è¿‡çš„æ­¥æ•°
                while x >= 0 and x < m and y >= 0 and y < n and maze[x][y] == 0:
                    x += dir[0]
                    y += dir[1]
                    step += 1
                x -= dir[0]
                y -= dir[1]
                step -= 1
                # åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
                if x == destination[0] and y == destination[1]:
                    return step
                if not visited[x][y]:
                    visited[x][y] = True
                    q.put((x, y))
        return -1
```

https://leetcode.cn/problems/the-maze-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/ti-huan-kong-ge-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    string replaceSpace(string s) {
        string ans;
        for (char c : s) {
            if (c == ' ') {
                ans += "%20";
            } else {
                ans += c;
            }
        }
        return ans;
    }
};
```

```go
// by chatGPT (go)
/**
 * @author ylx
 * @date 2021/2/2 19:19
 * @description Go å®ç°çš„ LeetCode å‰‘æŒ‡ Offer 05. æ›¿æ¢ç©ºæ ¼
 */
func replaceSpace(s string) string {
    var res strings.Builder
    for i := 0; i < len(s); i++ {
        if s[i] == ' ' {
            res.WriteString("%20")
        } else {
            res.WriteByte(s[i])
        }
    }
    return res.String()
}
```

```java
// by labuladong (java)
class Solution {
    public String replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == ' ') {
                sb.append("%20");
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }
}
```

```javascript
// by chatGPT (javascript)
var replaceSpace = function(s) {
  var sb = [];
  for (var i = 0; i < s.length; i++) {
    var c = s.charAt(i);
    if (c === ' ') {
      sb.push('%20');
    } else {
      sb.push(c);
    }
  }
  return sb.join('');
};
```

```python
# by chatGPT (python)
class Solution:
    def replaceSpace(self, s: str) -> str:
        sb = []
        for c in s:
            if c == ' ':
                sb.append('%20')
            else:
                sb.append(c)
        return ''.join(sb)
```

https://leetcode.cn/problems/ti-huan-kong-ge-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/top-k-frequent-elements çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
        unordered_map<int, int> valToFreq;
        for (int v : nums) {
            valToFreq[v]++;
        }

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        for (auto& [val, freq] : valToFreq) {
            pq.emplace(freq, val);
            if (pq.size() > k) {
                pq.pop();
            }
        }

        vector<int> res(k);
        int i = k - 1;
        while (!pq.empty()) {
            res[i] = pq.top().second;
            pq.pop();
            i--;
        }

        return res;
    }
};

class Solution2 {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
        unordered_map<int, int> valToFreq;
        for (int v : nums) {
            valToFreq[v]++;
        }

        // é¢‘ç‡ -> è¿™ä¸ªé¢‘ç‡æœ‰å“ªäº›å…ƒç´ 
        vector<vector<int>> freqToVals(nums.size() + 1);
        for (auto& [val, freq] : valToFreq) {
            freqToVals[freq].push_back(val);
        }

        vector<int> res(k);
        int p = 0;
        // freqToVals ä»åå¾€å‰å­˜å‚¨ç€å‡ºç°æœ€å¤šçš„å…ƒç´ 
        for (int i = freqToVals.size() - 1; i > 0; i--) {
            for (int j = 0; j < freqToVals[i].size(); j++) {
                res[p] = freqToVals[i][j];
                p++;
                if (p == k) {
                    return res;
                }
            }
        }

        return res;
    }
};
```

```go
// by chatGPT (go)
// ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—è§£å†³è¿™é“é¢˜
func topKFrequent(nums []int, k int) []int {
    // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
    valToFreq := make(map[int]int)
    for _, v := range nums {
        valToFreq[v]++
    }

    // å®šä¹‰ä¼˜å…ˆé˜Ÿåˆ—ï¼Œé˜Ÿåˆ—æŒ‰ç…§é”®å€¼å¯¹ä¸­çš„å€¼ï¼ˆå…ƒç´ å‡ºç°é¢‘ç‡ï¼‰ä»å°åˆ°å¤§æ’åºã€‚
    pq := priorityQueue{}
    for key, value := range valToFreq {
        pq = pq.Push(MapEntry{key, value})
        if len(pq) > k {
            pq.Pop()
        }
    }

    res := make([]int, k)
    for i := k - 1; i >= 0; i-- {
        // res æ•°ç»„ä¸­å­˜å‚¨å‰ k ä¸ªæœ€å¤§å…ƒç´ 
        res[i] = pq.Pop().key
    }

    return res
}

// å®šä¹‰ä¼˜å…ˆçº§é˜Ÿåˆ—
type MapEntry struct {
    key   int
    value int
}
type priorityQueue []MapEntry

func (pq priorityQueue) Len() int      { return len(pq) }
func (pq priorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] }
func (pq priorityQueue) Less(i, j int) bool {
    return pq[i].value < pq[j].value
}
func (pq priorityQueue) Push(x interface{}) priorityQueue {
    item := x.(MapEntry)
    return append(pq, item)
}
func (pq priorityQueue) Pop() MapEntry {
    item := pq[pq.Len()-1]
    pq = pq[:pq.Len()-1]
    return item
}

// ç”¨è®¡æ•°æ’åºçš„æ–¹æ³•è§£å†³è¿™é“é¢˜
func topKFrequent2(nums []int, k int) []int {
    // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
    valToFreq := make(map[int]int)
    for _, v := range nums {
        valToFreq[v]++
    }

    // é¢‘ç‡ -> è¿™ä¸ªé¢‘ç‡æœ‰å“ªäº›å…ƒç´ 
    freqToVals := make([][]int, len(nums)+1)
    for val, freq := range valToFreq {
        if _, ok := freqToVals[freq]; !ok {
            freqToVals[freq] = []int{}
        }
        freqToVals[freq] = append(freqToVals[freq], val)
    }

    res := make([]int, 0, k)
    // freqToVals ä»åå¾€å‰å­˜å‚¨ç€å‡ºç°æœ€å¤šçš„å…ƒç´ 
    for i := len(freqToVals) - 1; i > 0; i-- {
        if len(freqToVals[i]) == 0 {
            continue
        }
        res = append(res, freqToVals[i]...)
        if len(res) >= k {
            res = res[:k]
            break
        }
    }

    return res
}
```

```java
// by labuladong (java)
// ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—è§£å†³è¿™é“é¢˜
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
        HashMap<Integer, Integer> valToFreq = new HashMap<>();
        for (int v : nums) {
            valToFreq.put(v, valToFreq.getOrDefault(v, 0) + 1);
        }

        PriorityQueue<Map.Entry<Integer, Integer>>
                pq = new PriorityQueue<>((entry1, entry2) -> {
            // é˜Ÿåˆ—æŒ‰ç…§é”®å€¼å¯¹ä¸­çš„å€¼ï¼ˆå…ƒç´ å‡ºç°é¢‘ç‡ï¼‰ä»å°åˆ°å¤§æ’åº
            return entry1.getValue().compareTo(entry2.getValue());
        });

        for (Map.Entry<Integer, Integer> entry : valToFreq.entrySet()) {
            pq.offer(entry);
            if (pq.size() > k) {
                // å¼¹å‡ºæœ€å°å…ƒç´ ï¼Œç»´æŠ¤é˜Ÿåˆ—å†…æ˜¯ k ä¸ªé¢‘ç‡æœ€å¤§çš„å…ƒç´ 
                pq.poll();
            }
        }

        int[] res = new int[k];
        for (int i = k - 1; i >= 0; i--) {
            // res æ•°ç»„ä¸­å­˜å‚¨å‰ k ä¸ªæœ€å¤§å…ƒç´ 
            res[i] = pq.poll().getKey();
        }

        return res;
    }
}

// ç”¨è®¡æ•°æ’åºçš„æ–¹æ³•è§£å†³è¿™é“é¢˜
class Solution2 {
    public int[] topKFrequent(int[] nums, int k) {
        // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
        HashMap<Integer, Integer> valToFreq = new HashMap<>();
        for (int v : nums) {
            valToFreq.put(v, valToFreq.getOrDefault(v, 0) + 1);
        }

        // é¢‘ç‡ -> è¿™ä¸ªé¢‘ç‡æœ‰å“ªäº›å…ƒç´ 
        ArrayList<Integer>[] freqToVals = new ArrayList[nums.length + 1];
        for (int val : valToFreq.keySet()) {
            int freq = valToFreq.get(val);
            if (freqToVals[freq] == null) {
                freqToVals[freq] = new ArrayList<>();
            }
            freqToVals[freq].add(val);
        }

        int[] res = new int[k];
        int p = 0;
        // freqToVals ä»åå¾€å‰å­˜å‚¨ç€å‡ºç°æœ€å¤šçš„å…ƒç´ 
        for (int i = freqToVals.length - 1; i > 0; i--) {
            ArrayList<Integer> valList = freqToVals[i];
            if (valList == null) continue;
            for (int j = 0; j < valList.size(); j++) {
                // å°†å‡ºç°æ¬¡æ•°æœ€å¤šçš„ k ä¸ªå…ƒç´ è£…å…¥ res
                res[p] = valList.get(j);
                p++;
                if (p == k) {
                    return res;
                }
            }
        }

        return null;
    }
}
```

```javascript
// by chatGPT (javascript)
var topKFrequent = function(nums, k) {
    // nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
    const valToFreq = new Map();
    for (let v of nums) {
        valToFreq.set(v, valToFreq.get(v) ? valToFreq.get(v) + 1: 1);
    }

    const pq = new PriorityQueue((a, b) => a.value < b.value);

    for (let [key, value] of valToFreq) {
        pq.offer({key, value});
        if (pq.size() > k) {
            pq.poll();
        }
    }

    const res = [];
    for (let i = 0; i < k; i++) {
        res.push(pq.poll().key);
    }
    return res;
};
```

```python
# by chatGPT (python)
# ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—è§£å†³è¿™é“é¢˜
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
        valToFreq = {}
        for v in nums:
            valToFreq[v] = valToFreq.get(v, 0) + 1

        pq = []
        # æŒ‰ç…§é”®å€¼å¯¹ä¸­çš„å€¼ï¼ˆå…ƒç´ å‡ºç°é¢‘ç‡ï¼‰ä»å°åˆ°å¤§æ’åº
        for entry in valToFreq.items():
            heapq.heappush(pq, (entry[1], entry[0]))
            if len(pq) > k:
                # å¼¹å‡ºæœ€å°å…ƒç´ ï¼Œç»´æŠ¤é˜Ÿåˆ—å†…æ˜¯ k ä¸ªé¢‘ç‡æœ€å¤§çš„å…ƒç´ 
                heapq.heappop(pq)

        res = []
        for i in range(k - 1, -1, -1):
            # res æ•°ç»„ä¸­å­˜å‚¨å‰ k ä¸ªæœ€å¤§å…ƒç´ 
            res.append(heapq.heappop(pq)[1])

        return res[::-1]

# ç”¨è®¡æ•°æ’åºçš„æ–¹æ³•è§£å†³è¿™é“é¢˜
class Solution2:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # nums ä¸­çš„å…ƒç´  -> è¯¥å…ƒç´ å‡ºç°çš„é¢‘ç‡
        valToFreq = {}
        for v in nums:
            valToFreq[v] = valToFreq.get(v, 0) + 1

        # é¢‘ç‡ -> è¿™ä¸ªé¢‘ç‡æœ‰å“ªäº›å…ƒç´ 
        freqToVals = [[] for _ in range(len(nums) + 1)]
        for val, freq in valToFreq.items():
            freqToVals[freq].append(val)

        res = []
        # freqToVals ä»åå¾€å‰å­˜å‚¨ç€å‡ºç°æœ€å¤šçš„å…ƒç´ 
        for i in range(len(freqToVals) - 1, 0, -1):
            valList = freqToVals[i]
            for j in range(len(valList)):
                # å°†å‡ºç°æ¬¡æ•°æœ€å¤šçš„ k ä¸ªå…ƒç´ è£…å…¥ res
                res.append(valList[j])
                if len(res) == k:
                    return res

        return res
```

https://leetcode.cn/problems/top-k-frequent-elements çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/top-k-frequent-words çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        // å­—ç¬¦ä¸² -> è¯¥å­—ç¬¦ä¸²å‡ºç°çš„é¢‘ç‡
        unordered_map<string, int> wordToFreq;
        for (string word : words) {
            wordToFreq[word] += 1;
        }

        // é‡è½½ lambda è¡¨è¾¾å¼ï¼Œå¤„ç†ç›¸åŒé¢‘ç‡çš„é›†åˆæŒ‰å­—å…¸åºä¼˜å…ˆçº§
        auto cmp = [&](const pair<string, int>& a, const pair<string, int>& b) {
            if (a.second == b.second) {
                return a.first < b.first;
            }
            return a.second > b.second;
        };
        priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(cmp)> pq(cmp);

        // ç»´æŠ¤å‡ºç°é¢‘ç‡æœ€å¤šçš„ k ä¸ªå­—ç¬¦ä¸²
        for (auto it : wordToFreq) {
            pq.emplace(it.first, it.second);
            if (pq.size() > k) {
                pq.pop();
            }
        }

        // æŠŠå‡ºç°æ¬¡æ•°æœ€å¤šçš„ k ä¸ªå­—ç¬¦ä¸²è¿”å›
        vector<string> res(k, "");
        for (int i = k - 1; i >= 0; --i) {
            res[i] = pq.top().first;
            pq.pop();
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func topKFrequent(words []string, k int) []string {
    // å­—ç¬¦ä¸² -> è¯¥å­—ç¬¦ä¸²å‡ºç°çš„é¢‘ç‡
    wordToFreq := make(map[string]int)
    for _, word := range words {
        wordToFreq[word]++
    }

    pq := priorityQueue{}
    heap.Init(&pq)

    // entryç»“æ„ä½“æ•°ç»„
    type entry struct {
        key   string
        value int
    }

    // å¤§é¡¶å †å‡½æ•°
    heapFunc := func(a, b *entry) bool {
        // æ³¨æ„è¿™é‡Œï¼Œå¦‚æœå‡ºç°é¢‘ç‡ç›¸åŒï¼ŒæŒ‰ç…§å­—ç¬¦ä¸²å­—å…¸åºæ’åº
        if a.value == b.value {
            return a.key > b.key
        }
        // é˜Ÿåˆ—æŒ‰ç…§å­—ç¬¦ä¸²å‡ºç°é¢‘ç‡ä»å°åˆ°å¤§æ’åº
        return a.value < b.value
    }

    // ç»´æŠ¤å‡ºç°é¢‘ç‡æœ€å¤šçš„ k ä¸ªå•è¯
    for key, value := range wordToFreq {
        en := &entry{key, value}
        if pq.Len() == k {
            if heapFunc(pq[0], en) {
                heap.Pop(&pq)
                heap.Push(&pq, en)
            }
        } else {
            heap.Push(&pq, en)
        }
    }

    // æŠŠå‡ºç°æ¬¡æ•°æœ€å¤šçš„ k ä¸ªå­—ç¬¦ä¸²è¿”å›
    res := make([]string, k)
    for i := k - 1; i >= 0; i-- {
        res[i] = heap.Pop(&pq).(*entry).key
    }
    return res
}

// å®šä¹‰å †æ’åºå‡½æ•°
type priorityQueue []*entry

func (pq priorityQueue) Len() int { return len(pq) }

func (pq priorityQueue) Less(i, j int) bool {
    // æ³¨æ„è¿™é‡Œï¼Œä»¿ä½›è¦åç€æ¥
    return pq[i].value > pq[j].value
}

func (pq priorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] }

func (pq *priorityQueue) Push(x interface{}) {
    // æ³¨æ„ç±»å‹è½¬æ¢
    item := x.(*entry)
    *pq = append(*pq, item)
}

func (pq *priorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
}
```

```java
// by labuladong (java)
class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        // å­—ç¬¦ä¸² -> è¯¥å­—ç¬¦ä¸²å‡ºç°çš„é¢‘ç‡
        HashMap<String, Integer> wordToFreq = new HashMap<>();
        for (String word : words) {
            wordToFreq.put(word, wordToFreq.getOrDefault(word, 0) + 1);
        }

        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(
                (entry1, entry2) -> {
                    if (entry1.getValue().equals(entry2.getValue())) {
                        // å¦‚æœå‡ºç°é¢‘ç‡ç›¸åŒï¼ŒæŒ‰ç…§å­—ç¬¦ä¸²å­—å…¸åºæ’åº
                        return entry2.getKey().compareTo(entry1.getKey());
                    }
                    // é˜Ÿåˆ—æŒ‰ç…§å­—ç¬¦ä¸²å‡ºç°é¢‘ç‡ä»å°åˆ°å¤§æ’åº
                    return entry1.getValue().compareTo(entry2.getValue());
                });

        // æŒ‰ç…§å­—ç¬¦ä¸²é¢‘ç‡å‡åºæ’åº
        for (Map.Entry<String, Integer> entry : wordToFreq.entrySet()) {
            pq.offer(entry);
            if (pq.size() > k) {
                // ç»´æŠ¤å‡ºç°é¢‘ç‡æœ€å¤šçš„ k ä¸ªå•è¯
                pq.poll();
            }
        }

        // æŠŠå‡ºç°æ¬¡æ•°æœ€å¤šçš„ k ä¸ªå­—ç¬¦ä¸²è¿”å›
        LinkedList<String> res = new LinkedList<>();
        while (!pq.isEmpty()) {
            res.addFirst(pq.poll().getKey());
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var topKFrequent = function(words, k) {
    // å­—ç¬¦ä¸² -> è¯¥å­—ç¬¦ä¸²å‡ºç°çš„é¢‘ç‡
    let wordToFreq = new Map();
    for (let word of words) {
        wordToFreq.set(word, wordToFreq.get(word) + 1 || 1);
    }

    let pq = new PriorityQueue((a, b) => {
        if (a.freq === b.freq) {
            // å¦‚æœå‡ºç°é¢‘ç‡ç›¸åŒï¼ŒæŒ‰ç…§å­—ç¬¦ä¸²å­—å…¸åºæ’åº
            return b.word.localeCompare(a.word);
        }
        // é˜Ÿåˆ—æŒ‰ç…§å­—ç¬¦ä¸²å‡ºç°é¢‘ç‡ä»å°åˆ°å¤§æ’åº
        return a.freq - b.freq;
    });

    // æŒ‰ç…§å­—ç¬¦ä¸²é¢‘ç‡å‡åºæ’åº
    for (let [word, freq] of wordToFreq.entries()) {
        pq.offer({ word, freq });
        if (pq.size > k) {
            // ç»´æŠ¤å‡ºç°é¢‘ç‡æœ€å¤šçš„ k ä¸ªå•è¯
            pq.poll();
        }
    }

    // æŠŠå‡ºç°æ¬¡æ•°æœ€å¤šçš„ k ä¸ªå­—ç¬¦ä¸²è¿”å›
    let res = [];
    while (!pq.isEmpty()) {
        res.push(pq.poll().word);
    }
    return res.reverse();
};
```

```python
# by chatGPT (python)
class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        # å­—ç¬¦ä¸² -> è¯¥å­—ç¬¦ä¸²å‡ºç°çš„é¢‘ç‡
        wordToFreq = {}
        for word in words:
            wordToFreq[word] = wordToFreq.get(word, 0) + 1

        pq = []
        for word, freq in wordToFreq.items():
            # å­˜å‚¨è´Ÿå€¼ï¼Œè®©å°æ ¹å †å˜æˆå¤§æ ¹å †
            pq.append((-freq, word))

        # æ„å»ºå°æ ¹å †
        heapq.heapify(pq)

        # å–å‡ºå‰kä¸ªé«˜é¢‘å•è¯
        res = []
        for _ in range(k):
            freq, word = heapq.heappop(pq)
            res.append(word)

        return res
```

https://leetcode.cn/problems/top-k-frequent-words çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/transpose-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        // è½¬ç½®çŸ©é˜µçš„é•¿å’Œå®½é¢ å€’
        vector<vector<int>> res(n, vector<int>(m));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                res[j][i] = matrix[i][j];
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
// leetcode format 
func transpose(matrix [][]int) [][]int {
    m, n := len(matrix), len(matrix[0])
    //  è½¬ç½®çŸ©é˜µçš„é•¿å’Œå®½é¢ å€’
    res := make([][]int, n)
    for i := range res {
        res[i] = make([]int, m)
    }
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            res[j][i] = matrix[i][j]
        }
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    public int[][] transpose(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        // è½¬ç½®çŸ©é˜µçš„é•¿å’Œå®½é¢ å€’
        int[][] res = new int[n][m];
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++) {
                res[j][i] = matrix[i][j];
            }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var transpose = function(matrix) {
    var m = matrix.length, n = matrix[0].length;
    // è½¬ç½®çŸ©é˜µçš„é•¿å’Œå®½é¢ å€’
    var res = new Array(n).fill().map(() => new Array(m).fill(0));
    for (var i = 0; i < m; i++)
        for (var j = 0; j < n; j++) {
            res[j][i] = matrix[i][j];
        }
    return res;
}
```

```python
# by chatGPT (python)
class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        m, n = len(matrix), len(matrix[0]) #è½¬ç½®çŸ©é˜µçš„é•¿å’Œå®½é¢ å€’
        res = [[0] * m for _ in range(n)]
        for i in range(m):
            for j in range(n):
                res[j][i] = matrix[i][j]
        return res
```

https://leetcode.cn/problems/transpose-matrix çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/trapping-rain-water çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int trap(vector<int>& height) {
        if (height.empty()) {
            return 0;
        }
        int n = height.size();
        int res = 0;
        // æ•°ç»„å……å½“å¤‡å¿˜å½•
        vector<int> l_max(n);
        vector<int> r_max(n);
        // åˆå§‹åŒ– base case
        l_max[0] = height[0];
        r_max[n - 1] = height[n - 1];
        // ä»å·¦å‘å³è®¡ç®— l_max
        for (int i = 1; i < n; i++) {
            l_max[i] = max(height[i], l_max[i - 1]);
        }
        // ä»å³å‘å·¦è®¡ç®— r_max
        for (int i = n - 2; i >= 0; i--) {
            r_max[i] = max(height[i], r_max[i + 1]);
        }
        // è®¡ç®—ç­”æ¡ˆ
        for (int i = 1; i < n - 1; i++) {
            res += min(l_max[i], r_max[i]) - height[i];
        }
        /**<extend up -300>
        ![](../pictures/æ¥é›¨æ°´/1.jpg)
        */
        return res;
    }
};
```

```go
// by chatGPT (go)
func trap(height []int) int {
    if len(height) == 0 {
        return 0
    }
    n := len(height)
    res := 0
    // æ•°ç»„å……å½“å¤‡å¿˜å½•
    l_max := make([]int, n)
    r_max := make([]int, n)
    // åˆå§‹åŒ– base case
    l_max[0] = height[0]
    r_max[n - 1] = height[n - 1]
    // ä»å·¦å‘å³è®¡ç®— l_max
    for i := 1; i < n; i++ {
        l_max[i] = max(height[i], l_max[i - 1])
    }
    // ä»å³å‘å·¦è®¡ç®— r_max
    for i := n - 2; i >= 0; i-- {
        r_max[i] = max(height[i], r_max[i + 1])
    }
    // è®¡ç®—ç­”æ¡ˆ
    for i := 1; i < n - 1; i++ {
        res += min(l_max[i], r_max[i]) - height[i]
        /**<extend up -300>
        ![](../pictures/æ¥é›¨æ°´/1.jpg)
        */
    } 
    return res;
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b 
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b 
}
```

```java
// by labuladong (java)
class Solution {
    public int trap(int[] height) {
        if (height.length == 0) {
            return 0;
        }
        int n = height.length;
        int res = 0;
        // æ•°ç»„å……å½“å¤‡å¿˜å½•
        int[] l_max = new int[n];
        int[] r_max = new int[n];
        // åˆå§‹åŒ– base case
        l_max[0] = height[0];
        r_max[n - 1] = height[n - 1];
        // ä»å·¦å‘å³è®¡ç®— l_max
        for (int i = 1; i < n; i++)
            l_max[i] = Math.max(height[i], l_max[i - 1]);
        // ä»å³å‘å·¦è®¡ç®— r_max
        for (int i = n - 2; i >= 0; i--)
            r_max[i] = Math.max(height[i], r_max[i + 1]);
        // è®¡ç®—ç­”æ¡ˆ
        for (int i = 1; i < n - 1; i++)
            res += Math.min(l_max[i], r_max[i]) - height[i];
            /**<extend up -300>
            ![](../pictures/æ¥é›¨æ°´/1.jpg)
            */
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var trap = function(height) {
  if (height.length == 0) {
    return 0;
  }
  var n = height.length;
  var res = 0;
  // æ•°ç»„å……å½“å¤‡å¿˜å½•
  var l_max = new Array(n);
  var r_max = new Array(n);
  // åˆå§‹åŒ– base case
  l_max[0] = height[0];
  r_max[n - 1] = height[n - 1];
  // ä»å·¦å‘å³è®¡ç®— l_max
  for (var i = 1; i < n; i++) {
    l_max[i] = Math.max(height[i], l_max[i - 1]);
  }
  // ä»å³å‘å·¦è®¡ç®— r_max
  for (var i = n - 2; i >= 0; i--) {
    r_max[i] = Math.max(height[i], r_max[i + 1]);
  }
  // è®¡ç®—ç­”æ¡ˆ
  for (var i = 1; i < n - 1; i++) {
    res += Math.min(l_max[i], r_max[i]) - height[i];
  }
  /**<extend up -300>
  ![](../pictures/æ¥é›¨æ°´/1.jpg)
  */
  return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        n = len(height)
        res = 0
        # æ•°ç»„å……å½“å¤‡å¿˜å½•
        l_max = [0] * n
        r_max = [0] * n
        # åˆå§‹åŒ– base case
        l_max[0] = height[0]
        r_max[n - 1] = height[n - 1]
        # ä»å·¦å‘å³è®¡ç®— l_max
        for i in range(1, n):
            l_max[i] = max(height[i], l_max[i - 1])
        # ä»å³å‘å·¦è®¡ç®— r_max
        for i in range(n - 2, -1, -1):
            r_max[i] = max(height[i], r_max[i + 1])
        # è®¡ç®—ç­”æ¡ˆ
        for i in range(1, n - 1):
            res += min(l_max[i], r_max[i]) - height[i]
            """
            extend up -300
            ![](../pictures/æ¥é›¨æ°´/1.jpg)
            """
        return res
```

https://leetcode.cn/problems/trapping-rain-water çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/two-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // ç»´æŠ¤ val -> index çš„æ˜ å°„
        unordered_map<int, int> valToIndex;
        for (int i = 0; i < nums.size(); i++) {
            // æŸ¥è¡¨ï¼Œçœ‹çœ‹æ˜¯å¦æœ‰èƒ½å’Œ nums[i] å‡‘å‡º target çš„å…ƒç´ 
            int need = target - nums[i];
            if (valToIndex.count(need)) {
                return vector<int>{valToIndex[need], i};
            }
            // å­˜å…¥ val -> index çš„æ˜ å°„
            valToIndex[nums[i]] = i;
        }
        return vector<int>{};
    }
};
```

```go
// by chatGPT (go)
func twoSum(nums []int, target int) []int {
    // ç»´æŠ¤ val -> index çš„æ˜ å°„
    valToIndex := make(map[int]int)

    for i, num := range nums {
        // æŸ¥è¡¨ï¼Œçœ‹çœ‹æ˜¯å¦æœ‰èƒ½å’Œ nums[i] å‡‘å‡º target çš„å…ƒç´ 
        need := target - num
        if valToIndex[need] != 0 {
            return []int{valToIndex[need] - 1, i}
        }
        // å­˜å…¥ val -> index çš„æ˜ å°„
        valToIndex[num] = i + 1
    }

    return nil
}
```

```java
// by labuladong (java)
class Solution {
    public int[] twoSum(int[] nums, int target) {
        // ç»´æŠ¤ val -> index çš„æ˜ å°„
        HashMap<Integer, Integer> valToIndex = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            // æŸ¥è¡¨ï¼Œçœ‹çœ‹æ˜¯å¦æœ‰èƒ½å’Œ nums[i] å‡‘å‡º target çš„å…ƒç´ 
            int need = target - nums[i];
            if (valToIndex.containsKey(need)) {
                return new int[]{valToIndex.get(need), i};
            }
            // å­˜å…¥ val -> index çš„æ˜ å°„
            valToIndex.put(nums[i], i);
        }
        return null;
    }
}
```

```javascript
// by chatGPT (javascript)
var twoSum = function(nums, target) {
    // ç»´æŠ¤ val -> index çš„æ˜ å°„
    var valToIndex = new Map();
    for (var i = 0; i < nums.length; i++) {
        // æŸ¥è¡¨ï¼Œçœ‹çœ‹æ˜¯å¦æœ‰èƒ½å’Œ nums[i] å‡‘å‡º target çš„å…ƒç´ 
        var need = target - nums[i];
        if (valToIndex.has(need)) {
            return [valToIndex.get(need), i];
        }
        // å­˜å…¥ val -> index çš„æ˜ å°„
        valToIndex.set(nums[i], i);
    }
    return null;
};
```

```python
# by chatGPT (python)
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # ç»´æŠ¤ val -> index çš„æ˜ å°„
        valToIndex = {}
        for i in range(len(nums)):
            # æŸ¥è¡¨ï¼Œçœ‹çœ‹æ˜¯å¦æœ‰èƒ½å’Œ nums[i] å‡‘å‡º target çš„å…ƒç´ 
            need = target - nums[i]
            if need in valToIndex:
                return [valToIndex[need], i]
            # å­˜å…¥ val -> index çš„æ˜ å°„
            valToIndex[nums[i]] = i
        return []
```

https://leetcode.cn/problems/two-sum çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/two-sum-less-than-k çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int twoSumLessThanK(vector<int>& nums, int k) {
        // æ•°ç»„åŒæŒ‡é’ˆä¸€èˆ¬éƒ½è¦å…ˆæ’åº
        sort(nums.begin(), nums.end());
        // å·¦å³æŒ‡é’ˆæŠ€å·§
        int lo = 0, hi = nums.size() - 1;
        int sum = -1;
        while (lo < hi) {
            if (nums[lo] + nums[hi] < k) {
                // æ¯”ç›®æ ‡å€¼ k å°ï¼Œåˆ™å³ç§»å·¦æŒ‡é’ˆ
                sum = max(sum, nums[lo] + nums[hi]);
                lo++;
            } else {
                // æ¯”ç›®æ ‡å€¼ k å¤§ï¼Œåˆ™å·¦ç§»å³æŒ‡é’ˆ
                hi--;
            }
        }
        return sum;
    }
};
```

```go
// by chatGPT (go)
// 
import "sort"

// TwoSumLessThanK å‡½æ•°è¿”å› nums æ•°ç»„ä¸­ä»»æ„ä¸¤ä¸ªæ•°çš„æœ€å¤§å’Œï¼Œ
// ä½†ä¸è¶…è¿‡ k çš„å’Œ
func twoSumLessThanK(nums []int, k int) int {
	// æ•°ç»„åŒæŒ‡é’ˆä¸€èˆ¬éƒ½è¦å…ˆæ’åº
	sort.Ints(nums)

	// å·¦å³æŒ‡é’ˆæŠ€å·§
	lo, hi := 0, len(nums)-1
	sum := -1

	for lo < hi {
		if nums[lo]+nums[hi] < k {
			// æ¯”ç›®æ ‡å€¼ k å°ï¼Œåˆ™å³ç§»å·¦æŒ‡é’ˆ
			sum = max(sum, nums[lo]+nums[hi])
			lo++
		} else {
			// æ¯”ç›®æ ‡å€¼ k å¤§ï¼Œåˆ™å·¦ç§»å³æŒ‡é’ˆ
			hi--
		}
	}

	return sum
}

// è¾…åŠ©å‡½æ•° max è¿”å›ä¸¤ä¸ªæ•´æ•°ä¸­çš„è¾ƒå¤§å€¼
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

```java
// by labuladong (java)
class Solution {
    public int twoSumLessThanK(int[] nums, int k) {
        // æ•°ç»„åŒæŒ‡é’ˆä¸€èˆ¬éƒ½è¦å…ˆæ’åº
        Arrays.sort(nums);
        // å·¦å³æŒ‡é’ˆæŠ€å·§
        int lo = 0, hi = nums.length - 1;
        int sum = -1;
        while (lo < hi) {
            if (nums[lo] + nums[hi] < k) {
                // æ¯”ç›®æ ‡å€¼ k å°ï¼Œåˆ™å³ç§»å·¦æŒ‡é’ˆ
                sum = Math.max(sum, nums[lo] + nums[hi]);
                lo++;
            } else {
                // æ¯”ç›®æ ‡å€¼ k å¤§ï¼Œåˆ™å·¦ç§»å³æŒ‡é’ˆ
                hi--;
            }
        }
        return sum;
    }
}
```

```javascript
// by chatGPT (javascript)
var twoSumLessThanK = function(nums, k) {
   // æ•°ç»„åŒæŒ‡é’ˆä¸€èˆ¬éƒ½è¦å…ˆæ’åº
   nums.sort(function(a, b){return a - b});
   // å·¦å³æŒ‡é’ˆæŠ€å·§
   var lo = 0, hi = nums.length - 1;
   var sum = -1;
   while (lo < hi) {
       if (nums[lo] + nums[hi] < k) {
           // æ¯”ç›®æ ‡å€¼ k å°ï¼Œåˆ™å³ç§»å·¦æŒ‡é’ˆ
           sum = Math.max(sum, nums[lo] + nums[hi]);
           lo++;
       } else {
           // æ¯”ç›®æ ‡å€¼ k å¤§ï¼Œåˆ™å·¦ç§»å³æŒ‡é’ˆ
           hi--;
       }
   }
   return sum;
};
```

```python
# by chatGPT (python)
class Solution:
    def twoSumLessThanK(self, nums: List[int], k: int) -> int:
        # æ•°ç»„åŒæŒ‡é’ˆä¸€èˆ¬éƒ½è¦å…ˆæ’åº
        nums.sort()
        # å·¦å³æŒ‡é’ˆæŠ€å·§
        lo, hi = 0, len(nums) - 1
        sum = -1
        while lo < hi:
            if nums[lo] + nums[hi] < k:
                # æ¯”ç›®æ ‡å€¼ k å°ï¼Œåˆ™å³ç§»å·¦æŒ‡é’ˆ
                sum = max(sum, nums[lo] + nums[hi])
                lo += 1
            else:
                # æ¯”ç›®æ ‡å€¼ k å¤§ï¼Œåˆ™å·¦ç§»å³æŒ‡é’ˆ
                hi -= 1
        return sum
```

https://leetcode.cn/problems/two-sum-less-than-k çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/uUsW3B çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:

    vector<vector<int>>res;
    vector<vector<int>> combine(int n, int k) {
        if (k <= 0 || n <= 0) return res;
        vector<int> track;
        backtrack(n, k, 1, track);
        return res;
    }

    void backtrack(int n, int k, int start, vector<int>& track) {
        // åˆ°è¾¾æ ‘çš„åº•éƒ¨
        if (k == track.size()) {
            res.push_back(track);
            return;
        }
        // æ³¨æ„ i ä» start å¼€å§‹é€’å¢
        for (int i = start; i <= n; i++) {
            // åšé€‰æ‹©
            track.push_back(i);
            backtrack(n, k, i + 1, track);
            // æ’¤é”€é€‰æ‹©
            track.pop_back();
        }
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func combine(n int, k int) [][]int {
    res := make([][]int, 0)
    if k <= 0 || n <= 0 {
        return res
    }
    track := make([]int, 0)
    backtrack(n, k, 1, track, &res)
    return res
}

func backtrack(n, k, start int, track []int, res *[][]int) {
    // åˆ°è¾¾æ ‘çš„åº•éƒ¨
    if k == len(track) {
        temp := make([]int, len(track))
        copy(temp, track)
        *res = append(*res, temp)
        return
    }
    // æ³¨æ„ i ä» start å¼€å§‹é€’å¢
    for i := start; i <= n; i++ {
        // åšé€‰æ‹©
        track = append(track, i)
        backtrack(n, k, i+1, track, res)
        // æ’¤é”€é€‰æ‹©
        track = track[:len(track)-1]
    }
}
```

```java
// by chatGPT (java)
class Solution {
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        if (k <= 0 || n <= 0) return res;
        List<Integer> track = new ArrayList<>();
        backtrack(n, k, 1, track);
        return res;
    }

    private void backtrack(int n, int k, int start, List<Integer> track) {
        // åˆ°è¾¾æ ‘çš„åº•éƒ¨
        if (k == track.size()) {
            res.add(new ArrayList<>(track));
            return;
        }
        // æ³¨æ„ i ä» start å¼€å§‹é€’å¢
        for (int i = start; i <= n; i++) {
            // åšé€‰æ‹©
            track.add(i);
            backtrack(n, k, i + 1, track);
            // æ’¤é”€é€‰æ‹©
            track.remove(track.size() - 1);
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var combine = function(n, k) {
  let res = [];
  if (k <= 0 || n <= 0) return res;
  let track = [];
  // åˆ°è¾¾æ ‘çš„åº•éƒ¨
  const backtrack = function(n, k, start, track) {
    if (k === track.length) {
      res.push([...track]);
      return;
    }
    // æ³¨æ„ i ä» start å¼€å§‹é€’å¢
    for (let i = start; i <= n; i++) {
      // åšé€‰æ‹©
      track.push(i);
      backtrack(n, k, i + 1, track);
      // æ’¤é”€é€‰æ‹©
      track.pop();
    }
  };
  backtrack(n, k, 1, track);
  return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res = []
        if k <= 0 or n <= 0:
            return res
        def backtrack(n: int, k: int, start: int, track: List[int]) -> None:
            # åˆ°è¾¾æ ‘çš„åº•éƒ¨
            if k == len(track):
                res.append(track)
                return
            # æ³¨æ„ i ä» start å¼€å§‹é€’å¢
            for i in range(start, n + 1):
                # åšé€‰æ‹©
                track.append(i)
                backtrack(n, k, i + 1, track[:])
                # æ’¤é”€é€‰æ‹©
                track.pop()
        backtrack(n, k, 1, [])
        return res
```

https://leetcode.cn/problems/uUsW3B çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/ugly-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isUgly(int n) {
        if (n <= 0) return false;
        // å¦‚æœ n æ˜¯ä¸‘æ•°ï¼Œåˆ†è§£å› å­åº”è¯¥åªæœ‰ 2, 3, 5
        while (n % 2 == 0) n /= 2;
        while (n % 3 == 0) n /= 3;
        while (n % 5 == 0) n /= 5;
        return n == 1;
    }
};
```

```go
// by chatGPT (go)
func isUgly(n int) bool {
    if n <= 0 {
        return false
    }
    // å¦‚æœ n æ˜¯ä¸‘æ•°ï¼Œåˆ†è§£å› å­åº”è¯¥åªæœ‰ 2, 3, 5
    for n % 2 == 0 {
        n /= 2
    }
    for n % 3 == 0 {
        n /= 3
    }
    for n % 5 == 0 {
        n /= 5
    }
    return n == 1
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isUgly(int n) {
        if (n <= 0) return false;
        // å¦‚æœ n æ˜¯ä¸‘æ•°ï¼Œåˆ†è§£å› å­åº”è¯¥åªæœ‰ 2, 3, 5
        while (n % 2 == 0) n /= 2;
        while (n % 3 == 0) n /= 3;
        while (n % 5 == 0) n /= 5;
        return n == 1;
    }
}
```

```javascript
// by chatGPT (javascript)
var isUgly = function(n) {
    if (n <= 0) return false;
    // å¦‚æœ n æ˜¯ä¸‘æ•°ï¼Œåˆ†è§£å› å­åº”è¯¥åªæœ‰ 2, 3, 5
    while (n % 2 === 0) n /= 2;
    while (n % 3 === 0) n /= 3;
    while (n % 5 === 0) n /= 5;
    return n === 1;
};
```

```python
# by chatGPT (python)
class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False
        # å¦‚æœ n æ˜¯ä¸‘æ•°ï¼Œåˆ†è§£å› å­åº”è¯¥åªæœ‰ 2, 3, 5
        while n % 2 == 0:
            n //= 2
        while n % 3 == 0:
            n //= 3
        while n % 5 == 0:
            n //= 5
        return n == 1
```

https://leetcode.cn/problems/ugly-number çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/ugly-number-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int nthUglyNumber(int n) {
        // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæŒ‡å‘æœ‰åºé“¾è¡¨å¤´ç»“ç‚¹çš„æŒ‡é’ˆ
        int p2 = 1, p3 = 1, p5 = 1;
        // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæœ‰åºé“¾è¡¨çš„å¤´èŠ‚ç‚¹çš„å€¼
        int product2 = 1, product3 = 1, product5 = 1;
        // å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
        vector<int> ugly(n + 1, 0);
        // å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        int p = 1;

        // å¼€å§‹åˆå¹¶ä¸‰ä¸ªæœ‰åºé“¾è¡¨
        while (p <= n) {
            // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
            int min_val = min(min(product2, product3), product5);
            // æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
            ugly[p] = min_val;
            p++;
            // å‰è¿›å¯¹åº”æœ‰åºé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
            if (min_val == product2) {
                product2 = 2 * ugly[p2];
                p2++;
            }
            if (min_val == product3) {
                product3 = 3 * ugly[p3];
                p3++;
            }
            if (min_val == product5) {
                product5 = 5 * ugly[p5];
                p5++;
            }
        }
        // è¿”å›ç¬¬ n ä¸ªä¸‘æ•°
        return ugly[n];
    }
};
```

```go
// by chatGPT (go)
func nthUglyNumber(n int) int {
    // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæŒ‡å‘æœ‰åºé“¾è¡¨å¤´ç»“ç‚¹çš„æŒ‡é’ˆ
    p2, p3, p5 := 1, 1, 1
    // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæœ‰åºé“¾è¡¨çš„å¤´èŠ‚ç‚¹çš„å€¼
    product2, product3, product5 := 1, 1, 1
    // å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
    ugly := make([]int, n+1)
    // å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
    p := 1

    // å¼€å§‹åˆå¹¶ä¸‰ä¸ªæœ‰åºé“¾è¡¨
    for p <= n {
        // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
        min := min(product2, product3, product5)
        // æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
        ugly[p] = min
        p++
        // å‰è¿›å¯¹åº”æœ‰åºé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        if min == product2 {
            product2 = 2 * ugly[p2]
            p2++
        }
        if min == product3 {
            product3 = 3 * ugly[p3]
            p3++
        }
        if min == product5 {
            product5 = 5 * ugly[p5]
            p5++
        }
    }
    // è¿”å›ç¬¬ n ä¸ªä¸‘æ•°
    return ugly[n]
}

// å–ä¸‰ä¸ªæ•°çš„æœ€å°å€¼
func min(i, j, k int) int {
    if i < j {
        if i < k {
            return i
        } else {
            return k
        }
    } else {
        if j < k {
            return j
        } else {
            return k
        }
    }
}
```

```java
// by labuladong (java)
class Solution {
    public int nthUglyNumber(int n) {
        // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæŒ‡å‘æœ‰åºé“¾è¡¨å¤´ç»“ç‚¹çš„æŒ‡é’ˆ
        int p2 = 1, p3 = 1, p5 = 1;
        // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæœ‰åºé“¾è¡¨çš„å¤´èŠ‚ç‚¹çš„å€¼
        int product2 = 1, product3 = 1, product5 = 1;
        // å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
        int[] ugly = new int[n + 1];
        // å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        int p = 1;

        // å¼€å§‹åˆå¹¶ä¸‰ä¸ªæœ‰åºé“¾è¡¨
        while (p <= n) {
            // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
            int min = Math.min(Math.min(product2, product3), product5);
            // æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
            ugly[p] = min;
            p++;
            // å‰è¿›å¯¹åº”æœ‰åºé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
            if (min == product2) {
                product2 = 2 * ugly[p2];
                p2++;
            }
            if (min == product3) {
                product3 = 3 * ugly[p3];
                p3++;
            }
            if (min == product5) {
                product5 = 5 * ugly[p5];
                p5++;
            }
        }
        // è¿”å›ç¬¬ n ä¸ªä¸‘æ•°
        return ugly[n];
    }
}
```

```javascript
// by chatGPT (javascript)
var nthUglyNumber = function(n) {
    // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæŒ‡å‘æœ‰åºé“¾è¡¨å¤´ç»“ç‚¹çš„æŒ‡é’ˆ
    let p2 = 1, p3 = 1, p5 = 1;
    // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæœ‰åºé“¾è¡¨çš„å¤´èŠ‚ç‚¹çš„å€¼
    let product2 = 1, product3 = 1, product5 = 1;
    // å¯ä»¥ç†è§£ä¸ºæœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
    let ugly = new Array(n + 1);
    // å¯ä»¥ç†è§£ä¸ºç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
    let p = 1;
  
    // å¼€å§‹åˆå¹¶ä¸‰ä¸ªæœ‰åºé“¾è¡¨
    while (p <= n) {
        // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
        let min = Math.min(Math.min(product2, product3), product5);
        // æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
        ugly[p] = min;
        p++;
        // å‰è¿›å¯¹åº”æœ‰åºé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        if (min === product2) {
            product2 = 2 * ugly[p2];
            p2++;
        }
        if (min === product3) {
            product3 = 3 * ugly[p3];
            p3++;
        }
        if (min === product5) {
            product5 = 5 * ugly[p5];
            p5++;
        }
    }
    // è¿”å›ç¬¬ n ä¸ªä¸‘æ•°
    return ugly[n];
};
```

```python
# by chatGPT (python)
class Solution:
    def nthUglyNumber(self,n: int) -> int:
        # ä¸‰ä¸ªæŒ‡å‘æœ‰åºé“¾è¡¨å¤´ç»“ç‚¹çš„æŒ‡é’ˆ
        p2,p3,p5 = 1,1,1
        # ä¸‰ä¸ªæœ‰åºé“¾è¡¨çš„å¤´èŠ‚ç‚¹çš„å€¼
        product2, product3, product5 = 1, 1, 1
        # æœ€ç»ˆåˆå¹¶çš„æœ‰åºé“¾è¡¨ï¼ˆç»“æœé“¾è¡¨ï¼‰
        ugly = [0] * (n + 1)
        # ç»“æœé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        p = 1

        # å¼€å§‹åˆå¹¶ä¸‰ä¸ªæœ‰åºé“¾è¡¨
        while p <= n:
            # å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
            minv = min(product2, product3, product5)
            # æ¥åˆ°ç»“æœé“¾è¡¨ä¸Š
            ugly[p] = minv
            p += 1
            # å‰è¿›å¯¹åº”æœ‰åºé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
            if minv == product2:
                product2 = 2 * ugly[p2]
                p2 += 1
            if minv == product3:
                product3 = 3 * ugly[p3]
                p3 += 1
            if minv == product5:
                product5 = 5 * ugly[p5]
                p5 += 1

        # è¿”å›ç¬¬ n ä¸ªä¸‘æ•°
        return ugly[n]
```

https://leetcode.cn/problems/ugly-number-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/ugly-number-iii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
// äºŒåˆ†æœç´¢ + æ•°å­¦è§£æ³•
class Solution {
public:
    int nthUglyNumber(int n, int a, int b, int c) {
        // é¢˜ç›®è¯´æœ¬é¢˜ç»“æœåœ¨ [1, 2 * 10^9] èŒƒå›´å†…ï¼Œ
        // æ‰€ä»¥å°±æŒ‰ç…§è¿™ä¸ªèŒƒå›´åˆå§‹åŒ–ä¸¤ç«¯éƒ½é—­çš„æœç´¢åŒºé—´
        int left = 1, right = (int) 2e9;
        // æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æœç´¢
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (f(mid, a, b, c) < n) {
                // [1..mid] ä¸­çš„å…ƒç´ ä¸ªæ•°ä¸è¶³ nï¼Œæ‰€ä»¥ç›®æ ‡åœ¨å³ä¾§
                left = mid + 1;
            } else {
                // [1..mid] ä¸­çš„å…ƒç´ ä¸ªæ•°å¤§äº nï¼Œæ‰€ä»¥ç›®æ ‡åœ¨å·¦ä¾§
                right = mid - 1;
            }
        }
        return left;
    }

    // è®¡ç®— [1..num] ä¹‹é—´æœ‰å¤šå°‘ä¸ªèƒ½å¤Ÿè¢« a æˆ– b æˆ– c æ•´é™¤çš„æ•°å­—
    long f(int num, int a, int b, int c) {
        long setA = num / a, setB = num / b, setC = num / c;
        long setAB = num / lcm(a, b);
        long setAC = num / lcm(a, c);
        long setBC = num / lcm(b, c);
        long setABC = num / lcm(lcm(a, b), c);
        // é›†åˆè®ºå®šç†ï¼šA + B + C - A âˆ© B - A âˆ© C - B âˆ© C + A âˆ© B âˆ© C
        return setA + setB + setC - setAB - setAC - setBC + setABC;
        /*
        ![](../pictures/ä¸‘æ•°/1.jpg)
        */
    }

    // è®¡ç®—æœ€å¤§å…¬å› æ•°ï¼ˆè¾—è½¬ç›¸é™¤/æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼‰
    long gcd(long a, long b) {
        if (a < b) {
            // ä¿è¯ a > b
            return gcd(b, a);
        }
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }

    // æœ€å°å…¬å€æ•°
    long lcm(long a, long b) {
        // æœ€å°å…¬å€æ•°å°±æ˜¯ä¹˜ç§¯é™¤ä»¥æœ€å¤§å…¬å› æ•°
        return a * b / gcd(a, b);
    }
};

// ç”¨åˆå¹¶å•é“¾è¡¨çš„æ€è·¯ï¼ˆè¶…æ—¶ï¼‰
class Solution2 {
public:
    int nthUglyNumber(int n, int a, int b, int c) {
        // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæœ‰åºé“¾è¡¨çš„å¤´ç»“ç‚¹çš„å€¼
        long productA = a, productB = b, productC = c;
        // å¯ä»¥ç†è§£ä¸ºåˆå¹¶ä¹‹åçš„æœ‰åºé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        int p = 1;

        long min = -666;

        // å¼€å§‹åˆå¹¶ä¸‰ä¸ªæœ‰åºé“¾è¡¨ï¼Œè·å–ç¬¬ n ä¸ªèŠ‚ç‚¹çš„å€¼
        while (p <= n) {
            // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
            min = std::min({productA, productB, productC});
            p++;
            // å‰è¿›æœ€å°ç»“ç‚¹å¯¹åº”é“¾è¡¨çš„æŒ‡é’ˆ
            if (min == productA) {
                productA += a;
            }
            if (min == productB) {
                productB += b;
            }
            if (min == productC) {
                productC += c;
            }
        }
        return (int) min;
    }
};
```

```go
// by chatGPT (go)
// äºŒåˆ†æœç´¢ + æ•°å­¦è§£æ³•
func nthUglyNumber(n int, a int, b int, c int) int {
    // é¢˜ç›®è¯´æœ¬é¢˜ç»“æœåœ¨ [1, 2 * 10^9] èŒƒå›´å†…ï¼Œ
    // æ‰€ä»¥å°±æŒ‰ç…§è¿™ä¸ªèŒƒå›´åˆå§‹åŒ–ä¸¤ç«¯éƒ½é—­çš„æœç´¢åŒºé—´
    left, right := 1, 2*int(1e9)
    // æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æœç´¢
    for left <= right {
        mid := left + (right-left)/2
        if f(mid, a, b, c) < n {
            // [1..mid] ä¸­çš„å…ƒç´ ä¸ªæ•°ä¸è¶³ nï¼Œæ‰€ä»¥ç›®æ ‡åœ¨å³ä¾§
            left = mid + 1
        } else {
            // [1..mid] ä¸­çš„å…ƒç´ ä¸ªæ•°å¤§äº nï¼Œæ‰€ä»¥ç›®æ ‡åœ¨å·¦ä¾§
            right = mid - 1
        }
    }
    return left
}

// è®¡ç®— [1..num] ä¹‹é—´æœ‰å¤šå°‘ä¸ªèƒ½å¤Ÿè¢« a æˆ– b æˆ– c æ•´é™¤çš„æ•°å­—
func f(num int, a int, b int, c int) int {
    setA := num / a
    setB := num / b
    setC := num / c
    setAB := num / lcm(a, b)
    setAC := num / lcm(a, c)
    setBC := num / lcm(b, c)
    setABC := num / lcm(lcm(a, b), c)
    // é›†åˆè®ºå®šç†ï¼šA + B + C - A âˆ© B - A âˆ© C - B âˆ© C + A âˆ© B âˆ© C
    return setA + setB + setC - setAB - setAC - setBC + setABC
}

// è®¡ç®—æœ€å¤§å…¬å› æ•°ï¼ˆè¾—è½¬ç›¸é™¤/æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼‰
func gcd(a int64, b int64) int64 {
    if a < b {
        // ä¿è¯ a > b
        return gcd(b, a)
    }
    if b == 0 {
        return a
    }
    return gcd(b, a%b)
}

// æœ€å°å…¬å€æ•°
func lcm(a int64, b int64) int64 {
    // æœ€å°å…¬å€æ•°å°±æ˜¯ä¹˜ç§¯é™¤ä»¥æœ€å¤§å…¬å› æ•°
    return a * b / gcd(a, b)
}
```

```java
// by labuladong (java)
// äºŒåˆ†æœç´¢ + æ•°å­¦è§£æ³•
class Solution {
    public int nthUglyNumber(int n, int a, int b, int c) {
        // é¢˜ç›®è¯´æœ¬é¢˜ç»“æœåœ¨ [1, 2 * 10^9] èŒƒå›´å†…ï¼Œ
        // æ‰€ä»¥å°±æŒ‰ç…§è¿™ä¸ªèŒƒå›´åˆå§‹åŒ–ä¸¤ç«¯éƒ½é—­çš„æœç´¢åŒºé—´
        int left = 1, right = (int) 2e9;
        // æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æœç´¢
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (f(mid, a, b, c) < n) {
                // [1..mid] ä¸­çš„å…ƒç´ ä¸ªæ•°ä¸è¶³ nï¼Œæ‰€ä»¥ç›®æ ‡åœ¨å³ä¾§
                left = mid + 1;
            } else {
                // [1..mid] ä¸­çš„å…ƒç´ ä¸ªæ•°å¤§äº nï¼Œæ‰€ä»¥ç›®æ ‡åœ¨å·¦ä¾§
                right = mid - 1;
            }
        }
        return left;
    }

    // è®¡ç®— [1..num] ä¹‹é—´æœ‰å¤šå°‘ä¸ªèƒ½å¤Ÿè¢« a æˆ– b æˆ– c æ•´é™¤çš„æ•°å­—
    long f(int num, int a, int b, int c) {
        long setA = num / a, setB = num / b, setC = num / c;
        long setAB = num / lcm(a, b);
        long setAC = num / lcm(a, c);
        long setBC = num / lcm(b, c);
        long setABC = num / lcm(lcm(a, b), c);
        // é›†åˆè®ºå®šç†ï¼šA + B + C - A âˆ© B - A âˆ© C - B âˆ© C + A âˆ© B âˆ© C
        return setA + setB + setC - setAB - setAC - setBC + setABC;
        /**<extend up -400>
        ![](../pictures/ä¸‘æ•°/1.jpg)
        */
    }

    // è®¡ç®—æœ€å¤§å…¬å› æ•°ï¼ˆè¾—è½¬ç›¸é™¤/æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼‰
    long gcd(long a, long b) {
        if (a < b) {
            // ä¿è¯ a > b
            return gcd(b, a);
        }
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }

    // æœ€å°å…¬å€æ•°
    long lcm(long a, long b) {
        // æœ€å°å…¬å€æ•°å°±æ˜¯ä¹˜ç§¯é™¤ä»¥æœ€å¤§å…¬å› æ•°
        return a * b / gcd(a, b);
    }
}

// ç”¨åˆå¹¶å•é“¾è¡¨çš„æ€è·¯ï¼ˆè¶…æ—¶ï¼‰
class Solution2 {
    public int nthUglyNumber(int n, int a, int b, int c) {
        // å¯ä»¥ç†è§£ä¸ºä¸‰ä¸ªæœ‰åºé“¾è¡¨çš„å¤´ç»“ç‚¹çš„å€¼
        long productA = a, productB = b, productC = c;
        // å¯ä»¥ç†è§£ä¸ºåˆå¹¶ä¹‹åçš„æœ‰åºé“¾è¡¨ä¸Šçš„æŒ‡é’ˆ
        int p = 1;

        long min = -666;

        // å¼€å§‹åˆå¹¶ä¸‰ä¸ªæœ‰åºé“¾è¡¨ï¼Œè·å–ç¬¬ n ä¸ªèŠ‚ç‚¹çš„å€¼
        while (p <= n) {
            // å–ä¸‰ä¸ªé“¾è¡¨çš„æœ€å°ç»“ç‚¹
            min = Math.min(Math.min(productA, productB), productC);
            p++;
            // å‰è¿›æœ€å°ç»“ç‚¹å¯¹åº”é“¾è¡¨çš„æŒ‡é’ˆ
            if (min == productA) {
                productA += a;
            }
            if (min == productB) {
                productB += b;
            }
            if (min == productC) {
                productC += c;
            }
        }
        return (int) min;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number} n
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {number}
 */
var nthUglyNumber = function(n, a, b, c) {
  // é¢˜ç›®è¯´æœ¬é¢˜ç»“æœåœ¨ [1, 2 * 10^9] èŒƒå›´å†…ï¼Œ
  // æ‰€ä»¥å°±æŒ‰ç…§è¿™ä¸ªèŒƒå›´åˆå§‹åŒ–ä¸¤ç«¯éƒ½é—­çš„æœç´¢åŒºé—´
  let left = 1, right = 2e9;
  // æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æœç´¢
  while (left <= right) {
    let mid = left + (right - left) / 2;
    if (f(mid, a, b, c) < n) {
      // [1..mid] ä¸­çš„å…ƒç´ ä¸ªæ•°ä¸è¶³ nï¼Œæ‰€ä»¥ç›®æ ‡åœ¨å³ä¾§
      left = mid + 1;
    } else {
      // [1..mid] ä¸­çš„å…ƒç´ ä¸ªæ•°å¤§äº nï¼Œæ‰€ä»¥ç›®æ ‡åœ¨å·¦ä¾§
      right = mid - 1;
    }
  }
  return left;
  
  // è®¡ç®— [1..num] ä¹‹é—´æœ‰å¤šå°‘ä¸ªèƒ½å¤Ÿè¢« a æˆ– b æˆ– c æ•´é™¤çš„æ•°å­—
  function f(num, a, b, c) {
    let setA = Math.floor(num / a), setB = Math.floor(num / b), setC = Math.floor(num / c);
    let setAB = Math.floor(num / lcm(a, b));
    let setAC = Math.floor(num / lcm(a, c));
    let setBC = Math.floor(num / lcm(b, c));
    let setABC = Math.floor(num / lcm(lcm(a, b), c));
    // é›†åˆè®ºå®šç†ï¼šA + B + C - A âˆ© B - A âˆ© C - B âˆ© C + A âˆ© B âˆ© C
    return setA + setB + setC - setAB - setAC - setBC + setABC;
    /**<extend up -400>
    ![](../pictures/ä¸‘æ•°/1.jpg)
    */
  }

  // è®¡ç®—æœ€å¤§å…¬å› æ•°ï¼ˆè¾—è½¬ç›¸é™¤/æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼‰
  function gcd(a, b) {
    if (a < b) {
      // ä¿è¯ a > b
      return gcd(b, a);
    }
    if (b === 0) {
      return a;
    }
    return gcd(b, a % b);
  }

  // æœ€å°å…¬å€æ•°
  function lcm(a, b) {
    // æœ€å°å…¬å€æ•°å°±æ˜¯ä¹˜ç§¯é™¤ä»¥æœ€å¤§å…¬å› æ•°
    return a * b / gcd(a, b);
  }
};
```

```python
# by chatGPT (python)
class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        def gcd(x: int, y: int) -> int:
            if x < y:
                # ä¿è¯ x > y
                return gcd(y, x)
            if y == 0:
                return x
            return gcd(y, x % y)

        def lcm(x: int, y: int) -> int:
            # æœ€å°å…¬å€æ•°å°±æ˜¯ä¹˜ç§¯é™¤ä»¥æœ€å¤§å…¬å› æ•°
            return x * y // gcd(x, y)

        # é¢˜ç›®è¯´æœ¬é¢˜ç»“æœåœ¨ [1, 2 * 10^9] èŒƒå›´å†…ï¼Œ
        # æ‰€ä»¥å°±æŒ‰ç…§è¿™ä¸ªèŒƒå›´åˆå§‹åŒ–ä¸¤ç«¯éƒ½é—­çš„æœç´¢åŒºé—´
        left, right = 1, 2 * 10 ** 9
        # æœç´¢å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æœç´¢
        while left <= right:
            mid = (left + right) // 2
            if (mid // a + mid // b + mid // c -
               mid // lcm(a, b) - mid // lcm(b, c) -
               mid // lcm(a, c) + mid // lcm(lcm(a, b), c)) < n:
                # [1..mid] ä¸­çš„å…ƒç´ ä¸ªæ•°ä¸è¶³ nï¼Œæ‰€ä»¥ç›®æ ‡åœ¨å³ä¾§
                left = mid + 1
            else:
                # [1..mid] ä¸­çš„å…ƒç´ ä¸ªæ•°å¤§äº nï¼Œæ‰€ä»¥ç›®æ ‡åœ¨å·¦ä¾§
                right = mid - 1
        return left
```

https://leetcode.cn/problems/ugly-number-iii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/unique-binary-search-trees çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // å¤‡å¿˜å½•
    int memo[20][20];

    int numTrees(int n) {
        // å¤‡å¿˜å½•çš„å€¼åˆå§‹åŒ–ä¸º 0
        memset(memo, 0, sizeof(memo));
        return count(1, n);
    }

    int count(int lo, int hi) {
        if (lo > hi) return 1;
        // æŸ¥å¤‡å¿˜å½•
        if (memo[lo][hi] != 0) {
            return memo[lo][hi];
        }

        int res = 0;
        for (int mid = lo; mid <= hi; mid++) {
            int left = count(lo, mid - 1);
            int right = count(mid + 1, hi);
            res += left * right;
        }
        // å°†ç»“æœå­˜å…¥å¤‡å¿˜å½•
        memo[lo][hi] = res;

        return res;
    }
};
```

```go
// by chatGPT (go)
func numTrees(n int) int {
    // å¤‡å¿˜å½•çš„å€¼åˆå§‹åŒ–ä¸º 0
    memo := make([][]int, n+1)
    for i := 0; i <= n; i++ {
        memo[i] = make([]int, n+1)
    }

    var count func(lo, hi int) int
    count = func(lo, hi int) int {
        if lo > hi {
            return 1
        }
        // æŸ¥å¤‡å¿˜å½•
        if memo[lo][hi] != 0 {
            return memo[lo][hi]
        }

        res := 0
        for mid := lo; mid <= hi; mid++ {
            left := count(lo, mid-1)
            right := count(mid+1, hi)
            res += left * right
        }
        // å°†ç»“æœå­˜å…¥å¤‡å¿˜å½•
        memo[lo][hi] = res

        return res
    }

    return count(1, n)
}
```

```java
// by labuladong (java)
class Solution {
    // å¤‡å¿˜å½•
    int[][] memo;

    int numTrees(int n) {
        // å¤‡å¿˜å½•çš„å€¼åˆå§‹åŒ–ä¸º 0
        memo = new int[n + 1][n + 1];
        return count(1, n);
    }

    int count(int lo, int hi) {
        if (lo > hi) return 1;
        // æŸ¥å¤‡å¿˜å½•
        if (memo[lo][hi] != 0) {
            return memo[lo][hi];
        }

        int res = 0;
        for (int mid = lo; mid <= hi; mid++) {
            int left = count(lo, mid - 1);
            int right = count(mid + 1, hi);
            res += left * right;
        }
        // å°†ç»“æœå­˜å…¥å¤‡å¿˜å½•
        memo[lo][hi] = res;

        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var numTrees = function(n) {
    //å¤‡å¿˜å½•
    var memo = new Array(n+1).fill(0).map(() => new Array(n+1).fill(0));
    //è®¡ç®—æ ‘çš„ä¸ªæ•°
    function count(lo, hi) {
        //å½“å·¦ç«¯ç‚¹å¤§äºå³ç«¯ç‚¹æ—¶ï¼Œè¿”å›1
        if (lo > hi) return 1;
        //æŸ¥çœ‹å¤‡å¿˜å½•
        if (memo[lo][hi] != 0) {
            return memo[lo][hi];
        }

        var res = 0;
        //ç”¨midéå†å·¦å³å­æ ‘çš„æ‰€æœ‰æ ¹èŠ‚ç‚¹
        for (var mid = lo; mid <= hi; mid++) {
            //è®¡ç®—å·¦å­æ ‘çš„ä¸ªæ•°
            var left = count(lo, mid - 1);
            //è®¡ç®—å³å­æ ‘çš„ä¸ªæ•°
            var right = count(mid + 1, hi);
            //è®¡ç®—æ€»çš„æ–¹æ¡ˆæ•°
            res += left * right;
        }

        //å°†ç»“æœå­˜å…¥å¤‡å¿˜å½•
        memo[lo][hi] = res;

        return res;
    }
    //è¿”å›å…¨éƒ¨åŒºé—´ [1, n] çš„æ–¹æ¡ˆæ•°
    return count(1, n);
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        # å¤‡å¿˜å½•
        self.memo = []
        
    def numTrees(self, n: int) -> int:
        # å¤‡å¿˜å½•çš„å€¼åˆå§‹åŒ–ä¸º 0
        self.memo = [[0]*(n+1) for _ in range(n+1)]
        return self.count(1, n)

    def count(self, lo: int, hi: int) -> int:
        if lo > hi:
            return 1
        # æŸ¥å¤‡å¿˜å½•
        if self.memo[lo][hi] != 0:
            return self.memo[lo][hi]

        res = 0
        for mid in range(lo, hi+1):
            left = self.count(lo, mid - 1)
            right = self.count(mid + 1, hi)
            res += left * right
        # å°†ç»“æœå­˜å…¥å¤‡å¿˜å½•
        self.memo[lo][hi] = res

        return res
```

https://leetcode.cn/problems/unique-binary-search-trees çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/unique-binary-search-trees-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    /* ä¸»å‡½æ•° */
    vector<TreeNode*> generateTrees(int n) {
        if (n == 0) return vector<TreeNode*>({});
        // æ„é€ é—­åŒºé—´ [1, n] ç»„æˆçš„ BST
        return build(1, n);
    }

    /* æ„é€ é—­åŒºé—´ [lo, hi] ç»„æˆçš„ BST */
    vector<TreeNode*> build(int lo, int hi) {
        vector<TreeNode*> res;
        // base case
        if (lo > hi) {
            res.push_back(nullptr);
            return res;
        }

        // 1ã€ç©·ä¸¾ root èŠ‚ç‚¹çš„æ‰€æœ‰å¯èƒ½ã€‚
        for (int i = lo; i <= hi; i++) {
            // 2ã€é€’å½’æ„é€ å‡ºå·¦å³å­æ ‘çš„æ‰€æœ‰åˆæ³• BSTã€‚
            vector<TreeNode*> leftTree = build(lo, i - 1);
            vector<TreeNode*> rightTree = build(i + 1, hi);
            // 3ã€ç»™ root èŠ‚ç‚¹ç©·ä¸¾æ‰€æœ‰å·¦å³å­æ ‘çš„ç»„åˆã€‚
            for (auto left : leftTree) {
                for (auto right : rightTree) {
                    // i ä½œä¸ºæ ¹èŠ‚ç‚¹ root çš„å€¼
                    TreeNode* root = new TreeNode(i);
                    root->left = left;
                    root->right = right;
                    res.push_back(root);
                }
            }
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
/* ä¸»å‡½æ•° */
func generateTrees(n int) []*TreeNode {
    if n == 0 { return []*TreeNode{} }
    // æ„é€ é—­åŒºé—´ [1, n] ç»„æˆçš„ BST
    return build(1, n)
}

/* æ„é€ é—­åŒºé—´ [lo, hi] ç»„æˆçš„ BST */
func build(lo, hi int) []*TreeNode {
    res := []*TreeNode{}
    // base case
    if lo > hi {
        res = append(res, nil)
        return res
    }

    // 1ã€ç©·ä¸¾ root èŠ‚ç‚¹çš„æ‰€æœ‰å¯èƒ½ã€‚
    for i := lo; i <= hi; i++ {
        // 2ã€é€’å½’æ„é€ å‡ºå·¦å³å­æ ‘çš„æ‰€æœ‰åˆæ³• BSTã€‚
        leftTree := build(lo, i-1)
        rightTree := build(i+1, hi)
        // 3ã€ç»™ root èŠ‚ç‚¹ç©·ä¸¾æ‰€æœ‰å·¦å³å­æ ‘çš„ç»„åˆã€‚
        for _, left := range leftTree {
            for _, right := range rightTree {
                // i ä½œä¸ºæ ¹èŠ‚ç‚¹ root çš„å€¼
                root := &TreeNode{Val: i}
                root.Left = left
                root.Right = right
                res = append(res, root)
            }
        }
    }
    return res
}
```

```java
// by labuladong (java)
class Solution {
    /* ä¸»å‡½æ•° */
    public List<TreeNode> generateTrees(int n) {
        if (n == 0) return new LinkedList<>();
        // æ„é€ é—­åŒºé—´ [1, n] ç»„æˆçš„ BST
        return build(1, n);
    }

    /* æ„é€ é—­åŒºé—´ [lo, hi] ç»„æˆçš„ BST */
    List<TreeNode> build(int lo, int hi) {
        List<TreeNode> res = new LinkedList<>();
        // base case
        if (lo > hi) {
            res.add(null);
            return res;
        }

        // 1ã€ç©·ä¸¾ root èŠ‚ç‚¹çš„æ‰€æœ‰å¯èƒ½ã€‚
        for (int i = lo; i <= hi; i++) {
            // 2ã€é€’å½’æ„é€ å‡ºå·¦å³å­æ ‘çš„æ‰€æœ‰åˆæ³• BSTã€‚
            List<TreeNode> leftTree = build(lo, i - 1);
            List<TreeNode> rightTree = build(i + 1, hi);
            // 3ã€ç»™ root èŠ‚ç‚¹ç©·ä¸¾æ‰€æœ‰å·¦å³å­æ ‘çš„ç»„åˆã€‚
            for (TreeNode left : leftTree) {
                for (TreeNode right : rightTree) {
                    // i ä½œä¸ºæ ¹èŠ‚ç‚¹ root çš„å€¼
                    TreeNode root = new TreeNode(i);
                    root.left = left;
                    root.right = right;
                    res.add(root);
                }
            }
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var generateTrees = function(n) {
  if (n == 0) return new Array();
  // æ„é€ é—­åŒºé—´ [1, n] ç»„æˆçš„ BST
  return build(1, n);
}

var build = function(lo, hi) {
  // å­˜å‚¨ BST çš„ç»“æœé›†
  var res = new Array();
  // base case
  if (lo > hi) {
    // æ³¨æ„ï¼šè¿™é‡Œå¿…é¡»æ·»åŠ  nullï¼Œå¦åˆ™åœ¨ä¸‹é¢æ— æ³•é€’å½’å·¦å³å­æ ‘
    res.push(null);
    return res;
  }
  // 1ã€ç©·ä¸¾ root èŠ‚ç‚¹çš„æ‰€æœ‰å¯èƒ½
  for (var i = lo; i <= hi; i++) {
    // 2ã€é€’å½’æ„é€ å‡ºå·¦å³å­æ ‘çš„æ‰€æœ‰åˆæ³• BST
    var leftTree = build(lo, i - 1);
    var rightTree = build(i + 1, hi);
    // 3ã€ç»™ root èŠ‚ç‚¹ç©·ä¸¾æ‰€æœ‰å·¦å³å­æ ‘çš„ç»„åˆ
    for (var j = 0; j < leftTree.length; j++) {
      for (var k = 0; k < rightTree.length; k++) {
        // i ä½œä¸ºæ ¹èŠ‚ç‚¹ root çš„å€¼
        var root = new TreeNode(i);
        root.left = leftTree[j];
        root.right = rightTree[k];
        res.push(root);
      }
    }
  }
  return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        if n == 0: # å¦‚æœèŠ‚ç‚¹æ•°é‡ä¸º 0ï¼Œåˆ™è¿”å›ä¸€ä¸ªç©ºåˆ—è¡¨
            return [] 
        return self.build(1, n) # æ„é€ é—­åŒºé—´ [1, n] çš„ BST

    def build(self, lo: int, hi: int) -> List[TreeNode]:
        res = []
        # å½“ lo > hi æ—¶ï¼Œä¸å­˜åœ¨èŠ‚ç‚¹ï¼Œå°† None å­˜å…¥ç»“æœåˆ—è¡¨ä¸­ï¼Œå¹¶è¿”å›
        if lo > hi: 
            res.append(None)
            return res

        # 1ã€ç©·ä¸¾ root èŠ‚ç‚¹çš„æ‰€æœ‰å¯èƒ½ã€‚
        for i in range(lo, hi + 1): 
            # 2ã€é€’å½’æ„é€ å‡ºå·¦å³å­æ ‘çš„æ‰€æœ‰åˆæ³• BSTã€‚
            leftTree = self.build(lo, i - 1)
            rightTree = self.build(i + 1, hi)
            # 3ã€ç»™ root èŠ‚ç‚¹ç©·ä¸¾æ‰€æœ‰å·¦å³å­æ ‘çš„ç»„åˆã€‚
            for left in leftTree:
                for right in rightTree:
                    # i ä½œä¸ºæ ¹èŠ‚ç‚¹ root çš„å€¼
                    root = TreeNode(i)
                    root.left = left
                    root.right = right
                    res.append(root)

        return res
```

https://leetcode.cn/problems/unique-binary-search-trees-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/unique-paths çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    // å¤‡å¿˜å½•
    int[][] memo;

public:
    int uniquePaths(int m, int n) {
        memo = new int*[m];
        for(int i=0;i<m;i++) {
            memo[i] = new int[n];
            for(int j=0;j<n;j++) {
                memo[i][j] = 0;
            }
        }
        return dp(m - 1, n - 1);
    }

    int dp(int x, int y) {
        // base case
        if (x == 0 && y == 0) {
            return 1;
        }
        if (x < 0 || y < 0) {
            return 0;
        }
        // é¿å…å†—ä½™è®¡ç®—
        if (memo[x][y] > 0) {
            return memo[x][y];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // åˆ°è¾¾ (x, y) çš„è·¯å¾„æ•°ç­‰äºåˆ°è¾¾ (x - 1, y) å’Œ (x, y - 1) è·¯å¾„æ•°ä¹‹å’Œ
        memo[x][y] = dp(x - 1, y) + dp(x, y - 1);
        return memo[x][y];
    }
};
```

```go
// by chatGPT (go)
func uniquePaths(m int, n int) int {
    // å¤‡å¿˜å½•
    memo := make([][]int, m)
    for i := 0; i < m; i++ {
        memo[i] = make([]int, n)
    }

    // å®šä¹‰ï¼šä» (0, 0) åˆ° (x, y) æœ‰ dp(x, y) æ¡è·¯å¾„
    var dp func(int, int) int
    dp = func(x int, y int) int {
        // base case
        if x == 0 && y == 0 {
            return 1
        }
        if x < 0 || y < 0 {
            return 0
        }
        // é¿å…å†—ä½™è®¡ç®—
        if memo[x][y] > 0 {
            return memo[x][y]
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // åˆ°è¾¾ (x, y) çš„è·¯å¾„æ•°ç­‰äºåˆ°è¾¾ (x - 1, y) å’Œ (x, y - 1) è·¯å¾„æ•°ä¹‹å’Œ
        memo[x][y] = dp(x-1, y) + dp(x, y-1)
        return memo[x][y]
    }

    return dp(m-1, n-1)
}
```

```java
// by labuladong (java)
class Solution {
    // å¤‡å¿˜å½•
    int[][] memo;

    public int uniquePaths(int m, int n) {
        memo = new int[m][n];
        return dp(m - 1, n - 1);
    }

    // å®šä¹‰ï¼šä» (0, 0) åˆ° (x, y) æœ‰ dp(x, y) æ¡è·¯å¾„
    int dp(int x, int y) {
        // base case
        if (x == 0 && y == 0) {
            return 1;
        }
        if (x < 0 || y < 0) {
            return 0;
        }
        // é¿å…å†—ä½™è®¡ç®—
        if (memo[x][y] > 0) {
            return memo[x][y];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // åˆ°è¾¾ (x, y) çš„è·¯å¾„æ•°ç­‰äºåˆ°è¾¾ (x - 1, y) å’Œ (x, y - 1) è·¯å¾„æ•°ä¹‹å’Œ
        memo[x][y] = dp(x - 1, y) + dp(x, y - 1);
        return memo[x][y];
    }
}
```

```javascript
// by chatGPT (javascript)
var uniquePaths = function(m, n) {
    // å¤‡å¿˜å½•
    const memo = new Array(m).fill(0).map(() => new Array(n).fill(0));
    return dp(m - 1, n - 1);

    // å®šä¹‰ï¼šä» (0, 0) åˆ° (x, y) æœ‰ dp(x, y) æ¡è·¯å¾„
    function dp(x, y) {
        // base case
        if (x === 0 && y === 0) {
            return 1;
        }
        if (x < 0 || y < 0) {
            return 0;
        }
        // é¿å…å†—ä½™è®¡ç®—
        if (memo[x][y] > 0) {
            return memo[x][y];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // åˆ°è¾¾ (x, y) çš„è·¯å¾„æ•°ç­‰äºåˆ°è¾¾ (x - 1, y) å’Œ (x, y - 1) è·¯å¾„æ•°ä¹‹å’Œ
        memo[x][y] = dp(x - 1, y) + dp(x, y - 1);
        return memo[x][y];
    }
};
```

```python
# by chatGPT (python)
class Solution:
    # å¤‡å¿˜å½•
    memo = []

    def uniquePaths(self, m: int, n: int) -> int:
        self.memo = [[0] * n for _ in range(m)]
        return self.dp(m - 1, n - 1)

    # å®šä¹‰ï¼šä» (0, 0) åˆ° (x, y) æœ‰ dp(x, y) æ¡è·¯å¾„
    def dp(self, x: int, y: int) -> int:
        # base case
        if x == 0 and y == 0:
            return 1
        if x < 0 or y < 0:
            return 0
        # é¿å…å†—ä½™è®¡ç®—
        if self.memo[x][y] > 0:
            return self.memo[x][y]
        # çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        # åˆ°è¾¾ (x, y) çš„è·¯å¾„æ•°ç­‰äºåˆ°è¾¾ (x - 1, y) å’Œ (x, y - 1) è·¯å¾„æ•°ä¹‹å’Œ
        self.memo[x][y] = self.dp(x - 1, y) + self.dp(x, y - 1)
        return self.memo[x][y]
```

https://leetcode.cn/problems/unique-paths çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/univalued-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isUnivalTree(TreeNode* root) {
        if (root == nullptr) {
            return true;
        }
        prev = root->val;
        traverse(root);
        return isUnival;
    }

    int prev;
    bool isUnival = true;

    void traverse(TreeNode* root) {
        if (root == nullptr || !isUnival) {
            return;
        }
        if (root->val != prev) {
            isUnival = false;
            return;
        }
        traverse(root->left);
        traverse(root->right);
    }
};
```

```go
// by chatGPT (go)
func isUnivalTree(root *TreeNode) bool {
    var (
        prev int       // Closure to maintain previous node's value
        isUnival bool = true   // Closure to maintain result, whether tree is unival or not
    )

    var traverse func(root *TreeNode)
    traverse = func(root *TreeNode) {
        if root == nil || !isUnival {
            return
        }
        if root.Val != prev {
            isUnival = false
            return
        }
        traverse(root.Left)
        traverse(root.Right)
    }

    if root == nil {
        return true
    }
    prev = root.Val
    traverse(root)
    return isUnival
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isUnivalTree(TreeNode root) {
        if (root == null) {
            return true;
        }
        prev = root.val;
        traverse(root);
        return isUnival;
    }

    int prev;
    boolean isUnival = true;

    void traverse(TreeNode root) {
        if (root == null || !isUnival) {
            return;
        }
        if (root.val != prev) {
            isUnival = false;
            return;
        }
        traverse(root.left);
        traverse(root.right);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isUnivalTree = function(root) {
    if (root == null) {
        return true;
    }

    var prev = root.val;
    var isUnival = true;

    var traverse = function(root) {
        if (root == null || !isUnival) {
            return;
        }
        if (root.val != prev) {
            isUnival = false;
            return;
        }
        traverse(root.left);
        traverse(root.right);
    }

    traverse(root);
    return isUnival;
};
```

```python
# by chatGPT (python)
class Solution:
    def isUnivalTree(self, root: TreeNode) -> bool:
        if not root:
            return True
        self.prev = root.val
        self.isUnival = True
        self.traverse(root)
        return self.isUnival
    
    def traverse(self, root: TreeNode) -> None:
        if not root or not self.isUnival:
            return
        if root.val != self.prev:
            self.isUnival = False
            return
        self.traverse(root.left)
        self.traverse(root.right)
```

https://leetcode.cn/problems/univalued-binary-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/valid-anagram çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // åˆ¤æ–­å­—ç¬¦ä¸² s å’Œ t æ˜¯å¦ä¸ºå­—æ¯å¼‚ä½è¯
    bool isAnagram(string s, string t) {
        // ä½¿ç”¨ encode å‡½æ•°è®¡ç®—ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­å„å­—ç¬¦å‡ºç°çš„æ¬¡æ•°
        int[] count1 = encode(s);
        int[] count2 = encode(t);
        // åˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—ç¬¦å‡ºç°çš„æ•°é‡æ˜¯å¦ç›¸åŒ
        for (int i = 0; i < count1.length; i++) {
            if (count1[i] != count2[i]) {
                return false;
            }
        }
        return true;
    }

    // è®¡ç®—å­—ç¬¦ä¸²ä¸­å„å­—ç¬¦å‡ºç°çš„æ¬¡æ•°
    int[] encode(string s) {
        int[] count = new int[26];
        for (char c : s.toCharArray()) {
            int delta = c - 'a';
            count[delta]++;
        }
        return count;
    }
};
```

```go
// by chatGPT (go)
func isAnagram(s string, t string) bool {
    count1 := encode(s)
    count2 := encode(t)
    // ç¡®ä¿ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—ç¬¦å‡ºç°çš„æ•°é‡ç›¸åŒ
    for i := 0; i < len(count1); i++ {
        if count1[i] != count2[i] {
            return false
        }
    }
    return true
}

// è®¡ç®—å­—ç¬¦çš„å‡ºç°æ¬¡æ•°
func encode(s string) []int {
    count := make([]int, 26)
    for _, c := range s {
        delta := int(c - 'a')
        count[delta]++
    }
    return count
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] count1 = encode(s);
        int[] count2 = encode(t);
        // ç¡®ä¿ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—ç¬¦å‡ºç°çš„æ•°é‡ç›¸åŒ
        for (int i = 0; i < count1.length; i++) {
            if (count1[i] != count2[i]) {
                return false;
            }
        }

        return true;
    }

    // è®¡ç®—å­—ç¬¦çš„å‡ºç°æ¬¡æ•°
    int[] encode(String s) {
        int[] count = new int[26];
        for (char c : s.toCharArray()) {
            int delta = c - 'a';
            count[delta]++;
        }
        return count;
    }
}
```

```javascript
// by chatGPT (javascript)
var isAnagram = function(s, t) {
    var count1 = encode(s);
    var count2 = encode(t);
    // ç¡®ä¿ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—ç¬¦å‡ºç°çš„æ•°é‡ç›¸åŒ
    for (var i = 0; i < count1.length; i++) {
        if (count1[i] !== count2[i]) {
            return false;
        }
    }

    return true;
};

// è®¡ç®—å­—ç¬¦çš„å‡ºç°æ¬¡æ•°
var encode = function(s) {
    var count = new Array(26).fill(0);
    for (var i = 0; i < s.length; i++) {
        var delta = s.charCodeAt(i) - 'a'.charCodeAt(0);
        count[delta]++;
    }
    return count;
};
```

```python
# by chatGPT (python)
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        count1 = self.encode(s)
        count2 = self.encode(t)
        # ç¡®ä¿ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—ç¬¦å‡ºç°çš„æ•°é‡ç›¸åŒ
        for i in range(len(count1)):
            if count1[i] != count2[i]:
                return False

        return True

    # è®¡ç®—å­—ç¬¦çš„å‡ºç°æ¬¡æ•°
    def encode(self, s: str) -> List[int]:
        count = [0] * 26
        for c in s:
            delta = ord(c) - ord('a')
            count[delta] += 1
        return count
```

https://leetcode.cn/problems/valid-anagram çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/valid-palindrome çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isPalindrome(string s) {
        // å…ˆæŠŠæ‰€æœ‰å­—ç¬¦è½¬åŒ–æˆå°å†™ï¼Œå¹¶è¿‡æ»¤æ‰ç©ºæ ¼å’Œæ ‡ç‚¹è¿™ç±»å­—ç¬¦
        string nstr;
        for(int i=0;i<s.size();i++){
            char c = s[i];
            if(isalnum(c)){
                nstr += tolower(c);
            }
        }
        // ç„¶åå¯¹å‰©ä¸‹çš„è¿™äº›ç›®æ ‡å­—ç¬¦æ‰§è¡ŒåŒæŒ‡é’ˆç®—æ³•ï¼Œåˆ¤æ–­å›æ–‡ä¸²
        int left = 0, right = nstr.size() - 1;
        while(left<right){
            if(nstr[left]!=nstr[right]){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
};
```

```go
// by chatGPT (go)
func isPalindrome(s string) bool {
    // å…ˆæŠŠæ‰€æœ‰å­—ç¬¦è½¬åŒ–æˆå°å†™ï¼Œå¹¶è¿‡æ»¤æ‰ç©ºæ ¼å’Œæ ‡ç‚¹è¿™ç±»å­—ç¬¦
    var sb strings.Builder
    for i := 0; i < len(s); i++ {
        c := s[i]
        if unicode.IsLetter(c) || unicode.IsDigit(c) {
            sb.WriteRune(unicode.ToLower(rune(c)))
        }
    }

    // ç„¶åå¯¹å‰©ä¸‹çš„è¿™äº›ç›®æ ‡å­—ç¬¦æ‰§è¡ŒåŒæŒ‡é’ˆç®—æ³•ï¼Œåˆ¤æ–­å›æ–‡ä¸²
    s = sb.String()
    // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
    left, right := 0, len(s)-1
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isPalindrome(String s) {
        // å…ˆæŠŠæ‰€æœ‰å­—ç¬¦è½¬åŒ–æˆå°å†™ï¼Œå¹¶è¿‡æ»¤æ‰ç©ºæ ¼å’Œæ ‡ç‚¹è¿™ç±»å­—ç¬¦
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (Character.isLetterOrDigit(c)) {
                sb.append(Character.toLowerCase(c));
            }
        }

        // ç„¶åå¯¹å‰©ä¸‹çš„è¿™äº›ç›®æ ‡å­—ç¬¦æ‰§è¡ŒåŒæŒ‡é’ˆç®—æ³•ï¼Œåˆ¤æ–­å›æ–‡ä¸²
        s = sb.toString();
        // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
        int left = 0, right = s.length() - 1;
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

```javascript
// by chatGPT (javascript)
var isPalindrome = function(s) {
    // å…ˆæŠŠæ‰€æœ‰å­—ç¬¦è½¬åŒ–æˆå°å†™ï¼Œå¹¶è¿‡æ»¤æ‰ç©ºæ ¼å’Œæ ‡ç‚¹è¿™ç±»å­—ç¬¦
    let sb = "";
    for (let i = 0; i < s.length; i++) {
        let c = s.charAt(i);
        if (/[a-zA-Z0-9]/.test(c)) {
            sb += c.toLowerCase();
        }
    }

    // ç„¶åå¯¹å‰©ä¸‹çš„è¿™äº›ç›®æ ‡å­—ç¬¦æ‰§è¡ŒåŒæŒ‡é’ˆç®—æ³•ï¼Œåˆ¤æ–­å›æ–‡ä¸²
    s = sb;
    // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
    let left = 0;
    let right = s.length - 1;
    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
};
```

```python
# by chatGPT (python)
class Solution:
    def isPalindrome(self, s: str) -> bool:
        # å…ˆæŠŠæ‰€æœ‰å­—ç¬¦è½¬åŒ–æˆå°å†™ï¼Œå¹¶è¿‡æ»¤æ‰ç©ºæ ¼å’Œæ ‡ç‚¹è¿™ç±»å­—ç¬¦
        sb = []
        for c in s:
            if c.isalnum():
                sb.append(c.lower())

        # ç„¶åå¯¹å‰©ä¸‹çš„è¿™äº›ç›®æ ‡å­—ç¬¦æ‰§è¡ŒåŒæŒ‡é’ˆç®—æ³•ï¼Œåˆ¤æ–­å›æ–‡ä¸²
        s = "".join(sb)
        # ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
        left, right = 0, len(s) - 1
        while left < right:
            if s[left] != s[right]:
                return False
            left += 1
            right -= 1
        return True
```

https://leetcode.cn/problems/valid-palindrome çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/valid-parentheses çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isValid(string str) {
        stack<char> left;
        for (char c : str) {
            if (c == '(' || c == '{' || c == '[')
                left.push(c);
            else // å­—ç¬¦ c æ˜¯å³æ‹¬å·
                if (!left.empty() && leftOf(c) == left.top())
                    left.pop();
                else
                    // å’Œæœ€è¿‘çš„å·¦æ‹¬å·ä¸åŒ¹é…
                    return false;
        }
        // æ˜¯å¦æ‰€æœ‰çš„å·¦æ‹¬å·éƒ½è¢«åŒ¹é…äº†
        return left.empty();
    }

    char leftOf(char c) {
        if (c == '}') return '{';
        if (c == ')') return '(';
        return '[';
    }
};
```

```go
// by chatGPT (go)
// åŒ…åä¸º main
// å®šä¹‰ä¸€ä¸ªå­—èŠ‚æ•°ç»„æ ˆç±»å‹
type Stack []byte

// å…¥æ ˆæ“ä½œ
func (s *Stack) push(str byte) {
    *s = append(*s, str)
}

// å‡ºæ ˆæ“ä½œ
func (s *Stack) pop() byte {
    if len(*s) == 0 {
        return 0
    }
    res := (*s)[len(*s)-1]
    *s = (*s)[:len(*s)-1]
    return res
}

// åˆ¤æ–­ç»™å®šå­—ç¬¦ä¸²æ˜¯å¦æ˜¯åˆæ³•çš„æ‹¬å·åºåˆ—
func isValid(str string) bool {
    // å®šä¹‰ä¸€ä¸ªæ ˆ left ä¿å­˜å·¦æ‹¬å·
    var left Stack
    // éå†å­—ç¬¦
    for i := range str {
        c := str[i]
        // å½“ c æ˜¯å·¦æ‹¬å·æ—¶ï¼Œå…¥æ ˆ left
        if c == '(' || c == '[' || c == '{' {
            left.push(c)
        } else { // å½“ c æ˜¯å³æ‹¬å·æ—¶
            // å¦‚æœæ ˆ left éç©ºï¼Œä¸”æ ˆé¡¶çš„å·¦æ‹¬å·å’Œå½“å‰å³æ‹¬å·åŒ¹é…ï¼Œåˆ™å¼¹å‡ºæ ˆé¡¶å…ƒç´ 
            if len(left) != 0 && leftOf(c) == left.pop() {
                continue
            } else { // å½“å‰å·¦æ‹¬å·å’Œæœ€è¿‘çš„å·¦æ‹¬å·ä¸åŒ¹é…
                return false
            }
        }
    }
    // æ˜¯å¦æ‰€æœ‰çš„å·¦æ‹¬å·éƒ½è¢«åŒ¹é…äº†
    return len(left) == 0
}

// è¿”å›å·¦æ‹¬å·
func leftOf(c byte) byte {
    if c == '}' {
        return '{'
    } else if c == ')' {
        return '('
    } else {
        return '['
    }
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isValid(String str) {
        Stack<Character> left = new Stack<>();
        for (char c : str.toCharArray()) {
            if (c == '(' || c == '{' || c == '[')
                left.push(c);
            else // å­—ç¬¦ c æ˜¯å³æ‹¬å·
                if (!left.isEmpty() && leftOf(c) == left.peek())
                    left.pop();
                else
                    // å’Œæœ€è¿‘çš„å·¦æ‹¬å·ä¸åŒ¹é…
                    return false;
        }
        // æ˜¯å¦æ‰€æœ‰çš„å·¦æ‹¬å·éƒ½è¢«åŒ¹é…äº†
        return left.isEmpty();
    }

    char leftOf(char c) {
        if (c == '}') return '{';
        if (c == ')') return '(';
        return '[';
    }
}
```

```javascript
// by chatGPT (javascript)
var isValid = function(str) {
    // å»ºç«‹ä¸€ä¸ªæ ˆ
    let left = [];
    // éå†å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸€ä¸ªå­—ç¬¦
    for (let c of str) {
        // å¦‚æœæ˜¯å·¦æ‹¬å·ï¼Œåˆ™å…¥æ ˆ
        if (c == '(' || c == '{' || c == '[')
            left.push(c);
        else { // å­—ç¬¦ c æ˜¯å³æ‹¬å·
            // å¦‚æœæ ˆä¸ä¸ºç©ºï¼Œå¹¶ä¸”æœ€è¿‘å…¥æ ˆçš„å·¦æ‹¬å·å¯ä»¥åŒ¹é…ï¼Œåˆ™å‡ºæ ˆ
            if (left.length && leftOf(c) == left[left.length-1])
                left.pop();
            else
                // å’Œæœ€è¿‘çš„å·¦æ‹¬å·ä¸åŒ¹é…
                return false;
        }
    }
    // æ˜¯å¦æ‰€æœ‰çš„å·¦æ‹¬å·éƒ½è¢«åŒ¹é…äº†
    return !left.length;
}

function leftOf(c) {
    if (c == '}') return '{';
    if (c == ')') return '(';
    return '[';
}
```

```python
# by chatGPT (python)
class Solution:
    def isValid(self, s: str) -> bool:
        left = []  # ä½¿ç”¨æ ˆç»“æ„ï¼Œå­˜å‚¨æ‰€æœ‰å¾…åŒ¹é…çš„å·¦æ‹¬å·
        for c in s:
            if c == '(' or c == '{' or c == '[':
                left.append(c)  # å¦‚æœå­—ç¬¦ c æ˜¯å·¦æ‹¬å·ï¼Œåˆ™å°†å…¶åŠ å…¥å·¦æ‹¬å·æ ˆ left ä¸­
            else:
                if left and self.leftOf(c) == left[-1]:  # å¦‚æœå­—ç¬¦ c æ˜¯å³æ‹¬å·ï¼Œåˆ™æ¯”è¾ƒå®ƒä¸æœ€è¿‘ä¸€æ¬¡åŠ å…¥æ ˆ left ä¸­çš„å·¦æ‹¬å·æ˜¯å¦åŒ¹é…
                    left.pop()  # å¦‚æœåŒ¹é…ï¼Œåˆ™å°†æœ€è¿‘çš„å·¦æ‹¬å·å‡ºæ ˆï¼Œå¦åˆ™è¿”å› False
                else:
                    return False
        return not left  # æœ€ååˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœæ˜¯åˆ™è¯´æ˜æ‰€æœ‰çš„å·¦æ‹¬å·éƒ½è¢«åŒ¹é…äº†ï¼Œè¿”å› Trueï¼Œå¦åˆ™è¿”å› False

    def leftOf(self, c: str) -> str:
        if c == '}':
            return '{'
        elif c == ')':
            return '('
        else:
            return '['
```

https://leetcode.cn/problems/valid-parentheses çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/validate-binary-search-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        // é™å®šä»¥rootä¸ºæ ¹çš„å­æ ‘èŠ‚ç‚¹å¿…é¡»æ»¡è¶³max.val > root.val > min.val 
        return checkValidBST(root, nullptr, nullptr);
    }

    // é™å®šrootèŠ‚ç‚¹ç¬¦åˆminå’Œmaxçš„é™åˆ¶
    bool checkValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {
        // base case
        if (root == nullptr) return true;
        // è‹¥root.valä¸ç¬¦åˆmaxå’Œminçš„é™åˆ¶ï¼Œè¯´æ˜ä¸æ˜¯åˆæ³•BST
        if (minNode != nullptr && root->val <= minNode->val) return false;
        if (maxNode != nullptr && root->val >= maxNode->val) return false;
        // é™å®šå·¦å­æ ‘çš„æœ€å¤§å€¼æ˜¯root.valï¼Œå³å­æ ‘çš„æœ€å°å€¼æ˜¯root.val
        return checkValidBST(root->left, minNode, root)
            && checkValidBST(root->right, root, maxNode);
    }
};
```

```go
// by chatGPT (go)
func isValidBST(root *TreeNode) bool {
    return isValid(root, nil, nil)
}

/* é™å®šä»¥ root ä¸ºæ ¹çš„å­æ ‘èŠ‚ç‚¹å¿…é¡»æ»¡è¶³ max.val > root.val > min.val */
func isValid(root *TreeNode, min *TreeNode, max *TreeNode) bool {
    // base case
    if root == nil {
        return true
    }
    // è‹¥ root.val ä¸ç¬¦åˆ max å’Œ min çš„é™åˆ¶ï¼Œè¯´æ˜ä¸æ˜¯åˆæ³• BST
    if min != nil && root.Val <= min.Val {
        return false
    }
    if max != nil && root.Val >= max.Val {
        return false
    }
    // é™å®šå·¦å­æ ‘çš„æœ€å¤§å€¼æ˜¯ root.Valï¼Œå³å­æ ‘çš„æœ€å°å€¼æ˜¯ root.Val
    return isValid(root.Left, min, root) && isValid(root.Right, root, max)
}
```

```java
// by labuladong (java)
class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, null, null);
    }

    /* é™å®šä»¥ root ä¸ºæ ¹çš„å­æ ‘èŠ‚ç‚¹å¿…é¡»æ»¡è¶³ max.val > root.val > min.val */
    boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
        // base case
        if (root == null) return true;
        // è‹¥ root.val ä¸ç¬¦åˆ max å’Œ min çš„é™åˆ¶ï¼Œè¯´æ˜ä¸æ˜¯åˆæ³• BST
        if (min != null && root.val <= min.val) return false;
        if (max != null && root.val >= max.val) return false;
        // é™å®šå·¦å­æ ‘çš„æœ€å¤§å€¼æ˜¯ root.valï¼Œå³å­æ ‘çš„æœ€å°å€¼æ˜¯ root.val
        return isValidBST(root.left, min, root)
                && isValidBST(root.right, root, max);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
    return helper(root, null, null);
};

/**
 * é™å®šä»¥ root ä¸ºæ ¹çš„å­æ ‘èŠ‚ç‚¹å¿…é¡»æ»¡è¶³ max.val > root.val > min.val 
 * @param {TreeNode} root
 * @param {TreeNode} min
 * @param {TreeNode} max
 * @return {boolean}
 */
var helper = function(root, min, max) {
    // base case
    if (root == null) return true;
    // è‹¥ root.val ä¸ç¬¦åˆ max å’Œ min çš„é™åˆ¶ï¼Œè¯´æ˜ä¸æ˜¯åˆæ³• BST
    if (min != null && root.val <= min.val) return false;
    if (max != null && root.val >= max.val) return false;
    // é™å®šå·¦å­æ ‘çš„æœ€å¤§å€¼æ˜¯root.valï¼Œå³å­æ ‘çš„æœ€å°å€¼æ˜¯root.val
    return helper(root.left, min, root) && helper(root.right, root, max);
};
```

```python
# by chatGPT (python)
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        return self.helper(root, None, None)
    
    # é™å®šä»¥ root ä¸ºæ ¹çš„å­æ ‘èŠ‚ç‚¹å¿…é¡»æ»¡è¶³ max.val > root.val > min.val
    def helper(self, root, min_node, max_node):
        # base case
        if not root:
            return True
        # è‹¥ root.val ä¸ç¬¦åˆ max å’Œ min çš„é™åˆ¶ï¼Œè¯´æ˜ä¸æ˜¯åˆæ³• BST
        if min_node and root.val <= min_node.val:
            return False
        if max_node and root.val >= max_node.val:
            return False
        # é™å®šå·¦å­æ ‘çš„æœ€å¤§å€¼æ˜¯ root.valï¼Œå³å­æ ‘çš„æœ€å°å€¼æ˜¯ root.val
        return self.helper(root.left, min_node, root) and self.helper(root.right, root, max_node)
```

https://leetcode.cn/problems/validate-binary-search-tree çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/video-stitching çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int videoStitching(vector<vector<int>>& clips, int T) {
        if (T == 0) return 0;
        //æŒ‰èµ·ç‚¹å‡åºæ’åˆ—ï¼Œèµ·ç‚¹ç›¸åŒçš„é™åºæ’åˆ—
        //PSï¼šå…¶å®èµ·ç‚¹ç›¸åŒçš„ä¸ç”¨é™åºæ’åˆ—ä¹Ÿå¯ä»¥ï¼Œä¸è¿‡æˆ‘è§‰å¾—è¿™æ ·æ›´æ¸…æ™°
        sort(clips.begin(), clips.end(), [](vector<int>& a, vector<int>& b){
            if (a[0] == b[0]) {
                return b[1] < a[1];
            }
            return a[0] < b[0];
        });
        //è®°å½•é€‰æ‹©çš„çŸ­è§†é¢‘ä¸ªæ•°
        int res = 0;

        int curEnd = 0, nextEnd = 0;
        int i = 0, n = clips.size();
        while (i < n && clips[i][0] <= curEnd) {
            //åœ¨ç¬¬resä¸ªè§†é¢‘çš„åŒºé—´å†…è´ªå¿ƒé€‰æ‹©ä¸‹ä¸€ä¸ªè§†é¢‘
            while (i < n && clips[i][0] <= curEnd) {
                nextEnd = max(nextEnd, clips[i][1]);
                i++;
            }
            //æ‰¾åˆ°ä¸‹ä¸€ä¸ªè§†é¢‘ï¼Œæ›´æ–°curEnd
            res++;
            curEnd = nextEnd;
            if (curEnd >= T) {
                //å·²ç»å¯ä»¥æ‹¼å‡ºåŒºé—´ [0, T]
                return res;
            }
        }
        //æ— æ³•è¿ç»­æ‹¼å‡ºåŒºé—´ [0, T]
        return -1;
    }
};
```

```go
// by chatGPT (go)
import "sort"

func videoStitching(clips [][]int, T int) int {
	if T == 0 {
		return 0
	}
	// æŒ‰èµ·ç‚¹å‡åºæ’åˆ—ï¼Œèµ·ç‚¹ç›¸åŒçš„é™åºæ’åˆ—
	// PSï¼šå…¶å®èµ·ç‚¹ç›¸åŒçš„ä¸ç”¨é™åºæ’åˆ—ä¹Ÿå¯ä»¥ï¼Œä¸è¿‡æˆ‘è§‰å¾—è¿™æ ·æ›´æ¸…æ™°
	sort.Slice(clips, func(i, j int) bool {
		a, b := clips[i], clips[j]
		if a[0] == b[0] {
			return b[1] < a[1]
		}
		return a[0] < b[0]
	})
	// è®°å½•é€‰æ‹©çš„çŸ­è§†é¢‘ä¸ªæ•°
	var res int

	curEnd, nextEnd := 0, 0
	i, n := 0, len(clips)
	for i < n && clips[i][0] <= curEnd {
		// åœ¨ç¬¬ res ä¸ªè§†é¢‘çš„åŒºé—´å†…è´ªå¿ƒé€‰æ‹©ä¸‹ä¸€ä¸ªè§†é¢‘
		for i < n && clips[i][0] <= curEnd {
			nextEnd = max(nextEnd, clips[i][1])
			i++
		}
		// æ‰¾åˆ°ä¸‹ä¸€ä¸ªè§†é¢‘ï¼Œæ›´æ–° curEnd
		res++
		curEnd = nextEnd
		if curEnd >= T {
			// å·²ç»å¯ä»¥æ‹¼å‡ºåŒºé—´ [0, T]
			return res
		}
	}
	// æ— æ³•è¿ç»­æ‹¼å‡ºåŒºé—´ [0, T]
	return -1
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

```java
// by labuladong (java)
class Solution {
    public int videoStitching(int[][] clips, int T) {
        if (T == 0) return 0;
        // æŒ‰èµ·ç‚¹å‡åºæ’åˆ—ï¼Œèµ·ç‚¹ç›¸åŒçš„é™åºæ’åˆ—
        // PSï¼šå…¶å®èµ·ç‚¹ç›¸åŒçš„ä¸ç”¨é™åºæ’åˆ—ä¹Ÿå¯ä»¥ï¼Œä¸è¿‡æˆ‘è§‰å¾—è¿™æ ·æ›´æ¸…æ™°
        Arrays.sort(clips, (a, b) -> {
            if (a[0] == b[0]) {
                return b[1] - a[1];
            }
            return a[0] - b[0];
        });
        // è®°å½•é€‰æ‹©çš„çŸ­è§†é¢‘ä¸ªæ•°
        int res = 0;

        int curEnd = 0, nextEnd = 0;
        int i = 0, n = clips.length;
        while (i < n && clips[i][0] <= curEnd) {
            // åœ¨ç¬¬ res ä¸ªè§†é¢‘çš„åŒºé—´å†…è´ªå¿ƒé€‰æ‹©ä¸‹ä¸€ä¸ªè§†é¢‘
            while (i < n && clips[i][0] <= curEnd) {
                nextEnd = Math.max(nextEnd, clips[i][1]);
                i++;
            }
            // æ‰¾åˆ°ä¸‹ä¸€ä¸ªè§†é¢‘ï¼Œæ›´æ–° curEnd
            res++;
            curEnd = nextEnd;
            if (curEnd >= T) {
                // å·²ç»å¯ä»¥æ‹¼å‡ºåŒºé—´ [0, T]
                return res;
            }
        }
        // æ— æ³•è¿ç»­æ‹¼å‡ºåŒºé—´ [0, T]
        return -1;
    }
}
```

```javascript
// by chatGPT (javascript)
var videoStitching = function(clips, T) {
    if (T == 0) return 0;
    // æŒ‰èµ·ç‚¹å‡åºæ’åˆ—ï¼Œèµ·ç‚¹ç›¸åŒçš„é™åºæ’åˆ—
    // PSï¼šå…¶å®èµ·ç‚¹ç›¸åŒçš„ä¸ç”¨é™åºæ’åˆ—ä¹Ÿå¯ä»¥ï¼Œä¸è¿‡æˆ‘è§‰å¾—è¿™æ ·æ›´æ¸…æ™°
    clips.sort((a, b) => {
        if (a[0] == b[0]) {
            return b[1] - a[1];
        }
        return a[0] - b[0];
    });
    // è®°å½•é€‰æ‹©çš„çŸ­è§†é¢‘ä¸ªæ•°
    var res = 0;

    var curEnd = 0, nextEnd = 0;
    var i = 0, n = clips.length;
    while (i < n && clips[i][0] <= curEnd) {
        // åœ¨ç¬¬ res ä¸ªè§†é¢‘çš„åŒºé—´å†…è´ªå¿ƒé€‰æ‹©ä¸‹ä¸€ä¸ªè§†é¢‘
        while (i < n && clips[i][0] <= curEnd) {
            nextEnd = Math.max(nextEnd, clips[i][1]);
            i++;
        }
        // æ‰¾åˆ°ä¸‹ä¸€ä¸ªè§†é¢‘ï¼Œæ›´æ–° curEnd
        res++;
        curEnd = nextEnd;
        if (curEnd >= T) {
            // å·²ç»å¯ä»¥æ‹¼å‡ºåŒºé—´ [0, T]
            return res;
        }
    }
    // æ— æ³•è¿ç»­æ‹¼å‡ºåŒºé—´ [0, T]
    return -1;
};
```

```python
# by chatGPT (python)
class Solution:
    def videoStitching(self, clips: List[List[int]], T: int) -> int:
        if T == 0:
            return 0
        # æŒ‰èµ·ç‚¹å‡åºæ’åˆ—ï¼Œèµ·ç‚¹ç›¸åŒçš„é™åºæ’åˆ—
        # PSï¼šå…¶å®èµ·ç‚¹ç›¸åŒçš„ä¸ç”¨é™åºæ’åˆ—ä¹Ÿå¯ä»¥ï¼Œä¸è¿‡æˆ‘è§‰å¾—è¿™æ ·æ›´æ¸…æ™°
        clips.sort(key=lambda x: (x[0], -x[1]))
        # è®°å½•é€‰æ‹©çš„çŸ­è§†é¢‘ä¸ªæ•°
        res = 0
        curEnd, nextEnd = 0, 0
        i, n = 0, len(clips)
        while i < n and clips[i][0] <= curEnd:
            # åœ¨ç¬¬ res ä¸ªè§†é¢‘çš„åŒºé—´å†…è´ªå¿ƒé€‰æ‹©ä¸‹ä¸€ä¸ªè§†é¢‘
            while i < n and clips[i][0] <= curEnd:
                nextEnd = max(nextEnd, clips[i][1])
                i += 1
            # æ‰¾åˆ°ä¸‹ä¸€ä¸ªè§†é¢‘ï¼Œæ›´æ–° curEnd
            res += 1
            curEnd = nextEnd
            if curEnd >= T:
                # å·²ç»å¯ä»¥æ‹¼å‡ºåŒºé—´ [0, T]
                return res
        # æ— æ³•è¿ç»­æ‹¼å‡ºåŒºé—´ [0, T]
        return -1
```

https://leetcode.cn/problems/video-stitching çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/vvXgSW çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
// Definition for singly-linked list.
// struct ListNode {
//     int val;
//     ListNode *next;
//     ListNode(int x) : val(x), next(NULL) {}
// };

// Definition for singly-linked list.
// struct ListNode {
//     int val;
//     ListNode *next;
//     ListNode(int x) : val(x), next(NULL) {}
// };

// Definition for singly-linked list.
// struct ListNode {
//     int val;
//     ListNode *next;
//     ListNode(int x) : val(x), next(NULL) {}
// };

// Definition for singly-linked list.
// struct ListNode {
//     int val;
//     ListNode *next;
//     ListNode(int x) : val(x), next(NULL) {}
// };

// Definition for singly-linked list.
// struct ListNode {
//     int val;
//     ListNode *next;
//     ListNode(int x) : val(x), next(NULL) {}
// };

// Definition for singly-linked list.
// struct ListNode {
//     int val;
//     ListNode *next;
//     ListNode(int x) : val(x), next(NULL) {}
// };

// Definition for singly-linked list.
// struct ListNode {
//     int val;
//     ListNode *next;
//     ListNode(int x) : val(x), next(NULL) {}
// };

// Definition for singly-linked list.
// struct ListNode {
//     int val;
//     ListNode *next;
//     ListNode(int x) : val(x), next(NULL) {}
// };

// Definition for singly-linked list.
// struct ListNode {
//     int val;
//     ListNode *next;
//     ListNode(int x) : val(x), next(NULL) {}
// };

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.size() == 0) { return nullptr; }
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy;
        // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å †
        auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);

        // å°† k ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥æœ€å°å †
        for (auto head : lists) {
            if (head != nullptr)
                pq.push(head);
        }

        while (!pq.empty()) {
            // è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­
            ListNode* node = pq.top();
            p->next = node;
            pq.pop();
            if (node->next != nullptr) {
                pq.push(node->next);
            }
            // p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p->next;
        }
        return dummy->next;
    }
};
```

```go
// by chatGPT (go)
func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }

    // è™šæ‹Ÿå¤´ç»“ç‚¹
    dummy := &ListNode{}
    p := dummy

    // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å †
    pq := make(PriorityQueue, 0)
    for _, head := range lists {
        if head != nil {
            pq.Push(head)
        }
    }

    for !pq.IsEmpty() {
        // è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­
        node := pq.Pop().(*ListNode)
        p.Next = node
        if node.Next != nil {
            pq.Push(node.Next)
        }
        // p æŒ‡é’ˆä¸æ–­å‰è¿›
        p = p.Next
    }
    return dummy.Next
}

// ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å †
type PriorityQueue []*ListNode

func (pq PriorityQueue) Len() int { return len(pq) }

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i].Val < pq[j].Val
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    *pq = append(*pq, x.(*ListNode))
}

func (pq *PriorityQueue) Pop() interface{} {
    n := len(*pq)
    x := (*pq)[n-1]
    *pq = (*pq)[:n-1]
    return x
}

func (pq PriorityQueue) IsEmpty() bool {
    return len(pq) == 0
}
```

```java
// by labuladong (java)
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å †
        PriorityQueue<ListNode> pq = new PriorityQueue<>(
            lists.length, (a, b)->(a.val - b.val));
        // å°† k ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥æœ€å°å †
        for (ListNode head : lists) {
            if (head != null)
                pq.add(head);
        }

        while (!pq.isEmpty()) {
            // è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­
            ListNode node = pq.poll();
            p.next = node;
            if (node.next != null) {
                pq.add(node.next);
            }
            // p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p.next;
        }
        return dummy.next;
    }
}
```

```javascript
// by chatGPT (javascript)
var mergeKLists = function(lists) {
    if (lists.length == 0) return null;
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    var dummy = new ListNode(-1);
    var p = dummy;
    // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å †
    var pq = new PriorityQueue(
        lists.length, (a, b) => (a.val - b.val));
    // å°† k ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥æœ€å°å †
    for (var head of lists) {
        if (head != null)
            pq.add(head);
    }

    while (!pq.isEmpty()) {
        // è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­
        var node = pq.poll();
        p.next = node;
        if (node.next != null) {
            pq.add(node.next);
        }
        // p æŒ‡é’ˆä¸æ–­å‰è¿›
        p = p.next;
    }
    return dummy.next;
}
```

```python
# by chatGPT (python)
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists:
            return None
        # è™šæ‹Ÿå¤´ç»“ç‚¹
        dummy = ListNode(-1)
        p = dummy
        # ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å †
        pq = []
        for head in lists:
            if head:
                # å°† k ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥æœ€å°å †
                heapq.heappush(pq, (head.val, head))
        while pq:
            # è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­
            val, node = heapq.heappop(pq)
            p.next = node
            if node.next:
                heapq.heappush(pq, (node.next.val, node.next))
            # p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p.next
        return dummy.next
```

https://leetcode.cn/problems/vvXgSW çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/w6cpku çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // è®°å½•ç´¯åŠ å’Œ
    int sum = 0;
    TreeNode* convertBST(TreeNode* root) {
        traverse(root);
        return root;
    }

    // éå†å³å­æ ‘ -> ç»´æŠ¤ç´¯åŠ å’Œ -> è½¬æ¢ä¸ºç´¯åŠ æ ‘ -> éå†å·¦å­æ ‘
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        traverse(root->right); // éå†å³å­æ ‘
        sum += root->val; // ç»´æŠ¤ç´¯åŠ å’Œ
        root->val = sum; // å°†BSTè½¬æ¢ä¸ºç´¯åŠ æ ‘
        traverse(root->left); // éå†å·¦å­æ ‘
    }
};
```

```go
// by chatGPT (go)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func convertBST(root *TreeNode) *TreeNode {
    var sum int 
    var traverse func(*TreeNode)
    //è®°å½•ç´¯åŠ å’Œ
    traverse = func(root *TreeNode) {
        if root == nil {
            return
        }
        traverse(root.Right)
        //ç»´æŠ¤ç´¯åŠ å’Œ
        sum += root.Val
        //å°†BSTè½¬åŒ–æˆç´¯åŠ æ ‘
        root.Val = sum
        traverse(root.Left)
    }
    traverse(root)
    return root
}
```

```java
// by labuladong (java)
class Solution {
    public TreeNode convertBST(TreeNode root) {
        traverse(root);
        return root;
    }

    // è®°å½•ç´¯åŠ å’Œ
    int sum = 0;
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        traverse(root.right);
        // ç»´æŠ¤ç´¯åŠ å’Œ
        sum += root.val;
        // å°† BST è½¬åŒ–æˆç´¯åŠ æ ‘
        root.val = sum;
        traverse(root.left);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var convertBST = function(root) {
    // è®°å½•ç´¯åŠ å’Œ
    let sum = 0;
    function traverse(root) {
        if (root === null) {
            return;
        }
        traverse(root.right);
        // ç»´æŠ¤ç´¯åŠ å’Œ
        sum += root.val;
        // å°† BST è½¬åŒ–æˆç´¯åŠ æ ‘
        root.val = sum;
        traverse(root.left);
    }

    traverse(root);
    return root;
}
```

```python
# by chatGPT (python)
class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        self.sum = 0 #è®°å½•ç´¯åŠ å’Œ
        self.traverse(root)
        return root
    
    def traverse(self, root: TreeNode) -> None:
        if not root:
            return
        self.traverse(root.right)
        self.sum += root.val #ç»´æŠ¤ç´¯åŠ å’Œ
        root.val = self.sum #å°† BST è½¬åŒ–æˆç´¯åŠ æ ‘
        self.traverse(root.left)
```

https://leetcode.cn/problems/w6cpku çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/walls-and-gates çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    void wallsAndGates(vector<vector<int>>& rooms) {
        const int ROOM = INT_MAX;
        const int GATE = 0;

        int m = rooms.size();
        int n = rooms[0].size();

        queue<pair<int, int>> q;
        // æŠŠæ‰€æœ‰çš„é—¨æ”¾å…¥é˜Ÿåˆ—ï¼Œä½œä¸º BFS éå†çš„èµ·ç‚¹
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (rooms[i][j] == GATE) {
                    q.push({i, j});
                }
            }
        }

        vector<vector<int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        // å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•ï¼Œæ ¹æ® BFS ç®—æ³•çš„ç‰¹æ€§ï¼Œç¬¬ä¸€æ¬¡éå†åˆ°æ–°èŠ‚ç‚¹æ‰€èµ°çš„æ­¥æ•°å°±æ˜¯æœ€çŸ­è·ç¦»
        while (!q.empty()) {
            auto cur = q.front();
            q.pop();
            int x = cur.first, y = cur.second;
            for (auto d : dirs) {
                int next_x = x + d[0], next_y = y + d[1];
                if (next_x < 0 || next_y < 0 || next_x >= m || next_y >= n
                        || rooms[next_x][next_y] != ROOM) {
                    // è¿™ä¸ªä½ç½®æ˜¯éšœç¢ç‰©æˆ–è€…å·²ç»è®¡ç®—å‡ºæœ€çŸ­è·ç¦»äº†ï¼Œè·³è¿‡
                    continue;
                }
                // è®¡ç®—å‡º (next_x, next_y) è¾¾åˆ°æœ€è¿‘çš„é—¨çš„è·ç¦»
                rooms[next_x][next_y] = rooms[x][y] + 1;
                q.push({next_x, next_y});
            }
        }
    }
};
```

```go
// by chatGPT (go)
func wallsAndGates(rooms [][]int) {
    const ROOM, GATE = math.MaxInt32, 0

    m, n := len(rooms), len(rooms[0])

    q := [][]int{}
    // æŠŠæ‰€æœ‰çš„é—¨æ”¾å…¥é˜Ÿåˆ—ï¼Œä½œä¸º BFS éå†çš„èµ·ç‚¹
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if rooms[i][j] == GATE {
                q = append(q, []int{i, j})
            }
        }
    }

    dirs := [][]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}
    // å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•ï¼Œæ ¹æ® BFS ç®—æ³•çš„ç‰¹æ€§ï¼Œç¬¬ä¸€æ¬¡éå†åˆ°æ–°èŠ‚ç‚¹æ‰€èµ°çš„æ­¥æ•°å°±æ˜¯æœ€çŸ­è·ç¦»
    for len(q) > 0 {
        cur := q[0]
        q = q[1:]
        x, y := cur[0], cur[1]
        for _, d := range dirs {
            next_x, next_y := x+d[0], y+d[1]
            if next_x < 0 || next_y < 0 || next_x >= m || next_y >= n || rooms[next_x][next_y] != ROOM {
                // è¿™ä¸ªä½ç½®æ˜¯éšœç¢ç‰©æˆ–è€…å·²ç»è®¡ç®—å‡ºæœ€çŸ­è·ç¦»äº†ï¼Œè·³è¿‡
                continue
            }
            // è®¡ç®—å‡º (next_x, next_y) è¾¾åˆ°æœ€è¿‘çš„é—¨çš„è·ç¦»
            rooms[next_x][next_y] = rooms[x][y] + 1
            q = append(q, []int{next_x, next_y})
        }
    }
}
```

```java
// by labuladong (java)
class Solution {

    public void wallsAndGates(int[][] rooms) {
        final int ROOM = Integer.MAX_VALUE;
        final int GATE = 0;

        int m = rooms.length;
        int n = rooms[0].length;

        Queue<int[]> q = new LinkedList<>();
        // æŠŠæ‰€æœ‰çš„é—¨æ”¾å…¥é˜Ÿåˆ—ï¼Œä½œä¸º BFS éå†çš„èµ·ç‚¹
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (rooms[i][j] == GATE) {
                    q.add(new int[]{i, j});
                }
            }
        }

        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        // å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•ï¼Œæ ¹æ® BFS ç®—æ³•çš„ç‰¹æ€§ï¼Œç¬¬ä¸€æ¬¡éå†åˆ°æ–°èŠ‚ç‚¹æ‰€èµ°çš„æ­¥æ•°å°±æ˜¯æœ€çŸ­è·ç¦»
        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int x = cur[0], y = cur[1];
            for (int[] d : dirs) {
                int next_x = x + d[0], next_y = y + d[1];
                if (next_x < 0 || next_y < 0 || next_x >= m || next_y >= n
                        || rooms[next_x][next_y] != ROOM) {
                    // è¿™ä¸ªä½ç½®æ˜¯éšœç¢ç‰©æˆ–è€…å·²ç»è®¡ç®—å‡ºæœ€çŸ­è·ç¦»äº†ï¼Œè·³è¿‡
                    continue;
                }
                // è®¡ç®—å‡º (next_x, next_y) è¾¾åˆ°æœ€è¿‘çš„é—¨çš„è·ç¦»
                rooms[next_x][next_y] = rooms[x][y] + 1;
                q.offer(new int[]{next_x, next_y});
            }
        }
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[][]} rooms
 * @return {void} Do not return anything, modify rooms in-place instead.
 */

var wallsAndGates = function(rooms) {
  const ROOM = Infinity;
  const GATE = 0;

  let m = rooms.length;
  let n = rooms[0].length;

  let q = [];
  // æŠŠæ‰€æœ‰çš„é—¨æ”¾å…¥é˜Ÿåˆ—ï¼Œä½œä¸º BFS éå†çš„èµ·ç‚¹
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (rooms[i][j] === GATE) {
        q.push([i, j]);
      }
    }
  }

  let dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
  // å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•ï¼Œæ ¹æ® BFS ç®—æ³•çš„ç‰¹æ€§ï¼Œç¬¬ä¸€æ¬¡éå†åˆ°æ–°èŠ‚ç‚¹æ‰€èµ°çš„æ­¥æ•°å°±æ˜¯æœ€çŸ­è·ç¦»
  while (q.length) {
    let cur = q.shift();
    let x = cur[0], y = cur[1];

    for (let i = 0; i < dirs.length; i++) {
      let next_x = x + dirs[i][0], next_y = y + dirs[i][1];
      if (next_x < 0 || next_y < 0 || next_x >= m || next_y >= n || rooms[next_x][next_y] !== ROOM) {
        // è¿™ä¸ªä½ç½®æ˜¯éšœç¢ç‰©æˆ–è€…å·²ç»è®¡ç®—å‡ºæœ€çŸ­è·ç¦»äº†ï¼Œè·³è¿‡
        continue;
      }
      // è®¡ç®—å‡º (next_x, next_y) è¾¾åˆ°æœ€è¿‘çš„é—¨çš„è·ç¦»
      rooms[next_x][next_y] = rooms[x][y] + 1;
      q.push([next_x, next_y]);
    }
  }
};
```

```python
# by chatGPT (python)
from collections import deque

class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        """
        Do not return anything, modify rooms in-place instead.
        """
        ROOM = float('inf')
        GATE = 0
        
        m = len(rooms)
        n = len(rooms[0])
        
        q = deque()
        # æŠŠæ‰€æœ‰çš„é—¨æ”¾å…¥é˜Ÿåˆ—ï¼Œä½œä¸º BFS éå†çš„èµ·ç‚¹
        for i in range(m):
            for j in range(n):
                if rooms[i][j] == GATE:
                    q.append([i, j])
        
        dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
        # å¼€å§‹æ‰§è¡Œ BFS ç®—æ³•ï¼Œæ ¹æ® BFS ç®—æ³•çš„ç‰¹æ€§ï¼Œç¬¬ä¸€æ¬¡éå†åˆ°æ–°èŠ‚ç‚¹æ‰€èµ°çš„æ­¥æ•°å°±æ˜¯æœ€çŸ­è·ç¦»
        while q:
            cur = q.popleft()
            x = cur[0]
            y = cur[1]
            for d in dirs:
                next_x = x + d[0]
                next_y = y + d[1]
                if next_x < 0 or next_y < 0 or next_x >= m or next_y >= n or rooms[next_x][next_y] != ROOM:
                    # è¿™ä¸ªä½ç½®æ˜¯éšœç¢ç‰©æˆ–è€…å·²ç»è®¡ç®—å‡ºæœ€çŸ­è·ç¦»äº†ï¼Œè·³è¿‡
                    continue
                # è®¡ç®—å‡º (next_x, next_y) è¾¾åˆ°æœ€è¿‘çš„é—¨çš„è·ç¦»
                rooms[next_x][next_y] = rooms[x][y] + 1
                q.append([next_x, next_y])
```

https://leetcode.cn/problems/walls-and-gates çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/wildcard-matching çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    // å¤‡å¿˜å½•ï¼Œ-1 ä»£è¡¨è¿˜æœªè®¡ç®—ï¼Œ0 ä»£è¡¨ falseï¼Œ1 ä»£è¡¨ true
    vector<vector<int>> memo;

    bool isMatch(string s, string p) {
        if (p.empty()) {
            return s.empty();
        }
        // å°† p ä¸­ç›¸é‚»çš„ * å»é™¤ï¼Œä»¥æå‡æ•ˆç‡
        string pp = remove_adj_star(p);
        int m = s.size(), n = pp.size();
        // å¤‡å¿˜å½•åˆå§‹åŒ–ä¸º -1
        memo = vector<vector<int>>(m, vector<int>(n, -1));
        // æ‰§è¡Œè‡ªé¡¶å‘ä¸‹å¸¦å¤‡å¿˜å½•çš„åŠ¨æ€è§„åˆ’
        return dp(s, 0, pp, 0);
    }

    // åˆ é™¤ç›¸é‚»çš„ * å·ï¼Œè¿”å›åˆ é™¤åçš„å­—ç¬¦
    string remove_adj_star(string p) {
        if (p.empty()) {
            return "";
        }
        string pp;
        pp.push_back(p[0]);
        for (int i = 1; i < p.size(); i++) {
            if (p[i] == '*' && p[i - 1] == '*') {
                continue;
            }
            pp.push_back(p[i]);
        }
        return pp;
    }

    // å®šä¹‰ï¼šåˆ¤æ–­ s[i..] æ˜¯å¦èƒ½è¢« p[j..] åŒ¹é…
    bool dp(string& s, int i, string& p, int j) {
        // base case
        if (j == p.size() && i == s.size()) {
            return true;
        }
        if (i == s.size()) {
            for (int k = j; k < p.size(); k++) {
                if (p[k] != '*') {
                    return false;
                }
            }
            return true;
        }
        if (j == p.size()) {
            return false;
        }
        if (memo[i][j] != -1) {
            return bool(memo[i][j]);
        }

        bool res = false;
        if (s[i] == p[j] || p[j] == '?') {
            // s[i] å’Œ p[j] å®ŒæˆåŒ¹é…
            res = dp(s, i + 1, p, j + 1);
        } else if (p[j] == '*') {
            // s[i] å’Œ p[j] ä¸åŒ¹é…ï¼Œä½† p[j] æ˜¯é€šé…ç¬¦ *
            // å¯ä»¥åŒ¹é… 0 ä¸ªæˆ–å¤šä¸ª s ä¸­çš„å­—ç¬¦ï¼Œ
            // åªè¦æœ‰ä¸€ç§æƒ…å†µèƒ½å¤Ÿå®ŒæˆåŒ¹é…å³å¯
            res = dp(s, i + 1, p, j)
                    || dp(s, i, p, j + 1);
        }
        // å°† s[i] å’Œ p[j] çš„åŒ¹é…ç»“æœå­˜å‚¨å¤‡å¿˜å½•
        memo[i][j] = res;

        return res;
    }
};
```

```go
// by chatGPT (go)
func isMatch(s string, p string) bool {
    // å¤‡å¿˜å½•ï¼Œ-1 ä»£è¡¨è¿˜æœªè®¡ç®—ï¼Œ0 ä»£è¡¨ falseï¼Œ1 ä»£è¡¨ true
    memo := make([][]int, len(s))
    for i := range memo {
        memo[i] = make([]int, len(p))
        for j := range memo[i] {
            memo[i][j] = -1
        }
    }

    if len(p) == 0 {
        return len(s) == 0
    }
    // å°† p ä¸­ç›¸é‚»çš„ * å»é™¤ï¼Œä»¥æå‡æ•ˆç‡
    pp := removeAdjStar(p)

    return dp(s, 0, pp, 0, memo)
}

// åˆ é™¤ç›¸é‚»çš„ * å·ï¼Œè¿”å›åˆ é™¤åçš„å­—ç¬¦
func removeAdjStar(p string) string {
    if len(p) == 0 {
        return ""
    }
    pp := []byte{p[0]}
    for i := 1; i < len(p); i++ {
        if p[i] == '*' && p[i-1] == '*' {
            continue
        }
        pp = append(pp, p[i])
    }
    return string(pp)
}

// å®šä¹‰ï¼šåˆ¤æ–­ s[i..] æ˜¯å¦èƒ½è¢« p[j..] åŒ¹é…
func dp(s string, i int, p string, j int, memo [][]int) bool {
    // base case
    if j == len(p) && i == len(s) {
        return true
    }
    if i == len(s) {
        for k := j; k < len(p); k++ {
            if p[k] != '*' {
                return false
            }
        }
        return true
    }
    if j == len(p) {
        return false
    }
    if memo[i][j] != -1 {
        return memo[i][j] == 1
    }

    var res bool
    if s[i] == p[j] || p[j] == '?' {
        // s[i] å’Œ p[j] å®ŒæˆåŒ¹é…
        res = dp(s, i+1, p, j+1, memo)
    } else if p[j] == '*' {
        // s[i] å’Œ p[j] ä¸åŒ¹é…ï¼Œä½† p[j] æ˜¯é€šé…ç¬¦ *
        // å¯ä»¥åŒ¹é… 0 ä¸ªæˆ–å¤šä¸ª s ä¸­çš„å­—ç¬¦ï¼Œ
        // åªè¦æœ‰ä¸€ç§æƒ…å†µèƒ½å¤Ÿå®ŒæˆåŒ¹é…å³å¯
        res = dp(s, i+1, p, j, memo) || dp(s, i, p, j+1, memo)
    }
    // å°† s[i] å’Œ p[j] çš„åŒ¹é…ç»“æœå­˜å‚¨å¤‡å¿˜å½•
    memo[i][j] = 0
    if res {
        memo[i][j] = 1
    }

    return res
}
```

```java
// by chatGPT (java)
class Solution {
    // å¤‡å¿˜å½•ï¼Œ-1 ä»£è¡¨è¿˜æœªè®¡ç®—ï¼Œ0 ä»£è¡¨ falseï¼Œ1 ä»£è¡¨ true
    private int[][] memo;

    public boolean isMatch(String s, String p) {
        if (p.isEmpty()) {
            return s.isEmpty();
        }
        // å°† p ä¸­ç›¸é‚»çš„ * å»é™¤ï¼Œä»¥æå‡æ•ˆç‡
        String pp = removeAdjStar(p);
        int m = s.length(), n = pp.length();
        // å¤‡å¿˜å½•åˆå§‹åŒ–ä¸º -1
        memo = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(memo[i], -1);
        }
        // æ‰§è¡Œè‡ªé¡¶å‘ä¸‹å¸¦å¤‡å¿˜å½•çš„åŠ¨æ€è§„åˆ’
        return dp(s, 0, pp, 0);
    }

    // åˆ é™¤ç›¸é‚»çš„ * å·ï¼Œè¿”å›åˆ é™¤åçš„å­—ç¬¦
    private String removeAdjStar(String p) {
        if (p.isEmpty()) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        sb.append(p.charAt(0));
        for (int i = 1; i < p.length(); i++) {
            if (p.charAt(i) == '*' && p.charAt(i - 1) == '*') {
                continue;
            }
            sb.append(p.charAt(i));
        }
        return sb.toString();
    }

    // å®šä¹‰ï¼šåˆ¤æ–­ s[i..] æ˜¯å¦èƒ½è¢« p[j..] åŒ¹é…
    private boolean dp(String s, int i, String p, int j) {
        // base case
        if (j == p.length() && i == s.length()) {
            return true;
        }
        if (i == s.length()) {
            for (int k = j; k < p.length(); k++) {
                if (p.charAt(k) != '*') {
                    return false;
                }
            }
            return true;
        }
        if (j == p.length()) {
            return false;
        }
        if (memo[i][j] != -1) {
            return memo[i][j] == 1;
        }

        boolean res = false;
        if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?') {
            // s[i] å’Œ p[j] å®ŒæˆåŒ¹é…
            res = dp(s, i + 1, p, j + 1);
        } else if (p.charAt(j) == '*') {
            // s[i] å’Œ p[j] ä¸åŒ¹é…ï¼Œä½† p[j] æ˜¯é€šé…ç¬¦ *
            // å¯ä»¥åŒ¹é… 0 ä¸ªæˆ–å¤šä¸ª s ä¸­çš„å­—ç¬¦ï¼Œ
            // åªè¦æœ‰ä¸€ç§æƒ…å†µèƒ½å¤Ÿå®ŒæˆåŒ¹é…å³å¯
            res = dp(s, i + 1, p, j)
                    || dp(s, i, p, j + 1);
        }
        // å°† s[i] å’Œ p[j] çš„åŒ¹é…ç»“æœå­˜å‚¨å¤‡å¿˜å½•
        memo[i][j] = res ? 1 : 0;

        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var isMatch = function(s, p) {
    // å¤‡å¿˜å½•ï¼Œ-1 ä»£è¡¨è¿˜æœªè®¡ç®—ï¼Œ0 ä»£è¡¨ falseï¼Œ1 ä»£è¡¨ true
    var memo = [];

    function remove_adj_star(p) {
        if (p.length === 0) {
            return "";
        }
        var pp = p[0];
        for (var i = 1; i < p.length; i++) {
            if (p[i] === '*' && p[i - 1] == '*') {
                continue;
            }
            pp += p[i];
        }
        return pp;
    }

    // å®šä¹‰ï¼šåˆ¤æ–­ s[i..] æ˜¯å¦èƒ½è¢« p[j..] åŒ¹é…
    function dp(s, i, p, j) {
        // base case
        if (j === p.length && i === s.length) {
            return true;
        }
        if (i === s.length) {
            for (var k = j; k < p.length; k++) {
                if (p[k] !== '*') {
                    return false;
                }
            }
            return true;
        }
        if (j === p.length) {
            return false;
        }
        if (typeof memo[i] !== "undefined" && typeof memo[i][j] !== "undefined" && memo[i][j] !== -1) {
            return memo[i][j] === 1;
        }

        var res = false;
        if (s[i] === p[j] || p[j] === '?') {
            // s[i] å’Œ p[j] å®ŒæˆåŒ¹é…
            res = dp(s, i + 1, p, j + 1);
        } else if (p[j] === '*') {
            // s[i] å’Œ p[j] ä¸åŒ¹é…ï¼Œä½† p[j] æ˜¯é€šé…ç¬¦ *
            // å¯ä»¥åŒ¹é… 0 ä¸ªæˆ–å¤šä¸ª s ä¸­çš„å­—ç¬¦ï¼Œ
            // åªè¦æœ‰ä¸€ç§æƒ…å†µèƒ½å¤Ÿå®ŒæˆåŒ¹é…å³å¯
            res = dp(s, i + 1, p, j) || dp(s, i, p, j + 1);
        }
        // å°† s[i] å’Œ p[j] çš„åŒ¹é…ç»“æœå­˜å‚¨å¤‡å¿˜å½•
        if (typeof memo[i] === "undefined") {
            memo[i] = [];
        }
        memo[i][j] = res ? 1 : 0;

        return res;
    }

    // å°† p ä¸­ç›¸é‚»çš„ * å»é™¤ï¼Œä»¥æå‡æ•ˆç‡
    var pp = remove_adj_star(p);
    var m = s.length, n = pp.length;
    // å¤‡å¿˜å½•åˆå§‹åŒ–ä¸º -1
    for (var i = 0; i < m; i++) {
        memo[i] = [];
        for (var j = 0; j < n; j++) {
            memo[i][j] = -1;
        }
    }
    // æ‰§è¡Œè‡ªé¡¶å‘ä¸‹å¸¦å¤‡å¿˜å½•çš„åŠ¨æ€è§„åˆ’
    return dp(s, 0, pp, 0);
};
```

```python
# by chatGPT (python)
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        if not p:
            return not s
        # å°† p ä¸­ç›¸é‚»çš„ * å»é™¤ï¼Œä»¥æå‡æ•ˆç‡
        pp = self.remove_adj_star(p)
        m, n = len(s), len(pp)
        # å¤‡å¿˜å½•åˆå§‹åŒ–ä¸º -1
        memo = [[-1] * n for _ in range(m)]
        # æ‰§è¡Œè‡ªé¡¶å‘ä¸‹å¸¦å¤‡å¿˜å½•çš„åŠ¨æ€è§„åˆ’
        return self.dp(s, 0, pp, 0, memo)

    # åˆ é™¤ç›¸é‚»çš„ * å·ï¼Œè¿”å›åˆ é™¤åçš„å­—ç¬¦
    def remove_adj_star(self, p: str) -> str:
        if not p:
            return ""
        pp = p[0]
        for i in range(1, len(p)):
            if p[i] == '*' and p[i - 1] == '*':
                continue
            pp += p[i]
        return pp

    # å®šä¹‰ï¼šåˆ¤æ–­ s[i..] æ˜¯å¦èƒ½è¢« p[j..] åŒ¹é…
    def dp(self, s: str, i: int, p: str, j: int, memo: List[List[int]]) -> bool:
        # base case
        if j == len(p) and i == len(s):
            return True
        if i == len(s):
            for k in range(j, len(p)):
                if p[k] != '*':
                    return False
            return True
        if j == len(p):
            return False
        if memo[i][j] != -1:
            return bool(memo[i][j])

        res = False
        if s[i] == p[j] or p[j] == '?':
            # s[i] å’Œ p[j] å®ŒæˆåŒ¹é…
            res = self.dp(s, i + 1, p, j + 1, memo)
        elif p[j] == '*':
            # s[i] å’Œ p[j] ä¸åŒ¹é…ï¼Œä½† p[j] æ˜¯é€šé…ç¬¦ *
            # å¯ä»¥åŒ¹é… 0 ä¸ªæˆ–å¤šä¸ª s ä¸­çš„å­—ç¬¦ï¼Œ
            # åªè¦æœ‰ä¸€ç§æƒ…å†µèƒ½å¤Ÿå®ŒæˆåŒ¹é…å³å¯
            res = self.dp(s, i + 1, p, j, memo) or self.dp(s, i, p, j + 1, memo)
        # å°† s[i] å’Œ p[j] çš„åŒ¹é…ç»“æœå­˜å‚¨å¤‡å¿˜å½•
        memo[i][j] = res

        return res
```

https://leetcode.cn/problems/wildcard-matching çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/word-break-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<string> res;
    // è®°å½•å›æº¯è·¯å¾„
    deque<string> track;

    vector<string> wordBreak(string s, vector<string>& wordDict) {
        // æ ¹æ®å‡½æ•°å®šä¹‰ï¼Œåˆ¤æ–­ s[0..] æ˜¯å¦èƒ½å¤Ÿè¢«æ‹¼å‡º
        backtrack(s, 0, wordDict);
        return res;
    }

    // å›æº¯ç®—æ³•æ¡†æ¶
    void backtrack(string s, int i, vector<string>& wordDict) {
        // base caseï¼Œæ•´ä¸ª s éƒ½è¢«æ‹¼å‡ºæ¥äº†
        if (i == s.length()) {
            res.emplace_back(track[0]);
            for (int j = 1; j < track.size(); ++j) {
                res.back() += " " + track[j];
            }
            return;
        }
        if (i > s.length()) {
            return;
        }

        // éå†æ‰€æœ‰å•è¯ï¼Œå°è¯•åŒ¹é… s[i..] çš„å‰ç¼€
        for (const string& word : wordDict) {
            int len = word.length();
            // å•è¯å¤ªé•¿ï¼Œè·³è¿‡
            if (i + len > s.length()) {
                continue;
            }
            // æ— æ³•åŒ¹é…ï¼Œè·³è¿‡
            string subStr = s.substr(i, len);
            if (subStr != word) {
                continue;
            }
            // s[i..] çš„å‰ç¼€è¢« word åŒ¹é…ï¼Œåšé€‰æ‹©
            track.emplace_back(word);
            backtrack(s, i + len, wordDict);
            // æ’¤é”€é€‰æ‹©
            track.pop_back();
        }
    }
};
```

```go
// by chatGPT (go)
func wordBreak(s string, wordDict []string) []string {
    res := []string{}
    // è®°å½•å›æº¯è·¯å¾„
    track := []string{}
    // æ ¹æ®å‡½æ•°å®šä¹‰ï¼Œåˆ¤æ–­ s[0..] æ˜¯å¦èƒ½å¤Ÿè¢«æ‹¼å‡º
    backtrack(s, 0, wordDict, &track, &res)
    return res
}

// å›æº¯ç®—æ³•æ¡†æ¶
func backtrack(s string, i int, wordDict []string, track *[]string, res *[]string) {
    // base caseï¼Œæ•´ä¸ª s éƒ½è¢«æ‹¼å‡ºæ¥äº†
    if i == len(s) {
        *res = append(*res, strings.Join(*track, " "))
        return
    }
    if i > len(s) {
        return
    }

    // éå†æ‰€æœ‰å•è¯ï¼Œå°è¯•åŒ¹é… s[i..] çš„å‰ç¼€
    for _, word := range(wordDict) {
        len := len(word)
        // å•è¯å¤ªé•¿ï¼Œè·³è¿‡
        if i + len > len(s) {
            continue
        }
        // æ— æ³•åŒ¹é…ï¼Œè·³è¿‡
        subStr := s[i:i+len]
        if subStr != word {
            continue
        }
        // s[i..] çš„å‰ç¼€è¢« word åŒ¹é…ï¼Œåšé€‰æ‹©
        *track = append(*track, word)
        backtrack(s, i + len, wordDict, track, res)
        // æ’¤é”€é€‰æ‹©
        *track = (*track)[:len(*track)-1]
    }
}
```

```java
// by labuladong (java)
class Solution {

    List<String> res = new LinkedList<>();
    // è®°å½•å›æº¯è·¯å¾„
    LinkedList<String> track = new LinkedList<>();

    public List<String> wordBreak(String s, List<String> wordDict) {
        // æ ¹æ®å‡½æ•°å®šä¹‰ï¼Œåˆ¤æ–­ s[0..] æ˜¯å¦èƒ½å¤Ÿè¢«æ‹¼å‡º
        backtrack(s, 0, wordDict);
        return res;
    }

    // å›æº¯ç®—æ³•æ¡†æ¶
    void backtrack(String s, int i, List<String> wordDict) {
        // base caseï¼Œæ•´ä¸ª s éƒ½è¢«æ‹¼å‡ºæ¥äº†
        if (i == s.length()) {
            res.add(String.join(" ", track));
            return;
        }
        if (i > s.length()) {
            return;
        }

        // éå†æ‰€æœ‰å•è¯ï¼Œå°è¯•åŒ¹é… s[i..] çš„å‰ç¼€
        for (String word : wordDict) {
            int len = word.length();
            // å•è¯å¤ªé•¿ï¼Œè·³è¿‡
            if (i + len > s.length()) {
                continue;
            }
            // æ— æ³•åŒ¹é…ï¼Œè·³è¿‡
            String subStr = s.substring(i, i + len);
            if (!subStr.equals(word)) {
                continue;
            }
            // s[i..] çš„å‰ç¼€è¢« word åŒ¹é…ï¼Œåšé€‰æ‹©
            track.addLast(word);
            backtrack(s, i + len, wordDict);
            // æ’¤é”€é€‰æ‹©
            track.removeLast();
        }
    }
}
```

```javascript
// by chatGPT (javascript)
var wordBreak = function(s, wordDict) {
  let res = [];  // è®°å½•ç»“æœ
  let track = []; // è®°å½•å›æº¯è·¯å¾„

  // å›æº¯ç®—æ³•æ¡†æ¶
  function backtrack(s, i, wordDict) {
    // base caseï¼Œæ•´ä¸ª s éƒ½è¢«æ‹¼å‡ºæ¥äº†
    if (i === s.length) {
      res.push(track.join(" "));
      return;
    }
    if (i > s.length) {
      return;
    }

    // éå†æ‰€æœ‰å•è¯ï¼Œå°è¯•åŒ¹é… s[i..] çš„å‰ç¼€
    for (let word of wordDict) {
      let len = word.length;
      // å•è¯å¤ªé•¿ï¼Œè·³è¿‡
      if (i + len > s.length) {
        continue;
      }
      // æ— æ³•åŒ¹é…ï¼Œè·³è¿‡
      let subStr = s.substring(i, i + len);
      if (subStr !== word) {
        continue;
      }
      // s[i..] çš„å‰ç¼€è¢« word åŒ¹é…ï¼Œåšé€‰æ‹©
      track.push(word);
      backtrack(s, i + len, wordDict);
      // æ’¤é”€é€‰æ‹©
      track.pop();
    }
  }

  backtrack(s, 0, wordDict);
  return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.res = []
        # è®°å½•å›æº¯è·¯å¾„
        self.track = []

    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        # æ ¹æ®å‡½æ•°å®šä¹‰ï¼Œåˆ¤æ–­ s[0..] æ˜¯å¦èƒ½å¤Ÿè¢«æ‹¼å‡º
        self.backtrack(s, 0, wordDict)
        return self.res

    # å›æº¯ç®—æ³•æ¡†æ¶
    def backtrack(self, s: str, i: int, wordDict: List[str]) -> None:
        # base caseï¼Œæ•´ä¸ª s éƒ½è¢«æ‹¼å‡ºæ¥äº†
        if i == len(s):
            self.res.append(" ".join(self.track))
            return
        if i > len(s):
            return

        # éå†æ‰€æœ‰å•è¯ï¼Œå°è¯•åŒ¹é… s[i..] çš„å‰ç¼€
        for word in wordDict:
            length = len(word)
            # å•è¯å¤ªé•¿ï¼Œè·³è¿‡
            if i + length > len(s):
                continue
            # æ— æ³•åŒ¹é…ï¼Œè·³è¿‡
            sub_str = s[i:i + length]
            if sub_str != word:
                continue
            # s[i..] çš„å‰ç¼€è¢« word åŒ¹é…ï¼Œåšé€‰æ‹©
            self.track.append(word)
            self.backtrack(s, i + length, wordDict)
            # æ’¤é”€é€‰æ‹©
            self.track.pop()
```

https://leetcode.cn/problems/word-break-ii çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/word-pattern çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        vector<string> words;
        string sub_s = "";

        //å°†å•è¯å­˜å…¥vectorä¸­
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == ' ') {
                words.push_back(sub_s);
                sub_s = "";
            } else {
                sub_s += s[i];
            }
        }
        words.push_back(sub_s);
        if (pattern.size() != words.size()) {
            return false;
        }

        //è®°å½•patternå­—ç¬¦åˆ°å•è¯çš„æ˜ å°„
        unordered_map<char, string> patternToWord;
        //è®°å½•å“ªäº›å·²ç»æœ‰patternå¯¹åº”çš„å•è¯
        unordered_set<string> wordSet;

        for (int i = 0; i < pattern.size(); i++) {
            char c = pattern[i];
            string word = words[i];
            if (!patternToWord.count(c)) {
                if (wordSet.count(word)) {
                    //è¿™ä¸ªå•è¯ä»¥å‰å·²ç»æœ‰å…¶ä»–æ¨¡å¼å­—ç¬¦å¯¹åº”äº†
                    return false;
                }
                //æ·»åŠ c->wordçš„æ˜ å°„
                patternToWord[c] = word;
            } else {
                //è¿™ä¸ªpatternå­—ç¬¦å·²ç»å‡ºç°è¿‡ï¼Œç¡®ä¿å’Œä¹‹å‰å¯¹åº”çš„å•è¯ç›¸åŒ
                if (patternToWord[c] != word) {
                    return false;
                }
            }
            //è¿™ä¸ªå•è¯å·²ç»æœ‰æ¨¡å¼å­—ç¬¦å¯¹åº”
            wordSet.insert(word);

        }
        return true;
    }
};

class Solution2 {
public:
    bool wordPattern(string pattern, string s) {
        vector<string> words;
        string sub_s = "";

        //å°†å•è¯å­˜å…¥vectorä¸­
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == ' ') {
                words.push_back(sub_s);
                sub_s = "";
            } else {
                sub_s += s[i];
            }
        }
        words.push_back(sub_s);
        if (pattern.size() != words.size()) {
            return false;
        }

        //è®°å½•patternå­—ç¬¦åˆ°å•è¯çš„æ˜ å°„
        unordered_map<string, char> wordToPattern;
        unordered_set<char> patternCharSet;

        for (int i = 0; i < pattern.size(); i++) {
            char c = pattern[i];
            string word = words[i];
            if (!wordToPattern.count(word)) {
                //å½“å‰è¿™ä¸ªå•è¯è¿˜æ²¡æœ‰å¯¹åº”çš„æ¨¡å¼å­—ç¬¦
                if (patternCharSet.count(c)) {
                    //å¯¹åº”çš„æ¨¡å¼å­—ç¬¦ä¹‹å‰å·²ç»å¯¹åº”äº†å…¶ä»–å•è¯
                    return false;
                }
                //æ·»åŠ word->cçš„æ˜ å°„
                wordToPattern[word] = c;
            }
            else {
                //è¿™ä¸ªå•è¯ä¹‹å‰å·²ç»å‡ºç°è¿‡ï¼Œç¡®ä¿å½“å‰å•è¯å’Œä¹‹å‰å¯¹åº”çš„æ¨¡å¼å­—ç¬¦ç›¸åŒ
                if (wordToPattern[word] != c) {
                    return false;
                }
            }
            patternCharSet.insert(c);
        }
        return true;
    }
};
```

```go
// by chatGPT (go)
func wordPattern(pattern string, s string) bool {
    words := strings.Split(s, " ")
    if len(pattern) != len(words) {
        return false
    }
    // è®°å½• pattern å­—ç¬¦åˆ°å•è¯çš„æ˜ å°„
    patternToWord := make(map[byte]string)
    // è®°å½•é‚£äº›å·²ç»æœ‰ pattern å¯¹åº”çš„å•è¯
    wordSet := make(map[string]bool)

    for i := 0; i < len(pattern); i++ {
        c := pattern[i]
        word := words[i]
        if _, ok := patternToWord[c]; !ok {
            if _, ok := wordSet[word]; ok {
                // è¿™ä¸ªå•è¯ä»¥å‰å·²ç»æœ‰å…¶ä»–æ¨¡å¼å­—ç¬¦å¯¹åº”äº†
                return false
            }
            // æ·»åŠ  c -> word çš„æ˜ å°„
            patternToWord[c] = word
        } else {
            // è¿™ä¸ª pattern å­—ç¬¦å·²ç»å‡ºç°è¿‡ï¼Œç¡®ä¿å’Œä¹‹å‰å¯¹åº”çš„å•è¯ç›¸åŒ
            if patternToWord[c] != word {
                return false
            }
        }
        // è¿™ä¸ªå•è¯å·²ç»æœ‰æ¨¡å¼å­—ç¬¦å¯¹åº”
        wordSet[word] = true
    }
    return true
}


func wordPattern2(pattern string, s string) bool {
    words := strings.Split(s, " ")
    if len(pattern) != len(words) {
        return false
    }
    // è®°å½• word åˆ° pattern å­—ç¬¦çš„æ˜ å°„
    wordToPattern := make(map[string]byte)
    // è®°å½•é‚£äº›å·²ç»æœ‰å•è¯å¯¹åº”çš„ pattern å­—ç¬¦
    patternCharSet := make(map[byte]bool)

    for i := 0; i < len(pattern); i++ {
        c := pattern[i]
        word := words[i]
        if _, ok := wordToPattern[word]; !ok {
            // å½“å‰è¿™ä¸ªå•è¯è¿˜æ²¡æœ‰å¯¹åº”çš„æ¨¡å¼å­—ç¬¦
            if _, ok := patternCharSet[c]; ok {
                // å¯¹åº”çš„æ¨¡å¼å­—ç¬¦ä¹‹å‰å·²ç»å¯¹åº”äº†å…¶ä»–å•è¯
                return false
            }
            // æ·»åŠ  word -> c çš„æ˜ å°„
            wordToPattern[word] = c
        } else {
            // è¿™ä¸ªå•è¯ä¹‹å‰å·²ç»å‡ºç°è¿‡ï¼Œç¡®ä¿å½“å‰å•è¯å’Œä¹‹å‰å¯¹åº”çš„æ¨¡å¼å­—ç¬¦ç›¸åŒ
            if wordToPattern[word] != c {
                return false
            }
        }
        patternCharSet[c] = true
    }
    return true
}
```

```java
// by labuladong (java)
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] words = s.split(" ");
        if (pattern.length() != words.length) {
            return false;
        }
        // è®°å½• pattern å­—ç¬¦åˆ°å•è¯çš„æ˜ å°„
        HashMap<Character, String> patternToWord = new HashMap<>();
        // è®°å½•é‚£äº›å·²ç»æœ‰ pattern å¯¹åº”çš„å•è¯
        HashSet<String> wordSet = new HashSet<>();

        for (int i = 0; i < pattern.length(); i++) {
            char c = pattern.charAt(i);
            String word = words[i];
            if (!patternToWord.containsKey(c)) {
                if (wordSet.contains(word)) {
                    // è¿™ä¸ªå•è¯ä»¥å‰å·²ç»æœ‰å…¶ä»–æ¨¡å¼å­—ç¬¦å¯¹åº”äº†
                    return false;
                }
                // æ·»åŠ  c -> word çš„æ˜ å°„
                patternToWord.put(c, word);
            } else {
                // è¿™ä¸ª pattern å­—ç¬¦å·²ç»å‡ºç°è¿‡ï¼Œç¡®ä¿å’Œä¹‹å‰å¯¹åº”çš„å•è¯ç›¸åŒ
                if (!patternToWord.get(c).equals(word)) {
                    return false;
                }
            }
            // è¿™ä¸ªå•è¯å·²ç»æœ‰æ¨¡å¼å­—ç¬¦å¯¹åº”
            wordSet.add(word);
        }
        return true;
    }
}



class Solution2 {
    public boolean wordPattern(String pattern, String s) {
        String[] words = s.split(" ");
        if (pattern.length() != words.length) {
            return false;
        }
        // è®°å½• pattern å­—ç¬¦åˆ°å•è¯çš„æ˜ å°„
        HashMap<String, Character> wordToPattern = new HashMap<>();
        HashSet<Character> patternCharSet = new HashSet<>();

        for (int i = 0; i < pattern.length(); i++) {
            char c = pattern.charAt(i);
            String word = words[i];
            if (!wordToPattern.containsKey(word)) {
                // å½“å‰è¿™ä¸ªå•è¯è¿˜æ²¡æœ‰å¯¹åº”çš„æ¨¡å¼å­—ç¬¦
                if (patternCharSet.contains(c)) {
                    // å¯¹åº”çš„æ¨¡å¼å­—ç¬¦ä¹‹å‰å·²ç»å¯¹åº”äº†å…¶ä»–å•è¯
                    return false;
                }
                // æ·»åŠ  word -> c çš„æ˜ å°„
                wordToPattern.put(word, c);
            } else {
                // è¿™ä¸ªå•è¯ä¹‹å‰å·²ç»å‡ºç°è¿‡ï¼Œç¡®ä¿å½“å‰å•è¯å’Œä¹‹å‰å¯¹åº”çš„æ¨¡å¼å­—ç¬¦ç›¸åŒ
                if (!wordToPattern.get(word).equals(c)) {
                    return false;
                }
            }
            patternCharSet.add(c);
        }
        return true;
    }
}
```

```javascript
// by chatGPT (javascript)
var wordPattern = function(pattern, s) {
    var words = s.split(" ");
    if (pattern.length !== words.length) {
        return false;
    }
    // è®°å½• pattern å­—ç¬¦åˆ°å•è¯çš„æ˜ å°„
    var patternToWord = new Map();
    // è®°å½•é‚£äº›å·²ç»æœ‰ pattern å¯¹åº”çš„å•è¯
    var wordSet = new Set();

    for (var i = 0; i < pattern.length; i++) {
        var c = pattern.charAt(i);
        var word = words[i];
        if (!patternToWord.has(c)) {
            if (wordSet.has(word)) {
                // è¿™ä¸ªå•è¯ä»¥å‰å·²ç»æœ‰å…¶ä»–æ¨¡å¼å­—ç¬¦å¯¹åº”äº†
                return false;
            }
            // æ·»åŠ  c -> word çš„æ˜ å°„
            patternToWord.set(c, word);
        } else {
            // è¿™ä¸ª pattern å­—ç¬¦å·²ç»å‡ºç°è¿‡ï¼Œç¡®ä¿å’Œä¹‹å‰å¯¹åº”çš„å•è¯ç›¸åŒ
            if (!patternToWord.get(c) === (word)) {
                return false;
            }
        }
        // è¿™ä¸ªå•è¯å·²ç»æœ‰æ¨¡å¼å­—ç¬¦å¯¹åº”
        wordSet.add(word);
    }
    return true;
};


var wordPattern2 = function(pattern, s) {
    var words = s.split(" ");
    if (pattern.length !== words.length) {
        return false;
    }
    // è®°å½• pattern å­—ç¬¦åˆ°å•è¯çš„æ˜ å°„
    var wordToPattern = new Map();
    var patternCharSet = new Set();

    for (var i = 0; i < pattern.length; i++) {
        var c = pattern.charAt(i);
        var word = words[i];
        if (!wordToPattern.has(word)) {
            // å½“å‰è¿™ä¸ªå•è¯è¿˜æ²¡æœ‰å¯¹åº”çš„æ¨¡å¼å­—ç¬¦
            if (patternCharSet.has(c)) {
                // å¯¹åº”çš„æ¨¡å¼å­—ç¬¦ä¹‹å‰å·²ç»å¯¹åº”äº†å…¶ä»–å•è¯
                return false;
            }
            // æ·»åŠ  word -> c çš„æ˜ å°„
            wordToPattern.set(word, c);
        } else {
            // è¿™ä¸ªå•è¯ä¹‹å‰å·²ç»å‡ºç°è¿‡ï¼Œç¡®ä¿å½“å‰å•è¯å’Œä¹‹å‰å¯¹åº”çš„æ¨¡å¼å­—ç¬¦ç›¸åŒ
            if (!wordToPattern.get(word) === c) {
                return false;
            }
        }
        patternCharSet.add(c);
    }
    return true;
};
```

```python
# by chatGPT (python)
class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        words = s.split(" ")
        if len(pattern) != len(words):
            return False
        #è®°å½• pattern å­—ç¬¦åˆ°å•è¯çš„æ˜ å°„
        patternToWord = {}
        #è®°å½•é‚£äº›å·²ç»æœ‰ pattern å¯¹åº”çš„å•è¯
        wordSet = set()

        for i in range(len(pattern)):
            c = pattern[i]
            word = words[i]
            if c not in patternToWord:
                if word in wordSet:
                    #è¿™ä¸ªå•è¯ä»¥å‰å·²ç»æœ‰å…¶ä»–æ¨¡å¼å­—ç¬¦å¯¹åº”äº†
                    return False
                #æ·»åŠ  c -> word çš„æ˜ å°„
                patternToWord[c] = word
            else:
                #è¿™ä¸ª pattern å­—ç¬¦å·²ç»å‡ºç°è¿‡ï¼Œç¡®ä¿å’Œä¹‹å‰å¯¹åº”çš„å•è¯ç›¸åŒ
                if patternToWord[c] != word:
                    return False
            #è¿™ä¸ªå•è¯å·²ç»æœ‰æ¨¡å¼å­—ç¬¦å¯¹åº”
            wordSet.add(word)
        return True
        

class Solution2:
    def wordPattern(self, pattern: str, s: str) -> bool:
        words = s.split(" ")
        if len(pattern) != len(words):
            return False
        #è®°å½• pattern å­—ç¬¦åˆ°å•è¯çš„æ˜ å°„
        wordToPattern = {}
        patternCharSet = set()

        for i in range(len(pattern)):
            c = pattern[i]
            word = words[i]
            if word not in wordToPattern:
                #å½“å‰è¿™ä¸ªå•è¯è¿˜æ²¡æœ‰å¯¹åº”çš„æ¨¡å¼å­—ç¬¦
                if c in patternCharSet:
                    #å¯¹åº”çš„æ¨¡å¼å­—ç¬¦ä¹‹å‰å·²ç»å¯¹åº”äº†å…¶ä»–å•è¯
                    return False
                #æ·»åŠ  word -> c çš„æ˜ å°„
                wordToPattern[word] = c
            else:
                #è¿™ä¸ªå•è¯ä¹‹å‰å·²ç»å‡ºç°è¿‡ï¼Œç¡®ä¿å½“å‰å•è¯å’Œä¹‹å‰å¯¹åº”çš„æ¨¡å¼å­—ç¬¦ç›¸åŒ
                if wordToPattern[word] != c:
                    return False
            patternCharSet.add(c)
        return True
```

https://leetcode.cn/problems/word-pattern çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/word-search çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
    bool found = false;
public:
    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size(), n = board[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dfs(board, i, j, word, 0);
                if (found) {  // å¦‚æœæ‰¾åˆ°äº†ä¸€ä¸ªç­”æ¡ˆï¼Œç›´æ¥è¿”å›true
                    return true;
                }
            }
        }
        return false;  // æ²¡æœ‰æ‰¾åˆ°ç­”æ¡ˆï¼Œè¿”å›false
    }

    // ä» (i, j) å¼€å§‹å‘å››å‘¨æœç´¢ï¼Œè¯•å›¾åŒ¹é… word[p..]
    void dfs(vector<vector<char>>& board, int i, int j, string& word, int p) {
        if (p == word.size()) {  // æ•´ä¸ªwordå·²ç»è¢«åŒ¹é…å®Œï¼Œæ‰¾åˆ°äº†ä¸€ä¸ªç­”æ¡ˆ
            found = true;
            return;
        }
        if (found) {  // å·²ç»æ‰¾åˆ°äº†ä¸€ä¸ªç­”æ¡ˆï¼Œä¸ç”¨å†æœç´¢äº†
            return;
        }
        int m = board.size(), n = board[0].size();
        if (i < 0 || j < 0 || i >= m || j >= n) {  // åœ¨è¾¹ç•Œä¹‹å¤–ï¼Œè¿”å›
            return;
        }
        if (board[i][j] != word[p]) {  // ä¸å½“å‰å­—ç¬¦ä¸åŒ¹é…ï¼Œè¿”å›
            return;
        }

        // å› ä¸ºä¹‹å‰åŒ¹é…çš„å­—ç¬¦ä¸èƒ½é‡å¤åŒ¹é…ï¼Œæ‰€ä»¥æˆ‘ä»¬ç»™å®ƒä»¬æ·»åŠ ä¸€ä¸ªè´Ÿå·æ ‡è®°
        board[i][j] = (char)(-board[i][j]);
        dfs(board, i + 1, j, word, p + 1);  // å‘ä¸‹æœç´¢
        dfs(board, i, j + 1, word, p + 1);  // å‘å³æœç´¢
        dfs(board, i - 1, j, word, p + 1);  // å‘ä¸Šæœç´¢
        dfs(board, i, j - 1, word, p + 1);  // å‘å·¦æœç´¢
        board[i][j] = (char)(-board[i][j]);  // å›æº¯å½“å‰å­—ç¬¦
    }
};
```

```go
// by chatGPT (go)
func exist(board [][]byte, word string) bool {
    m, n := len(board), len(board[0])
    found := false
    var dfs func(i, j, p int)
    dfs = func(i, j, p int) {
        if p == len(word) {
            // æ•´ä¸ª word å·²ç»è¢«åŒ¹é…å®Œï¼Œæ‰¾åˆ°äº†ä¸€ä¸ªç­”æ¡ˆ
            found = true
            return
        }
        if found {
            // å·²ç»æ‰¾åˆ°äº†ä¸€ä¸ªç­”æ¡ˆï¼Œä¸ç”¨å†æœç´¢äº†
            return
        }
        if i < 0 || j < 0 || i >= m || j >= n {
            return
        }
        if board[i][j] != word[p] {
            return
        }

        // å·²ç»åŒ¹é…è¿‡çš„å­—ç¬¦ï¼Œæˆ‘ä»¬ç»™å®ƒæ·»ä¸€ä¸ªè´Ÿå·ä½œä¸ºæ ‡è®°ï¼Œé¿å…èµ°å›å¤´è·¯
        board[i][j] ^= 255
        // word[p] è¢« board[i][j] åŒ¹é…ï¼Œå¼€å§‹å‘å››å‘¨æœç´¢ word[p+1..]
        dfs(i+1, j, p+1)
        dfs(i, j+1, p+1)
        dfs(i-1, j, p+1)
        dfs(i, j-1, p+1)
        board[i][j] ^= 255
    }
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            dfs(i, j, 0)
            if found {
                return true
            }
        }
    }
    return false
}
```

```java
// by labuladong (java)
class Solution {

    boolean found = false;

    public boolean exist(char[][] board, String word) {
        int m = board.length, n = board[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dfs(board, i, j, word, 0);
                if (found) {
                    return true;
                }
            }
        }
        return false;
    }

    // ä» (i, j) å¼€å§‹å‘å››å‘¨æœç´¢ï¼Œè¯•å›¾åŒ¹é… word[p..]
    void dfs(char[][] board, int i, int j, String word, int p) {
        if (p == word.length()) {
            // æ•´ä¸ª word å·²ç»è¢«åŒ¹é…å®Œï¼Œæ‰¾åˆ°äº†ä¸€ä¸ªç­”æ¡ˆ
            found = true;
            return;
        }
        if (found) {
            // å·²ç»æ‰¾åˆ°äº†ä¸€ä¸ªç­”æ¡ˆï¼Œä¸ç”¨å†æœç´¢äº†
            return;
        }
        int m = board.length, n = board[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return;
        }
        if (board[i][j] != word.charAt(p)) {
            return;
        }

        // å·²ç»åŒ¹é…è¿‡çš„å­—ç¬¦ï¼Œæˆ‘ä»¬ç»™å®ƒæ·»ä¸€ä¸ªè´Ÿå·ä½œä¸ºæ ‡è®°ï¼Œé¿å…èµ°å›å¤´è·¯
        board[i][j] = (char)(-board[i][j]);
        // word[p] è¢« board[i][j] åŒ¹é…ï¼Œå¼€å§‹å‘å››å‘¨æœç´¢ word[p+1..]
        dfs(board, i + 1, j, word, p + 1);
        dfs(board, i, j + 1, word, p + 1);
        dfs(board, i - 1, j, word, p + 1);
        dfs(board, i, j - 1, word, p + 1);
        board[i][j] = (char)(-board[i][j]);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
    let found = false;
    let dfs = function(board, i, j, word, p){
        // å½“æ•´ä¸ª word å·²ç»è¢«åŒ¹é…å®Œï¼Œæ‰¾åˆ°äº†ä¸€ä¸ªç­”æ¡ˆ
        if (p == word.length) {
            found = true;
            return;
        }
        // å·²ç»æ‰¾åˆ°äº†ä¸€ä¸ªç­”æ¡ˆï¼Œä¸ç”¨å†æœç´¢äº†
        if (found) {
            return;
        }
        let m = board.length, n = board[0].length;
        // å¦‚æœè¶Šç•Œäº†ï¼Œç›´æ¥è¿”å›
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return;
        }
        // å¦‚æœå½“å‰å­—ç¬¦å’Œ word çš„å½“å‰å­—ç¬¦ä¸ç›¸ç­‰ï¼Œè¿”å›
        if (board[i][j] != word.charAt(p)) {
            return;
        }
        // å·²ç»åŒ¹é…è¿‡çš„å­—ç¬¦ï¼Œæˆ‘ä»¬ç»™å®ƒæ·»ä¸€ä¸ªè´Ÿå·ä½œä¸ºæ ‡è®°ï¼Œé¿å…èµ°å›å¤´è·¯
        board[i][j] = -board[i][j];
        // word[p] è¢« board[i][j] åŒ¹é…ï¼Œå¼€å§‹å‘å››å‘¨æœç´¢ word[p+1..]
        dfs(board, i + 1, j, word, p + 1);
        dfs(board, i, j + 1, word, p + 1);
        dfs(board, i - 1, j, word, p + 1);
        dfs(board, i, j - 1, word, p + 1);
        board[i][j] = -board[i][j];
    }
    let m = board.length, n = board[0].length;
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            dfs(board, i, j, word, 0);
            if (found) {
                return true;
            }
        }
    }
    return false;
};
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        self.found = False
    
    def exist(self, board: List[List[str]], word: str) -> bool:
        m, n = len(board), len(board[0])
        for i in range(m):
            for j in range(n):
                self.dfs(board, i, j, word, 0)
                # å¦‚æœæ‰¾åˆ°äº†ä¸€ä¸ªç­”æ¡ˆï¼Œåˆ™ç›´æ¥è¿”å›True
                if self.found:
                    return True
        return False
    
    # ä» (i, j) å¼€å§‹å‘å››å‘¨æœç´¢ï¼Œè¯•å›¾åŒ¹é… word[p..]
    def dfs(self, board, i, j, word, p):
        if p == len(word):
            # æ•´ä¸ª word å·²ç»è¢«åŒ¹é…å®Œï¼Œæ‰¾åˆ°äº†ä¸€ä¸ªç­”æ¡ˆ
            self.found = True
            return
        if self.found:
            # å·²ç»æ‰¾åˆ°äº†ä¸€ä¸ªç­”æ¡ˆï¼Œä¸ç”¨å†æœç´¢äº†
            return
        m, n = len(board), len(board[0])
        if i < 0 or j < 0 or i >= m or j >= n:
            return
        if board[i][j] != word[p]:
            return
        
        # å·²ç»åŒ¹é…è¿‡çš„å­—ç¬¦ï¼Œæˆ‘ä»¬ç»™å®ƒæ·»ä¸€ä¸ªè´Ÿå·ä½œä¸ºæ ‡è®°ï¼Œé¿å…èµ°å›å¤´è·¯
        board[i][j] = -board[i][j]
        
        # word[p] è¢« board[i][j] åŒ¹é…ï¼Œå¼€å§‹å‘å››å‘¨æœç´¢ word[p+1..]
        self.dfs(board, i+1, j, word, p+1)
        self.dfs(board, i, j+1, word, p+1)
        self.dfs(board, i-1, j, word, p+1)
        self.dfs(board, i, j-1, word, p+1)
        
        # è¿˜åŸæ ‡è®°ï¼ˆæ¢å¤ç°åœºï¼‰
        board[i][j] = -board[i][j]
```

https://leetcode.cn/problems/word-search çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/wtcaE1 çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> window;

        int left = 0, right = 0;
        int res = 0; // è®°å½•ç»“æœ
        while (right < s.size()) {
            char c = s[right];
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            window[c]++;
            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (window[c] > 1) {
                char d = s[left];
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                window[d]--;
            }
            // åœ¨è¿™é‡Œæ›´æ–°ç­”æ¡ˆ
            res = max(res, right - left);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
func lengthOfLongestSubstring(s string) int {
    window := make(map[byte]int) // ç”¨å“ˆå¸Œè¡¨è®°å½•çª—å£ä¸­æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°
    left, right := 0, 0 // å®šä¹‰ä¸€äº›å˜é‡ï¼Œè®°å½•çª—å£çš„å·¦å³è¾¹ç•Œå’Œæœ€é•¿å­ä¸²çš„é•¿åº¦
    res := 0
    for right < len(s) { // å½“å³è¾¹ç•Œæ²¡æœ‰åˆ°å­—ç¬¦ä¸²çš„æœ«å°¾æ—¶ï¼Œæ‰§è¡Œå¾ªç¯
        c := s[right] // è·å–å½“å‰å³è¾¹ç•ŒæŒ‡å‘çš„å­—ç¬¦
        right++ // å³è¾¹ç•Œåç§»ä¸€ä½
        window[c]++ // å“ˆå¸Œè¡¨ä¸­åŠ å…¥å½“å‰å­—ç¬¦ï¼Œè®°å½•å‡ºç°çš„æ¬¡æ•°
        for window[c] > 1 { // å¦‚æœå½“å‰å­—ç¬¦åœ¨çª—å£ä¸­çš„å‡ºç°æ¬¡æ•°å¤§äº1ï¼Œåˆ™è¿›å…¥å¾ªç¯
            d := s[left] // è·å–çª—å£ä¸­æœ€å·¦è¾¹çš„å­—ç¬¦
            left++ // å·¦è¾¹ç•Œå³ç§»ä¸€ä½
            window[d]-- // ä»å“ˆå¸Œè¡¨ä¸­ç§»é™¤æœ€å·¦è¾¹çš„å­—ç¬¦
        }
        res = max(res, right - left) // æ›´æ–°æœ€é•¿å­ä¸²çš„é•¿åº¦
    }
    return res // è¿”å›æœ€é•¿å­ä¸²çš„é•¿åº¦
}

func max(a, b int) int { // å®šä¹‰ä¸€ä¸ªå‡½æ•°ç”¨äºè¿”å›ä¸¤ä¸ªæ•´æ•°ä¸­çš„æœ€å¤§å€¼
    if a > b { // å¦‚æœaå¤§äºb
        return a // è¿”å›a
    }
    return b // å¦åˆ™è¿”å›b
}
```

```java
// by chatGPT (java)
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // ä½¿ç”¨å“ˆå¸Œè¡¨è®°å½•çª—å£å†…å­—ç¬¦å‡ºç°æ¬¡æ•°
        Map<Character, Integer> window = new HashMap<>();

        int left = 0, right = 0;
        int res = 0; // è®°å½•ç»“æœ
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            window.put(c, window.getOrDefault(c, 0) + 1);

            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (window.get(c) > 1) {
                char d = s.charAt(left);
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                window.put(d, window.getOrDefault(d, 0) - 1);
            }
            // åœ¨è¿™é‡Œæ›´æ–°ç­”æ¡ˆ
            res = Math.max(res, right - left);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    // åˆ›å»ºä¸€ä¸ªæ˜ å°„è¡¨ï¼Œç”¨äºè®°å½•å­—æ¯å‡ºç°çš„æ¬¡æ•°
    let window = {};
    // å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«è¡¨ç¤ºçª—å£çš„å·¦å³è¾¹ç•Œ
    let left = 0;
    let right = 0;
    // å®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œç”¨äºè®°å½•æœ€é•¿çš„å­ä¸²é•¿åº¦
    let res = 0;

    // å½“å³è¾¹ç•Œæ²¡æœ‰è¶…è¿‡å­—ç¬¦ä¸²sçš„é•¿åº¦æ—¶ï¼Œä¸€ç›´å¾ªç¯
    while (right < s.length) {
        let c = s[right];
        right++;

        // æ›´æ–°æ˜ å°„è¡¨
        window[c] = window[c] ? window[c] + 1 : 1;
        
        // å¦‚æœå½“å‰å­—æ¯å‡ºç°çš„æ¬¡æ•°å¤§äº1ï¼ˆå³çª—å£å†…å·²ç»æœ‰äº†è¯¥å­—æ¯ï¼‰ï¼Œéœ€è¦æ”¶ç¼©å·¦è¾¹ç•Œï¼Œä½¿å¾—çª—å£å†…ä¸å†æœ‰é‡å¤çš„å­—æ¯
        while (window[c] > 1) {
            let d = s[left];
            left++;

            // æ›´æ–°æ˜ å°„è¡¨
            window[d]--;
        }
        
        // æ›´æ–°å½“å‰æœ€é•¿çš„å­ä¸²é•¿åº¦
        res = Math.max(res, right - left);
    }

    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # åˆ›å»ºä¸€ä¸ªå“ˆå¸Œè¡¨
        window = {}
        
        # å®šä¹‰å·¦å³æŒ‡é’ˆå’Œç»“æœå˜é‡
        left, right = 0, 0
        res = 0
        
        # å½“å³æŒ‡é’ˆå°äºå­—ç¬¦ä¸²é•¿åº¦æ—¶
        while right < len(s):
            c = s[right]
            right += 1
            
            # å°†å­—ç¬¦æ·»åŠ åˆ°å“ˆå¸Œè¡¨ä¸­å¹¶æ›´æ–°å‡ºç°çš„æ¬¡æ•°
            if c not in window:
                window[c] = 1
            else:
                window[c] += 1
            
            # å½“çª—å£ä¸­å­—ç¬¦å‡ºç°æ¬¡æ•°å¤§äº 1 æ—¶ï¼Œå°†å·¦æŒ‡é’ˆå‘å³ç§»åŠ¨ï¼Œæ›´æ–°å“ˆå¸Œè¡¨ä¸­çš„å€¼
            while window[c] > 1:
                d = s[left]
                left += 1
                window[d] -= 1
            
            # æ›´æ–°ç»“æœå˜é‡ï¼Œè®°å½•æœ€é•¿å­ä¸²é•¿åº¦
            res = max(res, right - left)
        
        # è¿”å›æœ€é•¿å­ä¸²é•¿åº¦
        return res
```

https://leetcode.cn/problems/wtcaE1 çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Codec {
public:
    string SEP = ",";
    string EMPTY = "#";

    /* ä¸»å‡½æ•°ï¼Œå°†äºŒå‰æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸² */
    string serialize(TreeNode* root) {
        string res = "";
        serialize(root, res);
        return res;
    }

    /* è¾…åŠ©å‡½æ•°ï¼Œå°†äºŒå‰æ ‘å­˜å…¥å­—ç¬¦ä¸² */
    void serialize(TreeNode* root, string& res) {
        if (root == nullptr) {
            res += EMPTY + SEP;
            return;
        }

        /******å‰åºéå†ä½ç½®******/
        res += to_string(root->val) + SEP;
        /***********************/

        serialize(root->left, res);
        serialize(root->right, res);
    }
  
    /* ä¸»å‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„ */
    TreeNode* deserialize(string data) {
        // å°†å­—ç¬¦ä¸²è½¬åŒ–æˆåˆ—è¡¨
        vector<string> nodes;
        string s = "";
        for (char& c : data) {
            if (c == SEP[0]) {
                nodes.emplace_back(s);
                s = "";
            }
            else {
                s += c;
            }
        }
        if (!s.empty()) nodes.emplace_back(s);
        return deserialize(nodes);
    }

    /* è¾…åŠ©å‡½æ•°ï¼Œé€šè¿‡ nodes åˆ—è¡¨æ„é€ äºŒå‰æ ‘ */
    TreeNode* deserialize(vector<string>& nodes) {
        if (nodes.empty()) return nullptr;

        /******å‰åºéå†ä½ç½®******/
        // åˆ—è¡¨æœ€å·¦ä¾§å°±æ˜¯æ ¹èŠ‚ç‚¹
        string first = nodes[0];
        nodes.erase(nodes.begin());
        if (first == EMPTY) return nullptr;
        TreeNode* root = new TreeNode(stoi(first));
        /***********************/

        root->left = deserialize(nodes);
        root->right = deserialize(nodes);

        return root;
    }
};
```

```go
// by chatGPT (go)
type Codec struct {
    SEP string
    NULL string
}

func Constructor() Codec {
    return Codec{
        SEP: ",",
        NULL: "#",
    }
}

/* è¾…åŠ©å‡½æ•°ï¼Œå°†äºŒå‰æ ‘å­˜å…¥å­—ç¬¦ä¸² */
func (this *Codec) serialize(root *TreeNode, sb *strings.Builder) {
    if root == nil {
        sb.WriteString(this.NULL)
        sb.WriteString(this.SEP)
        return
    }

    /******å‰åºéå†ä½ç½®******/
    sb.WriteString(strconv.Itoa(root.Val))
    sb.WriteString(this.SEP)
    /***********************/

    this.serialize(root.Left, sb)
    this.serialize(root.Right, sb)
}

/* ä¸»å‡½æ•°ï¼Œå°†äºŒå‰æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸² */
func (this *Codec) serialize(root *TreeNode) string {
    var sb strings.Builder
    this.serialize(root, &sb)
    return sb.String()
}

/* è¾…åŠ©å‡½æ•°ï¼Œæ ¹æ®å­—ç¬¦ä¸²æ„å»ºäºŒå‰æ ‘ */
func (this *Codec) deserialize(nodes *[]string) *TreeNode {
    if len(*nodes) == 0 {
        return nil
    }
    /* ä» nodes ä¸­å–å‡ºä¸€ä¸ªå…ƒç´ ä½œä¸ºå½“å‰å­æ ‘çš„æ ¹èŠ‚ç‚¹ */
    first := (*nodes)[0]
    if first == this.NULL {
        // è‹¥è¯¥å…ƒç´ ä¸º "#" ï¼Œä»£è¡¨å…¶ä¸ºç©ºèŠ‚ç‚¹ï¼Œç›´æ¥å¼¹å‡ºå¹¶è¿”å› nil
        *nodes = (*nodes)[1:]
        return nil
    }
    /* å¦åˆ™ï¼Œè¯¥å…ƒç´ å®é™…ä¸Šæ˜¯æ•´æ•°ï¼Œå°†å…¶è½¬åŒ–ä¸ºèŠ‚ç‚¹ */
    val, _ := strconv.Atoi(first)
    root := &TreeNode{Val: val}
    /* é€’å½’æ„é€ å·¦å³å­æ ‘ */
    *nodes = (*nodes)[1:]
    root.Left = this.deserialize(nodes)
    root.Right = this.deserialize(nodes)
    return root
}

/* ä¸»å‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„ */
func (this *Codec) deserialize(data string) *TreeNode {
    nodes := strings.Split(data, this.SEP)
    return this.deserialize(&nodes)
}
```

```java
// by labuladong (java)
public class Codec {
    String SEP = ",";
    String NULL = "#";

    /* ä¸»å‡½æ•°ï¼Œå°†äºŒå‰æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸² */
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serialize(root, sb);
        return sb.toString();
    }

    /* è¾…åŠ©å‡½æ•°ï¼Œå°†äºŒå‰æ ‘å­˜å…¥ StringBuilder */
    void serialize(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(NULL).append(SEP);
            return;
        }

        /******å‰åºéå†ä½ç½®******/
        sb.append(root.val).append(SEP);
        /***********************/

        serialize(root.left, sb);
        serialize(root.right, sb);
    }

    /* ä¸»å‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„ */
    public TreeNode deserialize(String data) {
        // å°†å­—ç¬¦ä¸²è½¬åŒ–æˆåˆ—è¡¨
        LinkedList<String> nodes = new LinkedList<>();
        for (String s : data.split(SEP)) {
            nodes.addLast(s);
        }
        return deserialize(nodes);
    }

    /* è¾…åŠ©å‡½æ•°ï¼Œé€šè¿‡ nodes åˆ—è¡¨æ„é€ äºŒå‰æ ‘ */
    TreeNode deserialize(LinkedList<String> nodes) {
        if (nodes.isEmpty()) return null;

        /******å‰åºéå†ä½ç½®******/
        // åˆ—è¡¨æœ€å·¦ä¾§å°±æ˜¯æ ¹èŠ‚ç‚¹
        String first = nodes.removeFirst();
        if (first.equals(NULL)) return null;
        TreeNode root = new TreeNode(Integer.parseInt(first));
        /***********************/

        root.left = deserialize(nodes);
        root.right = deserialize(nodes);

        return root;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
    if(!root) {
        return '#,'; // æŠŠç©ºèŠ‚ç‚¹è½¬æ¢ä¸º "#,"
    }
    return root.val + ',' + serialize(root.left) + serialize(root.right); // å…ˆæŠŠå½“å‰èŠ‚ç‚¹çš„å€¼å­˜å…¥å­—ç¬¦ä¸²ï¼Œç„¶åé€’å½’åœ°åºåˆ—åŒ–å·¦å­æ ‘å’Œå³å­æ ‘
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
    var nodes = data.split(','); // æŠŠå­—ç¬¦ä¸²è½¬æ¢æˆèŠ‚ç‚¹åˆ—è¡¨
    var dfs = function() {
        var value = nodes.shift(); // å½“å‰å­—ç¬¦ä¸²å¯¹åº”çš„èŠ‚ç‚¹
        if(value === '#') { // é‡åˆ°ç©ºèŠ‚ç‚¹ï¼Œè¿”å› null
            return null;
        }
        var node = new TreeNode(value); // åˆ›å»ºå½“å‰èŠ‚ç‚¹
        node.left = dfs(); // é€’å½’æ„é€ å·¦å­æ ‘
        node.right = dfs(); // é€’å½’æ„é€ å³å­æ ‘
        return node;
    };
    return dfs(); // ä»æ ¹èŠ‚ç‚¹å¼€å§‹æ„é€ äºŒå‰æ ‘
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
```

```python
# by chatGPT (python)
class Codec:
    def __init__(self):
        self.SEP = ","
        self.NULL = "#"
    
    # ä¸»å‡½æ•°ï¼Œå°†äºŒå‰æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²
    def serialize(self, root: TreeNode) -> str:
        sb = []
        self._serialize(root, sb)
        return ''.join(sb)

    # è¾…åŠ©å‡½æ•°ï¼Œå°†äºŒå‰æ ‘å­˜å…¥åˆ—è¡¨
    def _serialize(self, root: TreeNode, sb: list):
        if not root:
            sb.append(self.NULL).append(self.SEP)
            return

        # å‰åºéå†
        sb.append(str(root.val)).append(self.SEP)

        self._serialize(root.left, sb)
        self._serialize(root.right, sb)

    # ä¸»å‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„
    def deserialize(self, data: str) -> TreeNode:
        # å°†å­—ç¬¦ä¸²è½¬åŒ–æˆåˆ—è¡¨
        nodes = data.split(self.SEP)
        return self._deserialize(nodes)

    # è¾…åŠ©å‡½æ•°ï¼Œé€šè¿‡ nodes åˆ—è¡¨æ„é€ äºŒå‰æ ‘ 
    def _deserialize(self, nodes: list) -> TreeNode:
        if not nodes:
            return None

        # å‰åºéå†
        first = nodes.pop(0)
        if first == self.NULL:
            return None
        root = TreeNode(int(first))

        root.left = self._deserialize(nodes)
        root.right = self._deserialize(nodes)

        return root
```

https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/xx4gT2 çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> pq; // å°é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å°å…ƒç´ 
        for (auto e : nums) {
            // æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
            pq.push(e);
            // å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
            if (pq.size() > k) {
                pq.pop();
            }
        }
        // pq ä¸­å‰©ä¸‹çš„æ˜¯ nums ä¸­ k ä¸ªæœ€å¤§å…ƒç´ ï¼Œ
        // å †é¡¶æ˜¯æœ€å°çš„é‚£ä¸ªï¼Œå³ç¬¬ k ä¸ªæœ€å¤§å…ƒç´ 
        return pq.top();
    }
};
```

```go
// by chatGPT (go)
import "container/heap"

func findKthLargest(nums []int, k int) int {
    pq := &minHeap{}
    heap.Init(pq)
    for _, e := range nums {
        // æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éå°æ ¹å †
        heap.Push(pq, e)
        // å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
        if pq.Len() > k {
            heap.Pop(pq)
        }
    }
    // pq ä¸­å‰©ä¸‹çš„æ˜¯ nums ä¸­ k ä¸ªæœ€å¤§å…ƒç´ ï¼Œ
    // å †é¡¶æ˜¯æœ€å°çš„é‚£ä¸ªï¼Œå³ç¬¬ k ä¸ªæœ€å¤§å…ƒç´ 
    return (*pq)[0]
}

type minHeap []int

func (h minHeap) Len() int { return len(h) }
func (h minHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h minHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }
func (h *minHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *minHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[:n-1]
    return x
}
```

```java
// by labuladong (java)
class Solution {
    public int findKthLargest(int[] nums, int k) {
        // å°é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å°å…ƒç´ 
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int e : nums) {
            // æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
            pq.offer(e);
            // å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
            if (pq.size() > k) {
                pq.poll();
            }
        }
        // pq ä¸­å‰©ä¸‹çš„æ˜¯ nums ä¸­ k ä¸ªæœ€å¤§å…ƒç´ ï¼Œ
        // å †é¡¶æ˜¯æœ€å°çš„é‚£ä¸ªï¼Œå³ç¬¬ k ä¸ªæœ€å¤§å…ƒç´ 
        return pq.peek();
    }
}
```

```javascript
// by chatGPT (javascript)
var findKthLargest = function(nums, k) {
    // å°é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å°å…ƒç´ 
    const pq = new PriorityQueue()
    for (let i = 0; i < nums.length; i++) {
        const e = nums[i]
        // æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
        pq.offer(e)
        // å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
        if (pq.size() > k) {
            pq.poll();
        }
    }
    // pq ä¸­å‰©ä¸‹çš„æ˜¯ nums ä¸­ k ä¸ªæœ€å¤§å…ƒç´ ï¼Œ
    // å †é¡¶æ˜¯æœ€å°çš„é‚£ä¸ªï¼Œå³ç¬¬ k ä¸ªæœ€å¤§å…ƒç´ 
    return pq.peek()
};
```

```python
# by chatGPT (python)
import heapq

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # å°é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å°å…ƒç´ 
        pq = []
        for e in nums:
            # æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
            heapq.heappush(pq, e)
            # å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
            if len(pq) > k:
                heapq.heappop(pq)
        # pq ä¸­å‰©ä¸‹çš„æ˜¯ nums ä¸­ k ä¸ªæœ€å¤§å…ƒç´ ï¼Œ
        # å †é¡¶æ˜¯æœ€å°çš„é‚£ä¸ªï¼Œå³ç¬¬ k ä¸ªæœ€å¤§å…ƒç´ 
        return pq[0]
```

https://leetcode.cn/problems/xx4gT2 çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class MyQueue {
private:
    stack<int> s1, s2;
public:
    MyQueue() {
        s1 = stack<int>();
        s2 = stack<int>();
    }

    /**
     * æ·»åŠ å…ƒç´ åˆ°é˜Ÿå°¾
     */
    void push(int x) {
        s1.push(x);
    }

    /** 
     * åˆ é™¤é˜Ÿå¤´çš„å…ƒç´ å¹¶è¿”å›
     */
    int pop() {
        // å…ˆè°ƒç”¨ peek ä¿è¯ s2 éç©º
        peek();
        int val = s2.top();
        s2.pop();
        return val;
    }

    /** 
     * è¿”å›é˜Ÿå¤´å…ƒç´ 
     */
    int peek() {
        if (s2.empty())
            // æŠŠ s1 å…ƒç´ å‹å…¥ s2
            while (!s1.empty()) {
                int val = s1.top();
                s1.pop();
                s2.push(val);
            }
        return s2.top();
    }

    /**
     * åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
     */
    bool empty() {
        return s1.empty() && s2.empty();
    }
};
```

```go
// by chatGPT (go)
type MyQueue struct {
    s1, s2 *stack.Stack
}

func Constructor() MyQueue {
    return MyQueue{
        s1: stack.New(),
        s2: stack.New(),
    }
}

/**
 * æ·»åŠ å…ƒç´ åˆ°é˜Ÿå°¾
 */
func (this *MyQueue) Push(x int) {
    this.s1.Push(x)
}

/**
 * åˆ é™¤é˜Ÿå¤´çš„å…ƒç´ å¹¶è¿”å›
 */
func (this *MyQueue) Pop() int {
    // å…ˆè°ƒç”¨ Peek ä¿è¯ s2 éç©º
    this.Peek()
    return this.s2.Pop().(int)
}

/**
 * è¿”å›é˜Ÿå¤´å…ƒç´ 
 */
func (this *MyQueue) Peek() int {
    if this.s2.Empty() {
        // æŠŠ s1 å…ƒç´ å‹å…¥ s2
        for !this.s1.Empty() {
            this.s2.Push(this.s1.Pop())
        }
    }
    return this.s2.Peek().(int)
}

/**
 * åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
 */
func (this *MyQueue) Empty() bool {
    return this.s1.Empty() && this.s2.Empty()
}
```

```java
// by labuladong (java)
class MyQueue {
    private Stack<Integer> s1, s2;

    public MyQueue() {
        s1 = new Stack<>();
        s2 = new Stack<>();
    }

    /**
     * æ·»åŠ å…ƒç´ åˆ°é˜Ÿå°¾
     */
    public void push(int x) {
        s1.push(x);
    }

    /**
     * åˆ é™¤é˜Ÿå¤´çš„å…ƒç´ å¹¶è¿”å›
     */
    public int pop() {
        // å…ˆè°ƒç”¨ peek ä¿è¯ s2 éç©º
        peek();
        return s2.pop();
    }

    /**
     * è¿”å›é˜Ÿå¤´å…ƒç´ 
     */
    public int peek() {
        if (s2.isEmpty())
            // æŠŠ s1 å…ƒç´ å‹å…¥ s2
            while (!s1.isEmpty())
                s2.push(s1.pop());
        return s2.peek();
    }

    /**
     * åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
     */
    public boolean empty() {
        return s1.isEmpty() && s2.isEmpty();
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * Initialize your data structure here.
 */
var MyQueue = function() {
    this.s1 = [];
    this.s2 = [];
};

/**
 * Push element x to the back of queue. 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    this.s1.push(x);
};

/**
 * Removes the element from in front of queue and returns that element.
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    // å…ˆè°ƒç”¨ peek ä¿è¯ s2 éç©º
    this.peek();
    return this.s2.pop();
};

/**
 * Get the front element.
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    if (this.s2.length === 0) {
        // æŠŠ s1 å…ƒç´ å‹å…¥ s2
        while (this.s1.length !== 0) {
            this.s2.push(this.s1.pop());
        }
    }
    return this.s2[this.s2.length - 1];
};

/**
 * Returns whether the queue is empty.
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    return this.s1.length === 0 && this.s2.length === 0;
};
```

```python
# by chatGPT (python)
class CQueue:
    def __init__(self):
        """
        åˆå§‹åŒ–ä¸€ä¸ªé˜Ÿåˆ—ï¼Œä½¿ç”¨ä¸¤ä¸ªå †æ ˆ s1 å’Œ s2
        """
        self.s1 = []
        self.s2 = []
    
    def appendTail(self, value):
        """
        æ·»åŠ å…ƒç´ åˆ°é˜Ÿå°¾
        """
        self.s1.append(value)
    
    def deleteHead(self):
        """
        åˆ é™¤é˜Ÿå¤´çš„å…ƒç´ å¹¶è¿”å›
        """
        # å…ˆè°ƒç”¨ peek ä¿è¯ s2 éç©º
        if self.peek() is None:
            return -1
        else: 
            return self.s2.pop() 
    
    def peek(self):
        """
        è¿”å›é˜Ÿå¤´å…ƒç´ 
        """
        if not self.s2:
            # æŠŠ s1 å…ƒç´ å‹å…¥ s2
            while self.s1:
                self.s2.append(self.s1.pop())
        
        return self.s2[-1] if self.s2 else None
        
    
    def empty(self):
        """
        åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
        """
        return not self.s1 and not self.s2
```

https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left_index = left_bound(nums, target);
        if (left_index == -1) {
            return 0;
        }
        int right_index = right_bound(nums, target);
        // æ ¹æ®å·¦å³è¾¹ç•Œå³å¯æ¨å¯¼å‡ºå…ƒç´ å‡ºç°çš„æ¬¡æ•°
        return right_index - left_index + 1;
    }

    int left_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        // æœç´¢åŒºé—´ä¸º [left, right]
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                // æœç´¢åŒºé—´å˜ä¸º [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // æœç´¢åŒºé—´å˜ä¸º [left, mid-1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                // æ”¶ç¼©å³ä¾§è¾¹ç•Œ
                right = mid - 1;
            }
        }
        // æ£€æŸ¥å‡ºç•Œæƒ…å†µ
        if (left >= nums.size() || nums[left] != target) {
            /**<extend up -300>
             ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/2.jpg)
             */
            return -1;
        }
        return left;
    }

    int right_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // è¿™é‡Œæ”¹æˆæ”¶ç¼©å·¦ä¾§è¾¹ç•Œå³å¯
                left = mid + 1;
            }
        }
        // è¿™é‡Œæ”¹ä¸ºæ£€æŸ¥ right è¶Šç•Œçš„æƒ…å†µï¼Œè§ä¸‹å›¾
        if (right < 0 || nums[right] != target) {
            /**<extend up -300>
             ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/4.jpg)
             */
            return -1;
        }
        return right;
    }
};
```

```go
// by chatGPT (go)
// äºŒåˆ†æŸ¥æ‰¾
// åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®
func search(nums []int, target int) int {
    // å…ƒç´ ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
    leftIndex := leftBound(nums, target)
    if leftIndex == -1 {
        return 0
    }
    // å…ƒç´ æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®
    rightIndex := rightBound(nums, target)
    // æ ¹æ®å·¦å³è¾¹ç•Œå³å¯æ¨å¯¼å‡ºå…ƒç´ å‡ºç°çš„æ¬¡æ•°
    return rightIndex - leftIndex + 1
}

// äºŒåˆ†æŸ¥æ‰¾ï¼ŒæŸ¥æ‰¾å…ƒç´ ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
func leftBound(nums []int, target int) int {
    left, right := 0, len(nums)-1
    // æœç´¢åŒºé—´ä¸º [left, right]
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] < target {
            // æœç´¢åŒºé—´å˜ä¸º [mid+1, right]
            left = mid + 1
        } else if nums[mid] > target {
            // æœç´¢åŒºé—´å˜ä¸º [left, mid-1]
            right = mid - 1
        } else if nums[mid] == target {
            // æ”¶ç¼©å³ä¾§è¾¹ç•Œ
            right = mid - 1
        }
    }
    // æ£€æŸ¥å‡ºç•Œæƒ…å†µ
    if left >= len(nums) || nums[left] != target {
        // è¯¥å…ƒç´ åœ¨æ•°ç»„ä¸­ä¸å­˜åœ¨çš„æƒ…å†µ
        return -1
    }
    return left
}

// äºŒåˆ†æŸ¥æ‰¾ï¼ŒæŸ¥æ‰¾å…ƒç´ æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®
func rightBound(nums []int, target int) int {
    left, right := 0, len(nums)-1
    // æœç´¢åŒºé—´ä¸º [left, right]
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] < target {
            // æœç´¢åŒºé—´å˜ä¸º [mid+1, right]
            left = mid + 1
        } else if nums[mid] > target {
            // æœç´¢åŒºé—´å˜ä¸º [left, mid-1]
            right = mid - 1
        } else if nums[mid] == target {
            // æ”¶ç¼©å·¦ä¾§è¾¹ç•Œ
            left = mid + 1
        }
    }
    // æ£€æŸ¥å‡ºç•Œæƒ…å†µ
    if right < 0 || nums[right] != target {
        // è¯¥å…ƒç´ åœ¨æ•°ç»„ä¸­ä¸å­˜åœ¨çš„æƒ…å†µ
        return -1
    }
    return right
}
```

```java
// by labuladong (java)
class Solution {
    public int search(int[] nums, int target) {
        int left_index = left_bound(nums, target);
        if (left_index == -1) {
            return 0;
        }
        int right_index = right_bound(nums, target);
        // æ ¹æ®å·¦å³è¾¹ç•Œå³å¯æ¨å¯¼å‡ºå…ƒç´ å‡ºç°çš„æ¬¡æ•°
        return right_index - left_index + 1;
    }

    int left_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        // æœç´¢åŒºé—´ä¸º [left, right]
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                // æœç´¢åŒºé—´å˜ä¸º [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // æœç´¢åŒºé—´å˜ä¸º [left, mid-1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                // æ”¶ç¼©å³ä¾§è¾¹ç•Œ
                right = mid - 1;
            }
        }
        // æ£€æŸ¥å‡ºç•Œæƒ…å†µ
        if (left >= nums.length || nums[left] != target) {
            /**<extend up -300>
             ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/2.jpg)
             */
            return -1;
        }
        return left;
    }

    int right_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // è¿™é‡Œæ”¹æˆæ”¶ç¼©å·¦ä¾§è¾¹ç•Œå³å¯
                left = mid + 1;
            }
        }
        // è¿™é‡Œæ”¹ä¸ºæ£€æŸ¥ right è¶Šç•Œçš„æƒ…å†µï¼Œè§ä¸‹å›¾
        if (right < 0 || nums[right] != target) {
            /**<extend up -300>
             ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/4.jpg)
             */
            return -1;
        }
        return right;
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  function left_bound(nums, target) {
    let left = 0
    let right = nums.length - 1
    // æœç´¢åŒºé—´ä¸º [left, right]
    while (left <= right) {
      let mid = left + Math.floor((right - left) / 2)
      if (nums[mid] < target) {
        // æœç´¢åŒºé—´å˜ä¸º [mid+1, right]
        left = mid + 1
      } else if (nums[mid] > target) {
        // æœç´¢åŒºé—´å˜ä¸º [left, mid-1]
        right = mid - 1
      } else if (nums[mid] === target) {
        // æ”¶ç¼©å³ä¾§è¾¹ç•Œ
        right = mid - 1
      }
    }
    // æ£€æŸ¥å‡ºç•Œæƒ…å†µ
    if (left >= nums.length || nums[left] !== target) {
      /**<extend up -300>
       ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/2.jpg)
       */
      return -1;
    }
    return left;
  }

  function right_bound(nums, target) {
    let left = 0
    let right = nums.length - 1
    while (left <= right) {
      let mid = left + Math.floor((right - left) / 2)
      if (nums[mid] < target) {
        left = mid + 1
      } else if (nums[mid] > target) {
        right = mid - 1
      } else if (nums[mid] === target) {
        // è¿™é‡Œæ”¹æˆæ”¶ç¼©å·¦ä¾§è¾¹ç•Œå³å¯
        left = mid + 1
      }
    }
    // è¿™é‡Œæ”¹ä¸ºæ£€æŸ¥ right è¶Šç•Œçš„æƒ…å†µï¼Œè§ä¸‹å›¾
    if (right < 0 || nums[right] !== target) {
      /**<extend up -300>
       ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/4.jpg)
       */
      return -1;
    }
    return right;
  }

  let left_index = left_bound(nums, target);
  if (left_index === -1) {
    return 0;
  }
  let right_index = right_bound(nums, target);
  // æ ¹æ®å·¦å³è¾¹ç•Œå³å¯æ¨å¯¼å‡ºå…ƒç´ å‡ºç°çš„æ¬¡æ•°
  return right_index - left_index + 1;
};
```

```python
# by chatGPT (python)
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left_index = self.left_bound(nums, target)
        if left_index == -1:
            return 0
        right_index = self.right_bound(nums, target)
        # æ ¹æ®å·¦å³è¾¹ç•Œå³å¯æ¨å¯¼å‡ºå…ƒç´ å‡ºç°çš„æ¬¡æ•°
        return right_index - left_index + 1

    def left_bound(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        # æœç´¢åŒºé—´ä¸º [left, right]
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] < target:
                # æœç´¢åŒºé—´å˜ä¸º [mid+1, right]
                left = mid + 1
            elif nums[mid] > target:
                # æœç´¢åŒºé—´å˜ä¸º [left, mid-1]
                right = mid - 1
            elif nums[mid] == target:
                # æ”¶ç¼©å³ä¾§è¾¹ç•Œ
                right = mid - 1
        # æ£€æŸ¥å‡ºç•Œæƒ…å†µ
        if left >= len(nums) or nums[left] != target:
            """
            <extend up -300>
            ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/2.jpg)
            """
            return -1
        return left

    def right_bound(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            elif nums[mid] == target:
                # è¿™é‡Œæ”¹æˆæ”¶ç¼©å·¦ä¾§è¾¹ç•Œå³å¯
                left = mid + 1
        # è¿™é‡Œæ”¹ä¸ºæ£€æŸ¥ right è¶Šç•Œçš„æƒ…å†µï¼Œè§ä¸‹å›¾
        if right < 0 or nums[right] != target:
            """
            <extend up -300>
            ![](../pictures/äºŒåˆ†æŸ¥æ‰¾/4.jpg)
            """
            return -1
        return right
```

https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    // å¤‡å¿˜å½•
    vector<vector<int>> memo;

    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        memo = vector<vector<int>>(m, vector<int>(n, -1));
        // æŒ‡é’ˆ iï¼Œj ä»ç´¢å¼• 0 å¼€å§‹ç§»åŠ¨
        return dp(s, 0, p, 0);
    }

    /* è®¡ç®— p[j..] æ˜¯å¦åŒ¹é… s[i..] */
    bool dp(string& s, int i, string& p, int j) {
        int m = s.size(), n = p.size();
        // base case
        if (j == n) {
            return i == m;
        }
        if (i == m) {
            if ((n - j) % 2 == 1) {
                return false;
            }
            for (; j + 1 < n; j += 2) {
                if (p[j + 1] != '*') {
                    return false;
                }
            }
            return true;
        }

        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[i][j] != -1) {
            return memo[i][j];
        }

        bool res = false;

        if (s[i] == p[j] || p[j] == '.') {
            if (j < n - 1 && p[j + 1] == '*') {
                res = dp(s, i, p, j + 2)
                        || dp(s, i + 1, p, j);
            } else {
                res = dp(s, i + 1, p, j + 1);
            }
        } else {
            if (j < n - 1 && p[j + 1] == '*') {
                res = dp(s, i, p, j + 2);
            } else {
                res = false;
            }
        }
        // å°†å½“å‰ç»“æœè®°å…¥å¤‡å¿˜å½•
        memo[i][j] = res;
        return res;
    }
};
```

```go
// by chatGPT (go)
func isMatch(s string, p string) bool {
    // å¤‡å¿˜å½•
    memo := make([][]int, len(s))
    for i := range memo {
        memo[i] = make([]int, len(p))
        for j := range memo[i] {
            memo[i][j] = -1
        }
    }
    // æŒ‡é’ˆ iï¼Œj ä»ç´¢å¼• 0 å¼€å§‹ç§»åŠ¨
    return dp(s, 0, p, 0, memo)
}

/* è®¡ç®— p[j..] æ˜¯å¦åŒ¹é… s[i..] */
func dp(s string, i int, p string, j int, memo [][]int) bool {
    m, n := len(s), len(p)
    // base case
    if j == n {
        return i == m
    }
    if i == m {
        if (n-j)%2 == 1 {
            return false
        }
        for ; j+1 < n; j += 2 {
            if p[j+1] != '*' {
                return false
            }
        }
        return true
    }
    // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
    if memo[i][j] != -1 {
        return memo[i][j] == 1
    }

    var res bool

    if s[i] == p[j] || p[j] == '.' {
        if j < n-1 && p[j+1] == '*' {
            res = dp(s, i, p, j+2, memo) || dp(s, i+1, p, j, memo)
        } else {
            res = dp(s, i+1, p, j+1, memo)
        }
    } else {
        if j < n-1 && p[j+1] == '*' {
            res = dp(s, i, p, j+2, memo)
        }
    }
    // å°†å½“å‰ç»“æœè®°å…¥å¤‡å¿˜å½•
    if res {
        memo[i][j] = 1
    } else {
        memo[i][j] = 0
    }
    return res
}
```

```java
// by chatGPT (java)
class Solution {
    // å¤‡å¿˜å½•
    private int[][] memo;

    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        memo = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(memo[i], -1);
        }
        // æŒ‡é’ˆ iï¼Œj ä»ç´¢å¼• 0 å¼€å§‹ç§»åŠ¨
        return dp(s, 0, p, 0);
    }

    /* è®¡ç®— p[j..] æ˜¯å¦åŒ¹é… s[i..] */
    private boolean dp(String s, int i, String p, int j) {
        int m = s.length(), n = p.length();
        // base case
        if (j == n) {
            return i == m;
        }
        if (i == m) {
            if ((n - j) % 2 == 1) {
                return false;
            }
            for (; j + 1 < n; j += 2) {
                if (p.charAt(j + 1) != '*') {
                    return false;
                }
            }
            return true;
        }

        // æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if (memo[i][j] != -1) {
            return memo[i][j] == 1;
        }

        boolean res = false;

        if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') {
            if (j < n - 1 && p.charAt(j + 1) == '*') {
                res = dp(s, i, p, j + 2)
                        || dp(s, i + 1, p, j);
            } else {
                res = dp(s, i + 1, p, j + 1);
            }
        } else {
            if (j < n - 1 && p.charAt(j + 1) == '*') {
                res = dp(s, i, p, j + 2);
            } else {
                res = false;
            }
        }
        // å°†å½“å‰ç»“æœè®°å…¥å¤‡å¿˜å½•
        memo[i][j] = res ? 1 : 0;
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var isMatch = function(s, p) {
    var m = s.length,
        n = p.length;
    var memo = new Array(m + 1); // å…ˆæ„é€ ä¸€ä¸ªæ•°ç»„
    for (var i = 0; i <= m; i++) {
        memo[i] = new Array(n + 1).fill(false);
    }
    memo[0][0] = true; // ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸ºç©ºä¸²æ—¶ï¼Œäº’ç›¸åŒ¹é…

    for (i = 0; i <= m; i++) {
        for (var j = 1; j <= n; j++) {
            if (p.charAt(j - 1) === '*') {
                // * å·èƒ½åŒ¹é… 0 æ¬¡æˆ–æ›´å¤šæ¬¡
                memo[i][j] = memo[i][j - 2] // åŒ¹é… 0 æ¬¡
                || (i > 0 && (s.charAt(i - 1) === p.charAt(j - 2) || p.charAt(j - 2) === '.') && memo[i - 1][j]);
            } else {
                if (i > 0 && (s.charAt(i - 1) === p.charAt(j - 1) || p.charAt(j - 1) === '.')) {
                    memo[i][j] = memo[i - 1][j - 1];
                }
            }
        }
    }

    return memo[m][n]; // è¿”å›ä»ä¸¤ä¸ªå­—ç¬¦ä¸²çš„å°¾éƒ¨å¼€å§‹ï¼Œæ˜¯å¦ç›¸äº’åŒ¹é…
};
```

```python
# by chatGPT (python)
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # å¤‡å¿˜å½•
        memo = []
        # åˆ›å»ºå¤§å°ä¸ºm*nçš„å¤‡å¿˜å½•ï¼Œåˆå§‹å€¼ä¸º-1
        m = len(s)
        n = len(p)
        for i in range(m):
            memo.append([-1] * n)
        # ç´¢å¼•æŒ‡é’ˆ i,j ä» 0 å¼€å§‹ç§»åŠ¨
        return self.dp(s, 0, p, 0, memo)

    # è®¡ç®— p[j..] æ˜¯å¦åŒ¹é… s[i..]
    def dp(self, s, i, p, j, memo):
        m = len(s)
        n = len(p)
        # å¦‚æœ j è¾¾åˆ°ç»“å°¾ï¼Œåˆ¤æ–­ i æ˜¯å¦ä¹Ÿåˆ°ç»“å°¾
        if j == n:
            return i == m
        # å¦‚æœ i è¾¾åˆ°ç»“å°¾ï¼Œåˆ¤æ–­ j æ¥ä¸‹æ¥çš„å­—ç¬¦èƒ½å¦åŒ¹é…ç©ºä¸²
        if i == m:
            if (n - j) % 2 == 1:
                return False
            for k in range(j + 1, n, 2):
                if p[k] != '*':
                    return False
            return True

        # æŸ¥å¤‡å¿˜å½•ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
        if memo[i][j] != -1:
            return memo[i][j]

        res = False
        if s[i] == p[j] or p[j] == '.':
            if j < n - 1 and p[j + 1] == '*':
                res = self.dp(s, i, p, j + 2, memo) or self.dp(s, i + 1, p, j, memo)
            else:
                res = self.dp(s, i + 1, p, j + 1, memo)
        else:
            if j < n - 1 and p[j + 1] == '*':
                res = self.dp(s, i, p, j + 2, memo)
            else:
                res = False

        # è®°å…¥å½“å‰ç»“æœåˆ°å¤‡å¿˜å½•
        memo[i][j] = res
        return res
```

https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    // å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    unordered_map<int, int> valToIndex;

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for (int i = 0; i < inorder.size(); i++) {
            valToIndex[inorder[i]] = i;
        }
        return build(preorder, 0, preorder.size() - 1,
                    inorder, 0, inorder.size() - 1);
    }

    /*
       å®šä¹‰ï¼šå‰åºéå†æ•°ç»„ä¸º preorder[preStart..preEnd]ï¼Œ
       ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
       æ„é€ è¿™ä¸ªäºŒå‰æ ‘å¹¶è¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    */
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd,
                   vector<int>& inorder, int inStart, int inEnd) {
        if (preStart > preEnd) {
            return nullptr;
        }

        // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        int rootVal = preorder[preStart];
        // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
        int index = valToIndex[rootVal];

        int leftSize = index - inStart;

        // å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
        TreeNode* root = new TreeNode(rootVal);
        /**<extend up -200>
        ![](../pictures/äºŒå‰æ ‘ç³»åˆ—2/4.jpeg)
        */
        // é€’å½’æ„é€ å·¦å³å­æ ‘
        root->left = build(preorder, preStart + 1, preStart + leftSize,
                inorder, inStart, index - 1);

        root->right = build(preorder, preStart + leftSize + 1, preEnd,
                inorder, index + 1, inEnd);
        return root;
    }
};
```

```go
// by chatGPT (go)
func buildTree(preorder []int, inorder []int) *TreeNode {
    indexMap := make(map[int]int)
    for i, val := range inorder {
        indexMap[val] = i
    }
    return build(preorder, inorder, 0, len(preorder)-1, 0, len(inorder)-1, indexMap)
}

func build(preorder []int, inorder []int, preStart int, preEnd int, inStart int, inEnd int, indexMap map[int]int) *TreeNode {
    if preStart > preEnd {
        return nil
    }

    // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    rootVal := preorder[preStart]
    // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
    index := indexMap[rootVal]

    leftSize := index - inStart

    // å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
    root := &TreeNode{Val: rootVal}
    // é€’å½’æ„é€ å·¦å³å­æ ‘
    root.Left = build(preorder, inorder, preStart+1, preStart+leftSize, inStart, index-1, indexMap)
    root.Right = build(preorder, inorder, preStart+leftSize+1, preEnd, index+1, inEnd, indexMap)
    return root
}
```

```java
// by labuladong (java)
class Solution {
    // å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    HashMap<Integer, Integer> valToIndex = new HashMap<>();

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for (int i = 0; i < inorder.length; i++) {
            valToIndex.put(inorder[i], i);
        }
        return build(preorder, 0, preorder.length - 1,
                    inorder, 0, inorder.length - 1);
    }

    /*
       å®šä¹‰ï¼šå‰åºéå†æ•°ç»„ä¸º preorder[preStart..preEnd]ï¼Œ
       ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
       æ„é€ è¿™ä¸ªäºŒå‰æ ‘å¹¶è¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    */
    TreeNode build(int[] preorder, int preStart, int preEnd,
                   int[] inorder, int inStart, int inEnd) {
        if (preStart > preEnd) {
            return null;
        }

        // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        int rootVal = preorder[preStart];
        // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
        int index = valToIndex.get(rootVal);

        int leftSize = index - inStart;

        // å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
        TreeNode root = new TreeNode(rootVal);
        /**<extend up -200>
        ![](../pictures/äºŒå‰æ ‘ç³»åˆ—2/4.jpeg)
        */
        // é€’å½’æ„é€ å·¦å³å­æ ‘
        root.left = build(preorder, preStart + 1, preStart + leftSize,
                inorder, inStart, index - 1);

        root.right = build(preorder, preStart + leftSize + 1, preEnd,
                inorder, index + 1, inEnd);
        return root;
    }
}
```

```javascript
// by chatGPT (javascript)
var buildTree = function(preorder, inorder) {
    // å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
    const valToIndex = new Map();
    for (let i = 0; i < inorder.length; i++) {
        valToIndex.set(inorder[i], i);
    }
    return build(preorder, 0, preorder.length - 1,
                    inorder, 0, inorder.length - 1);
};

/*
   å®šä¹‰ï¼šå‰åºéå†æ•°ç»„ä¸º preorder[preStart..preEnd]ï¼Œ
   ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
   æ„é€ è¿™ä¸ªäºŒå‰æ ‘å¹¶è¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
*/
function build(preorder, preStart, preEnd,
                   inorder, inStart, inEnd) {
    if (preStart > preEnd) {
        return null;
    }

    // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    const rootVal = preorder[preStart];
    // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
    const index = valToIndex.get(rootVal);

    const leftSize = index - inStart;

    // å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
    const root = new TreeNode(rootVal);
    /**<extend up -200>
    ![](../pictures/äºŒå‰æ ‘ç³»åˆ—2/4.jpeg)
    */
    // é€’å½’æ„é€ å·¦å³å­æ ‘
    root.left = build(preorder, preStart + 1, preStart + leftSize,
            inorder, inStart, index - 1);

    root.right = build(preorder, preStart + leftSize + 1, preEnd,
            inorder, index + 1, inEnd);
    return root;
}
```

```python
# by chatGPT (python)
class Solution:
    def __init__(self):
        # å­˜å‚¨ inorder ä¸­å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
        self.valToIndex = {}

    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        for i in range(len(inorder)):
            self.valToIndex[inorder[i]] = i
        return self.build(preorder, 0, len(preorder) - 1,
                           inorder, 0, len(inorder) - 1)

    '''
       å®šä¹‰ï¼šå‰åºéå†æ•°ç»„ä¸º preorder[preStart..preEnd]ï¼Œ
       ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ
       æ„é€ è¿™ä¸ªäºŒå‰æ ‘å¹¶è¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    '''

    def build(self, preorder: List[int], preStart: int, preEnd: int,
              inorder: List[int], inStart: int, inEnd: int) -> TreeNode:
        if preStart > preEnd:
            return None

        # root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        rootVal = preorder[preStart]
        # rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•
        index = self.valToIndex[rootVal]

        leftSize = index - inStart

        # å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
        root = TreeNode(rootVal)
        """
        <extend up -200>
        ![](../pictures/äºŒå‰æ ‘ç³»åˆ—2/4.jpeg)
        """

        # é€’å½’æ„é€ å·¦å³å­æ ‘
        root.left = self.build(preorder, preStart + 1, preStart + leftSize,
                               inorder, inStart, index - 1)

        root.right = self.build(preorder, preStart + leftSize + 1, preEnd,
                                inorder, index + 1, inEnd)
        return root
```

https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    vector<string> permutation(string s) {
        permuteUnique(s);
        // æ ¹æ® res å®¹é‡æ„é€ è¿”å›æ•°ç»„
        vector<string> arr = vector<string>(res.size());
        for (int i = 0; i < res.size(); i++) {
            arr[i] = res[i];
        }
        return arr;
    }

    // ä¿å­˜æ‰€æœ‰çš„æ’åˆ—ç»“æœ
    vector<string> res;
    // æ’åˆ—çš„è¿‡ç¨‹ä¸­è®°å½•ä¸€æ¡æ’åˆ—è·¯å¾„
    string track;
    // æ ‡è®°åœ¨è¿™ä¸ªæ’åˆ—è·¯å¾„ä¸­å“ªäº›å…ƒç´ å·²ç»è¢«è®¿é—®è¿‡
    vector<bool> used;

    void permuteUnique(string nums) {
        // å…ˆå¯¹æ’åˆ—çš„å…ƒç´ è¿›è¡Œæ’åºï¼Œç›¸åŒå…ƒç´ æ­£ç€æ’åˆ—
        sort(nums.begin(), nums.end());
        // åˆå§‹åŒ– used æ•°ç»„ä¸º false
        used.resize(nums.size(), false);
        backtrack(nums);
    }

    void backtrack(string nums) {
        // å¦‚æœç”Ÿæˆçš„è·¯å¾„é•¿åº¦ç­‰äºå…ƒç´ é•¿åº¦ï¼Œè¿™å°±æ˜¯ä¸€æ¡å®Œæ•´çš„æ’åˆ—è·¯å¾„ï¼Œæ·»åŠ åˆ° res ä¸­
        if (track.length() == nums.length()) {
            res.push_back(track);
            return;
        }

        // æšä¸¾æ’åˆ—è·¯å¾„ä¸­æ‰€æœ‰æœªä½¿ç”¨çš„å…ƒç´ 
        for (int i = 0; i < nums.length(); i++) {
            // å¦‚æœè¿™ä¸ªå…ƒç´ å·²ç»è¢«è®¿é—®è¿‡ï¼Œç›´æ¥è·³è¿‡
            if (used[i]) {
                continue;
            }
            // ä½¿ç”¨è¿™ä¸ªå…ƒç´ æ—¶ï¼Œåº”å¯¹é€šè¿‡è®¿é—®é¡ºåºæ¥é¿å…å…¶ä¸­ç›¸åŒå…ƒç´ é¡ºåºä¸åŒçš„é‡å¤æ’åˆ—
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
                continue;
            }
            // å°†è¿™ä¸ªå…ƒç´ æ·»åŠ åˆ°æ’åˆ—è·¯å¾„ä¸­
            track.push_back(nums[i]);
            used[i] = true;
            backtrack(nums);
            track.pop_back();
            used[i] = false;
        }
    }
};
```

```go
// by chatGPT (go)
import "sort"

func permutation(s string) []string {
    res := []string{}
    track := []byte{}
    used := make([]bool, len(s))
    nums := []byte(s)
    sort.Slice(nums, func(i, j int) bool { return nums[i] < nums[j] })
    backtrack(nums, &res, track, used)
    return res
}

func backtrack(nums []byte, res *[]string, track []byte, used []bool) {
    if len(track) == len(nums) {
        *res = append(*res, string(track))
        return
    }

    for i := 0; i < len(nums); i++ {
        if used[i] {
            continue
        }
        // æ–°æ·»åŠ çš„å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½®
        if i > 0 && nums[i] == nums[i-1] && !used[i-1] {
            continue
        }
        track = append(track, nums[i])
        used[i] = true
        backtrack(nums, res, track, used)
        track = track[:len(track)-1]
        used[i] = false
    }
}
```

```java
// by labuladong (java)
class Solution {
    public String[] permutation(String s) {
        permuteUnique(s.toCharArray());
        String[] arr = new String[res.size()];
        for (int i = 0; i < res.size(); i++) {
            arr[i] = res.get(i);
        }
        return arr;
    }

    List<String> res = new ArrayList<>();
    StringBuilder track = new StringBuilder();
    boolean[] used;

    public List<String> permuteUnique(char[] nums) {
        // å…ˆæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·
        Arrays.sort(nums);
        used = new boolean[nums.length];
        backtrack(nums);
        return res;
    }

    void backtrack(char[] nums) {
        if (track.length() == nums.length) {
            res.add(track.toString());
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }
            // æ–°æ·»åŠ çš„å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½®
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
                continue;
            }
            track.append(nums[i]);
            used[i] = true;
            backtrack(nums);
            track.deleteCharAt(track.length() - 1);
            used[i] = false;
        }
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {string} s
 * @return {string[]}
 */
var permutation = function(s) {
    let res = [];
    let track = [];
    let used;

    var permuteUnique = function(nums) {
        // å…ˆæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·
        nums.sort();
        used = new Array(nums.length).fill(false);
        backtrack(nums);
        return res;
    };

    var backtrack = function(nums) {
        if (track.length === nums.length) {
            res.push(track.join(""));
            return;
        }

        for (let i = 0; i < nums.length; i++) {
            if (used[i]) {
            continue;
            }
            // æ–°æ·»åŠ çš„å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½®
            if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {
            continue;
            }
            track.push(nums[i]);
            used[i] = true;
            backtrack(nums);
            track.pop();
            used[i] = false;
        }
    };

    permuteUnique(s.split(""));
    let arr = new Array(res.size());
    for (let i = 0; i < res.size(); i++) {
        arr[i] = res.get(i);
    }
    return arr;
};
```

```python
# by chatGPT (python)
class Solution:
    def permutation(self, s: str) -> List[str]:
        self.permuteUnique(list(s))
        # å°†ç»“æœè½¬åŒ–ä¸ºå­—ç¬¦ä¸²æ•°ç»„è¿”å›
        arr = [None] * len(self.res)
        for i in range(len(self.res)):
            arr[i] = self.res[i]
        return arr

    # å­˜å‚¨ç»“æœçš„åˆ—è¡¨
    res = []
    # å­˜å‚¨æ¯ä¸€æ¬¡é€’å½’åå¾—åˆ°çš„æ’åˆ—æ–¹æ¡ˆ
    track = ""
    # è®°å½•æ¯ä¸ªå­—ç¬¦æ˜¯å¦è¢«ä½¿ç”¨è¿‡
    used = []

    def permuteUnique(self, nums: List[str]) -> None:
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        # å…ˆæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·
        nums.sort()
        # åˆå§‹åŒ–æ ‡è®°åˆ—è¡¨
        self.used = [False] * len(nums)
        self.backtrack(nums)

    def backtrack(self, nums: List[str]) -> None:
        if len(self.track) == len(nums):
            self.res.append(self.track)
            return

        for i in range(len(nums)):
            if self.used[i]:
                continue
            # æ–°æ·»åŠ çš„å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½®
            if i > 0 and nums[i] == nums[i - 1] and not self.used[i - 1]:
                continue
            self.track += nums[i]
            self.used[i] = True
            self.backtrack(nums)
            self.track = self.track[:-1]
            self.used[i] = False
```

https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/zlDJc7 çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    int openLock(vector<string>& deadends, string target) {
        // è®°å½•éœ€è¦è·³è¿‡çš„æ­»äº¡å¯†ç 
        unordered_set<string> deads(deadends.begin(), deadends.end());
        // è®°å½•å·²ç»ç©·ä¸¾è¿‡çš„å¯†ç ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
        unordered_set<string> visited;
        queue<string> q;
        // ä»èµ·ç‚¹å¼€å§‹å¯åŠ¨å¹¿åº¦ä¼˜å…ˆæœç´¢
        int step = 0;
        q.push("0000");
        visited.emplace("0000");

        while (!q.empty()) {
            int sz = q.size();
            /* å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å‘¨å›´æ‰©æ•£ */
            for (int i = 0; i < sz; i++) {
                string cur = q.front();
                q.pop();

                /* åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹ */
                if (deads.find(cur) != deads.end())
                    continue;
                if (cur == target)
                    return step;

                /* å°†ä¸€ä¸ªèŠ‚ç‚¹çš„æœªéå†ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */
                for (int j = 0; j < 4; j++) {
                    string up = plusOne(cur, j);
                    if (visited.find(up) == visited.end()) {
                        q.push(up);
                        visited.emplace(up);
                    }
                    string down = minusOne(cur, j);
                    if (visited.find(down) == visited.end()) {
                        q.push(down);
                        visited.emplace(down);
                    }
                }
            }
            /* åœ¨è¿™é‡Œå¢åŠ æ­¥æ•° */
            step++;
        }
        // å¦‚æœç©·ä¸¾å®Œéƒ½æ²¡æ‰¾åˆ°ç›®æ ‡å¯†ç ï¼Œé‚£å°±æ˜¯æ‰¾ä¸åˆ°äº†
        return -1;
    }

    // å°† s[j] å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡
    string plusOne(string s, int j) {
        if (s[j] == '9')
            s[j] = '0';
        else
            s[j] += 1;
        return s;
    }

    // å°† s[i] å‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡
    string minusOne(string s, int j) {
        if (s[j] == '0')
            s[j] = '9';
        else
            s[j] -= 1;
        return s;
    }
};
```

```go
// by chatGPT (go)
func openLock(deadends []string, target string) int {
    // è®°å½•éœ€è¦è·³è¿‡çš„æ­»äº¡å¯†ç 
    var deads = map[string]bool{}
    for _, s := range deadends {
        deads[s] = true
    }
    // è®°å½•å·²ç»ç©·ä¸¾è¿‡çš„å¯†ç ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
    var visited = map[string]bool{}
    q := []string{"0000"}
    // ä»èµ·ç‚¹å¼€å§‹å¯åŠ¨å¹¿åº¦ä¼˜å…ˆæœç´¢
    step := 0
    visited["0000"] = true

    for len(q) > 0 {
        sz := len(q)
        /* å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å‘¨å›´æ‰©æ•£ */
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]

            /* åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹ */
            if deads[cur] {
                continue
            }
            if cur == target {
                return step
            }

            /* å°†ä¸€ä¸ªèŠ‚ç‚¹çš„æœªéå†ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */
            for j := 0; j < 4; j++ {
                up := plusOne(cur, j)
                if !visited[up] {
                    q = append(q, up)
                    visited[up] = true
                }
                down := minusOne(cur, j)
                if !visited[down] {
                    q = append(q, down)
                    visited[down] = true
                }
            }
        }
        /* åœ¨è¿™é‡Œå¢åŠ æ­¥æ•° */
        step++
    }
    // å¦‚æœç©·ä¸¾å®Œéƒ½æ²¡æ‰¾åˆ°ç›®æ ‡å¯†ç ï¼Œé‚£å°±æ˜¯æ‰¾ä¸åˆ°äº†
    return -1
}

// å°† s[j] å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡
func plusOne(s string, j int) string {
    ch := []byte(s)
    if ch[j] == '9' {
        ch[j] = '0'
    } else {
        ch[j] += 1
    }
    return string(ch)
}

// å°† s[i] å‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡
func minusOne(s string, j int) string {
    ch := []byte(s)
    if ch[j] == '0' {
        ch[j] = '9'
    } else {
        ch[j] -= 1
    }
    return string(ch)
}
```

```java
// by labuladong (java)
class Solution {
    public int openLock(String[] deadends, String target) {
        // è®°å½•éœ€è¦è·³è¿‡çš„æ­»äº¡å¯†ç 
        Set<String> deads = new HashSet<>();
        for (String s : deadends) deads.add(s);
        // è®°å½•å·²ç»ç©·ä¸¾è¿‡çš„å¯†ç ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
        Set<String> visited = new HashSet<>();
        Queue<String> q = new LinkedList<>();
        // ä»èµ·ç‚¹å¼€å§‹å¯åŠ¨å¹¿åº¦ä¼˜å…ˆæœç´¢
        int step = 0;
        q.offer("0000");
        visited.add("0000");

        while (!q.isEmpty()) {
            int sz = q.size();
            /* å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å‘¨å›´æ‰©æ•£ */
            for (int i = 0; i < sz; i++) {
                String cur = q.poll();

                /* åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹ */
                if (deads.contains(cur))
                    continue;
                if (cur.equals(target))
                    return step;

                /* å°†ä¸€ä¸ªèŠ‚ç‚¹çš„æœªéå†ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */
                for (int j = 0; j < 4; j++) {
                    String up = plusOne(cur, j);
                    if (!visited.contains(up)) {
                        q.offer(up);
                        visited.add(up);
                    }
                    String down = minusOne(cur, j);
                    if (!visited.contains(down)) {
                        q.offer(down);
                        visited.add(down);
                    }
                }
            }
            /* åœ¨è¿™é‡Œå¢åŠ æ­¥æ•° */
            step++;
        }
        // å¦‚æœç©·ä¸¾å®Œéƒ½æ²¡æ‰¾åˆ°ç›®æ ‡å¯†ç ï¼Œé‚£å°±æ˜¯æ‰¾ä¸åˆ°äº†
        return -1;
    }

    // å°† s[j] å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡
    String plusOne(String s, int j) {
        char[] ch = s.toCharArray();
        if (ch[j] == '9')
            ch[j] = '0';
        else
            ch[j] += 1;
        return new String(ch);
    }

    // å°† s[i] å‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡
    String minusOne(String s, int j) {
        char[] ch = s.toCharArray();
        if (ch[j] == '0')
            ch[j] = '9';
        else
            ch[j] -= 1;
        return new String(ch);
    }
}
```

```javascript
// by chatGPT (javascript)
var openLock = function (deadends, target) {
  // è®°å½•éœ€è¦è·³è¿‡çš„æ­»äº¡å¯†ç 
  const deads = new Set(deadends);
  // è®°å½•å·²ç»ç©·ä¸¾è¿‡çš„å¯†ç ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
  const visited = new Set();
  const q = [];
  let step = 0;
  // ä»èµ·ç‚¹å¼€å§‹å¯åŠ¨å¹¿åº¦ä¼˜å…ˆæœç´¢
  q.push("0000");
  visited.add("0000");

  while (q.length > 0) {
    let sz = q.length;
    /* å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å‘¨å›´æ‰©æ•£ */
    for (let i = 0; i < sz; i++) {
      let cur = q.shift();
      /* åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹ */
      if (deads.has(cur)) {
        continue;
      }
      if (cur === target) {
        return step;
      }
      /* å°†ä¸€ä¸ªèŠ‚ç‚¹çš„æœªéå†ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */
      for (let j = 0; j < 4; j++) {
        let up = plusOne(cur, j);
        if (!visited.has(up)) {
          q.push(up);
          visited.add(up);
        }
        let down = minusOne(cur, j);
        if (!visited.has(down)) {
          q.push(down);
          visited.add(down);
        }
      }
    }
    /* åœ¨è¿™é‡Œå¢åŠ æ­¥æ•° */
    step++;
  }
  // å¦‚æœç©·ä¸¾å®Œéƒ½æ²¡æ‰¾åˆ°ç›®æ ‡å¯†ç ï¼Œé‚£å°±æ˜¯æ‰¾ä¸åˆ°äº†
  return -1;

  // å°† s[j] å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡
  function plusOne(s, j) {
    let ch = s.split('');
    if (ch[j] === '9') {
      ch[j] = '0';
    } else {
      ch[j] = (+ch[j] + 1).toString();
    }
    return ch.join('');
  }
  // å°† s[i] å‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡
  function minusOne(s, j) {
    let ch = s.split('');
    if (ch[j] === '0') {
      ch[j] = '9';
    } else {
      ch[j] = (+ch[j] - 1).toString();
    }
    return ch.join('');
  }
};
```

```python
# by chatGPT (python)
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        #è®°å½•éœ€è¦è·³è¿‡çš„æ­»äº¡å¯†ç 
        deads = set(deadends)
        #è®°å½•å·²ç»ç©·ä¸¾è¿‡çš„å¯†ç ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
        visited = set()
        q = deque()
        #ä»èµ·ç‚¹å¼€å§‹å¯åŠ¨å¹¿åº¦ä¼˜å…ˆæœç´¢
        step = 0
        q.append("0000")
        visited.add("0000")

        while q:
            sz = len(q)
            #å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å‘¨å›´æ‰©æ•£
            for i in range(sz):
                cur = q.popleft()

                #åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
                if cur in deads:
                    continue
                if cur == target:
                    return step

                # å°†ä¸€ä¸ªèŠ‚ç‚¹çš„æœªéå†ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
                for j in range(4):
                    up = self.plusOne(cur, j)
                    if up not in visited:
                        q.append(up)
                        visited.add(up)
                    down = self.minusOne(cur, j)
                    if down not in visited:
                        q.append(down)
                        visited.add(down)

            #åœ¨è¿™é‡Œå¢åŠ æ­¥æ•°
            step += 1
        #å¦‚æœç©·ä¸¾å®Œéƒ½æ²¡æ‰¾åˆ°ç›®æ ‡å¯†ç ï¼Œé‚£å°±æ˜¯æ‰¾ä¸åˆ°äº†
        return -1

    
    #å°† s[j] å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡
    def plusOne(self, s: str, j: int) -> str:
        ch = list(s)
        if ch[j] == '9':
            ch[j] = '0'
        else:
            ch[j] = chr(ord(ch[j]) + 1)
        return "".join(ch)

    #å°† s[i] å‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡
    def minusOne(self, s: str, j: int) -> str:
        ch = list(s)
        if ch[j] == '0':
            ch[j] = '9'
        else:
            ch[j] = chr(ord(ch[j]) - 1)
        return "".join(ch)
```

https://leetcode.cn/problems/zlDJc7 çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by labuladong (cpp)
class Solution {
    public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> window;

        int left = 0, right = 0;
        int res = 0; // è®°å½•ç»“æœ
        while (right < s.size()) {
            char c = s[right];
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            window[c]++;
            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (window[c] > 1) {
                char d = s[left];
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                window[d]--;
            }
            // åœ¨è¿™é‡Œæ›´æ–°ç­”æ¡ˆ
            res = max(res, right - left);
        }
        return res;
    }
};
```

```go
// by chatGPT (go)
/**
 * @param s: a string
 * @return: the length of the longest substring without repeating characters
 */
func lengthOfLongestSubstring(s string) int {
    window := make(map[byte]int)

    left, right := 0, 0
    res := 0 // è®°å½•ç»“æœ
    for right < len(s) {
        c := s[right]
        right++
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        window[c]++
        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        for window[c] > 1 {
            d := s[left]
            left++
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            window[d]--
        }
        // åœ¨è¿™é‡Œæ›´æ–°ç­”æ¡ˆ
        res = max(res, right - left)
    }
    return res
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

```java
// by chatGPT (java)
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> window = new HashMap<>();

        int left = 0, right = 0;
        int res = 0; // è®°å½•ç»“æœ
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            window.put(c, window.getOrDefault(c, 0) + 1);
            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (window.get(c) > 1) {
                char d = s.charAt(left);
                left++;
                // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                window.put(d, window.get(d) - 1);
            }
            // åœ¨è¿™é‡Œæ›´æ–°ç­”æ¡ˆ
            res = Math.max(res, right - left);
        }
        return res;
    }
}
```

```javascript
// by chatGPT (javascript)
var lengthOfLongestSubstring = function(s) {
    // å“ˆå¸Œè¡¨è®°å½•çª—å£ä¸­å­—ç¬¦å‡ºç°çš„æ¬¡æ•°
    var window = new Map();
    // å·¦æŒ‡é’ˆã€å³æŒ‡é’ˆ
    var left = 0, right = 0;
    // æœ€é•¿å­ä¸²é•¿åº¦
    var res = 0;
    while (right < s.length) {
        // ç§»åŠ¨å³æŒ‡é’ˆï¼Œæ‰©å¤§çª—å£
        var c = s.charAt(right);
        right++;
        // æ›´æ–°å“ˆå¸Œè¡¨
        if(window.has(c)){
            window.set(c, window.get(c) + 1);
        } else {
            window.set(c, 1);
        }
        // å¦‚æœå½“å‰å­—ç¬¦åœ¨çª—å£ä¸­å·²ç»å‡ºç°è¿‡ï¼Œåˆ™è€ƒè™‘æ”¶ç¼©çª—å£
        while (window.get(c) > 1) {
            // ç§»åŠ¨å·¦æŒ‡é’ˆï¼Œæ”¶ç¼©çª—å£
            var d = s.charAt(left);
            left++;
            // æ›´æ–°å“ˆå¸Œè¡¨
            window.set(d, window.get(d) - 1);
        }
        // æ›´æ–°æœ€é•¿å­ä¸²é•¿åº¦
        res = Math.max(res, right - left);
    }
    return res;
};
```

```python
# by chatGPT (python)
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        window = {}  # ç”¨äºè®°å½•çª—å£ä¸­å„å­—ç¬¦å‡ºç°çš„æ¬¡æ•°
        left = right = res = 0  # leftä¸ºçª—å£å·¦è¾¹ç•Œï¼Œrightä¸ºçª—å£å³è¾¹ç•Œï¼Œ[left, right)ä¸ºå½“å‰çª—å£ï¼Œresç”¨æ¥è®°å½•æœ€é•¿æ— é‡å¤å­ä¸²çš„é•¿åº¦

        while right < len(s):
            c = s[right]
            right += 1
            window[c] = window.get(c, 0) + 1  # å°†å­—ç¬¦cçš„å‡ºç°æ¬¡æ•°åŠ 1

            while window[c] > 1:  # å½“å³ä¾§çª—å£ä¸­çš„å­—ç¬¦cçš„ä¸ªæ•°å¤§äº1æ—¶ï¼Œè¯´æ˜å½“å‰çª—å£ä¸­ä¸ç¬¦åˆæ¡ä»¶ï¼Œéœ€è¦è¿›è¡Œè°ƒæ•´
                d = s[left]
                left += 1
                window[d] -= 1  # å°†çª—å£å·¦ä¾§çš„å­—ç¬¦dç§»å‡ºçª—å£ï¼Œå…¶åœ¨windowä¸­çš„å‡ºç°æ¬¡æ•°å‡1

            res = max(res, right - left)  # æ›´æ–°æœ€é•¿æ— é‡å¤å­ä¸²çš„é•¿åº¦

        return res
```

https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
// äºŒå‰å †çš„è§£æ³•æ€è·¯
class Solution1 {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        // å¤§é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å¤§å…ƒç´ 
        priority_queue<int> pq;
        for (int e : arr) {
            // æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
            pq.push(e);
            // å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
            if (pq.size() > k) {
                pq.pop();
            }
        }
        // pq ä¸­å‰©ä¸‹çš„æ˜¯ arr ä¸­æœ€å°çš„ k ä¸ªå…ƒç´ 
        vector<int> res(k);
        int i = 0;
        while (!pq.empty()) {
            res[i] = pq.top();
            pq.pop();
            i++;
        }
        return res;
    }
};

// å¿«é€Ÿé€‰æ‹©çš„è§£æ³•æ€è·¯
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int> res(k);
        // æ³¨æ„æ­¤é¢˜çš„ k æ˜¯å…ƒç´ ä¸ªæ•°è€Œä¸æ˜¯ç´¢å¼•ï¼Œæ‰€ä»¥å’Œç´¢å¼• p åšæ¯”è¾ƒæ—¶è¦ - 1
        // é¦–å…ˆéšæœºæ‰“ä¹±æ•°ç»„
        shuffle(arr);
        int lo = 0, hi = arr.size() - 1;
        // ç°åœ¨å¼€å§‹å¯»æ‰¾ç¬¬ k å¤§çš„å…ƒç´ 
        while (lo <= hi) {
            // åœ¨ arr[lo..hi] ä¸­é€‰ä¸€ä¸ªåˆ†ç•Œç‚¹
            int p = partition(arr, lo, hi);
            if (p < k - 1) {
                // ç¬¬ k å¤§çš„å…ƒç´ åœ¨ arr[p+1..hi] ä¸­
                lo = p + 1;
            } else if (p > k - 1) {
                // ç¬¬ k å¤§çš„å…ƒç´ åœ¨ arr[lo..p-1] ä¸­
                hi = p - 1;
            } else {
                // arr[p] å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼Œåˆå› ä¸ºå¿«é€Ÿæ’åºçš„æ€§è´¨ï¼Œ
                // arr[p] å·¦è¾¹çš„å…ƒç´ éƒ½æ¯” arr[p] å°ï¼Œæ‰€ä»¥ç°åœ¨ arr[0..k] å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„ç­”æ¡ˆ
                for (int i = 0; i < k; i++) {
                    res[i] = arr[i];
                }
                return res;
            }
        }
        return res;
    }

    // å¯¹ nums[lo..hi] è¿›è¡Œåˆ‡åˆ†
    int partition(vector<int>& nums, int lo, int hi) {
        int pivot = nums[lo];
        // å…³äºåŒºé—´çš„è¾¹ç•Œæ§åˆ¶éœ€æ ¼å¤–å°å¿ƒï¼Œç¨æœ‰ä¸æ…å°±ä¼šå‡ºé”™
        // æˆ‘è¿™é‡ŒæŠŠ i, j å®šä¹‰ä¸ºå¼€åŒºé—´ï¼ŒåŒæ—¶å®šä¹‰ï¼š
        // [lo, i) <= pivotï¼›(j, hi] > pivot
        // ä¹‹åéƒ½è¦æ­£ç¡®ç»´æŠ¤è¿™ä¸ªè¾¹ç•ŒåŒºé—´çš„å®šä¹‰
        int i = lo + 1, j = hi;
        // å½“ i > j æ—¶ç»“æŸå¾ªç¯ï¼Œä»¥ä¿è¯åŒºé—´ [lo, hi] éƒ½è¢«è¦†ç›–
        while (i <= j) {
            while (i < hi && nums[i] <= pivot) {
                i++;
                // æ­¤ while ç»“æŸæ—¶æ°å¥½ nums[i] > pivot
            }
            while (j > lo && nums[j] > pivot) {
                j--;
                // æ­¤ while ç»“æŸæ—¶æ°å¥½ nums[j] <= pivot
            }

            if (i >= j) {
                break;
            }
            // æ­¤æ—¶ [lo, i) <= pivot && (j, hi] > pivot
            // äº¤æ¢ nums[j] å’Œ nums[i]
            swap(nums[i], nums[j]);
            // æ­¤æ—¶ [lo, i] <= pivot && [j, hi] > pivot
        }
        // æœ€åå°† pivot æ”¾åˆ°åˆé€‚çš„ä½ç½®ï¼Œå³ pivot å·¦è¾¹å…ƒç´ è¾ƒå°ï¼Œå³è¾¹å…ƒç´ è¾ƒå¤§
        swap(nums[lo], nums[j]);
        return j;
    }

    // æ´—ç‰Œç®—æ³•ï¼Œå°†è¾“å…¥çš„æ•°ç»„éšæœºæ‰“ä¹±
    void shuffle(vector<int>& nums) {
        srand((unsigned)time(NULL));
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            // ç”Ÿæˆ [i, n - 1] çš„éšæœºæ•°
            int r = i + rand() % (n - i);
            swap(nums[i], nums[r]);
        }
    }

    // åŸåœ°äº¤æ¢æ•°ç»„ä¸­çš„ä¸¤ä¸ªå…ƒç´ 
    void swap(int& a, int& b) {
        int temp = a;
        a = b;
        b = temp;
    }
};
```

```go
// by chatGPT (go)
// äºŒå‰å †çš„è§£æ³•æ€è·¯
func getLeastNumbers(arr []int, k int) []int {
    // å¤§é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å¤§å…ƒç´ 
    pq := make(IntHeap, 0)
    heap.Init(&pq)
    for _, e := range arr {
        // æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
        heap.Push(&pq, e)
        // å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
        if pq.Len() > k {
            heap.Pop(&pq)
        }
    }
    // pq ä¸­å‰©ä¸‹çš„æ˜¯ arr ä¸­æœ€å°çš„ k ä¸ªå…ƒç´ 
    res := make([]int, k)
    i := 0
    for pq.Len() > 0 {
        res[i] = heap.Pop(&pq).(int)
        i++
    }
    return res
}

type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

// å¿«é€Ÿé€‰æ‹©çš„è§£æ³•æ€è·¯
func getLeastNumbers(arr []int, k int) []int {
    res := make([]int, k)
    // æ³¨æ„æ­¤é¢˜çš„ k æ˜¯å…ƒç´ ä¸ªæ•°è€Œä¸æ˜¯ç´¢å¼•ï¼Œæ‰€ä»¥å’Œç´¢å¼• p åšæ¯”è¾ƒæ—¶è¦ - 1
    // é¦–å…ˆéšæœºæ‰“ä¹±æ•°ç»„
    shuffle(arr)
    lo, hi := 0, len(arr)-1
    // ç°åœ¨å¼€å§‹å¯»æ‰¾ç¬¬ k å¤§çš„å…ƒç´ 
    for lo <= hi {
        // åœ¨ arr[lo..hi] ä¸­é€‰ä¸€ä¸ªåˆ†ç•Œç‚¹
        p := partition(arr, lo, hi)
        if p < k-1 {
            // ç¬¬ k å¤§çš„å…ƒç´ åœ¨ arr[p+1..hi] ä¸­
            lo = p + 1
        } else if p > k-1 {
            // ç¬¬ k å¤§çš„å…ƒç´ åœ¨ arr[lo..p-1] ä¸­
            hi = p - 1
        } else {
            // arr[p] å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼Œåˆå› ä¸ºå¿«é€Ÿæ’åºçš„æ€§è´¨ï¼Œ
            // arr[p] å·¦è¾¹çš„å…ƒç´ éƒ½æ¯” arr[p] å°ï¼Œæ‰€ä»¥ç°åœ¨ arr[0..k] å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„ç­”æ¡ˆ
            copy(res, arr[:k])
            return res
        }
    }
    return res
}

// å¯¹ nums[lo..hi] è¿›è¡Œåˆ‡åˆ†
func partition(nums []int, lo, hi int) int {
    pivot := nums[lo]
    // å…³äºåŒºé—´çš„è¾¹ç•Œæ§åˆ¶éœ€æ ¼å¤–å°å¿ƒï¼Œç¨æœ‰ä¸æ…å°±ä¼šå‡ºé”™
    // æˆ‘è¿™é‡ŒæŠŠ i, j å®šä¹‰ä¸ºå¼€åŒºé—´ï¼ŒåŒæ—¶å®šä¹‰ï¼š
    // [lo, i) <= pivotï¼›(j, hi] > pivot
    // ä¹‹åéƒ½è¦æ­£ç¡®ç»´æŠ¤è¿™ä¸ªè¾¹ç•ŒåŒºé—´çš„å®šä¹‰
    i, j := lo+1, hi
    // å½“ i > j æ—¶ç»“æŸå¾ªç¯ï¼Œä»¥ä¿è¯åŒºé—´ [lo, hi] éƒ½è¢«è¦†ç›–
    for i <= j {
        for i < hi && nums[i] <= pivot {
            i++
            // æ­¤ while ç»“æŸæ—¶æ°å¥½ nums[i] > pivot
        }
        for j > lo && nums[j] > pivot {
            j--
            // æ­¤ while ç»“æŸæ—¶æ°å¥½ nums[j] <= pivot
        }

        if i >= j {
            break
        }
        // æ­¤æ—¶ [lo, i) <= pivot && (j, hi] > pivot
        // äº¤æ¢ nums[j] å’Œ nums[i]
        nums[i], nums[j] = nums[j], nums[i]
        // æ­¤æ—¶ [lo, i] <= pivot && [j, hi] > pivot
    }
    // æœ€åå°† pivot æ”¾åˆ°åˆé€‚çš„ä½ç½®ï¼Œå³ pivot å·¦è¾¹å…ƒç´ è¾ƒå°ï¼Œå³è¾¹å…ƒç´ è¾ƒå¤§
    nums[lo], nums[j] = nums[j], nums[lo]
    return j
}

// æ´—ç‰Œç®—æ³•ï¼Œå°†è¾“å…¥çš„æ•°ç»„éšæœºæ‰“ä¹±
func shuffle(nums []int) {
    rand.Seed(time.Now().UnixNano())
    n := len(nums)
    for i := 0; i < n; i++ {
        // ç”Ÿæˆ [i, n - 1] çš„éšæœºæ•°
        r := i + rand.Intn(n-i)
        nums[i], nums[r] = nums[r], nums[i]
    }
}
```

```java
// by labuladong (java)
// äºŒå‰å †çš„è§£æ³•æ€è·¯
class Solution1 {
    public int[] getLeastNumbers(int[] arr, int k) {
        // å¤§é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å¤§å…ƒç´ 
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> {
            return b - a;
        });
        for (int e : arr) {
            // æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
            pq.offer(e);
            // å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
            if (pq.size() > k) {
                pq.poll();
            }
        }
        // pq ä¸­å‰©ä¸‹çš„æ˜¯ arr ä¸­æœ€å°çš„ k ä¸ªå…ƒç´ 
        int[] res = new int[k];
        int i = 0;
        while (!pq.isEmpty()) {
            res[i] = pq.poll();
            i++;
        }
        return res;
    }
}

// å¿«é€Ÿé€‰æ‹©çš„è§£æ³•æ€è·¯
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        int[] res = new int[k];
        // æ³¨æ„æ­¤é¢˜çš„ k æ˜¯å…ƒç´ ä¸ªæ•°è€Œä¸æ˜¯ç´¢å¼•ï¼Œæ‰€ä»¥å’Œç´¢å¼• p åšæ¯”è¾ƒæ—¶è¦ - 1
        // é¦–å…ˆéšæœºæ‰“ä¹±æ•°ç»„
        shuffle(arr);
        int lo = 0, hi = arr.length - 1;
        // ç°åœ¨å¼€å§‹å¯»æ‰¾ç¬¬ k å¤§çš„å…ƒç´ 
        while (lo <= hi) {
            // åœ¨ arr[lo..hi] ä¸­é€‰ä¸€ä¸ªåˆ†ç•Œç‚¹
            int p = partition(arr, lo, hi);
            if (p < k - 1) {
                // ç¬¬ k å¤§çš„å…ƒç´ åœ¨ arr[p+1..hi] ä¸­
                lo = p + 1;
            } else if (p > k - 1) {
                // ç¬¬ k å¤§çš„å…ƒç´ åœ¨ arr[lo..p-1] ä¸­
                hi = p - 1;
            } else {
                // arr[p] å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼Œåˆå› ä¸ºå¿«é€Ÿæ’åºçš„æ€§è´¨ï¼Œ
                // arr[p] å·¦è¾¹çš„å…ƒç´ éƒ½æ¯” arr[p] å°ï¼Œæ‰€ä»¥ç°åœ¨ arr[0..k] å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„ç­”æ¡ˆ
                for (int i = 0; i < k; i++) {
                    res[i] = arr[i];
                }
                return res;
            }
        }
        return res;
    }

    // å¯¹ nums[lo..hi] è¿›è¡Œåˆ‡åˆ†
    private static int partition(int[] nums, int lo, int hi) {
        int pivot = nums[lo];
        // å…³äºåŒºé—´çš„è¾¹ç•Œæ§åˆ¶éœ€æ ¼å¤–å°å¿ƒï¼Œç¨æœ‰ä¸æ…å°±ä¼šå‡ºé”™
        // æˆ‘è¿™é‡ŒæŠŠ i, j å®šä¹‰ä¸ºå¼€åŒºé—´ï¼ŒåŒæ—¶å®šä¹‰ï¼š
        // [lo, i) <= pivotï¼›(j, hi] > pivot
        // ä¹‹åéƒ½è¦æ­£ç¡®ç»´æŠ¤è¿™ä¸ªè¾¹ç•ŒåŒºé—´çš„å®šä¹‰
        int i = lo + 1, j = hi;
        // å½“ i > j æ—¶ç»“æŸå¾ªç¯ï¼Œä»¥ä¿è¯åŒºé—´ [lo, hi] éƒ½è¢«è¦†ç›–
        while (i <= j) {
            while (i < hi && nums[i] <= pivot) {
                i++;
                // æ­¤ while ç»“æŸæ—¶æ°å¥½ nums[i] > pivot
            }
            while (j > lo && nums[j] > pivot) {
                j--;
                // æ­¤ while ç»“æŸæ—¶æ°å¥½ nums[j] <= pivot
            }

            if (i >= j) {
                break;
            }
            // æ­¤æ—¶ [lo, i) <= pivot && (j, hi] > pivot
            // äº¤æ¢ nums[j] å’Œ nums[i]
            swap(nums, i, j);
            // æ­¤æ—¶ [lo, i] <= pivot && [j, hi] > pivot
        }
        // æœ€åå°† pivot æ”¾åˆ°åˆé€‚çš„ä½ç½®ï¼Œå³ pivot å·¦è¾¹å…ƒç´ è¾ƒå°ï¼Œå³è¾¹å…ƒç´ è¾ƒå¤§
        swap(nums, lo, j);
        return j;
    }

    // æ´—ç‰Œç®—æ³•ï¼Œå°†è¾“å…¥çš„æ•°ç»„éšæœºæ‰“ä¹±
    private static void shuffle(int[] nums) {
        Random rand = new Random();
        int n = nums.length;
        for (int i = 0 ; i < n; i++) {
            // ç”Ÿæˆ [i, n - 1] çš„éšæœºæ•°
            int r = i + rand.nextInt(n - i);
            swap(nums, i, r);
        }
    }

    // åŸåœ°äº¤æ¢æ•°ç»„ä¸­çš„ä¸¤ä¸ªå…ƒç´ 
    private static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

```javascript
// by chatGPT (javascript)
var getLeastNumbers = function(arr, k) {
  // å¤§é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å¤§å…ƒç´ 
  let pq = new PriorityQueue((a, b) => {
    return b - a;
  });
  for (let e of arr) {
    // æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
    pq.offer(e);
    // å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
    if (pq.size() > k) {
      pq.poll();
    }
  }
  // pq ä¸­å‰©ä¸‹çš„æ˜¯ arr ä¸­æœ€å°çš„ k ä¸ªå…ƒç´ 
  let res = new Array(k);
  let i = 0;
  while (pq.size() > 0) {
    res[i] = pq.poll();
    i++;
  }
  return res;
}

class PriorityQueue {
  constructor(compareFn = (a, b) => a - b) {
    this.compareFn = compareFn;
    this.heap = [];
  }

  // è·å–å †çš„å¤§å°
  size() {
    return this.heap.length;
  }

  // è·å–å †é¡¶å…ƒç´ 
  peek() {
    if (this.heap.length === 0) {
      return null;
    }
    return this.heap[0];
  }

  // åˆ é™¤å †é¡¶å…ƒç´ 
  poll() {
    if (this.heap.length === 0) {
      return null;
    }
    const top = this.heap[0];
    const last = this.heap.pop();
    if (this.heap.length > 0) {
      this.heap[0] = last;
      this.siftDown(0);
    }
    return top;
  }

  // å‘å †ä¸­æ’å…¥ä¸€ä¸ªå…ƒç´ 
  offer(elem) {
    this.heap.push(elem);
    this.siftUp(this.heap.length - 1);
  }

  // å…ƒç´ ä¸‹æ»¤æ“ä½œ
  siftDown(k) {
    while (2 * k + 1 < this.heap.length) {
      let j = 2 * k + 1;
      if (j + 1 < this.heap.length && this.compareFn(this.heap[j + 1], this.heap[j]) < 0) {
        j++;
      }
      if (this.compareFn(this.heap[k], this.heap[j]) <= 0) {
        break;
      }
      this.swap(k, j);
      k = j;
    }
  }

  // å…ƒç´ ä¸Šæ»¤æ“ä½œ
  siftUp(k) {
    while (k > 0 && this.compareFn(this.heap[k], this.heap[Math.floor((k - 1) / 2)]) < 0) {
      this.swap(k, Math.floor((k - 1) / 2));
      k = Math.floor((k - 1) / 2);
    }
  }

  // äº¤æ¢å †ä¸­çš„ä¸¤ä¸ªå…ƒç´ 
  swap(i, j) {
    const temp = this.heap[i];
    this.heap[i] = this.heap[j];
    this.heap[j] = temp;
  }
}

var getLeastNumbers = function(arr, k) {
  let res = new Array(k);
  // æ³¨æ„æ­¤é¢˜çš„ k æ˜¯å…ƒç´ ä¸ªæ•°è€Œä¸æ˜¯ç´¢å¼•ï¼Œæ‰€ä»¥å’Œç´¢å¼• p åšæ¯”è¾ƒæ—¶è¦ - 1
  // é¦–å…ˆéšæœºæ‰“ä¹±æ•°ç»„
  shuffle(arr);
  let lo = 0, hi = arr.length - 1;
  // ç°åœ¨å¼€å§‹å¯»æ‰¾ç¬¬ k å¤§çš„å…ƒç´ 
  while (lo <= hi) {
    // åœ¨ arr[lo..hi] ä¸­é€‰ä¸€ä¸ªåˆ†ç•Œç‚¹
    let p = partition(arr, lo, hi);
    if (p < k - 1) {
      // ç¬¬ k å¤§çš„å…ƒç´ åœ¨ arr[p+1..hi] ä¸­
      lo = p + 1;
    } else if (p > k - 1) {
      // ç¬¬ k å¤§çš„å…ƒç´ åœ¨ arr[lo..p-1] ä¸­
      hi = p - 1;
    } else {
      // arr[p] å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼Œåˆå› ä¸ºå¿«é€Ÿæ’åºçš„æ€§è´¨ï¼Œ
      // arr[p] å·¦è¾¹çš„å…ƒç´ éƒ½æ¯” arr[p] å°ï¼Œæ‰€ä»¥ç°åœ¨ arr[0..k] å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„ç­”æ¡ˆ
      for (let i = 0; i < k; i++) {
        res[i] = arr[i];
      }
      return res;
    }
  }
  return res;
}

// å¯¹ nums[lo..hi] è¿›è¡Œåˆ‡åˆ†
function partition(nums, lo, hi) {
  let pivot = nums[lo];
  // å…³äºåŒºé—´çš„è¾¹ç•Œæ§åˆ¶éœ€æ ¼å¤–å°å¿ƒï¼Œç¨æœ‰ä¸æ…å°±ä¼šå‡ºé”™
  // æˆ‘è¿™é‡ŒæŠŠ i, j å®šä¹‰ä¸ºå¼€åŒºé—´ï¼ŒåŒæ—¶å®šä¹‰ï¼š
  // [lo, i) <= pivotï¼›(j, hi] > pivot
  // ä¹‹åéƒ½è¦æ­£ç¡®ç»´æŠ¤è¿™ä¸ªè¾¹ç•ŒåŒºé—´çš„å®šä¹‰
  let i = lo + 1, j = hi;
  // å½“ i > j æ—¶ç»“æŸå¾ªç¯ï¼Œä»¥ä¿è¯åŒºé—´ [lo, hi] éƒ½è¢«è¦†ç›–
  while (i <= j) {
    while (i < hi && nums[i] <= pivot) {
      i++;
      // æ­¤ while ç»“æŸæ—¶æ°å¥½ nums[i] > pivot
    }
    while (j > lo && nums[j] > pivot) {
      j--;
      // æ­¤ while ç»“æŸæ—¶æ°å¥½ nums[j] <= pivot
    }

    if (i >= j) {
      break;
    }
    // æ­¤æ—¶ [lo, i) <= pivot && (j, hi] > pivot
    // äº¤æ¢ nums[j] å’Œ nums[i]
    swap(nums, i, j);
    // æ­¤æ—¶ [lo, i] <= pivot && [j, hi] > pivot
  }
  // æœ€åå°† pivot æ”¾åˆ°åˆé€‚çš„ä½ç½®ï¼Œå³ pivot å·¦è¾¹å…ƒç´ è¾ƒå°ï¼Œå³è¾¹å…ƒç´ è¾ƒå¤§
  swap(nums, lo, j);
  return j;
}

// æ´—ç‰Œç®—æ³•ï¼Œå°†è¾“å…¥çš„æ•°ç»„éšæœºæ‰“ä¹±
function shuffle(nums) {
  let rand = new Random();
  let n = nums.length;
  for (let i = 0; i < n; i++) {
    // ç”Ÿæˆ [i, n - 1] çš„éšæœºæ•°
    let r = i + rand.nextInt(n - i);
    swap(nums, i, r);
  }
}

// åŸåœ°äº¤æ¢æ•°ç»„ä¸­çš„ä¸¤ä¸ªå…ƒç´ 
function swap(nums, i, j) {
  let temp = nums[i];
  nums[i] = nums[j];
  nums[j] = temp;
}

class Random {
  nextInt(bound) {
    return Math.floor(Math.random() * bound);
  }
}
```

```python
# by chatGPT (python)
# äºŒå‰å †çš„è§£æ³•æ€è·¯
class Solution1:
    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        # å¤§é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å¤§å…ƒç´ 
        pq = []
        for e in arr:
            # æ¯ä¸ªå…ƒç´ éƒ½è¦è¿‡ä¸€éäºŒå‰å †
            heapq.heappush(pq, -e)
            # å †ä¸­å…ƒç´ å¤šäº k ä¸ªæ—¶ï¼Œåˆ é™¤å †é¡¶å…ƒç´ 
            if len(pq) > k:
                heapq.heappop(pq)
        # pq ä¸­å‰©ä¸‹çš„æ˜¯ arr ä¸­æœ€å°çš„ k ä¸ªå…ƒç´ 
        res = []
        while pq:
            res.append(-heapq.heappop(pq))
        return res[::-1]

# å¿«é€Ÿé€‰æ‹©çš„è§£æ³•æ€è·¯
class Solution:
    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        res = [0] * k

        # æ³¨æ„æ­¤é¢˜çš„ k æ˜¯å…ƒç´ ä¸ªæ•°è€Œä¸æ˜¯ç´¢å¼•ï¼Œæ‰€ä»¥å’Œç´¢å¼• p åšæ¯”è¾ƒæ—¶è¦ - 1
        # é¦–å…ˆéšæœºæ‰“ä¹±æ•°ç»„
        self.shuffle(arr)
        lo, hi = 0, len(arr) - 1
        # ç°åœ¨å¼€å§‹å¯»æ‰¾ç¬¬ k å¤§çš„å…ƒç´ 
        while lo <= hi:
            # åœ¨ arr[lo..hi] ä¸­é€‰ä¸€ä¸ªåˆ†ç•Œç‚¹
            p = self.partition(arr, lo, hi)
            if p < k - 1:
                # ç¬¬ k å¤§çš„å…ƒç´ åœ¨ arr[p+1..hi] ä¸­
                lo = p + 1
            elif p > k - 1:
                # ç¬¬ k å¤§çš„å…ƒç´ åœ¨ arr[lo..p-1] ä¸­
                hi = p - 1
            else:
                # arr[p] å°±æ˜¯ç¬¬ k å¤§å…ƒç´ ï¼Œåˆå› ä¸ºå¿«é€Ÿæ’åºçš„æ€§è´¨ï¼Œ
                # arr[p] å·¦è¾¹çš„å…ƒç´ éƒ½æ¯” arr[p] å°ï¼Œæ‰€ä»¥ç°åœ¨ arr[0..k] å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„ç­”æ¡ˆ
                for i in range(k):
                    res[i] = arr[i]
                return res

        return res

    # å¯¹ nums[lo..hi] è¿›è¡Œåˆ‡åˆ†
    @staticmethod
    def partition(nums: List[int], lo: int, hi: int) -> int:
        pivot = nums[lo]
        # å…³äºåŒºé—´çš„è¾¹ç•Œæ§åˆ¶éœ€æ ¼å¤–å°å¿ƒï¼Œç¨æœ‰ä¸æ…å°±ä¼šå‡ºé”™
        # æˆ‘è¿™é‡ŒæŠŠ i, j å®šä¹‰ä¸ºå¼€åŒºé—´ï¼ŒåŒæ—¶å®šä¹‰ï¼š
        # [lo, i) <= pivotï¼›(j, hi] > pivot
        # ä¹‹åéƒ½è¦æ­£ç¡®ç»´æŠ¤è¿™ä¸ªè¾¹ç•ŒåŒºé—´çš„å®šä¹‰
        i, j = lo + 1, hi
        # å½“ i > j æ—¶ç»“æŸå¾ªç¯ï¼Œä»¥ä¿è¯åŒºé—´ [lo, hi] éƒ½è¢«è¦†ç›–
        while i <= j:
            while i < hi and nums[i] <= pivot:
                i += 1
                # æ­¤ while ç»“æŸæ—¶æ°å¥½ nums[i] > pivot
            while j > lo and nums[j] > pivot:
                j -= 1
                # æ­¤ while ç»“æŸæ—¶æ°å¥½ nums[j] <= pivot

            if i >= j:
                break
            # æ­¤æ—¶ [lo, i) <= pivot && (j, hi] > pivot
            # äº¤æ¢ nums[j] å’Œ nums[i]
            nums[i], nums[j] = nums[j], nums[i]
            # æ­¤æ—¶ [lo, i] <= pivot && [j, hi] > pivot

        # æœ€åå°† pivot æ”¾åˆ°åˆé€‚çš„ä½ç½®ï¼Œå³ pivot å·¦è¾¹å…ƒç´ è¾ƒå°ï¼Œå³è¾¹å…ƒç´ è¾ƒå¤§
        nums[lo], nums[j] = nums[j], nums[lo]
        return j

    # æ´—ç‰Œç®—æ³•ï¼Œå°†è¾“å…¥çš„æ•°ç»„éšæœºæ‰“ä¹±
    @staticmethod
    def shuffle(nums: List[int]) -> None:
        n = len(nums)
        for i in range(n):
            # ç”Ÿæˆ [i, n - 1] çš„éšæœºæ•°
            r = i + random.randint(0, n - i - 1)
            nums[i], nums[r] = nums[r], nums[i]
```

https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†

https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘‡

```cpp
// by chatGPT (cpp)
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        return s.substr(n) + s.substr(0, n);
    }
};
```

```go
// by chatGPT (go)
func reverseLeftWords(s string, n int) string {
    return s[n:] + s[:n]
}
```

```java
// by labuladong (java)
class Solution {
    public String reverseLeftWords(String s, int n) {
        return s.substring(n) + s.substring(0, n);
    }
}
```

```javascript
// by chatGPT (javascript)
/**
 * @param {string} s
 * @param {number} n
 * @return {string}
 */
var reverseLeftWords = function(s, n) {
    return s.substring(n) + s.substring(0, n);
};
```

```python
# by chatGPT (python)
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        return s[n:] + s[:n]
```

https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof çš„å¤šè¯­è¨€è§£æ³•ğŸ‘†