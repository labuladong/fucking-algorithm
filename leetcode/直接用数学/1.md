
## question
[829. 连续整数求和](https://leetcode-cn.com/problems/consecutive-numbers-sum/)
给定一个正整数 N，试求有多少组连续正整数满足所有数字之和为 N?

示例 1:

输入: 5
输出: 2
解释: 5 = 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。
示例 2:

输入: 9
输出: 3
解释: 9 = 9 = 4 + 5 = 2 + 3 + 4
示例 3:

输入: 15
输出: 4
解释: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5
说明: 1 <= N <= 10 ^ 9

通过次数4,639提交次数14,196

## solution

### 巧用质因数分解

拿到这道题，很自然想到高中学过的等差求和公式，从a开始的连续b个数之和：
首项是a，项数是b，末项是`a+b-1`
`N = b*(b+2a-1)/2`
把分母2乘到左边来：`2N = b*(b+2a-1)`。这样右边得到一个乘积的形式。
乘数b是任意的正整数。
因为a也是任意的正整数，所以2a-1是任意的正奇数，乘数b+2a-1是b加上一个奇数后的结果，和b奇偶性相反，记`c=b+2a-1`。
问题就转变为有多少组奇偶性不同的b和c满足：
`2N = b*c`
（因为c是正数a、b的线性组合，所以一对a、b对应一对b、c。本来的问题是有多少对这样的a、b，现在的问题变成了有多少对这样的b、c）
1. 朴素法:
b从1遍历到`√(2N)`，判断b是否整除`2N`，并且b和c奇偶性不同，代码如下：

```py
K = 2 * N
res = 0
b = 1
while b ** 2 < K: 
    if not K % b and (K // b - b) % 2:  ## 判断b是否整除2N，并且b和c奇偶性不同
        res += 1
    b += 1
return res
```
对所有N，朴素法时间复杂度都是`O(√(2N))=O(√N)`
2. 质因数分解法:
如果对2N先进行质因数分解，而质因数里包含了所有因数的信息，从而遍历得到b和c的组数，平均时间复杂度将大幅度降低。质因数分解代码如下：

```py
import collections
prime_factors = collections.defaultdict(int)  ## 字典用来存储所有质因数，key是质因数，value是质因数的次数
K = 2 * N
b = 2
while b ** 2 <= K:
    if not K % b:  ## 判断b是否整除K
        prime_factors[b] += 1
        K //= b  ## 若是，则把质数b从K中拿出，保证了后面的b只可能是质数
    else:
        b += 1
prime_factors[K] += 1  ## 最后剩下的K是2N的最大质因数

## 随着b不断从K取出，K最后会变成2N的最大的质因数，此时如果 b ** 2 <= K，那么继续 b += 1，遍历的终点为√K
## 此时如果 b ** 2 > K，那么停止循环，遍历的终点为b，b是2N的第二大质因数

print(prime_factors)
```
对质因数回溯求积得到所有因数，代码如下：

```py
factors = []  ## 列表用来存储所有因数
def traceback(component, prime_factors):
    if not prime_factors:
        factors.append(component)  ## 把所有的因数记录下来
    else:
        dic = copy.deepcopy(prime_factors)  ## 创建一个新的字典对象用来传参
        item = dic.popitem()  ## 从字典里取出一个质因数
        for i in range(item[1]+1):
            traceback(component * item[0] ** i, dic)  ## 对于这个质因数，考虑其在因数中可以出现的次数，最少0次，最多item[1]次

traceback(1, prime_factors)

print(factors)
```
遍历因数，验证b和c，代码如下：

```py
res = 0
for factor in factors:
    if factor ** 2 < 2 * N and ((2 * N) // factor - factor) % 2:  ## 判断大小两个因数是否奇偶性不同
        res += 1
return res
```
质因数分解法只需要遍历到2N的最大质因数的平方根和第二大质因数中大的那个，时间复杂度是O(max(√p,q)+r)，其中p是2N的最大的质因数, q是第二大的质因数，r是质因数的个数。也就是说，2N 的质因数越多，需要遍历的长度就缩短越多，使得对于随意的N，平均时间复杂度大幅下降。
但N是质数的话，2N的最大质因数是N，时间复杂度仍为O(√N)。计算机处理质数比合数慢很多，这也是为什么信息加密会用质数。

附整体代码：

```py
class Solution:
    def consecutiveNumbersSum(self, N: int) -> int:
        import copy
        import collections
        prime_factors = collections.defaultdict(int)
        K = 2 * N
        b = 2
        while b ** 2 <= K:
            if not K % b:
                prime_factors[b] += 1
                K //= b
            else:
                b += 1
        prime_factors[K] += 1

        factors = []
        def traceback(component, prime_factors):
            if not prime_factors:
                factors.append(component)
            else:
                dic = copy.deepcopy(prime_factors)
                item = dic.popitem()
                for i in range(item[1] + 1):
                    traceback(component * item[0] ** i, dic)

        traceback(1, prime_factors)

        # 回溯算法的替代方法，用循环而非递归
        # factors = [1]
        # while prime_factors:
        #     item = prime_factors.popitem()
        #     lis = []
        #     for i in factors:
        #         for j in range(item[1] + 1):
        #             lis.append(i * item[0] ** j)
        #     factors = lis

        res = 0
        for factor in factors:
            if factor ** 2 < 2 * N and ((2 * N) // factor - factor) % 2:
                res += 1
        return res
```