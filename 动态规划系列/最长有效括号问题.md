# Longest Valid Parentheses 32

Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.

**Example 1:**

```
Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
```

**Example 2:**

```
Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
```



注意：题目要求的是一个 **连续的** substring里头的valid parenthese





## 思路1：暴力 O(n^2)  两层for loops

最直观的解法就是两层for loops, 第一层从左到右过每一个index。

第二层就是从这个index往后看当前的longest valid parentheses substring有多长。可以把 `(` 算作 +1, `)` 算作 -1,   总和又变回0。所以直达哪次总和 < 0 了就说明遇到了个extra unhandled `)` , 那么这段就over了

这么做要O(n^2)，如何优化呢？

可以看出，无用功出现在这里：

<img src="images/Longest%20Valid%20Parentheses%2032/image-20200719011859447.png" alt="image-20200719011859447" style="zoom:50%;" />

外层循环从 `i` 开始往右遍历，会过一遍蓝色框框的部分，从 `i+1` 开始往右遍历还会过一遍蓝色框框的部分, 从 `i+2` 开始往右遍历还会过一遍蓝色框框的部分 ...

所以蓝色框框的部分一直在被重复计算，那么就可以考虑用DP来cache掉 （从右往左）







## 思路 2：DP（后缀型DP）

可以从右往左进行DP（后缀型DP）模拟，每看到当前的 `s[i]` 是个 `(` 的话，就尝试回头往右边找match。

当然，换成前缀型DP从左往右也可以，那就是每遇到一个当前的 `s[i]` 是个 `)` 的话, 就尝试回头往左找match。

#### DP定义：

以index `i` 为左端点往右看的longest valid parentheses substring

#### DP状态转移：

<img src="images/Longest%20Valid%20Parentheses%2032/image-20200719230210695.png" alt="image-20200719230210695" style="zoom:50%;" />

`dp[i]` 可以这么计算：

1. 首先看当前的 `s[i]` 是 `(` 还是 `)` 。 如果是 `)` ，那没戏，不可能和任何它右边的括号做匹配的，所以当场 `dp[i] = 0` ，然后继续往左expand dp[]

    如果 `s[i]` 是 `(` , 那就有可能在右侧有个 `)` 会和它匹配，尝试去找到这个 `)` 的位置

2. 首先要找一个 `j` , where `j` is the next index to the right of `i + dp[i + 1]` 

物理意义就是 `dp[i + 1]` 是一段以index `i+1` 为左端点的longest valid parenthese substring, 所以 `j` 就是这一段substring右边的第一个不合群的括号

3. 那么就看 `s[j]` 这个括号是啥：
    * 如果这个括号是 `(` ，那也没有办法和 `s[i]` 的 `(` 做匹配，再加上如果  `s[j]` 是个 `(` 的话，那它肯定不是在 `dp[i + 1]` 的longest valid parentheses substring里面的一部分，不然的话 `dp[i + 1]` 就会包括它继续延展

    * 如果这个括号是 `)` ，那就和 1. 里面希望得到的 `)` 一致，就可以和 `s[i]` 做匹配。

        则有 `dp[i] = dp[i + 1] + 2` 

        这里可以看下极端例子是否也成立：如果 `dp[i + 1] = 0`, 也就是说没有任何longest valid parenthese, 那么这时候 `j = i + dp[i + 1] + 1 ==> i + 1` 。而这时候如果 `s[j]` 又是个 `)` , 那就刚好和 `s[i] = (` 做个匹配，`dp[i] = dp[i + 1] + 2 = 0 + 2 = 2` 

    * 完事之后顺便看下 `j + 1` 是否越界，不越界的话就把 `dp[j + 1]` 也一同带上 （如果`dp[j + 1] = 0`, 就就 0 呗，说明 `j + 1` 为左端点没有longest valid parenthese substring)
    * 注意：遍历从 `for (int i = n - 2; i >=0; i--)` 开始，也就是倒数第二个空位。

#### DP答案：

每一个index `i` 时都更新下global longest valid parenthese substring, 最后返回这个global_max即可



## SOLUTION 2：DP（后缀型DP）

##### time: O(n)

##### space: O(n) for dp[]

```java
class Solution {
    public int longestValidParentheses(String str) {
        if (str == null || str.length() == 0) {
            return 0;
        }
        
        char[] s = str.toCharArray();
        int[] dp = new int[s.length];
        int longest = 0;
        for (int i = (s.length - 1) - 1; i >= 0; i--) {
            if (s[i] == '(') {
                int j = i + dp[i + 1] + 1;
                // 如果没越界 && 右括号
                if (j < s.length && s[j] == ')') {
                    dp[i] = dp[i + 1] + 2;
                    
                    //如果j+1没越界, 顺便带上dp[j+1]融入dp[i]
                    if (j + 1 < s.length) {
                        dp[i] += dp[j + 1];
                    }
                }
                
                longest = Math.max(longest, dp[i]);
            }
        }
        
        return longest;
    }
}
```











