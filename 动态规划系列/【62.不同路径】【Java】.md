[dekunma](https://www.linkedin.com/in/dekun-ma-036a9b198/) 提供Java代码  

**思路**：  
假设有```m```行，```n```列，  
则我们初始化```m```行，```n```列的二维数组```dp```   
  
从每一格出发的所有不同路径之和等于从这一格的右边一格，和下面一格出发的所有不同路径之和  
所以状态转移方程是：```dp[i][j] = dp[i-1][j] + dp[i][j-1]  ```,  
所以我们在遍历时要从最右下角出发，从下到上，从右往左遍历（沿着状态转移方程每一格求和的相反方向）  
  
需要注意的是，如果在最右边一列```dp[i][n - 1]```去看它右边的格子，或者在最下面一行```dp[m - 1][j]```去看它下面的格子，则会发生越界  
所以我们令这些格子为1，并不在遍历时经过它们（实际上最右下角的格子的值应该是0，但因为输入的```m```和```n```不会同时为0，所以我们永远不会去关心这个格子的值）  
  
完成遍历后，```dp[0][0]```则会储存我们从左上角出发到右下角的所有不同路径之和

时间复杂度：```O(m * n)```

空间复杂度：```O(m * n)```  
  
```java
class Solution {
    public int uniquePaths(int m, int n) {
        // 处理n == 0 的 edge case
        // 题目说了 1 <= m 所以不用考虑 m == 0的情况
        if(n == 0) return 0;

        // 初始化dp数组
        int[][] dp = new int[m][n];

        // 因为最后一行和最后一列一定会是1，且遍历时经过它们会越界
        // 所以我们先把它们射程1，且在后续遍历时不经过它们
        Arrays.fill(dp[m - 1], 1);
        for(int i = 0; i < m; i++) {
            dp[i][n - 1] = 1;
        }

        // 遍历dp数组求解
        for(int ii = m - 2; ii >= 0; ii--) {
            for (int jj = n - 2; jj >= 0; jj--) {
                dp[ii][jj] = dp[ii + 1][jj] + dp[ii][jj + 1];
            }
        }

        // dp[0][0]包含从(0,0)到右下角的所有独特路径之和
        return dp[0][0];
    }
}
```
